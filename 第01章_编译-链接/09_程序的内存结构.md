6. 再说说程序的内存结构
		程序的内存结构，也叫内存布局，也叫存储映像。
		
	6.1 什么是内存结构？
			前面已经介绍过，其实就是程序运行时在内存中存储结构。
				
			不管是裸机还是基于OS虚拟内存运行的情况，内存布局基本都差不多，所以我们这里只介绍程序基于OS虚拟内存运行时的
		内存布局，这个内存布局很重要，希望大家理解并记住它，至于说为什么重要，后面的课程会体现出来。
			
			图：

			
		
		
	6.2 指令 与 数据的存放
			程序在内存中存储时，就存储两个东西，一是指令，二是数据。
			
				
		6.2.1 指令
			指令存储在代码段中的.init和.text节中。
			
			.init节：放启动代码相关的指令
			.text节：主要放我们自己所写程序的指令
			
					
		6.2.2 数据
			（1）数据的存储形态
						有两种存储形态，
					
					1）第一种：量空数据存储在常间中
							数据存储在常量空间中时，由于常量空间只能读不能写，因此常量保存的数据将一直不变。
						
					2）第二种：数据存储在变量空间中
							由于变量空间的读写权限为可读/可写，所以数据存在变量中时，是可以被新的数据改写的。
				
			（2）常量
					常量空间要求是只读的，在程序的内存布局中，只有代码段是只读的，因此常量空间肯定只能在代码段中。
					在代码段中有两个地方可以用于开辟常量空间，一个是在.text中，另一个是在.rodata中。

					1）在.text中的情况
							此时，直接作为指令的一部分，放在了.text中。
							
							比如：a = a + 100;
							编译后100直接作为指令的一部分存储在了.text中，由于.text只能读不能写，因此数据100就保存在了常量中。
							
							
					2）在.rodata中的情况
						比如：
							int a = 100;
							printf("a = %d", a);
						
							char *p = "hello world";
							
							字符串"a = %d"/"hello world"被保存在了.rodata中，由于.rodata是只读的，因此"a = %d"/"hello world的存储
						空间是一个常量，在一般情况下为了好称呼，我们直接将"a = %d"/"hello world”称为常量。

						 有关char *p = "hello world"这种情况，我们后面讲字符串时，还会详细的介绍到。
						
						
						疑问：为什么不将这些字符串和指令一起直接保存在.text中
							太长了，无法作为指令的一部分存储在.text中。
							
						
			（2）变量
						变量空间只能开辟于在数据段，因为只有数据段是可读可写的。
						
						变量分为两种，一种是静态变量，另一种是动态变量。
						
						· 静态变量：空间开辟于静态数据段（.data/.bss）
							图：
							
						
						· 动态变量：空间开辟于动态数据段（堆/栈）
							图：
						

					
					1） 静态变量
							分两种情况，一个是在.data中，另一个是在.bss
							· .data：初始化了的静态变量
							· .bss：未初始化的静态变量
							
						（a）.data
									其实.data中的内容在编译时就决定好了，加载程序时，只需要将“可执行目标文件”的.data的内容，拷贝到
								内存即可。
									
									初始化了的静态变量分两种：初始化了的全局变量 和 初始化了的静态局部变量，它们都在.data中。
									
									
								+ 初始化了的全局变量
									int a = 100;
									int main(void)
									{
										...
									}
									
								+ 初始化了的静态局部变量
									int main(void)
									{
										static int a = 100;//main函数的初始化了的静态局部变量
										...
									}
							
							
						（b） .bss
								同样两种情况：
								
								+ 未初始化的全局变量
									int a;
									int main(void)
									{
										...
									}
									
								+ 未初始化的静态局部变量
									int main(void)
									{
										static int a;
										...
									}
							
								在“可执行目标文件”中，.bss并不存在，程序加载后才会开辟.bss的空间，然后再在.bss里面开辟未初始化
							静态变量的空间，并自动初始化为0。
							
								这就是以前常说的，未初始化的全局变量和静态局部变量，会被自动初始化为0。
							
							
							
							
							
						
					2） 动态变量
						之所称为动态的，是因为变量空间并不是在编译时决定的，而是在程序运行时才有的。
						
						动态变量分两种，一种是自动局部变量，另一种是手动开辟的变量。
						
						· 自动局部变量：空间开辟在栈中
						· 手动开辟的变量：空间开辟在堆中
						
						（a）自动局部变量（开辟于栈中）
								没有加static修饰的函数局部变量都是自动局部变量，我们这里将形参也归到自动局部变量里面。
						
								为什么称为自动局部变量？
								变量空间是函数运行时自动开辟，运行结束时自动释放的，所以把它称为“自动”的。
								正是由于是自动开辟和释放的，因此栈也被称为自动存储区。
							
								int fun(int a)//a形参
								{
									int b = 100;//没有加static修饰的局部变量
									int c;
									
									return a+b+c;
								}
								
								a、b、c都是开辟于栈中。
								
							
								疑问：编译得到可执行目标文件后，函数中的自动局部变量是一个什么样存在？
									
									fun函数被编译后，自动局部变量的定义会变为操作栈的指令（压栈指令push、弹栈指令pop），
									演示：
									
									
								· 压栈
										函数运行时会调用压栈指令，会将“栈顶指针”向低地址方向移动需要的字节数，挪出来的这个空间就是
									自动局部变量的空间。
										
										图：
										
										- 如果有初始化的话，就将初始化值写到空间中。
										- 如果没有初始化的话，空间中的内容就是别人之前使用后遗留的内容。
											这就是我们以前常说的，如果函数的自动局部变量不初始化的话，就是一个随机值。
											
											
											旁注：有关局部变量随机值问题。
												随机值其实是一个隐患，因为如果程序在运算时使用了不确定的随机值的话，会给程序的功能带来不
											确定的影响。
											
												比如程序控制的是机械设备的话，这种随机值是非常要不得的，如果程序进行控制运算时使用了
											随机值，设备的机械运动可能会出现无法预测的结果，这是非常危险的。
											
												因此我们要求必须给自动局部变量赋一个明确的值，特别是指针变量更是如此，如果你不知道赋什
											么值，那最起码要赋一个NULL空指针，以防止出现因随机值所导致的野指针。
												
												
											
								· 弹栈
										调用函数中的弹栈指令时，栈顶指针会向高地址方向回退相应的字节数，这样就把变量的空间给释放
									出来了，释放时并不会对空间清0，因此这一次使用的值，就变成了下一次别人使用这个空间时的随机值。
										
										图：

										
										
										
						（b）手动开辟的变量（开辟于堆中）
									栈中空间是自动开辟和释放的，但是堆空间不是的，对于堆来说，需要程序员自己在程序手动的调
								malloc函数，按需从堆中分配空间，当不再需要该空间时，就调用free函数来释放。
		
									因为堆空间是手动开辟和释放的，因此在堆也被称为手动存储区。
								
								· malloc、free的使用举例
																		
									int main(void)
									{
										int *p = NULL;
										
										p = malloc(4); //在堆中开辟4字节的空间，然后将首字节地址给p，以便访问空间
										if(p == NULL) 
										{
											printf("malloc fail\n");
											
											exit(-1);//开辟空间失败就结束进程
										}
										bzero(p, 4); //将开辟的空间清零
										
										*p = 100; //使用开辟的空间
										
										free(p);//删除p所指向的4字节空间
									}
									
									
										堆空间也存在和栈一样的随机值问题，所以我们从堆中开辟出空间后，必须主动清零，否者会影响写入
									的数据。
										
										比如程序中调用bzero(p, 4)的目的，就是将p所指向的4个字节空间清0。
								

								
								· 疑问：如果没有调用free来释放开辟的堆空间的话，程序运行结束后，堆空间会释放吗？
										当然，程序结束后，不仅堆空间，所占用所有的空间都会释放。
										
		
								· 疑问：既然程序终止时会释放所有堆空间，那为什么还需要调用free函数来释放呢？
										
										因为真实的程序，很多一旦运行起来后会长时间运行，甚至有些可能会永久运行，如果程序在运行的
									过程中每次malloc后都不free的话，程序的堆空间会越用越少，严重的话堆和栈的空间会顶到一起，相互
									篡改数据，最后导致程序死机，对于很多重要程序来说是绝不能死机的，因为死机所带来的经济损失可能
									是非常巨大的。
									
										其实正常情况下，栈和堆之间的空间距离非常大，如果正常操作（开辟后及时释放）的话，它们之间
									是不可能会碰到一起的，但是如果堆空降只开辟不释放的话，这种情况就有可能发生。
									
										为了保证堆空间不会越用越少，及时调用free是必不可少的。
										
										
								· 如何理解空间被占用
								
										空间被占用从而导致可用空间不足的情况，与现实生活中仓库很像。
										
										就好比你们家仓库是挺大的，但是就是每次放完东西后从来不清理，垃圾越来越多，最后导致仓库的空
									间全被垃圾占用，此时虽然仓库还是那个仓库，但是可用空间确是越来越少，严重时根本没有空间可用。
										

																		
							
				6.2.2 有关堆变量和栈变量，再提两句
					（1）栈变量
							从栈中开辟变量时，为了避免随机值带来的问题，一定要初始化
							
							1）基于OS虚拟内存运行时，随机值来源有两个
								（a）最开始时来自于子进程以前栈的遗留
								（b）新程序运行一段段时间后，随机值来自于自己使用后的的遗留
							
							2）裸机运行时
									没有OS虚拟内存，不存在父进程一说，上电运行时内存默认就是清零的，所以随机值来自于自己
								使用后的遗留。
						
					（2）堆变量
							1）基于OS虚拟内存运行时，随机值来源有两个
								（a）最开始时来自于子进程以前堆的遗留
								（b）来自于自己使用后的遗留
							
							2）裸机运行时
								没有OS虚拟内存时，不存在父进程一说，所以随机值也是来自于自己使用后的遗留
								
							
							3）malloc和free函数对堆内存的管理
							
								（a）malloc从堆中开辟的变量空间往往大于实际想要的空间
								
											malloc为了能够更好的管理堆内存，开辟空间时，并不是你想开辟多少，就刚好开辟多少，而是会做
										圆整处理，比如我想申请212字节，最终malloc实际开辟时会“圆整”为256。
											
											这就好比你去开房，为了好管理房间，人家肯定是一间一间来管理的，你去跟前台说我开半间房，前台
										肯定会给“圆整”为整间房，凡是大块的内存管理都是这样的，都是按“块”来管理的，目的是为了提高管
										理效率。
											
											疑问：圆整规则是怎样的?
											这是malloc内部的算法机理，这个我们无需关心。

								
								（b）如果忘了free，实际上导致的堆内存泄漏，要大于明面上所开辟的空间
										这个道理很简单，我想开辟212字节，但是malloc实际上开辟了256字节，所以如果忘了free，实际泄露
									的堆内存空间为256，大于明面上的212字节。
										
										
										有关malloc、free是如何管理堆内存的，这个属于malloc和free这两个函数的内部算法，我们作为
									应用程序开发者，其实无需关心，既然讲到这里了，我们就多说两句，作为了解即可。
								
			
				
				
				
				
				
		
		
		
			
	



		4）C可执行文件运行起来后，C内存结构布局
			（a）裸机与有OS时内存结构体的异同
			（b）c内存结构详解					
					代码段
					静态数据段
					常量数据段
					堆
					栈
					
					数据和代码是如何存放在这些段的。
					到底什么是常量，什么是变量。	
			
			
				
											
								

（2）预处理到底做了些什么
		预处理就做一下几件事
			处理宏定义，处理条件编译，文件包含，处理“特殊预处理关键字”，所以会详细介绍
		
		1）宏定义
				重点：使用宏定义构建复杂表达式
			
				很多同学在看复杂C语言程序时，其中有一个难关宏定义复杂表达式，在高级c语言程序中，大量存在各种
			宏定义实现的复杂表达式，我们举例讲解一些Linux内核中的复杂宏定义，让大家熟悉宏的复杂用法。
			
		2）条件编译
				条件编译也是各位同学无法阅读高级C程序的难点之一，复杂的C程序为了应对不同的软件和硬件平台，
			.c、.h文件中往往会写针对各种不同平台的代码，这些代码通过条件编译进行选择，如果你看不懂这些
			条件编译，这对阅读和实现复杂C代码来说是一个很大的难关。
				
				所以我们会详细介绍：
			
			条件编译的作用是什么？
			条件编译都有哪些
			每种中条件编译都是怎么用
			为了更好的理解条件编译，我们会为大家展示Linux内核源码的条件编译，加深理解。
			
		3）文件包含
			1）只能包含头文件吗？能包含C文件吗，为什么平时很少直接包含C文件？
			2）头文件中如下条件编译时是怎么回事
				#ifndef? MAX_H_??
				#define? MAX_H_??
				⋯⋯..
				#endif?
				
			3）我们.c文件中常用的哪些头文件都从哪里来的
			4）使用“”包含头文件时，只能包含当前路径的.h文件吗
				
				
		4）其它的一些预处理关键字
		
		
（4）存储类、作用域、生命周期、连接属性
		
		比如以连接为例，我们介绍连接时，会详细介绍连接到底做了什么事，连接时，
		extern这种关键字声明函数和变量时到底作用是什么


（5）指针、函数
		指针本身很简单，很多同学一直觉得指针很难，其实难得不是指针本身的概念，而是当数组、函数、字符串等
		等使用指针时，涉及到的形态很复杂，因此很多同学不理解，所以大家指针没学好，其实不是指针本身概念的
		理解有问题，其实是大话对数组、函数、字符串等着这些与知真相相关的一些东西还没有学号，所以你才会觉
		得难。
		
		
		变量名与地址
		一级指针与多级指针
		野指针与段错误
		const关键字与指针	
		指针的强制类型转换
		
		函数地址的意义
		指针与函数传参
		函数指针（函数指针数组）、指针函数
		函数调用时，是如何使用栈的（IDE）参数保存，arm4个参数以内寄存器保存，看arm汇编
		递归、内联函数
				
				
		变量定义和强制转换意义。
		
		
		
（6）C库
		
		
		库怎么来的，库可以是源码的吗
		库为什么需要头文件
		
		如何实现自己的动态库和静态库
		
		库的加载方式（以前的库是没有头文件）
		函数原型检测。
		
		
		动态链接库的二种加载方式，显示加载和隐式加载具体是怎么回事儿及优缺点
		
		
		C库、posix、BSD、关系
		
		
		
（7）数组与字符串
		多级指针构建多维数组
		


（8）结构体、联合体、枚举	
	
		变量定义和强制转换意义。
		
		结构体的对齐
		
		
		结构体强制转换，空间丢失和溢出，举struct sockaddr_例子

		
（9）c语言中值得被关注的细节问题
		1）数据溢出问题
		
		2）大小端序
		
		3）逗号表达式
		
		4）void
				变量定义和强制转换意义。
				
		
		NULL、\0 null，0
		
		5）如何理解C语言转移字符
		
		6）typedef的作用
			
			
			typedef构建的复杂表达式
			
		
		7）mian函数是谁调用的，main函数的参数到底有什么用
		
		8）++


						
（2）C语言的位操作
		& | ~ ^等等
		
		其实在C的应用层开发中，位操虽然也有用，但是用的并不频繁，但是位操作在驱动（裸机驱动、OS驱动）中会被
	大量使用，驱动开发的核心是就是进行寄存器的设置，而进行寄存器设置的核心就是进行微操作，必须掌握位操作。
		
		
		
（6）c面向应用时，其他相关知识

	图形界面与命令行之间的关系、多线程、网络、数据库

	
（7）数据结构

				
		内核链表
	
	
		
	




















	
（1）C语言的编译过程与内存结构
		1）对比使用IDE开发方式 与 直接源文件开发方式	
		2）C语言编译过程介绍
		3）c可执行文件格式	
		4）C可执行文件运行起来后，C内存结构布局
				C内存布局，其实可以简答认为就是进程空间的布局，虽然裸机不存在进程这一说，但是我们可以认为裸机
			是单进程的。
		
			（a）裸机与有OS时内存结构体的异同
			
			
			（b）c内存结构详解
					1、朱老师视频里讲解，内存中的程序分为三段.text段、.data段、.bss段，那么.rodata段是用
						来存放常量的，它属于.text段、.data段、.bss段中哪一个段？还是是独立的一个段？
					
					2、Printf(“%d”,3);  3是放在哪个段的？
					
					3、Printf(“%s”,“Linux”);  Linux是放在哪个段的？
			
					代码与数据都放在什么内存的什么位置。
					
					代码段
					静态数据段
					常量数据段
					堆
					栈
					
					
（2）C语言的位操作
		& | ~ ⋯⋯等
		
		
（3）预处理到底做了些什么时
		1）宏定义
			重点：使用宏定义构建复杂表达式
			
		2）条件编译
			复杂的.c文件以及.h文件包含会包含各式各样的条件编译，很多同学阅读复杂c程序，有一个最大的难点
			就是看不懂这些条件编译，所以我们会重点介绍这些条件编译，比如
			那么
			条件编译的作用是什么？
			条件编译都有哪些，各自都有什么具体用处
			
		3）文件包含
			1）只能包含头文件吗？能包含C文件吗，为什么平时很少直接包含C文件？
			2）头文件中如下条件编译时是怎么回事
				#ifndef? MAX_H_??
				#define? MAX_H_??
				⋯⋯..
				#endif?
				
			3）所包含的头文件都放在了哪里
			4）使用“”包含头文件时，只能包含当前路径的.h文件吗
				
				
		4）其它的一些预处理关键字
		
		
（4）存储类、作用域、生命周期、连接属性
			函数声明，做原型检查。

		连接时是怎么找到其它文件中的函数的
		
		
		结构体强制转换，空间丢失和溢出，举struct sockaddr_例子

		
（5）指针

		变量定义和强制转换意义。
		
		
		
（6）函数与库
		
		函数地址的意义
		函数调用时，是如何使用栈的（IDE）参数保存，arm4个参数以内寄存器保存，看arm汇编
		
		递归、内联函数、与宏之间的关系
		
		毁掉函数
		
		
		库怎么来的，库可以是源码的吗
		库为什么需要头文件
		
		如何实现自己的动态库和静态库
		
		库的加载方式（以前的库是没有头文件）
		函数原型检测。
		
		
		动态链接库的二种加载方式，显示加载和隐式加载具体是怎么回事儿及优缺点
		
		
		C库、posix、BSD、关系
		
		
		
（7）数组与字符串
		多级指针构建多维数组
		


（8）结构体、联合体、枚举	
	
		变量定义和强制转换意义。
		
		
		
		
（9）c语言中值得被关注的细节问题
		1）数据溢出问题
		
		2）大小端序
		
		3）逗号表达式
		
		4）void
				变量定义和强制转换意义。
				
		
		NULL、\0 null，0
		
		5）如何理解C语言转移字符
		
		6）typedef的作用
			
			
			typedef构建的复杂表达式
			
		
		7）main函数是谁调用的，main函数的参数到底有什么用
		
		8）字、半字等概念

		9）程序的优化
		
		10）程序的调试
		
（6）c面向应用时，其它相关知识

	图形界面与命令行之间的关系、多线程、网络、数据库

	
（7）数据结构

				
		内核链表
