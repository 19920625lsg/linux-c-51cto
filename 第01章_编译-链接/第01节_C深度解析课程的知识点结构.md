# 第01节_C深度解析课程的知识点结构

## 课程章节安排
	
### 课程目录
  + （1）C语言的编译过程与c程序的内存结构（存储映像）		
  + （2）预处理详细介绍
  + （3）存储类、作用域、生命周期、链接属性		
  + （4）指针、函数	
  + （5）c函数库
  + （6）数组与字符串				
  + （7）结构体、联合体、枚举				
  + （8）c语言中无法独立成章的知识
  + （9）C语言的位操作
  + （10）使用c来进行应用开发时，所涉及的一些其它相关知识

		
### 章节内容介绍	
	
  +（1）C语言的编译过程与c程序内存结构(存储映像)
        > 这一章所讲的内容，对后面每一章都有知识辐射，如果大家能够把这一章真正的理解到位，后面章节的很多知识理解起来非常容易，所以第一章是非常重要的核心章节。
	+ 1）IDE 与 源文件开发方式的异同
	+ 2）编译的详细过程
	+ 3）编译器集合的组成
	+ 4）gcc -v，编译信息的详细分析
	+ 5）可重定位目标文件（.o）格式介绍
	+ 6）链接器链接时，符号解析和重定位做了什么事情
	+ 7）可执行目标文件的格式，以及可执行目标文件的加载、执行
	+ 8）程序内存结构介绍，代码和数据(常量、变量)是如何存放在程序的内存结构中的
				
  + （2）预处理详细介绍
	+ 1）宏定义
	+ 2）条件编译
	+ 3）头文件包含
	  + <>和""的区别
	  + 为什么include很少包含.c文件
	  + 头文件中的#ifndef XXX  #define XXX      #endif条件编译的作用。
	+ 4）一些特殊的预编译关键字
	
  + （3）存储类、作用域、生命周期、链接属性
        > 这一章与第1章是紧密联系的，所以如果大家把第1章理解好了，这一章说白了只是在讲解细节知识而已。
        + 1）介绍什么是存储类、作用域、生命周期、连接属性
	+ 2）介绍extern、static、auto、register等等关键字，与存储类、作用域、生命周期、连接属性之间关系
	+ 3）介绍什么是无链接、内链接、外链接、
	+ 4）介绍为什么函数一定要声明，函数声明的目的到底是什么，不进行函数声明行不行等等
					
  + （4）指针、函数
	+ 指针
	  1）指针概念（一级指针与多级指针）
	  2）指针的强制转换到底做了什么
	  3）野指针、段错误
	  4）const与指针等

	+ 函数
	  + 1）函数指针 与 指针函数
	      > 指针的概念本身很简单，我们常说指针难，并不是指针概念难，而是指针与函数、数组、字符串、结构体等相结合后，里面有很多不易理解的地方，如果你只是理解了指针本身的概念的话，实际上你的指针并没有学会。
	  + 2）指针与函数传参
	  + 3）函数调用时栈的活动记录
	  + 4）回调函数：C语言模拟面向对象的思想时，与回调函数密不可分
	  + 5）递归函数
	  + 6）内联函数
	  + 7）const与函数传参
	  + 9）结构体与函数传参、返回值
				
				
				
  + （5）c函数库
	  + 1）c静态库与动态库
	  + 2）如何制作自己的静态库与动态库（windows和Linux）
	  + 3）静态库和动态库是如何链接到我们的程序中的
	 +4）什么是动态库的显示加载和隐式加载
	5）为什么使用库时，需要包含它的头文件
	6）c标准函数库都包含哪些子库
	7）c标准函数库与posix c函数库关系

	
		（6）数组与字符串
				1）数组的构建原理（多维数组是怎么基于一维数组引申出来的）
				2）数组指针与指针数组
				3）如何使用多级指针构建多维数组，并与传统的多维数组进行对比
				4）数组与sizeof和strlen
				5）字符串与数组
				6）字符串指针
					char *p = “hello”，对比char buf[] = "hello"，以此回顾第1章介绍的常量这个东西。
					
					字符串与sizeof和strlen
					
				7）字符串指针数组 与 main函数的argv参数
						字符串指针数组与NULL结尾。
						
						
		（7）结构体、联合体、枚举		
				1）结构体的传参
				2）结构体的强制转换
				3）结构体的对齐
				4）结构体与回调函数相结合，模拟面向对象的思想
					举实例介绍面c这种模拟面向对象思想，在构建复杂c工程项目时的好处。
				
				5）共用体与实际应用
				6）枚举与实际应用
					
					
		（8）c语言中无法独立成章的知识
	
				控制台程序和app程序
				1）数据的溢出
				2）大小端序
				3）逗号表达式
				4）void的作用是什么
				5）NULL、\0、null、0的异同
				
				6）转义字符
				7）typedef 与 ***_t类型
					typedef与宏、与数组、与结构体、与const等
					

				8）为什么scanf要求变量取地址，而printf不用
				
				9）main函数是谁调用的，main函数的参数到底有什么用、main的返回值给了谁
				
				10）字、半字等概念

				11）程序的优化
				
				12）程序的调试
				13）switch
					case前的指令是不执行的
					case中想定义局部变量，需要使用代码块
				

		（9）C语言的位操作
				&、|、~、^等
				
				
		（10）使用c来进行应用开发时，所涉及的其它相关知识
				1）多线程
				2）网络
				3）数据库
				4）数据结构
					单链接、双链表、内核链表
### 知识铺垫			
		
		2.3.1 我们应该如何学习本章
				学习本章的重点是理解，而不是记忆，大家要做的只是理解和消化本章，提升你的功力，在以后的工作学习中，当遇
			到一些比较难搞定的问题时，能够通过本章所理解的内容，引导你搞定一些深入的东西，找到解决方案，那么本章的学
			习目的就达到了。
					
					应该说不仅是本章，整个《C深度解析》这么课也是都以理解为主，不提倡死记硬背。
			
				
				为了能够让大家能够更好的理解课程内容，在有些名词的表述上可能会比较通俗，不是很准确，比如后面提到的
			“cpu的类型”这个词，其实指的是“cpu架构”，但是绝大多数同学并不知道什么是cpu架构，而作为应用工程师而言，我们
			又无需了解cpu架构方面的知识，为了方便理解就说成了"cpu类型"。
			
				类似的情况在后续课程能会有不少，如果你知道准确名词最好不过，如果不知道的话，就先按照我们的表述来理解，当然
			有疑问的话可以提出，我们很乐意回答。
				
				
		2.3.2 windows 和 Linux的命令行 
				本课程涉及到windows和linux命令行的使用，有关命令行，请看《Linux基础》这么课，在里面有详细介绍windows和linux
			命令行以及各种命令。
	
	
		2.3.3 IDE ——— Codeblocks
			在课程中，我们还不时的用到了Codeblocks这个IDE，我这里给出IDE的网盘地址，大家自行下载。
			链接：https://pan.baidu.com/s/1wbUUO0TKdX26MvxrHHLZtA 密码：k941
			
			Codeblocks主要是用来对比学习的，不需要深入熟悉这个IDE，安装完后，汉不汉化无所谓，使用英文版的也挺好。
	
	
		2.3.4 extern 和 static的作用
				本章会频繁的讲到extern和static这两个关键字，但是对于很多C底子比较差的同学来说，对这两个关键字不是很熟
			悉，所以这里要大概的介绍下，做点铺垫。
			
		（1）static
				
				1）修饰函数
						static修饰函数时表示，该函数只在本文件有效，也就是只能被本文件的其它函数调，其它文件不能调
					用（引用）。
						
						例子：
						a.c                       b.c
						
						int fun1(void)       			static void fun(int stu_num)
						{													{
							fun(100);//不能引用				......									
						
						}													}
						
						static就像是一把锁，把函数fun的有效范围锁在了b.c，其它.c看不见这个函数，自然无法调用。
						
						疑问：为什么static能锁住函数？
						答：因为static将函数名这个符号变成了“本地符号”，“本地符号”只在本文件可见，其它文件是看不见的，本章
						后续还会详细的介绍什么是本地符号，这里只是在做知识铺垫。
			
			
				2）修饰变量
					1）static修饰局部变量
						改变的是局部变量的存储位置，从栈变为静态存储区，与“本地符号”什么的没有关系。
						
						比如：
						int fun(int va)
						{
							int a; 
							int b = 100;
							
							...
						}
						
							a、b为“自动局部变量”，空间开辟于栈中，也许你对“自动局部变量”这个名字不熟悉，但是对所讲的这种情况绝对
						不陌生。
						
						加static修饰：
						int fun(int va)
						{
							static int a; 
							static int b = 100;
							
							...
						}
						
						a/b变为了“静态局部变量”，a/b的空间开辟于静态存储区，而不再是栈。
						（a）如果没有初始化的话，比如a就没有初始化，a的空间在静态区中的.bss区
						（b）如果有初始化的话，比如b就有初始化，b的空间在静态区中的.data区
						
						疑问：老师，我不懂什么是静态区，什么是静态区中的.data、.bss？
						答：不要紧，本章会深入介绍，这里只是想做点铺底，给大家建立起一点基础，后面学习起来就事半功倍了。
						
					2）static修饰全局变量
						与修饰函数一样，让全局变量只在本文件有效，其它文件无法引用。
						
						比如
						a.c                       b.c
						gVa = 200;//不能引用      static int gVa = 100;
						                          
																			int fun(void)
																			{
																				......
																			}
						
						
						b.c中的gVa被static修饰后，和被static修饰的函数一样，gVa变为了本地符号，只在本文件有效，不能被其它
						文件使用。
						
						static修饰全局变量时，与全局变量的存储位置无关系，全局变量的空间本来就是在静态存储区，加不加static，
						并不能改变存储位置，static只是改变了符号的有效范围，变为了本地符号。
						
						大家可以看出，static这个关键好像有点乱，没有固定套路，修饰变量和函数时，所起的作用不同，这个应该说
						是当初设计c语法时没有设计好导致的，使得static的用法有点乱，不过没关系，跟着我们的课程往后走，熟悉了后，
						你会发现其实很简单。
						
						
		（2）extern						
				1）修饰函数
					extern修饰的函数，表示除了能被本文件引用外，还可以被其它的文件引用，在其它文件中是可见的，只不过在其它
				文件中引用时，需要做声明，刚好与static相反。
					
						a.c                       				b.c
						extern void fun(int stu_num);			
						
						
						extern int a_fun(void)						extern void fun(int stu_num)
						{																	{
							fun(100);						     		 				......	
						}																	}
						
					
						
						事实上extern不需要明确写出，因为默认就是extern的，也就是说定义和声明可以写成如下形式。
						a.c                       				b.c
						void fun(int stu_num);						
																							
						int a_fun(void)										void fun(int stu_num)
						{																	{
							fun(100);						     		 				......	
						}																	}
						
					
						疑问：extern到底做了什么事情？
						答：extern修饰函数时，与static修饰函数时的作用刚好相反，extern修饰函数时表示，函数名是一个“全局符号”，
						“全局符号”的特点是，除了本文件可以引用外，在其它文件中也是“可见”的，只不过其它文件使用时，需要做声明，
						注意声明也必须是extern的，至于为什么，后面会详细解释。
						
						
				2）修饰变量
						extern修饰变量时，主要用于修饰全局变量，extern修饰局部变量的情况非常少见，所以暂不介绍。
						
						修饰全局变量时，与修饰函数一样，其实就是将全局变量名这个符号标记为“全局符号”，对其它文件来说也是可见的，
					不过同样的，其它文件引用时，需要做声明。
						
						a.c                       				b.c
						
						extern int gva;										extern int gVa = 100;
						                          
						gVa=200;//引用										int fun(void)
																							{
																								......
																							}
						
							声明时不能初始化。
							同样的extern可以省略，因为默认就是extern修饰的。
							有关extern的其它情况，后续课程涉及到时再介绍，目前就讲这些，还是那句话，目的只是想做点铺垫。
