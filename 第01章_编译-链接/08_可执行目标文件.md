# 5. 可执行目标文件
	
## 5.1 如何得到可执行目标文件		
链接程序collect2/ld，将所有的可重定位目标文件静态链接在一起，就得到了可执行目标文件。  
图：[待补]  
静态链接动态库时，只是留下函数的接口，当程序运行时再动态加载动态库。  
简单理解的话，链接的过程，其实就是将所有的.o文件合并为一个可执行文件的过程。  
`链接时，链接程序（静态链接器）做了什么事情？`  
**链接器主要做两件事情**
+ 第一：符号解析
+ 第二：地址重定位。
有关这两件事情，我们在前面大概的介绍过，接下来我们将会较为详细的介绍下这两件事。  

				
## 5.2 符号解析
### 5.2.1 符号解析的目的

确定模块中引用的每个符号都有明确的定义，并将每个符号的引用与定义关联起来。  
如果你引用了一个符号，结果这符号没有被定义，程序是无法运行的。  
比如：				
+ （1）如果引用的全局变量没有定义的话
     符号没有定义，这个变量就没有对应的空间，没有变量空间，就没办法进行读写了。
     
+ （2）如果引用的函数没有定义的话
    函数体（函数指令）就不存在，函数没办法调用。		
			
### 5.2.2 如何解析符号
 检查模块（.o）的.symtab符号表，看符号的定义情况。


#### （1）情况1：符号就是在本模块定义的（本地符号）
   像这种情况的话，链接器不需要做什么太多的解析工作，因为符号就是在本模块中定义的，每个符号对应的空间就被定义在了本模块的某个节中(比如.text、.data等节)，引用该符号时肯定没有问题。  

#### （2）情况2：符号由本模块引用，但是在其它模块定义的（全局符号）  
   被标记为UND的符号就是这种情况，UND表示此符号只是在本模块引用，但是在其它模块定义的。其实链接器进行符号解析时，重点解析的是标记为UND的符号，解析时会检查UND符号是否在其它模块中有定义。  

   `怎么解析UND符号的？`
    解析时，对于本模块中UND的符号，链接器会查看其它模块的.symtab符号表，看该符号是否在其它模块中有定义，如果找到定义，就将符号的引用和定义关联起来，如果找不到，链接器就会报undefined reference to ‘符号名’的错误。

比如：
```c
// a.c
int fun();
int main(void)
{
    fun();
    return 0;
}
```

gcc编译链接:
```shell
zxf@ubuntu:~/Desktop$ gcc a.c  b.c -o a
/tmp/ccTyxboK.o: In function `main':
a.c:(.text+0xa): undefined reference to `fun'
collect2: error: ld returned 1 exit status

undefined reference to `fun'这个错误是由链接器报的。
```


#### （3）说说有关编译链接时的报错	
其实编译链接时，四个阶段都有可能会报错误。

+ 1）预处理					
	`a.c ---> a.i（cpp、cc1）`  

	报预处理的错误，凡是宏、头文件包含、预编译等错误都是在预处理阶段，由“预处理器”报的。


+ 2）编译阶段
		`a.i ----> a.s （cc1）`  
	这个阶段报的都是c语法错误，因为这个阶段的主要目的就是按照c语法格式去解释c源码文件，然后翻译得到汇编，所以编译阶段报的主要是c语法的错误，只要你不按照c语法格式的要求写，就会报C语法错误。

	比如：
	+ （a）各种c关键字用错、写错
		+ 写错：return 10  写成了 retrun 10
		+ 用错：
		  ```c
		  switch(a)
		  {
		      case 12.6: a = 10;//c语法要求，switch的case不能跟浮点数
		  }
		  ```
	+ （b）各种重复定义
		编译时，是以单个源码文件为单位来操作的，单个源码文件（模块）中的一些关键内容，是不能重复定义的。
		+ 变量重复定义的错误
		  ```c
		  // a.c
		  int a = 100;
		  int a = 101;
		  int main(void)
		  {
		  }
		  ```
		   `疑问`：  
		   	```c
			int a; 
			int a = 100;
			```
			算不算重复定义?
		   答：这种不算，为什么不算，后面解释。  
                + 同一模块的重复定义，编译器编译时就会检查出来，不同模块之间的重复定义，只能留给链接器检查。
		```c
		// a.o                   
		int a = 10;          
		```
		```c
		// b.o
		int a = 100;
		```
		+ 类型重复定义的错误
			比如：
			```c
			a.c 
			struct student
			{
				int num;
			};
			struct student
			{
				int num;
			};
			int main(void)
			{
			}
			```
			`旁注`：像int、float、char、struct student等类型，是c语法格式才有的东西，是专门给cc1编译器用的，这些类型决定了数据空间的存储结构和大小，比如：  
				```c
				int a; 		//整形存储结构，4字节
				float b;	//浮点存储结构，4字节
				```
				一旦编译器cc1将其编译为汇编后，这些类型就消失了。    
				其实所有属于C语法格式的东西（比如，c的类型、关键字等），在cc1编译之后，都将不复存在。    
		+ 模块中函数重定义的错误
                      ```c
		        // a.c
			int fun()
			{
			    ...
			}
			int fun()
			{
		            ...
			}
		      ```
+ （3）汇编
		
		a.i -—————> a.s
		a.s ——————> a.o (as)

   事实上，汇编阶段并不会报什么错误，不报错的原因，并不是因为汇编器as没有检错的能力，而是只要c源码被编译为a.s时通过了，也就是说只要c源码没有错误，那么编译得到的a.s就没问题，从a.s汇编为a.o时，其实没有什么需要报的错误。


+ （4）链接
    > 报各种链接时产生的链接错误，比如  
	+ 某模块引用的符号，找遍其它所有模块，都找不到它的定义时，就会报undefined reference to ‘符号名’的错误
	+ 不同模块有强符号重复定义时，报重复定义的错误
        + 初始化了全局变量的重复定义
			```
			a.o                    b.o
			int a;                 int a = 100
			```
              链接时会报a重复定义了。  
		`如果不想报错怎么？`  
		+ 给其中一个加static，或者两个都加static  
		   加了static后，符号就是本地的，对其它模块无影响。
		+ 将其中一个的初始化去掉  
		  没有初始化的符号是弱符号，强弱符号不会冲突，有关强弱符号的问题，后面还会介绍。
	+ 同名函数的重复定义
		```c
		// a.o               // b.o
		float fun(int a)     int fun(void)
		{                    {
		}                    }
		```
		旁注：有关c++/java中同名函数的问题。  
		+ c的情况
			对于c来说，不管函数参数一不一样，只要函数名相同，就被认为是重名。
		+ c++/java等
			这类语言的函数允许重载，重载的意思就是说，函数名相同不一定重名，只要参数不同，就是两个不同的函数，
			```cpp
			int fun(int a)
			{
			}
			int fun(int b, int c)
			{
			}
			```
			因为在进行函数重名的判断时，函数名和函数参数会合在一起判断，只有当函数名和参数完全相同，才能算是重名。

### 5.2.3 链接器在符号解析时，是如何解决全局符号的重名问题的	
  前面说过，对于模块内部符号重名的情况，在编译时cc1编译器会检查出来，对于不同模块之间的全局符号重名情况，只能由链接器解析时来检查。
#### （1）模块之间全局符号重名的情况是无法避免的
  为了方便工程的组织管理，程序肯定是某块化组织管理的，此时模块之间必然会涉及全局变量和函数的声明，
	比如：
	```c
	// a.c                         		// b.c
	int fun();
	int a;                     		int a = 100;
	int main(void)                          int fun()
	{					{																  ...
		a = a + 100;			}
		fun();                                     
	}	
	```
	a.c中为了使用b.c中定义的a和fun，需要在a.c中进行声明，声明的符号与定义的符号是同名的，链接器将这两个文件链接为一个可执行文件，同名的符号就必须统一(合并)为一个，所以链接器进行符号解析时，重名符号的统一是必不可少的。


#### （2）链接器解析符号时，是如何解决全局符号重名的情况
 > 链接器根据符号的强弱共存规则来解析。
	+ 1）全局符号的强弱之分
		+ 1）全局变量
			+ （a）强符号：初始化了的全局变量
			+ （b）弱符号：未初始化的全局变量
		+ 2）函数
			+ （a）强符号：函数定义
			+ （b）弱符号：函数声明
			每个全局符号是强符号还是弱符号，在.symtab表中会有相应的记录。
	+ 2）重名符号的强弱共存规则
		+ 1）不允许多个同名的强符号同时存在，存在的话就报错
		+ 2）强符号只有一个，其它同名的都是弱符号的话，统一时，选强符号，舍弃弱符号
		+ 3）同名符号如果全都是弱符号的话，留其中某个，其它舍弃，留谁由链接器来决定
	+ 3）举例
		+ （a）例子1
				```c
				// a.c                        // b.c
				int a = 100;		      int a = 200;
				int fun()                     (extern) int fun()
				{                             {
					a += 10;                    a = a - 100;
							      }
				int main(void)            
				{
					static int a = 10;
					fun();
				}
				```
				由于文件中定义的全局变量a和函数fun都是全局的强符号（extern修饰的），在各自的.symtab符号表中，a和fun都会被标记为全局强符号。
				链接器进行符号解析时，会去检测这两个模块的.symtab表中的符号，发现这各自的a、fun都是全局强符号，根据强弱符号的共存规则，一山不容二虎，存在多个同名全局强符号时会报错。
			如何解决?
			+ 将其中的某个强符号变为弱符号
				```c
				int a = 100;  ————> int a;
				int fun(){...} ————> int fun();
				```
				留强去弱。
			+ 使用static来解决
				只要将其中的某个或者两个使用static修饰，将其变为本地符号，就不会存在冲突的情况。  
				```c
				int a = 100;  ————> static int a = 200;
				int fun(){...} ————> static int fun();
				```
				旁注：全局变量和函数加static，目的是将全局符号变为本地符号。局部变量加static，是将局部变量的从自动局部变量（栈）变为静态局部变量（.data/.bss）。
		+ （b）例子2
				```c
				// a.c                    // b.c
				int a;			  int a;
				int main(void)            
				{
					fun();
				}
				```
				`两个模块的a都是弱符号，统一符号时，留下其中一个即可。`
#### （3）cc1编译器处理模块内符号重名的情况								
  链接器处理模块间的全局符号的重名时，是按照强弱符号的规则来处理的。  
  对于模块内部的符号重名问题，编译器cc1在编译时，其实也是按照强弱符号的规则来处理的。  
	+ 1）例子1：
		```c
		// a.c 
		int a = 100;
		int a = 300;
		int fun()
		{
		}
		int fun()
		{
		}
		int main(void)
		{
		}
		```
		`编译时会报重复定义的错误（强符号只能有一个）。`
	+ 2）例子2：
		```c
		a.c 	
		int a;
		int a;
		int main(void)
		{
		}
		int a = 10;
		```
		没有错误，因为不存在强符号的冲突问题，编译时会统一为一个，.symtab只会记录一个a。  
		在经典的c讲解中，这种情况将int a解释成“int a = 100;这个定义”的声明，实际上本质关系是强弱符号关系。  
		只不过在单个模块中，弱符号（声明）可以将强符号（定义）的作用域提前。  
	+ 3）例子3
		```
		// a.c 	
		static int a = 20;
		int a = 10;
		int main(void)
		{
		}
		```
		`大家觉得会报错吗？`
		答：会报错，虽然一个是全局的，一个是本地的，但是由于都在一个模块中，因此编译时肯定报错。  
		但是如果它们两个是在不同的模块中的的话，链接器链接时就不会报错，这个前面讲过。
		```c
		// a.c 	                // b.c
		int a = 10;             static int a = 20;
		int main(void)
		{
		}
		```



#### （4）再说说声明和定义
  事实上，对于编译器、链接器来说，并不知道什么是声明、什么是定义，声明和定义只是学习C语言时会了表述的方便，我们自己的给的，编译器/链接器只知道强符号和弱符号，解析时是按照强弱符号的规则来处理的。  
  我们以全局变量为例，你会发现其实不太好明确的区分定义和声明。
	+ 1）能够区分的例子
		+ （a）例子1
			```c
			a.c 
			int a;
			int a = 100;
			...
			```
			针对这种情况来说，我么认为后面有初始化的a是定义，前面那个没初始化的a是后面a的声明。
		+ （b）例子2								
			工程中有两个.c
                        ```c
			a.c               b.c
			int a;	          int a = 0;
			...               ...
			```
			前面说过，没有明写出extern，默认就是extern修饰的。  
			有初始化的是定义，没有初始化的是声明。  
			在以上两个例子中，都能明确的区分出定义和声明。  
	+ 2）不能区分的例子
		```c
		a.c 
		int a;
		int a;
		int a;
		....
		```
		在这种情况下，到底那个是定义，那个是声明呢，不好讲了，你或许会说都是定义，都是声明，这就没有什么明确区分了。  
		又比如：  
		```c
		a.c
		int a;
		```
		只有一个int a时，到底应该说成是定义，还是说成声明呢？    
		又比如工程中有两个.c    
		```c
		a.c               b.c
		int a;		  int a;
		```
		你告诉我那个是声明，那个是定义，也是同样的情况。  
		所以说对于编译器/链接器来说，它不关心什么是定义、什么是声明，也没办法以定义和声明来区分，人家只关心强弱符号。    
		不过以后为了表述的方便，我们还是会继续使用“定义”和“声明”这两个概念，只不过在理解了强弱符号之后，大家心里应该清楚本质到底是什么。   
		以后不会再严格区分定义和声明，像int a;这种未初始化的情况，我们可能即会说成是定义，也可能会说成是声明，只要大家理解了强弱符号，说成什么其实都无所谓，只要方便表达和理解即可。  
								
								
