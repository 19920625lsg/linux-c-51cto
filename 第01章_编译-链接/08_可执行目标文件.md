5. 可执行目标文件
	
	5.1 如何得到可执行目标文件		
			链接程序collect2/ld，将所有的可重定位目标文件静态链接在一起，就得到了可执行目标文件。
			图：
			
			
			静态链接动态库时，只是留下函数的接口，当程序运行时再动态加载动态库。
			
			
			简单理解的话，链接的过程，其实就是将所有的.o文件合并为一个可执行文件的过程。
		
			
			链接时，链接程序（静态链接器）做了什么事情 
				链接器主要做两件事情，
				第一：符号解析
				第二：地址重定位。
				
				有关这两件事情，我们在前面大概的介绍过，接下来我们将会较为详细的介绍下这两件事。

				
	5.2 符号解析
		5.2.1 符号解析的目的
		
				确定模块中引用的每个符号都有明确的定义，并将每个符号的引用与定义关联起来。
				
				如果你引用了一个符号，结果这符号没有被定义，程序是无法运行的。
				
				比如：				
			（1）如果引用的全局变量没有定义的话
						符号没有定义，这个变量就没有对应的空间，没有变量空间，就没办法进行读写了。
					
					
			（2）如果引用的函数没有定义的话
						函数体（函数指令）就不存在，函数没办法调用。
			
			
			
		5.2.3 如何解析符号
				检查模块（.o）的.symtab符号表，看符号的定义情况。
				
				
			（1）情况1：符号就是在本模块定义的（本地符号）
						像这种情况的话，链接器不需要做什么太多的解析工作，因为符号就是在本模块中定义的，每个符号对应的空间
					就被定义在了本模块的某个节中(比如.text、.data等节)，引用该符号时肯定没有问题。
						
						
			（2）情况2：符号由本模块引用，但是在其它模块定义的（全局符号）
						被标记为UND的符号就是这种情况，UND表示此符号只是在本模块引用，但是在其它模块定义的。
						其实链接器进行符号解析时，重点解析的是标记为UND的符号，解析时会检查UND符号是否在其它模块中有定义。
					
						怎么解析UND符号的？
						解析时，对于本模块中UND的符号，链接器会查看其它模块的.symtab符号表，看该符号是否在其它模块中有定义，
					如果找到定义，就将符号的引用和定义关联起来，如果找不到，链接器就会报undefined reference to ‘符号名’的
					错误。
						
					比如：
						a.c
						
						int fun();

						int main(void)
						{
							fun();

							return 0;
						}
						
						gcc编译链接
						zxf@ubuntu:~/Desktop$ gcc a.c  b.c -o a
						/tmp/ccTyxboK.o: In function `main':
						a.c:(.text+0xa): undefined reference to `fun'
						collect2: error: ld returned 1 exit status

						undefined reference to `fun'这个错误是由链接器报的。
						
						
			（3）说说有关编译链接时的报错	
						其实编译链接时，四个阶段都有可能会报错误。
					
					1）预处理					
							a.c ---> a.i（cpp、cc1）
							
							报预处理的错误，凡是宏、头文件包含、预编译等错误都是在预处理阶段，由“预处理器”报的。
						
						
					2）编译阶段
							a.i ----> a.s （cc1）
							
							这个阶段报的都是c语法错误，因为这个阶段的主要目的就是按照c语法格式去解释c源码文件，然后翻译得到汇编，
							
							所以编译阶段报的主要是c语法的错误，只要你不按照c语法格式的要求写，就会报C语法错误。
							
							比如：
							（a）各种c关键字用错、写错
									· 写错：return 10  写成了 retrun 10
									· 用错：
										switch(a)
										{
														case 12.6: a = 10;//c语法要求，switch的case不能跟浮点数
										}
										
							（b）各种重复定义
										编译时，是以单个源码文件为单位来操作的，单个源码文件（模块）中的一些关键内容，是不能重复
									定义的。
							
									· 变量重复定义的错误
										a.c
										int a = 100;
										int a = 101;
										
										int main(void)
										{
										}
										
										疑问：int a; 
													int a = 100;
													算不算重复定义。
												
										答：这种不算，为什么不算，后面解释。

										
										同一模块的重复定义，编译器编译时就会检查出来，不同模块之间的重复定义，只能留给链接器检查。
										a.o                   b.o
										int a = 10;           int a = 100;
										
										
										
									· 类型重复定义的错误
										比如：
										a.c 
										struct student
										{
											int num;
										};
										
										struct student
										{
											int num;
										};
										
										int main(void)
										{
										}
							
										旁注：像int、float、char、struct student等类型，是c语法格式才有的东西，是专门给cc1编译器用的，
										这些类型决定了数据空间的存储结构和大小，比如：
											int a; 		//整形存储结构，4字节
											float b;	//浮点存储结构，4字节
											
											一旦编译器cc1将其编译为汇编后，这些类型就消失了。
											其实所有属于C语法格式的东西（比如，c的类型、关键字等），在cc1编译之后，都将不复存在。
											
											
									· 模块中函数重定义的错误
										
											a.c
											int fun()
											{
												...
											}
											
											int fun()
											{
												...
											}
											
										
							
							（c）汇编
										a.i -—————> a.s
										a.s ——————> a.o (as)
							
										事实上，汇编阶段并不会报什么错误，不报错的原因，并不是因为汇编器as没有检错的能力，而是只要
									c源码被编译为a.s时通过了，也就是说只要c源码没有错误，那么编译得到的a.s就没问题，从a.s汇编
									为a.o时，其实没有什么需要报的错误。
										
										
							（d）链接
									
							
									报各种链接时产生的链接错误，比如
									
									· 某模块引用的符号，找遍其它所有模块，都找不到它的定义时，就会报
											undefined reference to ‘符号名’的错误
									
									
									· 不同模块有强符号重复定义时，报重复定义的错误
									
										- 初始化了全局变量的重复定义
										
												a.o                    b.o
												int a;                 int a = 100;
												
												链接时会报a重复定义了。
												
												如果不想报错怎么？
												+ 给其中一个加static，或者两个都加static
													加了static后，符号就是本地的，对其它模块无影响。
									
												+ 将其中一个的初始化去掉
													没有初始化的符号是弱符号，强弱符号不会冲突，有关强弱符号的问题，后面还会介绍。
													
									
										
										- 同名函数的重复定义
												a.o            	b.o
												float fun(int a)  int fun(void)
												{              	{
													
												}              	}

				
										旁注：有关c++/java中同名函数的问题。
										
										· c的情况
											对于c来说，不管函数参数一不一样，只要函数名相同，就被认为是重名。
											
										· c++/java等
												这类语言的函数允许重载，重载的意思就是说，函数名相同不一定重名，只要参数不同，就是两个
											不同的函数，
												
												int fun(int a)
												{
													
												}
												
												int fun(int b, int c)
												{
													
												}
												
												因为在进行函数重名的判断时，函数名和函数参数会合在一起判断，只有当函数名和
											参数完全相同，才能算是重名。
												
											
			
			
			
			
			
			
			
					
出品：佳嵌工作室
----------------------------------------------------------------------------------------------------------------------------
	“佳嵌工作室”致力于物联网、嵌入式产品以及‘物联网、嵌入式技术课程’的研发，希望所推出的技术课程，能够帮助到正在努力
学习物联网、嵌入式的同学，欢迎大家和我们一起共同学习，共同进步。
----------------------------------------------------------------------------------------------------------------------------																							
	
			5.2.3 链接器在符号解析时，是如何解决全局符号的重名问题的	
					前面说过，对于模块内部符号重名的情况，在编译时cc1编译器会检查出来，对于不同模块之间的全局符号重名情况，
				只能由链接器解析时来检查。
				
				
				（1）模块之间全局符号重名的情况是无法避免的
					
					为了方便工程的组织管理，程序肯定是某块化组织管理的，此时模块之间必然会涉及全局变量和函数的声明，
					比如：
					
					a.c                         							 b.c
					
					int fun();
					int a;                     								 int a = 100;
					
					int main(void)                             int fun()
					{																					 {
						a = a + 100;
						fun();                                     ...
					}			                                     }
					
					
						a.c中为了使用b.c中定义的a和fun，需要在a.c中进行声明，声明的符号与定义的符号是同名的，链接器将这两
					个文件链接为一个可执行文件，同名的符号就必须统一(合并)为一个，所以链接器进行符号解析时，重名符号的统一
					是必不可少的。

					
				（2）链接器解析符号时，是如何解决全局符号重名的情况
						
						链接器根据符号的强弱共存规则来解析。
						
						1）全局符号的强弱之分
							1）全局变量
								（a）强符号：初始化了的全局变量
								（b）弱符号：未初始化的全局变量
								
							2）函数
								（a）强符号：函数定义
								（b）弱符号：函数声明
					
								每个全局符号是强符号还是弱符号，在.symtab表中会有相应的记录。
					
						2）重名符号的强弱共存规则
							1）不允许多个同名的强符号同时存在，存在的话就报错
							2）强符号只有一个，其它同名的都是弱符号的话，统一时，选强符号，舍弃弱符号
							3）同名符号如果全都是弱符号的话，留其中某个，其它舍弃，留谁由链接器来决定
							
							
						3）举例
							（a）例子1
									a.c                       b.c
									int a = 100;				int a = 200;
									
									int fun()                 (extern) int fun()
									{                         {
										a += 10;                    a = a - 100;
									}								          }
									
									int main(void)            
									{
										static int a = 10;
										fun();
									}
									
									由于文件中定义的全局变量a和函数fun都是全局的强符号（extern修饰的），在各自的.symtab符号表中，
								a和fun都会被标记为全局强符号。
									
									链接器进行符号解析时，会去检测这两个模块的.symtab表中的符号，发现这各自的a、fun都是全局强符号，
								根据强弱符号的共存规则，一山不容二虎，存在多个同名全局强符号时会报错。
									
									
								如何解决：
								· 将其中的某个强符号变为弱符号
									int a = 100;  ————> int a;
									int fun(){...} ————> int fun();
									
									留强去弱。
								
								· 使用static来解决
										只要将其中的某个或者两个使用static修饰，将其变为本地符号，就不会存在冲突的情况。
									int a = 100;  ————> static int a = 200;
									int fun(){...} ————> static int fun();
									
										
									旁注：全局变量和函数加static，目的是将全局符号变为本地符号。
												局部变量加static，是将局部变量的从自动局部变量（栈）变为静态局部变量（.data/.bss）。
									
									
									
							（b）例子2
									a.c                       b.c
									int a;										int a;
									
									int main(void)            
									{
										fun();
									}
									
									两个模块的a都是弱符号，统一符号时，留下其中一个即可。
									
									
									
				（3）cc1编译器处理模块内符号重名的情况								
						链接器处理模块间的全局符号的重名时，是按照强弱符号的规则来处理的。
						
						对于模块内部的符号重名问题，编译器cc1在编译时，其实也是按照强弱符号的规则来处理的。
						
						1）例子1：
							a.c 
							int a = 100;
							int a = 300;
							
							int fun()
							{
							
							}
							int fun()
							{
							
							}
							
							int main(void)
							{
								
							}
							
							编译时会报重复定义的错误（强符号只能有一个）。
									
						2）例子2：
							a.c 	
							int a;
							int a;
							
							
							int main(void)
							{
								
							}
							int a = 10;
							
							没有错误，因为不存在强符号的冲突问题，编译时会统一为一个，.symtab只会记录一个a。
							
							在经典的c讲解中，这种情况将int a解释成“int a = 100;这个定义”的声明，实际上本质关系是强弱符号关系。
							
							只不过在单个模块中，弱符号（声明）可以将强符号（定义）的作用域提前。
							
								
						3）例子3
							a.c 	
							static int a = 20;
							int a = 10;
							
							int main(void)
							{
							}
							
							大家觉得会报错吗？
							答：会报错，虽然一个是全局的，一个是本地的，但是由于都在一个模块中，因此编译时肯定报错。
							
								但是如果它们两个是在不同的模块中的的话，链接器链接时就不会报错，这个前面讲过。
								a.c 	                  b.c
																				 
								int a = 10;             static int a = 20;
								
								int main(void)
								{

								}
						
						
					
					（4）再说说声明和定义
								事实上，对于编译器、链接器来说，并不知道什么是声明、什么是定义，声明和定义只是学习C语言时
							会了表述的方便，我们自己的给的，编译器/链接器只知道强符号和弱符号，解析时是按照强弱符号的规则
							来处理的。
								
								我们以全局变量为例，你会发现其实不太好明确的区分定义和声明。
							
							1）能够区分的例子
								（a）例子1
										a.c 
										
										int a;
										
										int a = 100;
										
										...
										
										针对这种情况来说，我么认为后面有初始化的a是定义，前面那个没初始化的a是后面a的声明。
								
							（b）例子2								
									工程中有两个.c
									a.c               b.c
									
									int a;						int a = 0;
									
									...               ...
									
									前面说过，没有明写出extern，默认就是extern修饰的。
									有初始化的是定义，没有初始化的是声明。
									
								
									在以上两个例子中，都能明确的区分出定义和声明。
								
								
							2）不能区分的例子
								a.c 
								
								int a;
								int a;
								int a;
								
								....
								
								在这种情况下，到底那个是定义，那个是声明呢，不好讲了，你或许会说都是定义，都是声明，这就没有什
							么明确区分了。
								
								又比如：
								a.c
								
								int a;

								只有一个int a时，到底应该说成是定义，还是说成声明呢？
								
								
								又比如工程中有两个.c
								
								a.c               b.c
								
								int a;						int a;
															
								你告诉我那个是声明，那个是定义，也是同样的情况。
								
								所以说对于编译器/链接器来说，它不关心什么是定义、什么是声明，也没办法以定义和声明来区分，人家
							只关心强弱符号。
							
								不过以后为了表述的方便，我们还是会继续使用“定义”和“声明”这两个概念，只不过在理解了强弱符号之后，
							大家心里应该清楚本质到底是什么。
							
								以后不会再严格区分定义和声明，像int a;这种未初始化的情况，我们可能即会说成是定义，也
							可能会说成是声明，只要大家理解了强弱符号，说成什么其实都无所谓，只要方便表达和理解即可。
								
								
								
								
								
								
								
								
								
							
							
						
						
				
			
					
出品：佳嵌工作室
------------------------------------------------------------------------------------------------------------------
	“佳嵌工作室”致力于物联网、嵌入式产品以及‘物联网、嵌入式技术课程’的研发，希望所推出的技术课程，能够帮助到正在努力
学习物联网、嵌入式的同学，欢迎大家和我们一起共同学习，共同进步。
------------------------------------------------------------------------------------------------------------------
																									
			
	5.3 重定位			
			链接器在完成了符号解析之后，就可以进行重定位了。
			
			不过由于重定位的内容比较复杂，当然如果你是做编译器或者逆向的话，重定位的原理是必须要求掌握的，但是作为
		应用开发者来说这不需要，因为了解详细原理的意义不大，因此有关重定位，我们这里只介绍基本内容。
		
		
		5.3.1 重定位的种类
			重定位的种类其实有两种，
			
			（1）第一种：动态重定位
						所谓动态重定位就是，重定位的动作是在程序运行的过程中动态完成的，因此被称为动态重定位。
					有关动态重定位，在讲Uboot和内核移植时会介绍。
					
					
			（2）第二种：静态重定位
					所谓静态重定位就是，由链接阶段完成的重定位，因为是在程序运行之前做的重定位，因此被称为静态重定位。
					
					所以我们现在要讲的由链接器完成的静态重定位。
					
					
					
		5.3.2 静态重定位做什么事情
				做两件很重要的事情，
				
				· 将同名节整合为新的同名聚合节
				· 将可执行目标文件中各聚合节的地址，重定位为实际运行的地址
				
				
			（1）将同名节整合为新的同名聚合节
					其中重点是将.text和.data节聚合为新的同名聚合节，为了能够将.text和.data节聚合为新的聚合节，需要依赖一
				些信息，这些信息存储在了.rel.text和.rel.data中。
				
					.rel.text中的信息：实现.text的聚合
					.rel.data中的信息：实现.data的聚合
					
					
			（2）将可执行目标文件中各聚合节的地址，重定位为实际运行的地址
						其实就是将程序在内存中实际运行时的内存地址赋给聚合节，程序在内存中运行时，就是按照重定位的地址来
					运行的，至于重定位的地址具体是多少，要分裸机和OS两种情况来看。
					
					
					
					
					1）如果程序是直接裸机运行的话（没有OS）
							程序是直接运行在物理内存上的，所以重定位的运行地址就是物理地址，所以CPU取指时所取得的指令地址
						就是物理地址。

						
					2）如果程序是基于OS运行的话
					
							大部分的OS都有提供虚拟内存机制，所以程序是运行在OS虚拟内存上的，虚拟内存所提供的地址就是虚拟地址，
						，所以CPU取指时，所取得的指令地址就是虚拟地址。
							
							虚拟内存是基于真实的物理存储器构建出来的，所以程序最终其实还是运行在物理内存上的，因此虚拟地
						址最终还是会被转为物理地址，然后到物理内存上该物理地址所指定的位置读取指令。
						
						
						疑问：反正程序最终都是运行在物理内存上的，为什么要在真实物理存储器上弄出一个虚拟内存呢？
							有关这个原因，请大家看《计算机体系结构———操作系统》的课程，里面介绍虚拟内存时有详细介绍。		
							我们都知道现在的OS基本都支持多进程并发运行，其实多进程并发运行与虚拟内存机制有着莫大关系。
							
									
						疑问：什么是进程，与程序什么关系？
							· 进程：动态运行的程序，进程有生有死，是一个动态运行的过程
							· 程序：存放在硬盘上，没有运行的静态的可执行目标文件。
								
								
						疑问：什么是进程的并发运行？
							多个进程同时运行，这就并发运行，比如酷狗/浏览器/wps同时运行着，这几个程序就是并发运行的。

							我们这里简单认为，单个程序对应单个的进程，实际上一程序可以是多进程的，有关这一点，请大家看
						《Linux系统编程、网络编程》这门课，有详细介绍。
							
							
						为什么能够并发运行？
							实际上与虚拟内存有很大关系。因为有虚拟内存这个东西，所以每个程序运行时，虚拟内存机制会给每一个进程
						都弄一个虚拟内存，也就是说每一个进程都是运行在自己独立的虚拟内存上的。
							图：
										
										
									
							由于进程是运行在虚拟内存上的，因此“虚拟内存空间”也被称为了“进程空间”。

							进程运行在自己的虚拟内存上时，每个进程运行了一个短暂的时间片（ms）后，快速切换到其它进程上
						运行，此时cpu就会取指运行不同进程的指令。
							图：
							
							
							
							如此在宏观上，我们会感觉所有的进程都是同时运行的，这就是进程的并发运行，从介绍可以看出，进程间的
						并发运行与虚拟内存机制有着密切的关系。
									
							与并发运行相对应的还是一个概念，那就是“并行运行”，有关这两个概念的异同请看
						《Linux系统编程、网络编程》的课程。
						

							我们这里所面对的OS是Linux，Linux有虚拟内存机制，所以gcc编译得到的程序基于Linux运行时，就是运行在
						虚拟内存上的。
								
						
						
			（3）如何指定重定位运行地址
			
					实际上是通过“链接脚本文件”来指定的，“链接脚本文件”里面会说明实际的运行地址是多少，重定位时会把把实际
				的运行地址赋值给新的聚合节，如此一来，函数和全局变量就有了真正可以运行的运行地址。
					
					实际运行时，将程序拷贝到运行地址所指定的内存位置，cpu的pc存放第一条指令地址(指向第一条指令_start)，
				然后整个程序就运行起来了。
					
					
					至于重定位时，给聚合节具体指定的运行地址应该是多少，这里要分裸机和OS两种情况来定。
					
					1）裸机运行
							运行地址（物理地址）是多少，可以由程序员自己来定，比如我们一般可以指定为0，表示程序需要拷贝到物
						理内存的0地址处，从0地址处开始存放。
						
							我们将0地址写到链接脚本文件中，gcc编译时给他指定链接脚本，重定位后运行地址就从0开始。
						
							我们后面讲到arm裸机时，会介绍如何修改这个链接脚本。
						
							裸机运行时，整个计算机上就一个程序，由于没有OS虚拟内存的参与，所以裸机只能运行一个程序（单进程）。
							
							
					2）基于OS运行
							运行地址（虚拟地址）为一个固定值，不同OS这个固定值不一样，比如在Linux这边
							32位OS：从0x08048000开始
							64位OS：从0x0000000000400000开始
							
							程序运行时，程序会被拷贝到虚拟内存的0x08048000或者0x0000000000400000位置处，然后pc指向_start，程序
						就运行起来了。
						
							这个地址也是指定在链接脚本中的，gcc编译基于Linux运行的程序时，这个链接脚本不需要我们自己给，是自动
						给的，这个脚本中会指定0x08048000或者0x0000000000400000的地址。
						
							而且gcc编译每一个程序，链接重定位所指定的地址都是0x08048000或者0x0000000000400000。
							
						疑问：重定位时，如果每个程序都是相同的0x08048000或者0x0000000000400000的话，运行时不会冲突吗？
						不会冲突，因为每个进程的虚拟内存是独立的，虽然都是相同的地址，但是底层实际对应的都是不同的物理空间，
						图：
						
						
						将虚拟地址转换为物理地址后，得到的物理地址是不同的，所以不同的物理地址所指向的物理空间不同，自然不
					同物理内存空间中存放的是不同程序的指令。
			
			



			
					
出品：佳嵌工作室
----------------------------------------------------------------------------------------------------------------------------
	“佳嵌工作室”致力于物联网、嵌入式产品以及‘物联网、嵌入式技术课程’的研发，希望所推出的技术课程，能够帮助到正在努力
学习物联网、嵌入式的同学，欢迎大家和我们一起共同学习，共同进步。
----------------------------------------------------------------------------------------------------------------------------																													
			
		5.3.3 可执行目标文件的ELF格式
				图：
			
			
			
			
		（1）相比.o的ELF格式，有哪些变化？
			
				（1）.rel.text和.rel.data消失了
						为什么这两个节会消失？
							
							链接器将各.o中同名的.text和.data节整合到一起时，会对整合后的.text和.data进行重定位。
						
						其实重定位时主要针对就是.text和.data节，不过这.text和.data节重定位时需要依赖.rel.text和.rel.data中的
						信息，一旦重定位结束后，这两个节的使命就完成了，自然也就会消失。
							
							
						
				（2）多出了两个节
						
						1）init节
							（a）作用
									这个节会提供_init等函数，专门用于实现程序的一些初始化。
									
									程序入口为_start，从_start开始执行后，在正式调用main函数之前，会先调用_init等函数进行程序的
								初始化（比如建立函数栈等等）。
									
									
							（b）init节怎么来的
									回顾gcc链接的过程，
									collect2    //链接程序
																	
									-dynamic-linker  /lib64/ld-linux-x86-64.so.2 //动态链接器

									crt1.o  crti.o  crtbegin.o //启动代码

									ccyIcm4A.o  			//自己程序的.o
																	
									-lc 						//libc，常用c函数库——c标准库的子库
																	
									crtend.o  crtn.o 		//扫尾代码

									init节就是由gcc提供的crt1.o、crti.o、crtbegin.o等.o构建而来的。


						2）“段头部表”节
								重定位时，链接器根据“链接脚本文件”所给的运行地址，给.text/.data中指令和变量重定位运行地址时，
							这些“运行地址”只是链接时理论上安排的。
							
								当加载程序到内存中运行时，就需要将硬盘上所存放的程序，搬到“运行地址”所指定的内存位置，段头部表中
							的内容，就是用来辅助加载程序的。
									
						
						
				
		（2）再说说“可执行目标文件”的ELF格式
					
					“可执行目标文件”的各个节，可以进行进一步的归类。
					
					图：
					
					
					
					总结：
					1）程序最终运行时，需要搬到内存上的节有：ELF/.init/.text/.rodata/.data/.bss。
							搬到内存上什么位置呢？
							搬到重定位的“运行地址”所指定的位置。
					
					2）ELF/.init/.text/.rodata：只读的存储段（代码段）
					
					3）.data/.bss：可读可写存储段（静态数据段）
							之所以称为静态数据段，是因为.data/.bss的空间规划，是在编译时就进行了理论安排，并不是程序运行起来
						才安排的，所以被称为静态数据段。
					

				
				
				
				
				
				
出品：佳嵌工作室
-------------------------------------------------------------------------------------------------------------------
	“佳嵌工作室”致力于物联网、嵌入式产品以及‘物联网、嵌入式技术课程’的研发，希望所推出的技术课程，能够帮助到正在努力
学习物联网、嵌入式的同学，欢迎大家和我们一起共同学习，共同进步。
-------------------------------------------------------------------------------------------------------------------
																							

		5.3.4 程序的加载、运行
		
				编译得到可执行目标文件后，就可以将“可执行目标文件”加载“运行地址”所指的内存位置，然后运行了。
			不过这里还是要分两种情况来看，第一种是裸机运行的情况，第二种是基于OS虚拟内存运行的情况。
			
			
			（1）裸机的情况
						使用专门针对裸机的编译器来编译程序，最后得到的就是可以在裸机上运行的可执行程序。
						
						加载裸机程序时，由专门的加载程序（加载软件）来实现的。
						如果你无法想象裸机程序是如何加载的话，你就想一想单片机程序的加载，因为单片机其实就是裸机的情况。
						
					
					
					1）加载
								其实加载的过程就是将“代码段”和“数据段”复制到内存上
								
								裸机时，链接器重定位后的“运行地址”是真实的物理地址，加载时直接将“代码段”和“数据段”复制到物理
							内存中“运行地址”所指定的位置。
							
								裸机运行地址是多少，可以由我们程序员自己来定。
									
								图：
								
								
								
								注意：裸机时就不是ELF格式头了，而是bin格式头。
									
						
						
						
					2）运行         
						（a）CPU的PC（程序计数器）存放第一条指令_start的地址，也就是将PC指向第一条指令_start。
								pc是cpu的寄存器之一。
								
						（b）从_start开始执行启动代码。
								
						（c）启动代码调用_init等函数进行初始化。
									初始化有一件非常重要的事情就是，从内存划出一片空间出来用作堆和栈，因为空间是以堆和栈的方式来
								管理的，因此就称为堆 和 栈。
								
								
						（d）启动代码调用main函数，main函数再调用各个子函数，我们自己写的代码就开始运行了。
								
						（e）main函数调用return关键字，返回到启动代码。
								对于裸机的来说，返回到启动代码就结束了。
										
								至于return的返回值，有没有返回值，对于裸机来说都没有什么影响。
								就算有返回值，将返回值返回给启动代码后，这个返回值对启动代码来说也没有什么意义。
								
								所以说，对于裸机来说，其实main函数的返回值没有什么意义，所以大家在学习单片机时候，以前的main
							函数的返回值都是void的。
								void main(void)
								{
									return;
								}
							
								不过现在都规范化了，单片机等裸机里面，也要求main函数的返回值类型为int型。
								int main(void)
								{
									return 0;
								}
								
								尽管在这里要求返回int型的返回值，但是我们自己应该清楚，在裸机下，main函数的返回值并没有
							什么大的意义。

									
									
					3）栈、堆
						前面说过，程序运行起来后，初始化代码会从内存中划出一片空间，用来作为程序运行所需要的栈和堆。
							
								图：
								
								
								
								
						（a）栈（stack）
									栈的意思是，表示内存空间以栈这种数据结构来进行管理，所谓管理就是管理空间的开辟和释放。
								学过栈这种数据结构的同学都知道，栈的特点是，只能在栈顶进行操作，不能够在栈的中间和栈底操作。
										
								· 栈是向下生长的
										所谓向下生长就是，栈底在最高地址处，当栈中没有任何空间被使用时，栈顶指针就指向栈底，
									每当栈顶被占用一个字节的空间，栈顶指针就向低地址方向移动一个字节。
										图：
										
										
										从高地址向低地址方向移动，就是向下生长，栈顶指针所指的那个字节是没被用的。
										栈顶和栈底之间的栈空间，就是被占用的空间。
	
	
										反过来，栈顶指针向高地址后退一个字节，就表示释放一个字节的空间。
										释放的意思就是将空间交出去，让别人可以使用。
										图：
										
										
										
										
										怎么理解栈顶指针？
										就是某个寄存器或则指针变量，专门用于存放栈顶字节的地址。
										
									
									
								· 栈的作用
								
										函数自动局部变量、形参等就开辟于栈。
										int fun(int a)
										{
											int b;
											...
										}
										
											不过这里有一点需要强调下，对于ARM来说，由于arm cpu内部寄存器比较多，所以如果形参在4个以内的，
										实际上形参是在寄存器中，而并不在栈中。
											如果超过4个的话，第4个往后的形参才会存在栈中。
											
											不过在intel的CPU上又不一样，因为Intel cpu的寄存器比较紧俏，所以形参基本都是存在栈中的。
										
											我们这里为了讲课的方便，我们一律认为形参都是在栈中的。
	
										从栈中开辟和释放自动局部变量、形参空间的过程，由函数被调用时，在运行的过程中自动完成的，
									无需程序员关心，开辟空间和释放空间的本质，其实就是栈顶指针移动的过程。

										
										
						（b）堆（heap）
									堆空间和栈空间的管理方式是有区别的。
									
								· 栈的话只能在栈顶才能进行操作，但是堆不是，堆的话可以在中间任何位置操作。
								· 堆的空间是向上生长的，也就是说在堆中开辟空间时与栈相反，是从低地址往高地址方向延伸的。
									图：
									
									
								· 栈的空间是自动开辟和释放的，但是堆的空间不是的，堆只能手动开辟和释放。
									
									- 从堆里面开辟空间
											程序需要调用malloc函数来手动开辟。
											
											所谓手动开辟，就是程序员需要在程序中亲自调用某个函数来实现，至于说在堆中什么位置开辟空间，
										这个由malloc函数的算法来决定。
													
									- 释放在堆中开辟的空间：在程序中调用free函数，手动释放
										释放的意思，也是将空间让出来，让别人可以使用。
								
		
		
			
			
出品：佳嵌工作室
-------------------------------------------------------------------------------------------------------------------
	“佳嵌工作室”致力于物联网、嵌入式产品以及‘物联网、嵌入式技术课程’的研发，希望所推出的技术课程，能够帮助到正在努力
学习物联网、嵌入式的同学，欢迎大家和我们一起共同学习，共同进步。
-------------------------------------------------------------------------------------------------------------------																																				
			
		（2）基于OS虚拟内存的情况
					
					基于OS运行程序时，常见有两种方式，
					· 在图形界面，双击快捷图标实现
					· 在命令行，执行./a.out命令实现
						
						我们前面说过，说每一个进程都是运行在自己的独立虚拟内存中的，命令行和图形界面本身也是一个
					程序（进程），所以也是运行在自己独立的虚拟内存上的。
					
				
				1）程序的加载
						当我们双击程序，或者执行./a.out命令时，就开始了程序的加载操作，具体步骤如下：
					
					
					（a）首先从父进程复制出一个子进程
					
								图形界面、命令行程序就是父进程，执行程序时会从父进程复制出子进程，复制的目的其实就是从父进程的
							“虚拟内存”复制出一个子进程的“虚拟内存”，准确讲应该是复制出“虚拟内存”的相关数据结构，用于建立子进
							程的虚拟内存。
								
								有了子进程的虚拟内存，就可以将新的程序加载到虚拟内存中了。
								
								图：
								
								
								
								
								虚拟内存空间被分为了两部分，一部分是内核空间，另一个部分是应用空间，应用程序的应该加载到应
							用空间。
							
	
								在Linux下复制子进程时需要调用Linux OS所提供的fork函数，该函数在《Linux系统编程、网络编程》
							中有详细介绍。fork是由父进程调用的。
							
								至于虚拟内存与真实物理内存之间的对应关系，这个事情就留给“虚拟内存机制”来操心。
							
							
					（b）调用加载器，将自己程序（新程序）的“代码段”和“数据段”加载到子进程虚拟内存的应用空间中
							
								基于Linux运行的话，gcc链接时重定位的运行地址是从0x08048000或者0x0000000000400000开始的，所以程序会
							被加载到虚拟内存中0x08048000或者0x0000000000400000地址往后的空间中。
								
								至于虚拟内存0~0x08048000或者0~0x0000000000400000之间的虚拟空间，则未被使用。
							
								图：
								
								
								
									
								基于Linux OS运行时，加载器是由Linux OS提供的，任何一个程序都可以通过execve这个系统API来调用
							加载器，为了方便称呼，我们就直接将“execve函数”称为加载器。
								
								
								有关调用fork函数创建子进程，然后调用execve函数加载新程序到子进程的过程，在
							《Linux系统编程、网络编程》第8章—进程控制有详细的介绍，大家把这章学完之后，你就知道在有OS时，
							新程序是如何基于OS运行起来的。

	
				
				2）运行
					（a）cpu的pc指向_start（将第一条指令——start所在位置的虚拟地址存放到pc）
					
					（b）从_start开始执行启动代码。
					
					（c）启动代码调用_init等函数进行初始化。
							其中很重要的就是弄出堆和栈这两个东西，这一点与前面裸机的情况时类似的，这里不再赘述。
							
							不过与裸机不同的是，在栈和堆之间，还有一个“共享映射区”。
							图：
							
							
					（d）启动代码调用main函数，main函数再调用子函数，我们自己写的代码就开始运行了。
						
					（e）main函数调用return关键字，返回到启动代码。
					
								有OS时，main函数将返回值return给启动代码后，启动代码会调用exit函数，接着将返回值返回给OS。
								在裸机情况下，启动代码不存在调用exit函数这一说，只有基于OS时才存在这种情况。
								
								
								疑问：将返回值返回给OS有什么用？
									在《Linux系统编程、网络编程》第7章—进程控制有详细介绍，我们这里只是C语言相关的课程，所以这个知
								识点不属于本门课的课程范围，请看《Linux系统编程、网络编程》。

									我们这里虽然讲的只是c的情况，实际上c++等其它语言的程序也是类似的。

							

							
			
			3）加载执行新程序后——子进程从父进程复制而来的堆/栈去哪里了
			
			（a）谁代表了堆和栈的存在
					堆栈指针代表了“堆和栈”的存在，堆栈指针存储在了寄存器或者静态区。
					
					堆栈指针在，堆栈就在，堆栈指针没有了，堆栈就没有了。
						
				
			（b）向子进程中加载新程序后会怎么样
						
						加载新程序之前，子进程中的所有内容（包括堆和栈），都是从父进程复制（继承）而来，子进程的.text、
					.data、...、堆栈与父进程的一模一样。
						
						加载新程序后，子进程原来的.text、.rodata等都被覆盖了，那么子进程原来的堆栈指针也就无效了，无效的意
					思就是原来的堆栈被释放了，释放的意思就是让出来，别人可以去操作了，只是以前的堆栈被使用时，里面的数值
					还遗留在了空间中。
						图：
						
						
					
						当exec加载新程序后，新程序的.text、.rodata、.data等会覆盖子进程原有的.text、.rodata、.data、.bss，
					然后开始执行新程序。
						
						执行新程序时一定是从.text中的“启动代码”开始执行的，当执行启动代码中设置堆栈的代码时，会重新设置新
					程序自己的堆栈指针，此时所代表的就是新程序自己的堆栈，只不过堆栈空间还是以前那个堆栈空间。
						
						这就好比上家公司搬走了，重新使用办公地点时，会从新布置办公空间的道理是一样的，只是重新布置，但是空间
					还是原来那个空间。
						
						
						
			（c）重新设置堆栈时，堆栈空间会被清零吗？
			
						子进程以前的堆栈被释放时，空间是没有清零的，设置新堆栈时清不清零，这个要看设置堆栈的代码是怎
					么做的，它可以清零，也可以不清零，实际上都是没有清零。
					
						不清零也没关系，只要我们开辟变量空间时，记得初始化一个新的值，将以前的值给它覆盖掉就行。
						就好搬进上家公司的地方时先不腾空空间，等用到哪些空间时，再搬新东西进去覆盖它即可。
						
						
						正是由于新程序重新设置堆栈时不会清零，所以当新程序最开始运行时，
						· 如果函数的“自动局部变量”没有赋初始值的话，就会是一个随机值，这个随机值就是子进程以前的栈所遗留的。
						· malloc从堆中开辟变量空间时，如果没有初始化值的话，也是子进程以前的堆所遗留的值。
							
							
						疑问：为什么以前遗留的值会被称为随机值？
						答：因为对于我们来说，并不知道里面到底遗留的是什么值，所以它可能是任何值，因此就是随机的，自然就被
						称为了随机值。
							就跟买彩票一样，号摇出来后肯定一个确定的数，但是对于不知道号是多少的我们来说，它可能是任何数，
						所以对于不知道号是多少的我们来说，它是一个随机值。
							
						
						新程序自己在释放“堆栈”中的变量空间时，实际上也不会清零，
						
						· 比如某函数运行结束，自动局部变量释放了，但是数据还遗留在了里面。
						· 比如free释放了malloc所开辟的空间，同样的，以前所使用数据也遗留在了里面。
						
							所以当新程序运行一段时间后，堆栈中的随机值已经不再是以前堆栈所遗留的数据了，而是自己所遗留的数据。
						
						
						因此，我们从堆栈中开辟变量空间时，如果不初始化的话，里面就是一个随机值，总结起来，随机来自于两个地方。
					· 新程序重新设置堆栈时没有清零，遗留了子进程的以前堆栈的数据
					· 新程序在运行的过程中，在释放堆栈中的变量空间时，也不会清零，也会导致随机值
						
						正是由于以上原因，在堆栈中开辟变量空间时，我们总是建议大家一定要初始化，否者这些随机值可能会带来
					一些麻烦，比如程序进行计算时不小心使用了随机值，从而导致程序计算结果不对，如果程序非常重要的话，这种错
					误的结果往往会带来很严重的大麻烦，不过好在于，一般性的程序都还无所谓。
					
						疑问：初始化时，我不知道初始化为什么值，怎么办呢？
						答：不知道初始化为多少，那就初始化为0（自己清零），比如。
						
						栈：
						int fun(void)
						{
							int a = 0;
							...
						}
						
						堆：
						int *p = malloc(4);
						bzero(p); //调用bzero将空间清零，或则使用memset也行，memset(p, 0, 4);
						
						
						memset与bzero的不同之处在于，bzero只能将内容设置为0，但是memset还可以设置为其它值，比如
						memset(p, 1, 4);，将4个字节全部设置1，bzero其实就是memset的特例。
						
						
			（d）请区分“释放 与 清零”，这是两回事
			
						很多同学总以为释放就是清零，清零就是释放，其实释放是释放，清零是清零，并不不是一回事，千万不要混淆，
					这就好比上厕所，上完厕所把厕所让出来是释放，走时把大便冲干净就是清零，对于不讲究的人来说，完全可以只
					释放厕所但是不清零，估计大家都挺讨厌这种人的。
					
						子进程以前的堆栈空间被释放时，其实只是把空间让出来，好让新程序重新设置自己的堆栈，但是空间并没
					有清零，以前的数据还遗留在了里面，而启动代码重新设置自己的堆栈时，往往也也不会清，所以还一直遗留着。
					不过，只要程序员在开辟变量空间时，记得初始化新值覆盖它，其实也没什么大不了的，总不至于会像不冲大便那样，
					让人讨厌。
						
					
						
						
						
					
					
				
						

									
出品：佳嵌工作室
----------------------------------------------------------------------------------------------------------------------------
	“佳嵌工作室”致力于物联网、嵌入式产品以及‘物联网、嵌入式技术课程’的研发，希望所推出的技术课程，能够帮助到正在努力
学习物联网、嵌入式的同学，欢迎大家和我们一起共同学习，共同进步。
----------------------------------------------------------------------------------------------------------------------------																																						
	
		（3）对比裸机运行和基于os虚拟内存运行时，程序的内存结构（内存布局）
					
				1）什么是程序的内存布局？
						就是程序存储在内存中运行时，程序所占用的存储空间的结构，也可以被称为“存储映像”。
						
						通过对比发现，其实裸机和基于OS虚拟内存运行时的程序布局几乎差不多，二者的共同之处就是，
					最基本的组成都是 = 代码段 + 静态数据段 + 堆 + 栈。
						
						图：
						
						但是从图中可以看出，它们还是有区别的。
						
						
				2）二者的区别
				
					（a）运行地址不同，一个是物理地址，另一个是虚拟地址
				
					（b）相比裸机的情况，基于OS虚拟内存运行时，进程的虚拟内存空间分为了“应用空间”和“内核空间”
					
							· 应用空间：运行应用程序的代码
									虚拟内存中的“应用空间”，底层对应的是“应用程序代码”真实所在的物理存储器空间，这种对应关系被
								称为“映射”。
								
								图：
								
									
									
							· 内核空间：运行内核代码
						
								虚拟内存中的“内核空间”，底层对应的是“OS代码”真实所在的物理存储器空间。										
								
								图：
									
								
									不管应用程序有多少个，运行的OS只有一个，所以所有进程虚拟内存中的“内核空间”，映射（对应）的
								是同一个OS。
								
								
								程序基于虚拟内存运行时，cpu取指所得到的指令地址都是虚拟地址，
								
								- 如果运行的指令是“应用程序”的指令的话
									虚拟地址被转为物理地址，通过物理地址找到“应用程序指令”真实所在的物理空间，取出指令给cpu执行。
									图：
									
									
								- 如果调用了OS的API，就会进入内核空间，cpu取指时所得到的指令地址为“内核空间”的虚拟地址
									内核空间的虚拟地址被转成物理地址后，找到的是OS所在的真实物理空间，取出的指令自然就是OS的指令。
				
									图：
											
												
									如此一来，应用层序就能调用OS的系统函数了。

										
					
				3）基于OS虚拟内存运行时，在栈与堆之间还有一个共享映射区
				
						有关共享操作这个东西，只能在有OS虚拟内存支持的情况下才存在，裸机的话不可能实现的。
				
				
				
					· 映射同一个共享库（动态库），多进程共享使用同一个共享库
						图：
								
								
								
					· 映射相同的物理内存，通过共享内存，实现进程间通信
						图：
								
								
								
						《Linux系统编程、网络编程》的第8章——本机进程间通信中，有详细讲这个东西
								
								
					· 映射相同的文件
						共享操作同一个文件。
						
						图：
								
								
						有关映射共享文件，我们在《Linux系统编程、网络编程》课程的第9章———高级IO有详细介绍。
