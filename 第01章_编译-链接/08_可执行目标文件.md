# 5. 可执行目标文件
	
## 5.1 如何得到可执行目标文件		
链接程序collect2/ld，将所有的可重定位目标文件静态链接在一起，就得到了可执行目标文件。  
过程中会把把多个o中同名的节合并在一起.   
静态链接动态库时，只是留下函数的接口，当程序运行时再动态加载动态库。  
简单理解的话，链接的过程，其实就是将所有的.o文件合并为一个可执行文件的过程。  
`链接时，链接程序（静态链接器）做了什么事情？`  
**链接器主要做两件事情**
+ 第一：符号解析
+ 第二：地址重定位。
有关这两件事情，我们在前面大概的介绍过，接下来我们将会较为详细的介绍下这两件事。  

				
## 5.2 符号解析
### 5.2.1 符号解析的目的

确定模块中引用的每个符号都有明确的定义，并将每个符号的引用与定义关联起来。  
如果你引用了一个符号，结果这符号没有被定义，程序是无法运行的。  
比如：				
+ （1）如果引用的全局变量没有定义的话
     符号没有定义，这个变量就没有对应的空间，没有变量空间，就没办法进行读写了。
     
+ （2）如果引用的函数没有定义的话
    函数体（函数指令）就不存在，函数没办法调用。		
			
### 5.2.2 如何解析符号
 检查模块（.o）的.symtab符号表，看符号的定义情况。


#### （1）情况1：符号就是在本模块定义的（本地符号）
   像这种情况的话，链接器不需要做什么太多的解析工作，因为符号就是在本模块中定义的，每个符号对应的空间就被定义在了本模块的某个节中(比如.text、.data等节)，引用该符号时肯定没有问题。  

#### （2）情况2：符号由本模块引用，但是在其它模块定义的（全局符号）  
   被标记为UND的符号就是这种情况，UND表示此符号只是在本模块引用，但是在其它模块定义的。其实链接器进行符号解析时，重点解析的是标记为UND的符号，解析时会检查UND符号是否在其它模块中有定义。  

   `怎么解析UND符号的？`
    解析时，对于本模块中UND的符号，链接器会查看其它模块的.symtab符号表，看该符号是否在其它模块中有定义，如果找到定义，就将符号的引用和定义关联起来，如果找不到，链接器就会报undefined reference to ‘符号名’的错误。

比如：
```c
// a.c
int fun();
int main(void)
{
    fun();
    return 0;
}
```

gcc编译链接:
```shell
zxf@ubuntu:~/Desktop$ gcc a.c  b.c -o a
/tmp/ccTyxboK.o: In function `main':
a.c:(.text+0xa): undefined reference to `fun'
collect2: error: ld returned 1 exit status

undefined reference to `fun'这个错误是由链接器报的。
```


#### （3）说说有关编译链接时的报错	
其实编译链接时，四个阶段都有可能会报错误。

+ 1）预处理					
	`a.c ---> a.i（cpp、cc1）`  

	报预处理的错误，凡是宏、头文件包含、预编译等错误都是在预处理阶段，由“预处理器”报的。


+ 2）编译阶段
		`a.i ----> a.s （cc1）`  
	这个阶段报的都是c语法错误，因为这个阶段的主要目的就是按照c语法格式去解释c源码文件，然后翻译得到汇编，所以编译阶段报的主要是c语法的错误，只要你不按照c语法格式的要求写，就会报C语法错误。

	比如：
	+ （a）各种c关键字用错、写错
		+ 写错：return 10  写成了 retrun 10
		+ 用错：
		  ```c
		  switch(a)
		  {
		      case 12.6: a = 10;//c语法要求，switch的case不能跟浮点数
		  }
		  ```
	+ （b）各种重复定义
		编译时，是以单个源码文件为单位来操作的，单个源码文件（模块）中的一些关键内容，是不能重复定义的。
		+ 变量重复定义的错误
		  ```c
		  // a.c
		  int a = 100;
		  int a = 101;
		  int main(void)
		  {
		  }
		  ```
		   `疑问`：  
		   	```c
			int a; 
			int a = 100;
			```
			算不算重复定义?
		   答：这种不算，为什么不算，后面解释。  
                + 同一模块的重复定义，编译器编译时就会检查出来，不同模块之间的重复定义，只能留给链接器检查。
		```c
		// a.o                   
		int a = 10;          
		```
		```c
		// b.o
		int a = 100;
		```
		+ 类型重复定义的错误
			比如：
			```c
			a.c 
			struct student
			{
				int num;
			};
			struct student
			{
				int num;
			};
			int main(void)
			{
			}
			```
			`旁注`：像int、float、char、struct student等类型，是c语法格式才有的东西，是专门给cc1编译器用的，这些类型决定了数据空间的存储结构和大小，比如：  
				```c
				int a; 		//整形存储结构，4字节
				float b;	//浮点存储结构，4字节
				```
				一旦编译器cc1将其编译为汇编后，这些类型就消失了。    
				其实所有属于C语法格式的东西（比如，c的类型、关键字等），在cc1编译之后，都将不复存在。    
		+ 模块中函数重定义的错误
                      ```c
		        // a.c
			int fun()
			{
			    ...
			}
			int fun()
			{
		            ...
			}
		      ```
+ （3）汇编
		
		a.i -—————> a.s
		a.s ——————> a.o (as)

   事实上，汇编阶段并不会报什么错误，不报错的原因，并不是因为汇编器as没有检错的能力，而是只要c源码被编译为a.s时通过了，也就是说只要c源码没有错误，那么编译得到的a.s就没问题，从a.s汇编为a.o时，其实没有什么需要报的错误。


+ （4）链接
    > 报各种链接时产生的链接错误，比如  
	+ 某模块引用的符号，找遍其它所有模块，都找不到它的定义时，就会报undefined reference to ‘符号名’的错误
	+ 不同模块有强符号重复定义时，报重复定义的错误
        + 初始化了全局变量的重复定义
			```
			a.o                    b.o
			int a;                 int a = 100
			```
              链接时会报a重复定义了。  
		`如果不想报错怎么？`  
		+ 给其中一个加static，或者两个都加static  
		   加了static后，符号就是本地的，对其它模块无影响。
		+ 将其中一个的初始化去掉  
		  没有初始化的符号是弱符号，强弱符号不会冲突，有关强弱符号的问题，后面还会介绍。
	+ 同名函数的重复定义
		```c
		// a.o               // b.o
		float fun(int a)     int fun(void)
		{                    {
		}                    }
		```
		旁注：有关c++/java中同名函数的问题。  
		+ c的情况
			对于c来说，不管函数参数一不一样，只要函数名相同，就被认为是重名。
		+ c++/java等
			这类语言的函数允许重载，重载的意思就是说，函数名相同不一定重名，只要参数不同，就是两个不同的函数，
			```cpp
			int fun(int a)
			{
			}
			int fun(int b, int c)
			{
			}
			```
			因为在进行函数重名的判断时，函数名和函数参数会合在一起判断，只有当函数名和参数完全相同，才能算是重名。

### 5.2.3 链接器在符号解析时，是如何解决全局符号的重名问题的	
  前面说过，对于模块内部符号重名的情况，在编译时cc1编译器会检查出来，对于不同模块之间的全局符号重名情况，只能由链接器解析时来检查。
#### （1）模块之间全局符号重名的情况是无法避免的
为了方便工程的组织管理，程序肯定是某块化组织管理的，此时模块之间必然会涉及全局变量和函数的声明，
比如：  
```c
// a.c                         		// b.c
int fun();
int a;                     		int a = 100;
int main(void)                          int fun()
{					{												                                             ...
	a = a + 100;			}
	fun();                                     
}	
```
a.c中为了使用b.c中定义的a和fun，需要在a.c中进行声明，声明的符号与定义的符号是同名的，链接器将这两个文件链接为一个可执行文件，同名的符号就必须统一(合并)为一个，所以链接器进行符号解析时，重名符号的统一是必不可少的。


#### （2）链接器解析符号时，是如何解决全局符号重名的情况
 > 链接器根据符号的强弱共存规则来解析。
+ 1）全局符号的强弱之分
	+ 1）全局变量
		+ （a）强符号：初始化了的全局变量
		+ （b）弱符号：未初始化的全局变量
	+ 2）函数
		+ （a）强符号：函数定义  
		+ （b）弱符号：函数声明  
		每个全局符号是强符号还是弱符号，在.symtab表中会有相应的记录。
+ 2）重名符号的强弱共存规则
	+ 1）不允许多个同名的强符号同时存在，存在的话就报错
	+ 2）强符号只有一个，其它同名的都是弱符号的话，统一时，选强符号，舍弃弱符号
	+ 3）同名符号如果全都是弱符号的话，留其中某个，其它舍弃，留谁由链接器来决定
+ 3）举例
	+ （a）例子1
		```c
		// a.c                        // b.c
		int a = 100;		      int a = 200;
		int fun()                     (extern) int fun()
		{                             {
			a += 10;                    a = a - 100;
		}			      }
		int main(void)            
		{
			static int a = 10;
			fun();
		}
		```
		由于文件中定义的全局变量a和函数fun都是全局的强符号（extern修饰的），在各自的.symtab符号表中，a和fun都会被标记为全局强符号。  
		链接器进行符号解析时，会去检测这两个模块的.symtab表中的符号，发现这各自的a、fun都是全局强符号，根据强弱符号的共存规则，一山不容二虎，存在多个同名全局强符号时会报错。  
		`如何解决?`
		+ 将其中的某个强符号变为弱符号
			```c
			int a = 100;  ————> int a;
			int fun(){...} ————> int fun();
			```
			留强去弱。
		+ 使用static来解决
			只要将其中的某个或者两个使用static修饰，将其变为本地符号，就不会存在冲突的情况。  
			```c
			int a = 100;  ————> static int a = 200;
			int fun(){...} ————> static int fun();
			```
			旁注：全局变量和函数加static，目的是将全局符号变为本地符号。局部变量加static，是将局部变量的从自动局部变量（栈）变为静态局部变量（.data/.bss）。
	+ （b）例子2
		```c
		// a.c                    // b.c
		int a;			  int a;
		int main(void)            
		{
			fun();
		}
		```
		`两个模块的a都是弱符号，统一符号时，留下其中一个即可。`
#### （3）cc1编译器处理模块内符号重名的情况								
链接器处理模块间的全局符号的重名时，是按照强弱符号的规则来处理的。  
对于模块内部的符号重名问题，编译器cc1在编译时，其实也是按照强弱符号的规则来处理的。  
+ 1）例子1：
	```c
	// a.c 
	int a = 100;
	int a = 300;
	int fun()
	{
	}
	int fun()
	{
	}
	int main(void)
	{
	}
	```
	`编译时会报重复定义的错误（强符号只能有一个）。`
+ 2）例子2：
	```c
	a.c 	
	int a;
	int a;
	int main(void)
	{
	}
	int a = 10;
	```
	没有错误，因为不存在强符号的冲突问题，编译时会统一为一个，.symtab只会记录一个a。  
	在经典的c讲解中，这种情况将int a解释成“int a = 100;这个定义”的声明，实际上本质关系是强弱符号关系。  
	只不过在单个模块中，弱符号（声明）可以将强符号（定义）的作用域提前。  
+ 3）例子3
	```
	// a.c 	
	static int a = 20;
	int a = 10;
	int main(void)
	{
	}
	```
	`大家觉得会报错吗？`
	答：会报错，虽然一个是全局的，一个是本地的，但是由于都在一个模块中，因此编译时肯定报错。  
	但是如果它们两个是在不同的模块中的的话，链接器链接时就不会报错，这个前面讲过。
	```c
	// a.c 	                // b.c
	int a = 10;             static int a = 20;
	int main(void)
	{
	}
	```



#### （4）再说说声明和定义
  事实上，对于编译器、链接器来说，并不知道什么是声明、什么是定义，声明和定义只是学习C语言时会了表述的方便，我们自己的给的，编译器/链接器只知道强符号和弱符号，解析时是按照强弱符号的规则来处理的。  
  我们以全局变量为例，你会发现其实不太好明确的区分定义和声明。
+ 1）能够区分的例子
	+ （a）例子1
		```c
		a.c 
		int a;
		int a = 100;
		...
		```
		针对这种情况来说，我么认为后面有初始化的a是定义，前面那个没初始化的a是后面a的声明。
	+ （b）例子2								
		工程中有两个.c
		```c
		a.c               b.c
		int a;	          int a = 0;
		...               ...
		```
		前面说过，没有明写出extern，默认就是extern修饰的。  
		有初始化的是定义，没有初始化的是声明。  
		在以上两个例子中，都能明确的区分出定义和声明。  
+ 2）不能区分的例子
	```c
	a.c 
	int a;
	int a;
	int a;
	....
	```
	在这种情况下，到底那个是定义，那个是声明呢，不好讲了，你或许会说都是定义，都是声明，这就没有什么明确区分了。  
	又比如：  
	```c
	a.c
	int a;
	```
	只有一个int a时，到底应该说成是定义，还是说成声明呢？    
	又比如工程中有两个.c    
	```c
	a.c               b.c
	int a;		  int a;
	```
	你告诉我那个是声明，那个是定义，也是同样的情况。  
	所以说对于编译器/链接器来说，它不关心什么是定义、什么是声明，也没办法以定义和声明来区分，人家只关心强弱符号。    
	不过以后为了表述的方便，我们还是会继续使用“定义”和“声明”这两个概念，只不过在理解了强弱符号之后，大家心里应该清楚本质到底是什么。   
	以后不会再严格区分定义和声明，像int a;这种未初始化的情况，我们可能即会说成是定义，也可能会说成是声明，只要大家理解了强弱符号，说成什么其实都无所谓，只要方便表达和理解即可。  
								

## 5.3 重定位			
链接器在完成了符号解析之后，就可以进行重定位了。
不过由于重定位的内容比较复杂，当然如果你是做编译器或者逆向的话，重定位的原理是必须要求掌握的，但是作为
应用开发者来说这不需要，因为了解详细原理的意义不大，因此有关重定位，我们这里只介绍基本内容。
		
		
### 5.3.1 重定位的种类
重定位的种类其实有两种，
#### （1）第一种：动态重定位
所谓动态重定位就是，重定位的动作是在程序运行的过程中动态完成的，因此被称为动态重定位。有关动态重定位，在讲Uboot和内核移植时会介绍。
#### （2）第二种：静态重定位
所谓静态重定位就是，由链接阶段完成的重定位，因为是在程序运行之前做的重定位，因此被称为静态重定位。所以我们现在要讲的由链接器完成的静态重定位。
					
					
					
### 5.3.2 静态重定位做什么事情
做两件很重要的事情，
+ 将同名节整合为新的同名聚合节
+ 将可执行目标文件中各聚合节的地址，重定位为实际运行的地址


#### （1）将同名节整合为新的同名聚合节
其中重点是将.text和.data节聚合为新的同名聚合节，为了能够将.text和.data节聚合为新的聚合节，需要依赖一些信息，这些信息存储在了.rel.text和.rel.data中。
+ .rel.text中的信息：实现.text的聚合
+ .rel.data中的信息：实现.data的聚合

#### （2）将可执行目标文件中各聚合节的地址，重定位为实际运行的地址
其实就是将程序在内存中实际运行时的内存地址赋给聚合节，程序在内存中运行时，就是按照重定位的地址来运行的，至于重定位的地址具体是多少，要分裸机和OS两种情况来看。
+ 1）如果程序是直接裸机运行的话（没有OS）
    程序是直接运行在物理内存上的，所以重定位的运行地址就是物理地址，所以CPU取指时所取得的指令地址就是物理地址。
+ 2）如果程序是基于OS运行的话
     大部分的OS都有提供虚拟内存机制，所以程序是运行在OS虚拟内存上的，虚拟内存所提供的地址就是虚拟地址，所以CPU取指时，所取得的指令地址就是虚拟地址。虚拟内存是基于真实的物理存储器构建出来的，所以程序最终其实还是运行在物理内存上的，因此虚拟地址最终还是会被转为物理地址，然后到物理内存上该物理地址所指定的位置读取指令。
     + 疑问：反正程序最终都是运行在物理内存上的，为什么要在真实物理存储器上弄出一个虚拟内存呢？
	有关这个原因，请大家看《计算机体系结构———操作系统》的课程，里面介绍虚拟内存时有详细介绍。我们都知道现在的OS基本都支持多进程并发运行，其实多进程并发运行与虚拟内存机制有着莫大关系。
     + 疑问：什么是进程，与程序什么关系？  
	 + 进程：动态运行的程序，进程有生有死，是一个动态运行的过程
	 + 程序：存放在硬盘上，没有运行的静态的可执行目标文件。
     + 疑问：什么是进程的并发运行？
	多个进程同时运行，这就并发运行，比如酷狗/浏览器/wps同时运行着，这几个程序就是并发运行的。  
	我们这里简单认为，单个程序对应单个的进程，实际上一程序可以是多进程的，有关这一点，请大家看《Linux系统编程、网络编程》这门课，有详细介绍。
     + 为什么能够并发运行？
	实际上与虚拟内存有很大关系。因为有虚拟内存这个东西，所以每个程序运行时，虚拟内存机制会给每一个进程都弄一个虚拟内存，也就是说每一个进程都是运行在自己独立的虚拟内存上的。  
	图：
	由于进程是运行在虚拟内存上的，因此“虚拟内存空间”也被称为了“进程空间”。  
	进程运行在自己的虚拟内存上时，每个进程运行了一个短暂的时间片（ms）后，快速切换到其它进程上运行，此时cpu就会取指运行不同进程的指令。
	图：
	如此在宏观上，我们会感觉所有的进程都是同时运行的，这就是进程的并发运行，从介绍可以看出，进程间的并发运行与虚拟内存机制有着密切的关系。与并发运行相对应的还是一个概念，那就是“并行运行”，有关这两个概念的异同请看《Linux系统编程、网络编程》的课程。  
	我们这里所面对的OS是Linux，Linux有虚拟内存机制，所以gcc编译得到的程序基于Linux运行时，就是运行在
	虚拟内存上的。  



#### （3）如何指定重定位运行地址
实际上是通过“链接脚本文件”来指定的，“链接脚本文件”里面会说明实际的运行地址是多少，重定位时会把把实际的运行地址赋值给新的聚合节，如此一来，函数和全局变量就有了真正可以运行的运行地址。实际运行时，将程序拷贝到运行地址所指定的内存位置，cpu的pc存放第一条指令地址(指向第一条指令_start)，然后整个程序就运行起来了。  
至于重定位时，给聚合节具体指定的运行地址应该是多少，这里要分裸机和OS两种情况来定。  
+ 1）裸机运行
运行地址（物理地址）是多少，可以由程序员自己来定，比如我们一般可以指定为0，表示程序需要拷贝到物理内存的0地址处，从0地址处开始存放。  
我们将0地址写到链接脚本文件中，gcc编译时给他指定链接脚本，重定位后运行地址就从0开始。  
我们后面讲到arm裸机时，会介绍如何修改这个链接脚本。    
裸机运行时，整个计算机上就一个程序，由于没有OS虚拟内存的参与，所以裸机只能运行一个程序（单进程）。  

+ 2）基于OS运行
运行地址（虚拟地址）为一个固定值，不同OS这个固定值不一样，比如在Linux这边  
32位OS：从0x08048000开始  
64位OS：从0x0000000000400000开始  

程序运行时，程序会被拷贝到虚拟内存的0x08048000或者0x0000000000400000位置处，然后pc指向_start，程序就运行起来了。  

这个地址也是指定在链接脚本中的，gcc编译基于Linux运行的程序时，这个链接脚本不需要我们自己给，是自动给的，这个脚本中会指定0x08048000或者0x0000000000400000的地址。  

而且gcc编译每一个程序，链接重定位所指定的地址都是0x08048000或者0x0000000000400000。    

`疑问`：重定位时，如果每个程序都是相同的0x08048000或者0x0000000000400000的话，运行时不会冲突吗？  
 不会冲突，因为每个进程的虚拟内存是独立的，虽然都是相同的地址，但是底层实际对应的都是不同的物理空间，
图：  
将虚拟地址转换为物理地址后，得到的物理地址是不同的，所以不同的物理地址所指向的物理空间不同，自然不同物理内存空间中存放的是不同程序的指令。

			
### 5.3.3 可执行目标文件的ELF格式
图：
#### （1）相比.o的ELF格式，有哪些变化？

+ 1）.rel.text和.rel.data消失了
	为什么这两个节会消失？  
	链接器将各.o中同名的.text和.data节整合到一起时，会对整合后的.text和.data进行重定位。  
	其实重定位时主要针对就是.text和.data节，不过这.text和.data节重定位时需要依赖.rel.text和.rel.data中的信息，一旦重定位结束后，这两个节的使命就完成了，自然也就会消失。

+ 2）多出了两个节
	+ 1）init节
		+ （a）作用
			这个节会提供_init等函数，专门用于实现程序的一些初始化。  
			程序入口为_start，从_start开始执行后，在正式调用main函数之前，会先调用_init等函数进行程序的初始化（比如建立函数栈等等）。  
		+ （b）init节怎么来的
			回顾gcc链接的过程:
			```shell
			collect2    //链接程序
			-dynamic-linker  /lib64/ld-linux-x86-64.so.2 //动态链接器
			crt1.o  crti.o  crtbegin.o //启动代码
			ccyIcm4A.o  			//自己程序的.o
			-lc 						//libc，常用c函数库——c标准库的子库
			crtend.o  crtn.o 		//扫尾代码
			init节就是由gcc提供的crt1.o、crti.o、crtbegin.o等.o构建而来的。
			```

	+ 2）“段头部表”节
		重定位时，链接器根据“链接脚本文件”所给的运行地址，给.text/.data中指令和变量重定位运行地址时，这些“运行地址”只是链接时理论上安排的。
		当加载程序到内存中运行时，就需要将硬盘上所存放的程序，搬到“运行地址”所指定的内存位置，段头部表中的内容，就是用来辅助加载程序的。

#### （2）再说说“可执行目标文件”的ELF格式
“可执行目标文件”的各个节，可以进行进一步的归类。

图： 

总结：  
+ 1）程序最终运行时，需要搬到内存上的节有：ELF/.init/.text/.rodata/.data/.bss。
	搬到内存上什么位置呢？  
	搬到重定位的“运行地址”所指定的位置。   

+ 2）ELF/.init/.text/.rodata：只读的存储段（代码段）

+ 3）.data/.bss：可读可写存储段（静态数据段）
	之所以称为静态数据段，是因为.data/.bss的空间规划，是在编译时就进行了理论安排，并不是程序运行起来
	才安排的，所以被称为静态数据段。

