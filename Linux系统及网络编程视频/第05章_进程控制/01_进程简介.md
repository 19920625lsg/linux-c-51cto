# 1. 有关进程

## 1.1 什么是进程

我们在前面的课程就讲过这个问题，我们这里再来回顾下。

我们说，将程序代码从硬盘拷贝到内存上，在内存上动态运行的程序就是进程。

对比一下进程和程序：
      存储位置                                       存在状态      运行过程
程序  硬盘                                           静态的        无运行的过程
进程  存在内存中，它是从磁盘上的程序考过来的副本        动态的        有运行的过程，所以进程有生有死

## 1.2 多进程并发运行

有OS支持时，会有很多的进程在运行，这些进程都是并发运行的。

什么是并发运行？  
就是CPU轮换的执行，当前进程执行了一个短暂的时间片（ms）后，切换执行另一个进程，如此循环往复，由于时间片很短，在宏观上我们会感觉到所有的进程都是在同时运行的，但是在微观上cpu每次只执行某一个进程的指令。  

当然我们这里说的单核cpu的情况，如果cpu是多核的话，不同的cpu核可以同时独立的执行不同的进程，这种叫并行运行。

所以当cpu是多核时，并发与并行是同时存在的。

## 1.3 进程ID（PID）

### 1.3.1 什么是PID

基于OS运行的进程有很多，OS为了能够更好地管理进程，为每个进程分配了一个唯一的编号（非负整数），这个编号就是PID，P就是process——进程的意思。

这记好比公安局给每个人分配了一个唯一的身份证号（ID）是一样的。

如果当前进程结束了，这个PID可以被可以被重复使用，但是所有“活着”的进程，它们的进程ID一定都是唯一的。

因为ID的唯一性，当我们想创建一个名字唯一的文件时，往往可以在文件名中加入PID，这样就能保证文件名的唯一性。

### 1.3.2 那么PID放在了那里呢？

进程在运行的过程中，OS会去管理进程，这就涉及到很多的管理信息，OS(Linux)为了管理进程，会为每一个进程创建一个task_struct结构体变量，里面放了各种的该进程的管理信息，比如第一章介绍的文件描述符表，又比如我们这里讲的PID。

所以PID放在了该进程的task_struct结构体变量中，有关task_struct在前面的课程就介绍过，相信大家不会陌生。

### 1.3.3 如何获取PID呢？

后面回答这个问题。

## 1.4 三个特殊的进程

OS运行起来后有三个特殊的进程我们需要了解下，他们的PID分别是0、1、2。

0、1、2这个三个进程，是OS启动起来后会一直默默运行的进程，直到关机OS结束运行，尽管我们总是忽略它们的存在，但是它们确非常的重要。

+ PID=0 调度进程
+ PID=1 init进程
+ PID=2 守护进程

### 1.4.1 进程 PID == 0 的进程

#### （1）作用

这个进程被称为调度进程，功能是实现进程间的调度和切换，该进程根据调度算法，该进程会让CPU轮换的执行所有的进程。

怎么实现的？
当pc指向不同的进程时，cpu就去执行不同的进程，这样就能实现切换

#### （2）这个进程怎么来的

这个进程就是有OS演变来的，OS启动起来后，最后有一部分代码会持续的运行，这个就是PID==0的进程由于这个进程是OS的一部分，凡是由OS代码演变来的进程，都称之为系统进程。

### 1.4.2 进程ID == 1的进程

#### （1）作用

+ 1）作用1：初始化  
这个进程被称为init进程，这个进程的作用是，他会去读取各种各样的系统文件，使用文件中的数据来初始化OS的启动，让我们的OS进入多用户状态，也就是让OS支持多用户的登录。

+ 2）作用2：托管孤儿进程  

什么事孤儿进程，怎么托管的，有关这个问题后面会详细介绍。

+ 3）作用3：原始父进程  

  ```txt
  原始进程————>进程————————>进程————————>终端进程——————>a.out进程
              |            |             |
              |            |             |
              V            V             |
            进程          进程          进程
              |            |             |
              |            |             |
             ...          ...           ...
  ```

#### （2）这个进程怎么运行起来的

这个进程不是OS演变来的，也就是说这个进程的代码不属于OS的代码，这个进程是一个独立的程序，程序代码放在了/sbin/init下，当OS启动起来后，OS回去执行init程序，将它的代码加载到内存，这个进程就运行起来了。

### 1.4.3 进程ID == 2的进程  

+ （1）作用  
  也叫页精灵进程，专门负责虚拟内存的请页操作。
  
  疑问：什么精灵进程？    
  精灵进程也叫守护进程，我们后面讲到“守护进程”这一章时，你自然就知道了
  
  怎么理解换页操作，我们说当OS支持虚拟内存机制时，加载应用程序到内存时，并不会进行完整的代码拷贝，只会拷贝当前要运行的那部分代码，当这部分代码运行完毕后，会再拷贝另一部分需要运行的代码到内存中，拷贝时是按照一页一页来操作的，每一页大概4096字节，这就是换页操作  

  想了解详细换页操作的同学，请看《计算机体系结构》软件篇4——操作系统部分的课程

+ （2）这个进程怎么运行起来的  

  与调度进程一样，也是一个系统进程，代码属于OS的一部分。

## 1.5 获取与进程相关的各种ID的函数

### 1.5.1 函数原型和所需头文件

```c
#include <sys/types.h>
#include <unistd.h>

pid_t getpid(void);
pid_t getppid(void);
uid_t getuid(void);
gid_t getgid(void);
```

+ （1）功能
  + 1）getpid函数：获取调用该函数进程的进程ID。
  + 2）getppid函数：获取调用该函数进程的父进程ID，第一个P是parent，第二个process。
  + 3）getuid函数：获取调用该函数进程的用户ID。
      在什么用户下运行的该进程，得到的就是该用户的用户ID，查看/etc/passed文件，可以找到该UID对应的用户名。
  + 4）getgid函数：获取用户组的ID，也就是调用该函数的那个进程，它的用户所在用户组的组ID。

+ （2）返回值  
  返回各种ID值，不会调用失败，永远都是成功的。

### 1.5.2 代码演示

```c
#include <stdio.h>
#include <sys/types.h>
#include <unistd.h>

int main(void)
{
    printf("pid = %d\n", getpid());
    printf("pid of parent = %d\n", getppid());
    printf("user id = %d\n", getuid()); // root用的uid为0
    printf("group id = %d\n", getgid());
    return 0;
}
```

结果为

```shell
pid = 13960
pid of parent = 13958
user id = 0
group id = 0
```
