

6. 进程状态

每个进程与其它进程并发运行时，该进程会在不同的“进程状态”之间进行转换，所以我们需要介绍一下进程状态。

1）图：

2）进程运行状态有哪些

	（a）就绪态：表示进程准备就绪，随时等待被调度运行
	（b）执行态：被PID=0的调用进程调度，开始占有CPU，被cpu执行，运行的时间片到后让出CPU，再次进入就绪态，
			然后PID==0的调度进程开始调度其它进程，CPU去执行其他进程的指令

	（c）阻塞态：当进程需要的某些条件的不满足，进程会进入阻塞态（休眠）
			当条件满足后，会再次进入就绪态，等待再次被调度执行。

	（d）终止态：进程终止（正常终止、异常终止）
				如果进程终止时，父进程没有回收进程资源的话，终止的进程会变成僵尸进程。

7. java进程
	java属于解释型语言，类似的像c#，python等都是属于解释型语言，而c/c++等则是属于编译型语言。


7.1 编译型语言
		将编译型语言的程序编译后，得到的直接就是机器指令，可以被CPU直接执行。


7.2 解释型语言
		将解释型语言的程序编译后，得到的只是字节码，字节码并不是机器指令，并不能直接被cpu执行，只有当字节码被虚拟机程序解
	释（翻译）为机器指令后才能被cpu执行，解释的过程也被称为翻译的过程。


7.3 如何运行编译型和解释型语言的程序

		我们这里讨论的都是有OS支持的情况。	


	7.3.1 运行编译型语言的程序
		（1）父进程（命令行终端窗口、图形界面）会fork复制出子进程空间

		（2）调用exec加载器，直接将编译后代码拷贝到子进程空间
				然后被CPU执行时，整个程序就运行起来了。
				图：


			在程序里面，我们自己也可以调用fork和exec函数来执行另外的新程序。



	7.3.2 运行解释型语言的程序

		（1）java程序的运行

				1）父进程（命令行窗口、图形界面）会fork复制出子进程空间
				2）调用exec加载java虚拟机程序，将虚拟机程序的代码拷贝到子进程空间中

						当java虚拟机程序运行起来后，会自动的去解释编译得到的java字节码文件，将字节码翻译为机器指令，cpu再去执行
					翻译得到的机器指令。

						每解释一句，cpu就会执行一句，在虚拟机的翻译下，整个java进程就开始运行起来了。
						图：


						其实最简单的理解就是，java虚拟机就代表了java进程。

					当你运行另一个java程序时，又会自动地启动一个虚拟机程序来解释java字节码，此时另一个java进程又诞生了。
					也就是说你执行多少个java进程，就会运行多少个java虚拟机，当然java虚拟机程序在硬盘上只有一份，只不过被多次
				启动而已。


		（2）java虚拟机怎么得到
					运行解释型语言的程序时，必须要有虚拟机，不过好在当我们安装java等解释型语言的开发环境时，往往都会自
				动安装虚拟机程序，我们不用操心。

					当我们运行java程序时，虚拟机会被自动启动。


					虚拟机一般是运行在OS上的，不过其实虚拟机也可以运行在没有OS的裸机上，当虚拟机安装在裸机上后，java程序也可以
				运行在裸机上。

					 java字节码文件
						  虚拟机
								os
							 硬件


						java字节码文件
							虚拟机
							 硬件




		（3）在java程序里面，也可以调用java库提供的类似的fork和exec函数，我们自己来创建一个java子进程，并执行新程序。
				java库提供的类似的fork、exec函数，下层也是调用OS的fork、exec函数。
				图：





		（3）思考：虚拟机程序是什么语言写的
				虚拟机程序能够被exec直接加载运行，说明虚拟机必然是编译型语言写的，如果虚拟机使用解释性语言来写的话，
			编译后得到是字节码，字节码不是机器指令，此时还要另外安装一个程序来解释虚拟机程序，这就陷入了一个死循环

				所以java虚拟机必须使用编译型语言来写，比如使用c/c++编写，一般来说是c写的。

8. 有关程序多进程

8.1 多进程 和 多线程

	8.1.1 多进程

			一般对于小程序来说，由于体量小，因此基本都是单进程的，在平时的开发中，一般开发的程序都比较小，特别是大家在学习
		过程中写的程序，那就更小了，因此基本都是单进程的。

			不过在学习了本章以后，我们完全可以在自己的程序里面调用fork、exec来创建多个进程，特别是当我们需要多线并发工作时，
		我们完全可以使用这种多进程的方式来实现。

			当然本章的fork、exec是c接口的，只能供c/c++调用，java等其他语言如果像实现多进程的话，就需要调用该语言的fork、exec，
		我们前面说过，这也是基于底层OS的fork和exec来实现的。


	（1）程序多进程的例子：同时读鼠标和键盘

			当鼠标和键盘没有数据时，这两个读操作会阻塞，如果在一个进程即读键盘、也读鼠标的话，就会出现相互堵的情况。		

				while(1)
				{
					read(键盘);																	
					read(鼠标);
				} 

				此时就可以fork创建出一个子进程，然后让父子进程并发的读数据。

				 父进程             子进程

				read(键盘)         read(鼠标)


				父子进程并发运行，各自读各自的，互不干扰，这样就不会出现相互堵的情况了。


	8.1.2 多线程并发

			在平时的开发中，小型的程序一般都是单进程的，此时很少会使用多进程来并发做事，因为多进程太过耗费计算机资源，为什么
		多进程会如此的耗费计算机资源，我们后面讲到线程时再来详说。

			如果程序真的需要并发的话，我们会在进程内部创建多个线程，使用多个线程来实现并发，比如：

				 主线程          次线程
				read(键盘)      read(鼠标)


			后面课程会详细的介绍C线程函数。

			疑问：程序多进程会不会用到？
			答：当然会


8.2 什么情况下，我们让程序创建出多进程，实现多进程的并发

		我们前面介绍到，在一般小型应用程序的开发中，程序基本都是单进程的，如果涉及到并发时，往往会多线程来实现，但这并不是说
	程序就不存在多进程的情况了，那么在什么情况下，程序会用到多进程呢？



		比如：
	（1）编写框架
				安卓的系统框架，中大型游戏底层框架等，软件框架属于结构性的代码，在实现框架结构的过程中，基本都要使用多进程来搭
			建这个框架。

				像框架这种东西，在实际开发中，并不是任何人都会涉及到的，对于绝大多数人来说，在实际开发中，基本只涉及到框架的使用，
			但不涉及到框架的编写。


	（2）如果你的程序必须启动新程序
			1）例子1
					比如windows图形界面、命令行，当我们在图形界面或者命令启动新程序时，必须创建子进程，然后在子进程空间中运
				行新代码，这个时候必须要涉及多进程。


			2）例子2
					那些大型的业务功能复杂的软件，基本都是多进程的，为什么？

					这里说的大型软件，有可能是客户端软件，也有可能是服务器端的软件。

					对于大型的软件程序来说，往往包含很多种功能（功能套件），而且每一个功能具有相当的独立性，所以大型复杂的软件
				在实现时，如果将这些独立功能全都放到单进程里面来实现，很不现实，因为所有的东西都杂糅在一起，很不好实现。

					既然每个功能具有独立性，在大型软件里面，每个独立的功能，均由独立的进程来实现，其中有一个是主进程，主进程往往会
				提供主的交互界面，主进程启动起来后，会去启动不同的子进程，每个子进程负责实现不同的功能。

					在每个子进程的内部往往还会有多线程的参与，所以对于大型软件来说，多进程 和 多线程都会涉及。

							主 进 程（提供主交互界面，负责启动子进程）										
							 |         |        |
							 |         |        |
							 V				 V        V
							 子       子        子
							 进       进        进
							 程       程        程
							 1        2         3

							 某       某        某
							 功       功        功
							 能       能        能



						典型比如360、鲁大师、WPS、腾讯QQ，在任务管理器里面你会发现，它们有很多的进程
						演示：


						如果你是做c++/java/c#等纯应用方向开发的话，还是有机会遇到多进程的大型软件的开发的，不过在我们嵌入式开
					发中，复杂的多进程程序并不多见，因此在嵌入式里面很少见到。


	（3）早期服务器程，会通过多进程来支持多用户的访问


					 服务器程序
							A     B
							子    子
							进    进
							程    程
							|     |
							|     |  .....
							|     | 
							A     B
							客		客
							户    户
							机    机 

					总之，服务器可以并发运行n多个子进程来应对多客户的访问。


					不过对于现在的服务器来说，更喜欢使用多线程来实现多客户的访问，多进程的情况慢慢比较少了。
				这里只是想告诉你，存在这种情况。

				     服务器程序
							A     B
							线    线
							程    程
							|     |
							|     |  .....
							|     | 
							A     B
							客		客
							户    户
							机    机 

					有关多线程，我们后面讲线程时，会详细的讲到。


8. 进程关系
	本来是打算详细介绍“进程关系”的，但是后来考虑再三，觉得对实际开发的意义不大，所以我们这里就不在详细讲解，只做简单的介绍，
当然，对“进城关系”做一个简单的介绍还是很有必要的。

进程间的关系，大致有三种，即父子关系、进程组关系、会话期关系。

8.1 父子关系
	已有进程调用fork创建出一个新的进程，那么这两个进程之间就是父子进程关系，子进程会继承和父进程的属性。

8.2 进程组
	8.2.1 什么是进程组
			多个进程可以在一起组成一个进程组，其中某个进程会担任组长，组长进程的pid就是整个进程组的组ID。

	8.2.2 进程组的生命周期
		就算进程组的组长终止了，只要进程中还有一个进程存在，这个进程组就存在。
		进程组从开始被创建，到进程组最后一个进程结束，这段时间就是进程组的生命周期。

	8.2.3 进程组举例
		当我们自己的程序fork出很多子进程时，所有的进程会默认的为一组，我自己程序中的原始父进程会担任组长。
		图：


		命令行终端窗口与最开始的父进程建立联系，最原始的父进程结束了，就会将终端交互权还给shell程序。
		演示：

	8.2.4 相关API
			我们可以调用相关API将一个非组长进程，设置为一个新的进程组组长，或者说加入其它进程组。
		由于这些API在实际开发中基本用不到，所以不用了解。


8.3 会话期关系
	多个进程组在一起，就组成了会话期。
	有关会话期我们不做太多讲解，了解有这么个东西存在即可。


9. 守护进程
	我们前面介绍过，守护进程也被称为精灵进程。

		对于一些稍大型的软件来说，往往都是多进程的，而且其中好多进程都是默默无闻运行的，像这种默默无闻运行的进程都需要做
	成守护进程。

		不过由于在我们实际开发中，特别是在嵌入式开发中，根本用不到守护进程，因此我们这里就不做详细的讲解，就算讲，我们讲的
	也只是基于C实现的守护进程。

		如果你确实想深入了解守护进程相关的内容，大家可以留言，我们发现需求还挺多时我们补录这个课程。
		不过我个人还是认为，没有深入学习学习守护进程的必要。





