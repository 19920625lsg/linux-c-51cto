10. link，unlink，remove，rename函数

			这几个函数与ln、rm、mv命令息息相关，因为这几个命令就是调用这几个函数来实现的，学习这几个函数的其中一
		个重要目的，就是理解ln、rm、mv命令的实现原理。
			
			
	10.1 link、unlink
			
			这两个函数涉及到硬链接，在讲《Linux基础初级》时，就介绍过什么是硬链接，这里还是来回顾下什么是硬链接。
			
			
		10.1.1 回顾硬链接
			
			（1）ln命令创建硬链接
			
						ln xxx.txt xxx1.txt
					
					
			（2）创建硬链接，创建的是什么
			
				
							创建硬链接，就是再为文件创建一个名字。
						
						
					1）每创建一个硬链接，文件就多一个文件名，硬件链接数+1
								
							多个文件名指向了同一个文件，操作文件时，使用任何一个名字都可以。
							
							图：
					
					
						
					
					
					
					
					
					2）为什么说多个文件名，指向的是同一个文件
					
							看文件系统的管理图：
							图：
							
							
							
							
							从图中看出，创建硬链接后所得到的多个文件名，指向的同一个inode节点，只有inode节点代表了文件的真实存在，
						inode节点只有一个，因此多个文件名指向的是同一个文件，不管使用的是哪一个文件名，都能操作这个文件。

							这就好比你有好多外号，但是代表你这个人真实存在的身体只有一个，多个名字代表的都是同一个人。
							
						
				
					3）硬链接数
							
							记录了有多少个文件名指向了inode节点，通过创建硬链接，每增加一个文件名，就多一个硬链接数。
							
							同理，每删除一个硬链接，也就是删除一个文件名，就少一个硬链接数，当硬链接数被减为0时，也就代表着
						文件名被删除完了，这个文件也就被删除了。
							
							
							不过这里需要注意一点，当硬链接数被减为了0时，如果还有进程在操作这个文件的话，这个文件还会一直存在，直到进
						程结束后，这个文件才被删除。
							
							
						删除文件后，文件数据还在吗?
							
							还在，因为删除文件时，只是将文件的inode节点空间释放了，如果这个文件有数据的话，那么这个文件的数据仍然还在，
						在这种情况下，只要将文件的inode节点空间恢复，即可还原该文件。
							
					
					
					4）有关目录的硬链接数
					
					
						（a）为什么新建的目录一开始的文件链接数就是2
						
								· 演示：
									比如创建一个目录new
						
						
						
								·原因：
									因为新创建的目录，一开始就有两个名字指向了目录的inode节点，分别是目录的本名new和.
					
									图：
					
					
					
						（b）为什么在该目录下，每多创建一个目录，当前目录就会多一个硬链数
								· 演示：
					
					
								· 原因
									新创建目录的..名字，也指向了当前目录new。
									
									图：
									
									
			
						（c）能不能使用ln命令，自己给目录创建硬链接
						
								答：不能，Linux不允许用户自己给目录创建硬链接，只能由Linux系统自己给目录创建硬链接。
								
									用户只能给目录以外的，其它类型的文件创建硬链接。
									


		10.1.2 link函数
		
			（1）函数原型
					#include <unistd.h>
					
					int link(const char *oldpath, const char *newpath);
					
					
					1）功能：为非目录文件建立一个新的硬连接。
					
							ln命令就是调用这个系统函数来实现的。
							
					
					2）返回值：调用成功返回0，失败返回-1，errno被设置
					
					3）参数
						· oldpath：原有路径名
						· newpath：新的路径名
						
							从参数看出，与ln命令的用法其实是一样的。
							
								ln 原有路径名 新的路径名
							
			（2）代码演示
							
					
					
					
					
	10.2 unlink函数
		
		16.2.1 函数原型和所需头文件
			#include <unistd.h>
			
			int unlink(const char *pathname);
			
			（1）功能：删除一个硬连接，其实就是删除一个名字。
						unlink，只能用于删除非目录文件的硬链接，不能删除目录的硬链接，Linux系统不允许用户修改目录的硬件链接。
						
						
			（2）返回值：调用成功返回0，失败返回-1，errno被设置
						
						
			（3）参数
					pathname：要删除路径名。
	

		10.2.3 测试用例：

		
			
				当硬链接数减为0时，文件即被删除了。
		
		
		
		
		10.2.4 使用unlink创建临时文件 
		
				所谓临时文件就是，只在程序运行过程中有效，程序运行结束后就自动删除，这就是临时文件，使用unlink就可以实现一个
			临时文件。
			
				
				
				
			如何使用unlink创建临时文件？
				open创建一个文件后（新文件的硬链接数都是1），然后立即调用unlink将文件硬链接数减为0，将其删除。
				
				虽然文件的硬链接数变成了0，但是在进程没有结束之前，这个文件仍然可以被使用，直到进程结束后，文件才被删除，
			这样一来就实现了临时文件。
				
				演示：
				
		
	10.3、remove函数
	
		10.3.1函数原型
			#include <stdio.h>
			
			int remove(const char *pathname);
	
	
		（1）功能：可以用于删除任何文件（既可以删除目录文件，也可以删除非目录文件）。
					
					删除非目录文件时，功能与unlink一样。
				
				
		（2）返回值：调用成功返回0，失败返回-1，errno被设置
				
				
		（3）代码演示
				把unlink换成remove。
				
				
				
				
				
				
		10.3.2 为什么这个函数既能用于删除一般文件，也能用于删除目录
		
			（1）remove是一个库函数
			
					它封装了unlink和rmdir这两个系统函数。
					
						   remove
							  /	  \
						   /     \
						  /				\
 					unlink      rmdir（后面讲）
						|          |
						|          |
					非目录      目录
				
					remove会自动检测文件类型，如果是目录就调用rmdir删除，如果其它文件，就调用unlink删除。
					
				
			（2）为什么会封装remove库函数？
					主要想把unlink和rmdir统一起来，方便使用。
					

			（3）rm命令
					这个命令既能用于删除目录，也能用于删除其它所有的文件，可以认为就是调用remove实现。
				
								rm
								 |
								 | 
							 remove
							  /	  \
						   /     \
						  /				\
 					unlink      rmdir（后面讲）
						|          |
						|          |
					非目录      目录
		
		
		
		
			
	10.4、rename函数
			
			修改文件的路径名，mv命令就是调用这个函数实现的。
	
	
		10.4.1 mv命令回顾
		
			（1）改名
			（2）移动
			（3）移动+改名
					
					mv就是调用rename函数实现的，看起来功能有三个，其实功能就一个，修改文件的路径名。
					

		10.4.1函数原型和所需头文件
				#include <stdio.h>
			
				int rename(const char *oldpath, const char *newpath);
			
			
			（1）功能：修改文件路径名，将旧的路径名oldpath，改为新的路径名newpath。

			
			（2）返回值：调用成功返回0，失败返回-1，errno被设置
			
			
		10.4.2 代码演示
		
		
		
			1）修改路径名情况1：当只改路径，不改文件名字
					
					这种情况其实就是移动。
					
				（a）比如：
						· 普通文件：./new_file.txt   改为  ../new_file.txt
						· 目录：./kk 改为 ../kk
					
						· 其它文件：一样的
								
						
												
				（b）代码演示
							
								
								
						· 如果文件移动起始位置和目标位置，在同一个分区里面的话
							移动文件时，不会移动文件的数据，只是把文件的基本信息（名字、inode编号），从这个目录记录到另一个目录下。
							
							
						· 如果移动的起始位置和目标位置，不在同一个分区。
						
							既要移动数据，也要移动文件基本信息，比如：
							
							- windows：从u盘拷贝文件
							- Linux：从U盘拷贝文件
							
								在Linux下，分区是以目录的形式存在的，而在windows分区是以c:等盘符形式存在的。
				
								不管是在windows下还是在linux，从u盘拷贝文件，都是从u盘这个移动分区，将文件拷贝到电脑硬盘的分区，
							拷贝时，既要拷贝数据，也要拷贝文件的基本信息。

				
				
			2）修改路径名情况2：不改路径，只改文件名
						这种情况就是一般意义上的改名。
			
			
					（a）普通文件：./new_file.txt   改为  ./new_file1.txt
					（b）目录：./kk 改为 ./yy
					
					（c）其它文件：一样的
						
						代码演示：
					
					
					
		
			3）修改路径名情况3：既改路径，也改文件名
					
					（a）普通文件：./new_file.txt   改为  ../new_file1.txt
					（b）目录：./kk 改为 ../yy
					
					（c）其它文件：一样的
					
						
						代码演示：
		