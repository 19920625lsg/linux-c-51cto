# 1. 信号

## 1.1 什么是信号

> 信号是一种向进程发送通知，告诉其某件事情发生了的一种简单通信机制。

## 1.2 信号的命名

Linux下边定义了很多的信号，所有的信号都是一个整数编号，不过为了好辨识，Linux系统给这些整数编号都定义了对应的宏名，

宏名都是以SIG开头，比如SIGABRT，

+ SIG：signal的缩写
+ ABRT：abort的缩写

宏名SIG***，***是对信号的描述，ABRT表示放弃的意思，向进程发送SIGABRT信号，进程会被信号异常终止

在前面的课程我们就讲过，当我们调用abort函数时，该函数就会向进程发送一个SIGABRT信号，你一看到ABRT就知道与abort函数有关系

疑问：这么多的信号，都有哪些呢？记不住怎么办？  
答：不用担心，后面会详细解释这个问题

## 1.3 谁会向进程发送信号

 ![进程接收信号的三个来源](https://i.loli.net/2019/04/02/5ca344dd21944.jpg)
 
  总结起来，会有三个“人”会向进程发送信号，分别是“另一进程”、“OS内核”、“硬件”。

+ （1）另一个进程发送信号
  比如在命令行终端窗口通过kill命令向某个进程发送一个信号将其终止。

  演示:
  `kill PID`

+ （2）内核发送信号

  发生了某个事件，Linux内核可能会发送该事件对应的信号给某个进程,进程从管道文件读取数据，但是管道文件的读权限被关闭了，进程会被内核发送一个SIGPIPE信号，提示读管道出错了。
后面讲进程间通信时，会讲到这个问题。

+ （3）底层硬件发送信号  
  底层硬件发生了某个事件，会向进程发送对应的某个信号  

  比如按下ctrl+c按键终止进程时，内核收到ctrl+c按键后，会向正在运行的进程发送SIGINT信号，将其异常终止  

  不管进程是被哪一个信号给终止了，只要是被信号终止的，都是异常终止  

## 1.4 进程收到信号后，进程会如何处理

三种处理方式，分别是忽略、捕获、默认。

+  忽略  
  忽略的意思就是说，进程就当信号从来没有发生过。这就好比别人送了封信给你，但是你忽略这封信的存在，那么这封信将不会对你产生任何影响。

+ 捕获  
  捕获的意思就是说，进程会调用相应的处理函数，进行相应的处理。

+ 默认  
  如果不忽略也不捕获的话，此时进程会使用系统设置的默认处理方式来处理信号  

## 1.5 都有哪些信号

### 1.5.1 信号列表(没有32和33，一共62个)

```shell
1) SIGHUP         2) SIGINT     3) SIGQUIT        4) SIGILL         5) SIGTRAP
6) SIGABRT        7) SIGBUS     8) SIGFPE         9) SIGKILL        10) SIGUSR1
11) SIGSEGV       12) SIGUSR2   13) SIGPIPE       14) SIGALRM       15) SIGTERM
16) SIGSTKFLT     17) SIGCHLD   18) SIGCONT       19) SIGSTOP       20) SIGTSTP
21) SIGTTIN       22) SIGTTOU   23) SIGURG        24) SIGXCPU       25) SIGXFSZ
26) SIGVTALRM     27) SIGPROF   28) SIGWINCH      29) SIGIO         30) SIGPWR
31) SIGSYS        34) SIGRTMIN  

35) SIGRTMIN+1    36) SIGRTMIN+2    37) SIGRTMIN+3    38) SIGRTMIN+4
39) SIGRTMIN+5    40) SIGRTMIN+6    41) SIGRTMIN+7    42) SIGRTMIN+8  
43) SIGRTMIN+9    44) SIGRTMIN+10   45) SIGRTMIN+11   46) SIGRTMIN+12
47) SIGRTMIN+13   48) SIGRTMIN+14   49) SIGRTMIN+15   50) SIGRTMAX-14
51) SIGRTMAX-13   52) SIGRTMAX-12   53) SIGRTMAX-11   54) SIGRTMAX-10
55) SIGRTMAX-9    56) SIGRTMAX-8    57) SIGRTMAX-7    58) SIGRTMAX-6
59) SIGRTMAX-5    60) SIGRTMAX-4    61) SIGRTMAX-3    62) SIGRTMAX-2
63) SIGRTMAX-1    64) SIGRTMAX	
```

| 信号        | 取值       | 默认动作 | 含义（发出信号的原因）                  |
| --------- | -------- | ---- | ---------------------------- |
| SIGHUP    | 1        | Term | 终端的挂断或进程死亡                   |
| SIGINT    | 2        | Term | 来自键盘的中断信号                    |
| SIGQUIT   | 3        | Core | 来自键盘的离开信号                    |
| SIGILL    | 4        | Core | 非法指令                         |
| SIGABRT   | 6        | Core | 来自abort的异常信号                 |
| SIGFPE    | 8        | Core | 浮点例外                         |
| SIGKILL   | 9        | Term | 杀死                           |
| SIGSEGV   | 11       | Core | 段非法错误(内存引用无效)                |
| SIGPIPE   | 13       | Term | 管道损坏：向一个没有读进程的管道写数据          |
| SIGALRM   | 14       | Term | 来自alarm的计时器到时信号              |
| SIGTERM   | 15       | Term | 终止                           |
| SIGUSR1   | 30,10,16 | Term | 用户自定义信号1                     |
| SIGUSR2   | 31,12,17 | Term | 用户自定义信号2                     |
| SIGCHLD   | 20,17,18 | Ign  | 子进程停止或终止                     |
| SIGCONT   | 19,18,25 | Cont | 如果停止，继续执行                    |
| SIGSTOP   | 17,19,23 | Stop | 非来自终端的停止信号                   |
| SIGTSTP   | 18,20,24 | Stop | 来自终端的停止信号                    |
| SIGTTIN   | 21,21,26 | Stop | 后台进程读终端                      |
| SIGTTOU   | 22,22,27 | Stop | 后台进程写终端                      |
| SIGBUS    | 10,7,10  | Core | 总线错误（内存访问错误）                 |
| SIGPOLL   |          | Term | Pollable事件发生(Sys V)，与SIGIO同义 |
| SIGPROF   | 27,27,29 | Term | 统计分布图用计时器到时                  |
| SIGSYS    | 12,-,12  | Core | 非法系统调用(SVr4)                 |
| SIGTRAP   | 5        | Core | 跟踪/断点自陷                      |
| SIGURG    | 16,23,21 | Ign  | socket紧急信号(4.2BSD)           |
| SIGVTALRM | 26,26,28 | Term | 虚拟计时器到时(4.2BSD)              |
| SIGXCPU   | 24,24,30 | Core | 超过CPU时限(4.2BSD)              |
| SIGXFSZ   | 25,25,31 | Core | 超过文件长度限制(4.2BSD)             |
| SIGIOT    | 6        | Core | IOT自陷，与SIGABRT同义             |
| SIGEMT    | 7,-,7    |      | Term                         |
| SIGSTKFLT | -,16,-   | Term | 协处理器堆栈错误(不使用)                |
| SIGIO     | 23,29,22 | Term | 描述符上可以进行I/O操作                |
| SIGCLD    | -,-,18   | Ign  | 与SIGCHLD同义                   |
| SIGPWR    | 29,30,19 | Term | 电力故障(System V)               |
| SIGINFO   | 29,-,-   |      | 与SIGPWR同义                    |
| SIGLOST   | -,-,-    | Term | 文件锁丢失                        |
| SIGWINCH  | 28,28,20 | Ign  | 窗口大小改变(4.3BSD, Sun)          |
| SIGUNUSED | -,31,-   | Term | 未使用信号(will be SIGSYS)        |

在命令行执行`kill -l`，可以显示所有的信号列表  
总共62个信号，也就是说每个进程可以接收的信号种类有62种，1~64为信号的编号，SIG***为信号的宏名  

+ （1）为什么这么多信号？  
  每个信号代表着某种事件，一般情况下，当进程收到某个信号时，就表示该信号所代表的事件发生了。
  可能发生的事件会有很多种，所以弄出了这么多的信号，每个信号对应着自己特有的事件。	

+ （2）这么多信号，我记不住怎么办？  
  + （1）35~64：这些信号是Linux后期增设的信号，这些个信号不需要关心，所以不用了解  
  + （2）1~34：也不是所有的信号都要掌握，我们只关心其中常用的信号  
  + （3）就算对1~34中的于常用信号，我们的要求是理解，而不是记忆，因为我也记不住，当你忘记了信号名字时，kill -l查看即可  
  总之对于这些个信号，理解才是关键




### 1.5.2 常用信号

| 信号宏名    | 信号编号 | 说明                       | 系统默认处理方式    |
| ------- | ---- | ------------------------ | ----------- |
| SIGABRT | 6    | 终止进程，调abort函数是产生         | 终止，产生core文件 |
| SIGALRM | 14   | 超时，调用alarm函数时产生          | 终止          |
| SIGBUS  | 7    | 硬件故障                     | 终止，产生core文件 |
| SIGCHLD | 17   | 子进程状态改变                  | 忽略          |
| SIGINT  | 2    | 终止进程（ctrl+c）             | 终止          |
| SIGIO   | 29   | 异步通知信号                   | 终止          |
| SIGKILL | 9    | 无条件终止一个进程，不可以被捕获或忽略      | 终止          |
| SIGPIPE | 13   | 写没有读权限的管道文件时             | 终止          |
| SIGPOLL | 8    | 轮询事件，涉及POLL机制            | 终止          |
| SIGQUIT | 3    | 终止进程（ctrl+\）             | 终止，产生core文件 |
| SIGSEGV | 11   | 无效存储访问（指针错误）             | 终止，产生core文件 |
| SIGTERM | 15   | 终止，kill PID时，默认发送的就是这个信号 | 终止          |
| SIGUSR1 | 10   | 用户自定义信号1                 | 终止          |
| SIGUSR2 | 12   | 用户自定义信号2                 | 终止          |


#### （1）为什么当进程收到某些信号时，会被终止呢？

+ 1）比如ctrl+c发送SIGINT给进程时
+ 2）比如操作一个错误地址，内核发送SIGSEGV信号给进程时
+ 3）比如ctrl+\发送SIGQUIT信号给进程时
+ 4）比如在命令行使用kill pid，默认发送SIGTERM信号给进程时

因为你发送的这些信号的处理方式是终止，所以进程会被终止掉。

#### （2）kill命令

##### 1）kill的作用

+ （a）kill -l：查询信号列表  
+ （b）通过PID向进程发送一个信号  
  kill只是发送信号，至于进程会不会被终止，这就看信号的处理方式，处理方式如果是终止，那么就会终止进程。所以进程是否会被信号终止，是由信号的处理方式来决定的，而不是kill命令，当初起名字的时候，如果把kill起名为send估计更好理解些，因为kill所起到的作用只是发送信号  
  
  发送信号的完整格式：`kill -信号编号 PID`

  信号编号写数字和宏名都可以。如果不写明信号编号的话：`kill PID`，默认发送的是15(SIGTERM)信号，等价于`kill -SIGTERM PID`或者`kill -15 PID`，只有发送15这个信号时才能省略信号编号，发送其它信号时必须写明信号编号。

+ （c）为什么kill发送15(SIGTERM)这个信号时，信号编号可以省略？    

  我们说每个信号都有自己的特有用途，当初定义15（SIGTERM）信号的目的，就是专门给我们从命令行终端窗口，发送该信号去终止某个进程用的，也就是说如果你想在命令行使用kill命令去中断某个进程时，专用信号就是15。

  其实一般只要默认处理方式是终止的信号，我们都可以使用Kill命令将其发送给某个进程，这些信号都可以将进程终止掉，但是既然每个信号有自己的专门用途，那么在命令行去终止某个进程时，我们最好是使用专门的SIGTERM信号，这样显得更专业些。

  为了方便我们使用，Linux允许发送15这个信号时，不用设置信号编号，kill pid时会帮你默认发送这个信号。

##### 2）pkill

kill命令的兄弟，用法与kill差不多，只不过kill是按照PID来识别进程的，pkill是按照名字来识别进程的  

`Pkill -信号编号 名字`：`pkill -SIGINT  a.out`

同样的，如果不写明信号编号的话，默认发送的是15(SIGTERM)这个信号  

#### （3）信号的发送与接收

##### 1）发送

一般来说，大多数发送信号的原因，都是因为内核、硬件发生了某些事件时，才会向某个进程发送该事件专用的信号，告诉该进程这个事件发生了。

不过对于我们自己写的进程来说，其实更多是接收信号，而不是发送信号。

我们自己发送信号的原因无非如下几种情况：  
+ （a）ctrl+C、ctrl+\发送信号，终止正在运行进程    
+ （b）命令行执行kill命令发送信号，终止跑飞的进程，通常都是发送15这个信号    
  15这个信号的名字叫SIGTERM，TERM就是terminal的缩写，其实就是命令行终端的意思  
  当无法使用ctrl+c、ctrl+\来终止进程时，往往就使用kill命令来终止进程。

  那么什么样的进程会使用crtl+c、ctrl+\来终止？   
  只有当进程有占用命令行终端时，才能crtl+c、ctrl+\来终止。  

+ （c）因为某些特殊需求，往往在我们自己的程序里面，需要调用kill函数向另一个进程发送某个信号  
  + 什么特殊需求呢？  
    比如A进程和B进程需要协同工作，A进程将相应事件准备好以后，可能需要发送一个信号给B进程，通知B进程，B进程收到信号后，就知道该事件已经准备好，可以配合A进程做事了。

  + 至于说自己写的进程发送什么信号合适呢？  
    其实发送哪一种信号都行，但是我们说几乎每一种信号都有自己特定的用途。

    所以我们自己的程序在发送信号时，如果发送别人专用事件的信号的话，这样显得很不正规，而且很可能造成误会，比如我的A进程给另一个进程发送了一个SIGSEGV信号，B进程还以为发生了指针错误事件，其实发生并不是指针错误事件，而是其它事件，这就造成了理解的错误。

    因此自己进程调用kill函数发送信号时，我们可以发送的是SIGUSR1、SIGUSR2这两个自定义信号，所谓自定义就是，信号所代表的事件，可以由程序员自己根据实际情况来规定。

##### 2）接收

对于我们自己写的进程来说，最常见信号操作的还是接收信号，不过在一般情况下，我们进程并不会去重新设置信号的处理方式，而是使用信号的默认处理方式来处理信号

虽然很少重新设置信号的处理方式，但是总还是有这种需求的，所以我们后面会介绍，如何调用API来重新设置信号的处理方式。

#### （4）core文件  

##### 1）什么是core文件  

用于保存程序（进程）在当前结束的这一刻，进程在内存中的代码和数据，core文件可以用于分析进程在结束时的状况，不过由于进程代码和数据都是二进制的，所以把core文件直接打开后我们是看不懂的，一般需要特殊软件翻译后才能看懂。

##### 2）并不是所有的信号在终止进程时都会产生core文件  

只有某个些信号在终止进程时才会产生core文件，不过一般情况下并不会创建这个文件，因为系统默认将产生core的设置给关闭了，只有打开后这个设置后才会保存core文件。

所以当你看到提示core dumped，这就表示这个信号终止进程时，会产生core文件，只不过由于关闭了设置，因此core文件被丢弃了，dumped就是丢弃的意思。						
演示：
+ 例子1：crtl+\ 发送SIGQUIT信号  
+ 例子2：操作错误地址

##### 3）如果你不想丢弃core文件怎么办？  

对相关的系统文件进行设置就可以了，core文件一般默认保存在当前路径下

由于core在实际开发中基本用不到（除非某些很特殊的场合），所以我们这里不再深入介绍core文件
