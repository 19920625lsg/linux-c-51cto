# 6. 信号的发送、接收和处理的过程				

## 6.1 信号屏蔽字

### 6.1.1 信号屏蔽字的作用，以及它被放在了哪里

+ （1）作用
  屏蔽子的作用就是用来屏蔽信号的，有点像公司前台，信号来了先问前台(屏蔽字)，我能被立即处理不，能就立即处理，不能就暂不处理。

  每个进程能够接收的信号有62种，信号屏蔽字的每一位记录了每个信号是被屏蔽的还是被打开的。
  + 如果是打开的就立即处理。
  + 如果是屏蔽的就暂不处理

+ （2）屏蔽字放在了哪里
  每一个进程都有一个信号屏蔽字，它被放在了进程表(task_struct结构体变量)中

### 6.1.2 屏蔽字张啥样子

为了方便理解，我们简单地认为屏蔽字就是一个64位的unsigned int数，每一位对应着一个信号，如果这一位为0，表示信号可以被立即处理，如果为1表示该信号被屏蔽了，暂不处理。

```c
1   2   3   4   5           61  62  63  64             
*   *   *   *   *  ......   *   *   *   * 
```

比如：
+ （1）第1位：对应编号为1（SIGHUP）的信号，该位为
  + 1）0：表示1（SIGHUP）这个信号是打开的，可以被立即处理
  + 2）1：表示信号被屏蔽了，暂时不能处理

+ （2）第2位：对应编号为2（SIGINT）的信号
  + 1）0：表示2这个信号可以被立即处理
  + 2）1：表示信号被屏蔽了，暂时不能处理

...
...

### 6.1.3 我们可不可以自己修改信号屏蔽字，实现某个信号的打开和屏蔽呢？

可以，后面会专门介绍对应的API，这些API就是用于修改信号屏蔽字的  

只不过在**默认情况下，信号屏蔽字中所有的位都为0，也就说默认将所有的信号都打开了**  

## 6.2 未处理信号集 		

### 6.2.1 作用

跟屏蔽字一样，也一个64位的无符号整形数，专门用于记录未处理的信号。

“未处理信号集”同样也是被放在了进程的进程表中（task_struct）。

### 6.2.2 什么时候会记录

信号来了，**当进程的信号处理机制，检查该信号在屏蔽字中的对应位时发现是1，表示该信号被屏蔽了，暂时不能被处理**  

此时就会将“未处理信号集”中该信号编号所对应的位设置为1，这个记录就表示，有一个信号未被处理  

这就有点像你去访问领导，前台(屏蔽字)跟你说领导正忙，请你到休息室(未处理信号集)休息  

如果该信号发送了多次，但是每一次都因为被屏蔽了而无法处理的话，在“未处理信号集”中只记录一次  

这就有点像别人欠你钱，你去催债，别人还的的慢了，所以你催了好多回，但是不管催多少回，人家只还你一次  

### 6.2.3 什么时候处理记录的“未处理信号”

当屏蔽字中该信号的位变成0时（被打开了），此时就回去检查“未处理信号”，看该信号有没有未决的情况，有的话就处理它。

## 6.3 信号处理的完整过程 						

有了屏蔽字和未处理信号集的铺垫，现在就可以来看一看进程处理信号的完整过程了。https://edu.51cto.com/center/course/lesson/index?id=260237 的5:36

![信号处理流程](https://i.loli.net/2019/04/04/5ca58183a9e19.jpg)

## 6.4 代码演示

```c
#include <stdio.h>
#include <signal.h>
#include <unistd.h>

void signal_func(int signo)
{
    printf("hello\n");
    sleep(3); // 信号处理过程中信号屏蔽字一直为1，这个期间发SIGINT信号不会响应
    printf("world\n");
}

int main(int argc, char **argv, char **environ)
{
    pid_t ret = 0;    
    signal(SIGINT, signal_func);
    
    while(1);
    return 0;
}
```

`信号处理过程中信号屏蔽字一直为1，这个期间发SIGINT信号不会响应`, 结果如下：

```shell
^Chello
^C^C^C^C^Cworld
hello
^Cworld
hello
^C^C^C^C^C^C^C^Ccworld
hello
^Cworld
hello
world
```
