第11章 网络编程（网络IPC）

1. 本机进程间通信 与 网络通信

	1.1 本机进程间通信
			实现本机内部的进程间的通信，通信时需要使用专门IPC机制，比如信号、管道（无名、有名）、system V IPC
		（消息队列、共享内存、进程信号量），有关这些IPC的API在第8章“进程间通信”中，已经讲的非常清楚，这里不
		再赘述。
		
	1.2 网络通信
			网络通信也被称为网络IPC，直译就是网络进程间通信，简称网络通信，说白了就是跨机进程间的通信。
			图：
			
			
			在网络通信没有出现之前，那个时候只有“本机进程间通信”，直到后来人们发现两台不同计算机的进程间也
		有通信的需求，此时才发明了网络通信，以实现“跨机进程间通信”。
			
			所以可以简单的认为，网络通信其实就是“本机进程间通信”向“跨机进程间通信”扩展后的产物，只是这个扩展并
		不是那么容易的，为了实现跨机通信最起码：
			（1）通信协议的实现
			（2）各种通信设备的支持（网卡、路由器、光纤、电缆、基站等等）
				
				不过对于本章来说，我们重点关心的不是通信协议和中间的通信设备，这些东西都是别人早已实现好，
			（1）通信设备
					1）网卡：你的计算机肯定有
					2）路由器：没有路由器怎么上网，个人的路由器一般都自己买的
					3）光纤、电缆、基站等：由电信、移动、联通等网络运行商提供，我们无需操心
						
			（2）通信协议
						协议很早以前就已经被定义好了，至于协议栈的代码实现，Linux等系统也早已实现好，只要使相应的
					网络API调用即可。
						多数情况下协议栈代码属于OS的一部分，但是如果裸机需要网络通信时，裸机没有运行OS，此时只能运行
					独立的协议栈代码。
			
				对于本章来说，重点是学习系统提供的网络编程API，从而实现网络通信。				
				图：
				
		
2. 网络编程API 与 系统API	
		本章虽然叫网络编程API，不过由于网络的协议栈代码属于Linux OS的一部分，所以网络编程的API其实也是Linux
	所提供的系统API之一，只不过是专门被用于网络通信，所以我们单独的称为网络编程接口（API），但是你自己要知道，
	与前面章节介绍各种的API在本质上并没有什么差别，其实都是系统提供的系统API。
		
		搞清楚这一点后，大家不要过分的神话本章，本章的学习与前面章节的API学习相比，本质上并没有什么特殊
	的地方。
		

3. 本章的会严格掐好知识点的深度，避免形成极端

		本章的API虽然也是系统API，与其他系统API并无本质区别，但是毕竟是用于网络通信的，因此也不是一点基础
	知识都不要的。
	
		如果想要学习也好本章的话，大家必须具备一定的网络基础知识，如果没有的，大家在听本章的课程时，可能会
	有一定的障碍，因为我们所讲的内容不可能不涉及到这些网络知识。
		
		为了打好网络基础知识，所以大家学习本章之前，请一定先学习《计算机体系结构体——网络篇》的课程，打好
	网络基础知识之后，再来学习本章的内容，你会觉得本章的学习很容易。
		
		不过为了更好的讲解本章，在本章的开头，我们也会对《网络篇》里面的一些重要知识进行回顾。
	
		当然本章的名字叫“网络编程”，所以重点是讲如何使用这些API来编写网络通信的程序，而不是将网络原理，
	因此我们的课程会严格把握知识的深度，防止出现两种极端情况：
		
	（1）极端1：讲的过于简单
			基本只讲API的大概怎么用，参数怎么写，但是不会与网络相关的知识进行结合学习，按照这种方式来讲的话，
		大家可能好像觉得听懂了，但是仔细一想其实并没有理解，比如：
			1）跨网通信时，TCP和UDP各自是怎么实现，TCP有连接和UDP无连接有什么区别
			2）TCP会建立连接，到底什么是连接，为什么建立连接就能够实现可靠通信
			
			我们所写的例子程序虽然是局域网测试的，准确讲是本机测试的，但是我们会介绍TCP/UDP“跨网通信”的情况。
		
		
	（2）极端2：讲的太复杂
			比如深入分析数据封包格式，分析网络协议栈的源码等等，有关这些深入的内容我们本章不会涉及，因为如果
		讲这些内容的话，本章讲的就不是网络编程，而是网络原理。
			
			
			我们后面计划会出网络原理的课程，到时我们会讲封包格式以及协议的源码，同时通过抓取网络数据包来验
		证分析，不过前提是大家一定先打好网络的基础知识，只有当有了这些网络基础知识之后，到时候再去学习
		深入的网络原理时，所有的理解才会水到渠成的。
				
			所以本章的课程一定会介绍的比较深入，但是同时又不会深到让大家难以理解。

		
		
4.学习本章的意义
		学习本章非常有意义，
		
	（1）后面的课程会用到今天的内容
	
	（2）便于理解其它系统的网络API以及库提供的网络API
	
	（3）如果你未来想深入理解网络的话，如果没有本章这些知识作为基础，很难深入理解
		
	
	4.1 后面的课程会用到今天的内容
		后面进行Linunx嵌入式开发时，如果C程序需要涉及到网络通信时，会调用到今天所学的API
		
		既然会用到，重要性自然就不用多说了
	
	
	4.2 便于理解其它系统的网络API以及库提供的网络API
		
		（1）网络编程的接口有两种
				第一种：系统API
				
				第二种：库API，通过封装系统API实现
						当然库在封装系统提供的网络API时，往往可能还会进一步简化，就是把我们本章讲的很多步骤的函数，
					封装为一个函数，调用库接口往往更简洁，不过总体上你会发现其实实现方式都是一样的。
					
					
				1）C程序实现网络通信
				
					（a）直接调用系统提供网络API
							比如直接调用Linux或者windows的系统API。
							
					（b）直接调用C库的网络API
							不过这里说的C库并不是标准C库（因为标准C库并不提供网络编程的接口），而是一些特定c库，这些
						c库会提供网络编程接口。
							
						Linux嵌入式c程序想要通信的话，既可以调用C库提供的网络API，也可以直接Linux系统的网络API，
					不过在嵌入式开发里面，为了节省计算机的资源，往往会尽量避免运行额外的库，所以此时会直接调用
					Linux的网络API来实现。
						
						
				2）C++、java等程序实现网络通信
						基本都是直接调用它们的库接口来实现的，特别是java程序，java程序里面不能直接写C接口，所以必须
					使用java自己网络编程库接口。
					
						不过C++还好，因为c++兼容c，所以c++程序有三种选择
				（a）使用c++自己“类库”提供的网络API
				（b）使用某c库提供的网络API
				（c）直接使用Linux OS提供的网络API
						
						c++程序一般使用的都是“类库”的网络API。
			
			
		（2）为什么说学习本章，有助于理解其它形式的网络API
			
					不管是window、Linux等系统提供网络API，还是各种库通过封装OS的网络API从而提供的库API，
				其实用法几乎一样，因此学会本章Linux的网络API，非常有助于大家接触和学习其它形式的网络API。
				
					实际上你去学习windows的网络API时你会发现，它与Linux网络API几乎是差不多的，函数名称、功能、
				参数几乎没有什么区别。
					
					
					
	4.3 有利于深入学习和理解网络原理
		
				如果只是站在应用编程的角度的话，网络篇和本章的内容就够用了，但是如果你职业规划是想往网络方向
			深入发展的话，仅这些内容是不够的，但是想要深入理解网络原理，又不能一蹴而就，需要一定基础。
			
			而网络篇和本章网络编程其实就是深入学习网络原理的基础。
			
			
			
			

5. 本章知识结构
	1. 回顾《计算机体系结构体——网络篇》的部分内容
	2. 网络通信协议 与 网络编程接口
	3. 如何使用TCP/IP实现网络通信
	4. TCP通信
	5. UDP通信	
	6. 域套接字
	7. 广播
	8. 带外数据
	9. 服务器如何实现多客户

1. 回顾《计算机体系结构体——网络篇》的部分知识


	1.1 TCP/IP协议栈的四层结构
			图：
			
			
			
			
	1.2 TCP/IP协议族的详细情况
			在前面的课程我们说过，TCP/IP协议是由不同子协议，按照以上四层结构组合在一起的协议家族。
		图：
		
		
		
		应用层想使用TCP/IP通信有三条路线：
		
		（1）tcp路线：应用层——>TCP——> ip ——>硬件接口
		
		（2）udp路线：应用层——>UDP——> ip ——>硬件接口
		
		（3）ip路线：应用层——> ip ——>硬件接口
					越过了TCP和UDP。
		
		
		
		
	1.3 数据传输的时的封包和拆包
		图：
	
	
			
		ip层封装的源IP和目标IP是怎么来的。
		
		（1）源ip：自动检测本机ip得到的
		（2）目标ip：由应用层（应用程序）或者传输层交给ip层的。
				
				为什么是应用层或者传输层交给IP层的？
				答：因为只有应用层或则传输层才知道你要将数据发送给谁（目标）。

	1.4 回顾数据传输的几种情况
		
		1.4.1 目标ip == 源IP（本机通信）
			数据只在本机内通信，数据到ip层就回去了，不过网卡，也不经过链路层。
			
			图：
				
				
				
		1.4.2 目标ip != 源IP，但是目标IP网段 == 源IP网段（局域网通信）
				此时仅仅在局域网内通信，数据不会经过路由器到外网。
		
		
		（1）封包的过程
				
				
				
		
		（2）如何找到对方的
					图：
					
					
					
		

	
		1.4.3 目标ip网段 != 源ip网段（跨网通信）
				此时数据一定会过路由器，通信双方属于跨网通信

				
		（1）封包的过程	

					图：

					
					
					跨网通信时，目标IP一定要封装对方所在路由器的公网IP。
					ip同样的是由应用层或者传输层嫁给IP层封装的。
					
	
		
		（2）如何找到对方的
					跨网通信时，必须通过NAT转换才能找到对方。
					
				
				 图：
				
				
				
					服务器NAT转换所需的信息，必须由管理人员自动配置，但是客户端NAT转换记录的信息，是在向外主动发
				送信息时自动记录的。

					对方收到数据包后，会得到发送发方所在路由器的公网ip，然后即可原路返回数据。
					图：

					
					
					
									
				疑问：网上不是说发送数据和回答数据时，所走的路由器可能是不一样吗，但是如果原路返回的话路由器
					不就一样了吗？
				
					其实我们的这个图只是一个示意图，画的非常简略，路由器都是以集群形式存在的，某集群中的路由器
				都会记录相同信息，所以返回时不管走的是哪些路由器，返回时NAT所用的信息是一样的，因为所用的信息
				是一样的，所以相当于还是原路返回的。
			
					对于以上NAT转换的过程，不论是TCP通信还是UDP通信都是一样的，TCP和UDP的不同并不体现在底层的实际
				传输上，而是TCP和UDP协议本身的实现上。

2. 网络通信协议 与 网络编程接口（API）
	
	2.1 是不是只有TCP/IP这一种网络通信协议
	
			不是的，其实有很多种，后面会介绍有大概哪些网络通信协议，只不过现在的互联网使用的主流协议是
		TCP/IP协议。
			
			所以正是由于存在着很多种的网络通信协议，因此各个OS（比如Linux）会同时支持多种网络通信协议，而不是
		只支持TCP/IP这一个。
		
	
	2.2 网络API 与 网络协议之间的关系
	
			以Linux为例，Linux所提供的网络API支持多种通信协议，只要给API指定不同的参数，就可以使用你想要使用的
		那个协议。
		
			我们本章讲的是TCP/IP，显然是希望使用TCP/IP来通信，所以调用网络API时需要通过参数来指定，我们使用的是
		TCP/IP协议。
		
		
	
3. 如何使用TCP/IP实现网络通信
			有三种方式：
	
		（1）tcp路线：应用层——>TCP——> ip ——>硬件接口
					封装传输层包头时，封装的是TCP协议的包头。
		
		（2）udp路线：应用层——>UDP——> ip ——>硬件接口
					封装传输层包头时，封装的是UDP协议的包头。
		
		（3）ip路线：应用层——> ip ——>硬件接口
					越过了TCP和UDP。
		
		本章只讲前两种，第三种我们不介绍，因为除非有什么特殊用途，否者第三种情况基本碰不到。

		
		
			
4. 使用TCP协议通信	
		
		TCP的全称叫Transmission Control Protocol，即传输控制协议，简称TCP。
		
		
	4.1 TCP协议的特点
			TCP协议是有序的、面向连接的、可靠的字节流传输层协议。
		
		
		4.1.1 什么是字节流 
				字节流的意思就是说，将数据分组发送时，分组数据的大小可以以字节为单位进行调整。
				
			（1）为什么要调整分组数据的字节数
			
					当网络状况不好，如果你还拼命的发送字节数很大的分组数据时，出错的可能性很高。
					这就好比道路状况本来就差，结果还大量的涌入车辆，出事的概率自然就很高，所以当道路状况很差时
				就应该减少汽车流量，当路况好转时在逐步的增加汽车流量。
					
					所以进行TCP通信时，如果TCP检测到网络不佳时，就会减少分组数据的字节数（把分组数据变小），
				网络状况好转时再逐步增加字节数，总之会根据网络的好坏来调整字节数，这个调整的机制被称为
				“滑动窗口机制”。
				
					之所以起名叫“滑动窗口机制”，是因为和“滑动窗口”调整通风状况的原理很相似，“滑动窗口机制”工作
				原理如下：	
				
				（1）当网络不好导致数据丢失时，数据每丢失一次，分组字节数减为以前的二分之一
						比如原本1000字节，现在变为500字节。
						
				（2）当网络状态恢复时
						1）如果目前分组大小 < 最初大小的二分之一时，每成功发送一个字节，字节数增加1倍
						
						2）如果目前分组大小 >= 最初大小的二分之一时，每成功发送一次，分组字节数只增加1字节，增加减缓了。
						
						
						
			（2）对比UDP
					DUP跟TCP不一样的，UDP的分组数据包是固定长度的数据报，并不会根据网络的好坏来进行调整。
					
			
					
		4.1.2 TCP协议为什么是可靠传输协议
		
			通过三点来保证：
				第一：三次握手建立连接
				
				第二：有应答机制，也就是将数据发送给对方后，对方必须应答是否发送成功
				
				第三：使用“滑动窗口”机制，根据网络的好坏，控制发送的分组数据的大小
			
			
			（1）三次握手建立连接
			
					1）三次握手
						图：
					
								这张图不仅画出了三次握手（三次通信），还出画出了双发收发数据时的应答机制，断开连接
							时四次握手。
								
								
						（a）三次握手
								只要三次握手成功，客户和服务器就建立了连接，否者连接没有建立成功，双方不能通信。
							
								· 三次握手，一定是由客户方先发起的。
									为什么是一定是客户先发起的呢？
									
										因为只有服务器的IP和端口是固定不变、以及公开的，而客户端（pc）的ip和端口就不一定了，
									如果让服务器向客户主动发起握手请求，服务器根本就不知道客户的IP和端口多少，怎么主动
									连接呢。
										
										所以只能是客户主动向服务器发起握手请求，当服务器收到客户数据后，在数据包里面提取出
									客户的IP和端口后，服务器能够向客户回发数据。
										
										所以从这里我们可以看出，我们实现服务器程序时，必须想办法固定服务器的IP和端口，至于
									如何固定，我们后面在再介绍，其实很简单，只要调用bind函数即可实现。

									
									
								· 为什么是三次握手，不是建立两次，不是四次、五次？
										这个是由TCP实现原理来决定的，这里不解释这个问题，大家只需知道三次握手成功后，客户和
									服务器即可成功建立连接，建立连接后即可正式通信。
										
										三次我握手的通信并不是正式通信，只是握手通信。
									
								
									疑问：怎么理解TCP的“连接”？
										后面回答这个问题。
								
				
								· 如何实现TCP的三次握手
										调用相应的API来实现，后面再介绍。

										
						（b）应答机制
									就是将数据发送给对方后，不管对方是服务器还是客户，对方必须回答我是否收到数据，收到的数
								据是否正确，这就是应答机制。
			
						
							
						（c）四次握手断开连接
									
									发起者可以是服务器和客户任何一方，不像三次握手，一定要客户方先发起，为什么服务器也
								可以发起呢？
									
									因为断开连接时，连接已经建立了，在建立连接时服务器已经记录下客户的IP和端口，所以服务
								器可以主动向客户发起断开连接的请求。
								
									四次握手结束后，连接就断开了，断开的意思就是客户和服务器之间不能再进行通信。
									
									疑问：具体怎么断开连接呢？
									调用相应的API来实现，调用API后，四次握手由TCP自动完成。
			
					2）三次握手建立连接的目的	
						
						第一：提高通信的可靠性
						第二：记录对方的ip和端口，正式通信时会自动的使用记录的ip和端口
						
						（a）提高通信的可靠性
						
							 · 疑问：为什么建立连接就可以提高通信的可靠性呢？
									
									要回答这个问题，就必须先明白到底什么是建立连接，其实从三次握手可以看出，所谓的建立连
								接其实就是相互成功问答三次，相互问答三次说白了就是相互打个招呼，“哎我要和你通信了”，
								对方说“好，没问题”，只要双方问答成功，就说明双方的通信线路是好的，此时再正式通信，双方
								就能进行可靠的数据传输，如果问答不成功就说明通信线路有问题，不能进行通信。

									这就好比我想往某个地方运输货物，但是我又怕走到半道发现道路有问题，导致半途而废，此时
								我就可以先去探探路，如果能够到达目的地，就说明道路是通的，然后我正式运输货物，如此一来
								就能保证运输是可靠的。

									所以不要把“三次握手建立连接”想得太复杂，这个“连接”说白了就是事先通信探探路，把路探通
								后在进行正式的数据传输，如此就能在相当程度上保证传输的可靠性。
									
							 · UDP
									udp不是这样的，udp在发送数据时，并不会通过连接先确认线路是不是通的，然后再发数据，
								对于UDP协议来说，数据发送方并不知道线路是不是通的。
								
									正是由于UDP不存在这种通过连接确认线路的机制，所以UDP属于不可靠通信。
									
					
						（b）记录对方的IP和端口
								客户与服务器建立连接后，各自的TCP都会记录好对方IP和端口，后面正式通信时就会自动使用记
							录的IP和端口。

							
			
			（2）有应答机制
					
					1）为什么应答机制能够TCP的可靠性
					
							因为如果发送给对方的分组数据有丢失、有错误，对方就会回答数据有错误，那么发送方会重发，
						以保证一定将正确的数据发送对方。
						
					
					2）UDP
							UDP没有应答机制，发送方完全不关心对方对于数据的接受状态，所以
							
							TCP：可靠通信，因为TCP完全清楚现在通信状态，可以保证一定可以把户数发送给对方，发送的
									数据一定是正确的。
									
							UDP：不可靠通信，因为UDP完全不清楚目前的通信状态，有点像种庄稼“凭天收”的感觉。
							
						
						
			（2）滑动窗口机制				
					可以根据网络状态调整分组数据大小，减少网络状况不好所带来的错误。
						
					UDP就没有这种机制，不管网络是好是外，每次发送的都是固定字节数的分组数据。
					

	
	4.3 什么时候使用TCP协议
	
			需要进行可靠传输时就使用TCP，比如好多现成的应用层协议就要求可靠传输，是以他们使用的就是TCP协议，
			
			（1）HTTP：专门用于访问WEB的“超文本传输”的应用层协议
			（2）SMTP：邮件传输的应用层协议
			（3）Telnet：远程登录协议
			（4）SNMP：简单网络管理协议
			（5）FTP：文件传输协议
			（6）TFTP：简单文件传输协议
			（7）NFS：网络文件系统协议
			
				如果你不想使用现成的应用层协议，或者压根就没有你要的应用层协议的话，我们就可以自己直接调用TCP
			来通信，本章讲TCP通信时，讲的就是应用程序如何直接调用TCP来通信。
			
				
				当然这些“应用层协议”不一定非要使用TCP/IP这种网络协议，只不过由于TCP/IP是主流网络通信协议，所以
			这些应用层协议下层对接的基本都是TCP/IP协议。
					
	4.4 使用TCP通信时，TCP协议要求必须要有一个服务器端
			
			这一点是由TCP协议本身的特性决定的，只要你使用TCP协议来通信，就必须要有一个TCP服务器端。
	
			
			
		4.4.1 TCP服务器的大概工作过程
		
			（1）服务器会使用专门“文件描述符”来监听客户的“三次握手”，然后建立连接。
			
			（2）一旦连接建立成功后，服务器会分配一个专门的“通信文件描述符”，用于实现与该连接客户的通信
					
				
				由于建立连接时，双方的TCP协议都已经记住了对方IP和端口，所以双方正式通信时，TCP会自动使用记录
			的IP和端口，我们不需要重新指定对方的IP和端口。
			
			
			
		4.4.2 TCP编程模型				
				在编程模型里面，必须要有一方是TCP服务器，另一方是TCP客户。
				
				服务器只有一个，但是客户端有很多，不管客户端有多少个，客户端与服务器端的通信，都按照编程模型
			的描述来实现的。

				图：
				
				
				
	
	
		4.4.3 服务器是如何同时应对多客户的通信呢？
			
			
			（1）多线程 和 多进程
					图：
					
			
			
			（2）多路io
			
					图：

			
	4.6 TCP通信代码举例

		· 写一个TCP服务器程序
		
		· 写一个客户端程序
			
			不过为了不要让例子太复杂，服务器程序目前只为一个客户服务，至于使用多进程、多线程以及多路io为多客
		户服务的情况，后面再介绍。
			
			
		4.6.1 实现TCP服务器程序
		
		（1）第1步：调用socket 网络API，创建套接字文件
				
				1）socket函数
					 #include <sys/types.h>
					 #include <sys/socket.h>

					 int socket(int domain, int type, int protocol);
				
				
				（a）功能：创建一个套接字文件，然后以文件形式来操作通信，不过套接字文件没有文件名。
							Linux有7种文件，套接字文件就是其中一种。
							
							socket翻译为中文就是“套接字”的意思，其实翻译为插座更合适些，因为socket本来就有插座的意思，
						使用socket创建一个通信的套接字文件，就好比插上了一个通信的插座，有了这个插座就可以和对方
						通信了。
							
							
				（b）返回值
				
						· 成功：返回套接字文件描述符。
							
						· 失败：返回-1，errno被设置
						
						
						
				（b）参数
						· domian
														 族/范围
							int socket(int domain, int type, int protocol);
							
							- 作用：指定协议族
								
								为什么要指定协议族？
								
									因为你要使用的通信协议一定是属于某个协议族，所以如果不指定协议族，又怎么指定
								协议族中的某个具体协议呢。
										
									比如我们想用的是TCP协议，TCP属于TCP/IP协议族中的子协议，所以必须先通过domain指定
								TCP/IP协议族，不过TCP/IP协议族有两个版本，分别是IPV4是IPV6版本，我们目前使用的还是
								IPV4版本，因为Ipv6还未普及。
									
									IPV4是Internet Protocol Version4的缩写，直译为“网络协议第四版”，IPV4和IPV6这两个版
								本所使用的ip地址格式完全不同，
									IPV4：ip为32位
									IPV6：ip为128位
									
									不仅IPV4和IPV6的ip地址格式不同，其实所有不同网络协议族所使用ip地址格式都不相同。

									
							int socket(int domain, int type, int protocol);
							
							- domain可设置的常见宏值
							
									可设置的有：AF_UNIX, AF_LOCAL、AF_INET、AF_INET6、AF_IPX、AF_NETLINK、AF_APPLETALK
								AF_PACKET、AF_UNSPEC，有关每个宏的作用后面再解释，这里先介绍下这些“宏名”。
								
								
									AF是address family，表示地址家族的意思，由于每个网络协议族的ip地址格式完全不同，
								因此在指定ip地址格式时需要做区分，所以这些AF_***宏就是用于说明所使用的是什么协议的
								IP地址，
									
									
									这些个宏定义在了socket.h中，
									#define AF_UNSPEC	0
									#define AF_UNIX		1	/* Unix domain sockets 		*/
									#define AF_LOCAL	1	/* POSIX name for AF_UNIX	*/
									#define AF_INET		2	/* Internet IP Protocol 	*/
									#define AF_AX25		3	/* Amateur Radio AX.25 		*/
									...
								
								
									有同学可能会说不对呀，domain是用来指定协议族的吗，但是AF_***确是用来区分不同协议ip
								格式的，给domain指定AF_***合适吗？
									
									
									其实区分不同协议族应该使用PF_UNIX, PF_LOCAL、PF_INET、PF_INET6、PF_IPX、PF_NETLINK、
								PF_APPLETALK、PF_PACKET、PF_UNSPEC，PF就是protocol family的意思，意思是“协议家族”。
								
									PF_***与AF_***不同的只是前缀，不过AF_***与PF_***的值完全一样，比如AF_UNIX == PF_UNIX，
								所以给domain指定AF_***，与指定PF_***完全是一样的。
					
					
					
								疑问： 为什么AF_*** == PF_***?
								
									AF_***用于区分不同协议族的ip地址格式，而PF_***则用于区分不同的协议族，但是每个协议族的
								IP格式就一种，所以协议族与自己的IP格式其实是一对一的，因此如果你知道使用的是什么ip地址
								格式，其实你也就知道了使用的是什么协议族，所以使用AF_***也可以用于区分不同的协议族。
									
									不过为了更加正规一点，区分不同协议族的宏还是被命名为了PF_***，只不过它的值就是
								AF_***的值。
									
									#define PF_UNSPEC	AF_UNSPEC
									#define PF_UNIX		AF_UNIX
									#define PF_LOCAL	AF_LOCAL
									#define PF_INET		AF_INET
									#define PF_AX25		AF_AX25
									...
									
									int socket(int domain, int type, int protocol);
									
									总之希望大家理解，domain是用于指定协议族的，设置的宏可以是AF_***，也可以是PF_***，
								不过正规一点的话还是应该写PF_***，因为这个宏才是专门用来区分协议族的，而AF_***则是用
								来区分不同协议族的ip地址格式的。
									
									不过socket的手册里面写的都是AF_***，没有写PF_***。
								
								
								
								
							- domain的常见宏值，各自代表是什么协议族
									AF_UNIX, AF_LOCAL、AF_INET、AF_INET6、AF_IPX、AF_NETLINK、AF_APPLETALK
								AF_PACKET、AF_UNSPEC
							
									PF_UNIX, PF_LOCAL、PF_INET、PF_INET6、PF_IPX、PF_NETLINK、PF_APPLETALK、
								PF_PACKET、PF_UNSPEC
								
								
								+ PF_UNIX、PF_LOCAL：域通信协议族
										这两个宏值是一样（宏值都是1）。
										
										给domain指定该宏时就表示，你要使用的是“本机进程间通信”协议族，我们在讲第8章IPC
									时就说过，还有一种域套接字的IPC，也可以专门用来实现“本机进程间通信”。
										
										这个域就是本机的意思，当我们给socket的domain指定这个宏时，创建的就是域套接字文件。
										后面讲域套接字通信时，会具体的来使用这个宏。
								
										
										
								+ PF_INET：指定ipv4的TCP/IP协议族。
										我们本章要讲的TCP和UDP就是IPV4的TCP和UDP。
									
									
								+ PF_INET6：ipv6的TCP/IP协议族，目前还未普及使用，我们这里不讲。
									
									
								+ PF_IPX：novell协议族，几乎用不到，了解即可
								
										由美国Novell网络公司开发的一种专门针对局域网的“局域网通信协议”。
										
										这个协议的特点是效率较高，所以好多局域网游戏很喜欢使用这个协议来进行局域网通信，比如
									以前的局域网游戏CS，据说使用的就是novell协议族。
									
										之所以使用novell协议族，是因为CS的画面数据量太大，而且协同性要求很高，所以就选择了使
									用novell协议族这个高效率的局域网协议。
										
										现在互联网使用的都是TCP/IP协议，而novell和TCP/IP是两个完全不同的协议，所以使用
									novell协议族的局域网与使用TCP/IP协议族的互联网之间兼容性比较差，如果novell协议的
									局域网要接入TCP/IP的Internet的话，数据必须进行协议转换。
									
										所谓协议转换就是，
										novell局域网的数据包发向TCP/IP的互联网时，将novell协议族的数据包拆包，然后重新封包为
											TCP/IP协议的数据包。
										
										TCP/IP的互联网数据包发向novell局域网时，将TCP/IP协议族的数据包拆包，然后重新封包为
											novell协议的数据包。
										
										
										windows似乎并不是支持novell协议，但是Linux、unix这边是支持的。
										
										我怎么知道是支持的？
										既然我们在socket手册中查到了PF_IPX，就说明时肯定支持。
										
								
								+ PF_APPLETALK：苹果公司专为自己“苹果电脑”设计的局域网协议族。
									
			
			
								
								+ AF_UNSPEC：不指定具体协议族
											
											int socket(int domain, int type, int protocol);
								
										此时可以通过第三个参数protocol指定协议编号来告诉socket，你使用的是什么协议族中的
									哪个子协议。
										
										什么事协议编号？
										每个协议的唯一识别号，制订协议的人给的。
								


								
						
							
							
						int socket(int domain, int type, int protocol);						
						
						· type：套接字类型，说白了就是进一步指定，你想要使用协议族中的那个子协议来通信。
								
								比如，如果你想使用TCP协议来通信，
								首先：将domain指定为PF_INET，表示使用的是IPV4的TCP/IP协议族
								其次：对type进行相应的设置，进一步表示我想使用的是TCP/IP协议族中的TCP协议。
							
							
							
								type的常见设置值：SOCK_STREAM、SOCK_DGRAM、SOCK_RDM、SOCK_NONBLOCK、SOCK_CLOEXEC
								
							- SOCK_STREAM：
									将type指定为SOCK_STREAM时，表示想使用的是“有序的、面向连接的、双向通信的、可靠的字
								节流通信”，并且支持带外数据。
									有关什么是带外数据后面再介绍。
									
									int socket(int domain, int type, int protocol);	
									
									如果domain被设置为PF_INET，type被设置为SOCK_STREAM，就表示你想使用TCP来通信，因为
								在TCP/IP协议族里面，只有TCP协议是“有序的、面向连接的、双向的、可靠的字节流通信”。
									
									使用TCP通信时TCP并不是孤立的，它还需要网络层和链路层协议的支持才能工作。
									
									如果type设置为SOCK_STREAM，但是domain指定为了其它协议族，那就表示使用的是其它“协议族”
								中类似TCP这样的可靠传输协议。
									
									
							- SOCK_DGRAM：
							
									将type指定为SOCK_DGRAM时，表示想使用的是“无连接、不可靠的、固定长度的数据报通信”。
										
									固定长度意思是说，分组数据的大小是固定的，不管网络好不好，不会自动去调整分组数据的
								大小，所以“固定长度数据报”其实就是“固定长度分组数据”的意思。
									
									当domain指定为PF_INET、type指定为SOCK_DGRAM时，就表示想使用的是TCP/IP协议族中的
								中的DUP协议，因为在TCP/IP协议族中，只有UDP是“无连接、不可靠的、固定长度的数据报通信”。
								
									同样的UDP不可能独立工作，需要网络层和链路层协议的支持。

									如果type设置为SOCK_DGRAM，但是domain指定为了其它协议族，那就表示使用的是其它“协议族”
								中类似UDP这样的不可靠传输协议。
									
									后面讲UDP时就会使用SOCK_DGRAM。
									
									
							- SOCK_RDM：表示想使用的是“原始网络通信”。
									
									int socket(int domain, int type, int protocol);	
									
									比如，当domain指定为TCP/IP协议族、type指定为SOCK_RDM时，就表示想使用ip协议来通信，使用
								IP协议来通信，其实就是原始的网络通信。
									
								为什么称为原始通信？	
									以TCP/IP协议族为例，TCP/IP之所以能够实现网络通信，最根本的原因是因为IP协议的存
								在，ip协议才是关键，只是原始的IP协议只能实现最基本的通信，还缺乏很多精细的功能，所以才
								多了基于IP工作的TCP和UDP，TCP/UDP弥补了IP缺失的精细功能。
								
									尽管ip提供的只是非常原始的通信，但是我们确实可以使用比较原始的IP协议来进通信，特别是
								当你不满意TCP和UDP的表现，你想实现一个比TCP和UDP更好的传输层协议时，你就可以直接使用
								ip协议，然后由自己的应用程序来实现符合自己要求的类似tcp/udp协议，不过我们几乎遇不到
								这种情况，这里了解下即可。
								
									如果type设置为SOCK_RDM，但是domain指定为了其它协议族，那就表示使用的是其它“协议族”
								中类似ip这样最基本的原始通信协议。
								
								
								int socket(int domain, int type, int protocol);	
							
							- SOCK_NONBLOCK：将socket返回的文件描述符指定为非阻塞的。
									
									如果不指定这个宏的话，使用socket返回“套接字文件描述符”时，不管是是用来“监听”还是用
								来通信，都是阻塞操作的，但是指定这个宏的话，就是非阻塞的。
										
									当然也可以使用fcntl来指定SOCK_NONBLOCK，至于fcntl怎么用，我们在高级IO讲的非常清楚。
									
									SOCK_NONBLOCK宏可以和前面的宏进行 | 运算，比如：
										SOCK_STREAM | SOCK_NONBLOCK
									
									
							- SOCK_CLOEXEC：表示一旦进程exec执行新程序后，自动关闭socket返回的“套接字文件描述符”。
								图：
								
								
								
								这个标志也是可以和前面的宏进行 | 运算的，不过一般不指定这个标志。
								
								SOCK_STREAM | SOCK_NONBLOCK | SOCK_CLOEXEC 
								
								
								
						int socket(int domain, int type, int protocol);		
						
						· protocol：指定协议号		
						
								一般情况下protocol写0，表示使用domain和type所指定的协议。
								
								不过如果domain和type所对应的协议有好几个时，此时就需要通过具体的协议号来区分了，否者
							写0即可，表示domain和type所对应的协议就一个，不需要指定协议号来区分。
								
								
								疑问：在哪里可以查到协议号？
								所有协议的协议号都被保存在了/etc/protocols下。

								协议  编号
								ip 			0 
								icmp		1
								igmp		2
								tcp 		6
								udp 		17
								等
								
								socket(PF_INET, SOCK_STREAM, 0);		
								
								
				2）代码演示								

		（2）第2步：调用bind 网络API，将套接字文件、ip和端口绑定到一起。
					图：

				
				1）bind函数
						#include <sys/types.h>          
						#include <sys/socket.h>

						int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
										
										
					（a）功能：将指定了通信协议（TCP）的套接字文件与IP以及端口绑定起来。
								
								注意，绑定的一定是自己的Ip和端口，不是对方的，比如对于TCP服务器来说，绑定的就是服务器自己
							的ip和端口。
							
								至于什么是绑定，为什么要绑定，我们后面再详细解释。
							
								
							
					（b）返回值：成功返回0，失败返回-1，errno被设置。
							
							
					（c）参数
							· sockfd：套接字文件描述符，代表socket创建的套接字文件。
												既然要绑定套接字文件、ip和端口，肯定要有一个东西来代表套接字文件。
							
							· addrlen：第二个参数所指定的结构体变量的大小
							
							· addr：struct sockaddr结构体变量的地址，结构体成员用于设置你要绑定的ip和端口。
								
								- 结构体成员
								
									struct sockaddr {
										sa_family_t sa_family;
										char  			sa_data[14];
									}
									
									sa_family：指定AF_***，表示使用的什么协议族的IP，前面说过，协议族不同，ip格式就不同
									sa_data：存放ip和端口

										大家可以看出，如果将ip和端口直接写入sa_data数组中，虽然可以做到，但是操作起来有点麻烦，
									不过好在，我们可以使用更容易操作的struct sockaddr_in结构体来设置。
									
										不过这个结构体在在bind函数的手册中没有描述。
										
											struct sockaddr_in 
											{
													sa_family_t			sin_family;	//设置AF_***（地址族）
													__be16					sin_port;		//设置端口号
													struct in_addr	sin_addr;		//设置Ip
													
													/* 设置IP和端口时，这个成员用不到，这个成员的作用后面再解释， */
													unsigned char		__pad[__SOCK_SIZE__ - sizeof(short int) - 
														sizeof(unsigned short int) - sizeof(struct in_addr)];
											};
											
											struct in_addr 
											{
													__be32	s_addr; //__be32是32位的unsigned int，因为IPV4的ip是32位的无符号整形数
											};
											
										在struct sockaddr_in中，存放端口和ip的成员是分开的，所以设置起来很方便。
										
										使用struct sockaddr_in设置后，然后将其强制转为struct sockaddr类型，然后传递给bind
									函数即可。
										
										疑问：为什么要强制转换？
										bind要求的是struct sockaddr结构体，但是你设置的是struct sockaddr_in，自然要记性类
										型转换了。
										
										疑问：为什么这么麻烦，搞出了struct sockaddr和struct sockaddr_in这两个结构体类型？
										后面再解释。
																				

								
								- struct sockaddr_in的使用例子：
								
									struct sockaddr_in addr;
									
									addr.sin_family = AF_INET;//使用是IPV4 TCP/IP协议族的ip地址（32位）
									addr.sin_port		= htons(5006);//指定端口
									addr.sin_addr.s_addr = inet_addr("192.168.1.105");//指定ip地址
									
									ret = bind(sockfd, (struct sockaddr*)&addr, sizeof(addr));
									
									
									注意，如果是跨网通信时，绑定的一定是所在路由器的公网ip。
									
									bind会将sockfd代表的套接字文件与addr中设置的ip和端口绑定起来。
								
									有关htons和inet_addr这两个函数，我们后面会详细解释，目前我们先用起来。
									
									
									
									
				2）代码演示						
							
							
				
				
				
				
				3）有关bind的一些必须解释的问题
				
					（a）为什么要绑定，或者说绑定的目的是什么
					
								虽然bind函数看起来很简单，但是很多同学初学bind时基本都是似懂非懂，可能你感觉自己好
							像懂了，但是其实并不懂什么是绑定，以及为什么要绑定。
								
								调用socket创建套接字文件时，只是指定了所使用的协议（比如TCP协议），但是并没有指定通
							信时所需要ip地址和端口号。
									
							· ip作用：ip是用来定位和找到对方的，如果没有IP就不叫网络通信了。
									
							· 端口号的作用
								- 区分同一台计算机上不同的网络通信进程
									图：
									
								有了ip和端口后，对方首先通过ip找到目标计算机，然后再通过“端口”找到具体的网络通信进程。
								
									
							如果我们不明确的调用bind绑定一个固定的ip和端口的话，会怎么样？
								答：会被自动指定一个ip和端口，而且是不固定的，而且还不一定时你想用的iP和端口。
								
								
								
							自动指定ip和端口好不好？

						  · 对于TCP的服务器来说，自动指定ip和端口是不行的，为什么？
							
								因为客户端向服务器连接时，是由客户端主动发起三次握手请求的，如果服务器Ip和端口是变着的
							（不确定），此时客户端在向服务器请求连接时就抓瞎了，因为它根本就不知道服务器的ip和端口到
							底是多少，没办法建立连接。
							
								这就好比政府部门是服务器，我们这些群众是客户，如果政府部分的办公地址天天变来变去，我们这
							些客户不就抓瞎了吗，天天变，上哪联系政府去。
								
								所以对于TCP的服务器来说，必须调用bind函数给自己绑定固定的ip和端口号。
								
							到底什么是绑定？
								所以所谓绑定就是让套接字文件在通信时，使用固定的IP和端口。
							
							
						· 对于TCP通信的客户端来说，自动指定ip和端口是常态
						
							疑问：客户端的IP和端口自动指定的话，服务器怎么知道客户的ip和端口是多少呢？
							
							客户与服务器建立连接时，服务器会从客户的数据包中提取出客户的ip和端口，并保存起来，如果
							是跨网通信，那么记录的就是客户所在路由器的公网Ip。
		
					（b）htons函数和inet_addr函数		
					
								struct sockaddr_in addr;
								
								addr.sin_family = AF_INET;
								addr.sin_port		= htons(5006);
								addr.sin_addr.s_addr = inet_addr("192.168.1.105");
								
								ret = bind(sockfd, (struct sockaddr*)&addr, sizeof(addr));
								
								
							· htons
								
								- 函数原型
									#include <arpa/inet.h>
								
									uint16_t htons(uint16_t hostshort);
								
									+ 功能：功能有两个
										1. 将端口号从“主机端序”转为“网络端序”
										2. 如果给的端口不是short，将其类型转为short型
									
										htons：是host to net short的缩写，
										
										host：主机端序，主机端序可能是大端序，也可能是小端序，视OS而定
										net：网络端序，网络端序都是固定使用大端序
										short：短整形
									
										疑问：什么是大端序和小端序？
										有关这个问题，我们在讲《C语言深度解析》时已经介绍的非常清楚，这里不再赘述。
									
									+ 参数：主机端序的端口号
									
									+ 返回值：该函数的调用永远都是成功的，返回转换后的端口号
									
									
								- 为什么要进行大小端序的转换？
									+ 网络通信的过程
										
									 发送计算机          网络           接收计算机
 										主机端序 ——————> 网络端序 ———————> 主机端序
									
										发送计算机的端序与接收计算机的端序可能不一致，比如发送者是大端序，而接收者是小端序，
									如果通信时数据的端序处理不好，数据可能会出现乱码，甚至导致无法接收到数据。
									
										所以发送数据时，先从发送者的主机端序转成统一的网络端序，接收计算机接收到后，再统一
									的转成接收计算机的主机端序，如此接收者才能以正确的端序接收数据，否者就会出错。
									
									
									疑问：我没有调用htons函数，直接设置端口号（5006）好像也可以呢！
										
										因为我们写的程序是本机测试的，发送机和接收机都是同一台计算机，碰巧端序是一样的，
									所以不设置端序没有问题。
										
										而且就算你跨机测试时，不进行端序的转换的话，也有可能是正确的，因为有可能送计算机的
									端序和接收计算机的端序碰巧一样，但是如果不一样就出问题了。
									
										不过我们并不能保证发送和接收计算机的端序一定是一样的，所以不能冒这样的风险，我们一定
									要进行端序的转换。
							
							
								- htons的兄弟函数：htonl、ntohs、ltohs
									htonl：与htons唯一的区别是，转完的端口号时long，我们不使用这个函数，因为我们的端口号
											要的是short。
											
									ntohs：htons的相反情况，网络端序转为主机端序，后会用到
									ntohl：htonl的相反情况
										
										
								- 有关端口号的数值问题			
									addr.sin_port  = htons(5006);	
								
								
								 + 端口号的作用	
										用于区分同一台机器上的不同通信程序，对于同一台计算机来说，不同通信程序（可以是
									服务器、也可以客户端程序），他们的端口号都不能冲突，否者收发数据就出问题。
									图：	
									
									
									这就好比在同一层楼有两个房间叫101，客户就犯难了，不知道应该去按个房间。
									
									
									疑问：不同计算机的通信程序可以使用相同的端口号吗？
										当然可以，相互间毫无影响，这就好比1层有个101，2层也有个101，这是两个不同楼层的
									101房间，同名无所谓。
									
										所以A公司的计算机搭建web服务器端口是80，B公司服务器计算机搭建web同样是80端口，
									相互间并无干扰。
									
									
									+ 端口号的选择范围
										三个范围：0~1023、1024~49151、49152~65535。
									
									 0~1023：
											这个范围的端口最好不要用，因为这个范围的端口已经被世界公认的各种服务征用了，比如
										80就被web服务征用了，所以所有web服务器程序的端口都是固定的80。
										
										
										疑问：真的就不能用吗？
											我说的是最好不要用，但并没有说用了就一定会出问题，我们之所以建议不要用的原因是，
										如果使用这个范围的端口号的话，可能会遇到一些麻烦事。
										
											比如自己写了一个服务器程序，
										而且使用的是80端口，但是如果恰巧我又在计算机上安装了一个web服务器，web服务器
										程序默认使用的是就80端口，这下自己写的服务器程序的端口与安装的现成的web服务器的端口
										冲突了。
											web除了使用80端口，有些还是用8080端口。
											
											图：
										
										
										
										
											当然，如果你不安装web的话，其实也没什么，完全可以使用80端口，但是我们建议还是准守
										规则，不要使用这个范围的端口，因为保不齐你可能就安装了某些现成的全世界公认的服务器
										程序，如此一来就造成了端口的冲突，将会无法通信成功。
											
											总之我们自己在写服务器程序时，最好不要指定这个范围的端口号。
										
										
									1024~49151：
											自己实现服务器程序，建议使用这个范围的端口号，比如我写的TCP服务器所使用的5006，
										用的就是这个范围的端口号。
											
										疑问：当我们自己写的TCP服务器，在我们自己的PC机上测试运行时，难道指定5006就真的没有
											冲突的可能吗？
											
										说实话，还是有可能会冲突的，不过大家尽可以大胆使用，因为冲突的可能性很小，真要冲突了
										，我怀疑可能是大家的人品有问题^-^，那么为什么指定1024~49151范围的端口时几乎不可
										能冲突呢？										
										
										1. 全世界公认的有名的服务，使用的都是0~1023范围的端口，而不是这个范围的
										
										2. 这个范围的端口默认都是给自己写的服务器程序使用的，对于我的pc机来说，只有可能
											安装客户端
											程序（qq/微信客户端），几乎不会安装网络服务器程序（pc根本跑不动），所以这个范
											围的端口基本不可能会被什么服务器程序所使用，也就是我自己写的TCP服务器程序可能
											会使用。
												
												就算碰巧你的PC上安装了某个网络服务程序，使用了1024~49151中的某个端口，但是这个
											范围这么大，真想要冲突上也挺难的。


										3. 疑问：pc会安装很多的网络客户端程序（qq/微信客户端），万一某个客户端使用也是5006
											的话，这个客户端和我自己写的TCP服务器的端口5006，不就冲突了吗？
											
											Pc确实会大量安装客户端程序，但是客户端的端口都是自动分配的，而自动分配的端口范围为
											49152~65535，根本就不是1024~49151这个范围的，所以与客户端端口冲突的可能性不大。
										
											
									49152~65535：
											用于自动分配的，一般客户端程序不会绑定固定的ip和端口，因为客户端的Ip和端口都是
										自动分配的，在自动分配端口时，所分配的就是49152~65535范围的端口。
		
						· inet_addr函数			
								
								addr.sin_addr.s_addr = inet_addr("192.168.1.105");
							
								+ 函数原型
									#include <sys/socket.h>
									#include <netinet/in.h>
									#include <arpa/inet.h>

									in_addr_t inet_addr(const char *cp);
								 
								+ 功能：两个
									1. 将字符串形式的Ip"192.168.1.105"（点分十进制），转为IPV4的32位无符号整形数的ip
									2. 将无符号整形数的ip，从主机端序转为网络端序
									
										为什么要转换端序？
										与端口号端序的转换原因是一样的。
							 
								+ 参数：字符串形式的ip

								+ 返回值：永远成功，返回网络端序的、32位无符号整形数的ip。	
										
								+ 其它兄弟函数
										它的兄弟函数很多，虽然形态上有差异，实际上功能差不多，只是略有区别，这些函数并不难，
										不过由于时间关系，我不再一一详细介绍，等待真的用到其中某一个了，大家自己去学习和
										理解即可。
								
								
						· 为什么区分struct sockaddr和struct sockaddr_in
						
								struct sockaddr {
									sa_family_t sa_family;
									char  			sa_data[14];
								}

								struct sockaddr_in {
									sa_family_t			sin_family;
									__be16					sin_port;
									struct in_addr	sin_addr;
									
				
								/* 填补相比struct sockaddr所缺的字节数，保障强制转换不要出错 */
									unsigned char		__pad[__SOCK_SIZE__ - sizeof(short int) - 
										sizeof(unsigned short int) - sizeof(struct in_addr)];
								};
								
								我们不管使用什么协议族来通信，底层统一使用struct sockaddr结构体。
								
							那么为什么会有struct sockaddr_in？
								struct sockaddr设置起来不方便，为了方便设置，所以有了sockaddr_in结构体类型。
							
							
								注意：sockaddr_in是专门给TCP/IP协议族使用的，如果是其它协议族，对应的是其它的设置结构体，
								比如“域通信协议族”使用的就是struct sockaddr_un结构体。

								
								
					· 强制转换时发生了什么
							struct sockaddr_in addr;
							
							addr.sin_family = AF_INET;
							addr.sin_port		= htons(5006);
							addr.sin_addr.s_addr = inet_addr("192.168.1.105");
								
							ret = bind(sockfd, (struct sockaddr*)&addr, sizeof(addr));
							
							结构体内容并没有变，但是空间的解释方式变了，当我们将struct sockaddr_in强制转为
						struct sockaddr时候，struct sockaddr_in的后三个成员被强制解释为了struct sockaddr的sa_data
						成员，如此一来就把ip和端口给设置到了struct sockaddr是sa_data成员中。
							
							图：
	
		（4）第3步：调用listen 网络API，将套接字文件描述符，从主动变为被动文件描述符
		
				1）listen函数
						#include <sys/types.h>          /* See NOTES */
						#include <sys/socket.h>

						int listen(int sockfd, int backlog);
					
					（a）功能：将套接字文件描述符，从主动文件描述符变为被动描述符，然后用于被动监听客户的连接
					
					（b）返回值：成功返回0，失败返回-1，ernno被设置
					
					（c）参数
							· sockfd：socket所返回的套接字文件描述符
								socket返回的“套接字文件描述符”默认是主动的，如果你想让它变为被动的话，你需要自己调用
								listen函数来实现。
								
								
							· backlog：指定队列的容量。
							
									这个队列用于记录正在连接，但是还没有连接完成的客户，一般将队列容量指定为2、3就可以了。
									这个容量并没有什么统一个设定值，一般来说只要小于30即可。
					
					
					
				2）代码演示
						
						
						
						
						不要因为listen有听的意思，就想当然的认为，listen就是用于被动监听客户连接的函数，事实上
					真正用于被动监听客户连接的函数，并不是listen，而是其它函数。
					
						listen的作用仅仅只是用于将“套接字文件描述符”变成被动描述符，以供“监听函数”用于被动监听客户
					连接而已。
						
						
							
						
							
				3）TCP服务器为什么要listen
					
					（a）一定要注意，只有TCP服务器才会调用listen
							图：编程模型
							
							
							
					（b）TCP服务器调用listen的目的
					
								TCP服务器监听客户连接时，是使用socket返回的“套接字文件描述符”来实现的，但是这个文件
							描述符默认是主动文件描述符，所以需要使用listen函数将其转为被动描述符，否者无法用于被动
							监听客户的连接。
							
							什么是主动描述符？
							使用主动描述符可以主动的向对方发送数据。
							
							被动描述符？
							只能被动的等别人主动想你发数据，然后再回答数据，不能主动的发送数据。
							
							
							
							为什么要将“套接字文件描述符”转为被动描述符后，才能监听连接。
							
								TCP服务器和客户端必须要建立连接，建立连接时的三次握手是由客户端主动先发起的，
							也就是由客户端率先主动向服务器发送三次握手的数据，而服务器这一端则被动的接收，然后回答。
								
								图：
								
								
								
								正式由于服务器在三次握手时的这一被动属性，所以使用“套接字文件描述符”监听客户连接时，
							描述符必须是被动的描述符。
							
		（5）第4步：调用accept 网络API，被动监听客户的连接
				
				1）accept函数
						#include <sys/types.h>          /* See NOTES */
						#include <sys/socket.h>

						int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);

						
					（a）功能：被动监听客户发起三次握手的连接请求，三次握手成功，即建立连接成功。
								accept被动监听客户连接的过程，其实也被称为监听客户上线的过程。
									
								对于那些只连接了一半，还未连接完成的客户，会被记录到未完成队列中，队列的容量由
							listen函数的第二个参数（backlog）来指定。
								
								服务器调用accept函数监听客户连接，而客户端则是调用connect来连接请求的。
								
								一旦连接成功，服务器这边的TCP协议会记录客户的IP和端口，如果是跨网通信的，记录ip的就是
							客户所在路由器的公网Ip。
									
				
					（b）返回值：
							· 成功：
									返回一个通信描述符，专门用于与该连接成功的客户的通信，总之后续服务器与该客户间
								正式通信，使用的就是accept返回的“通信描述符”来实现的。
											
							· 失败：返回-1，errno被设置
						
							
						int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);
					（c）参数
							· sockefd：已经被listen转为了被动描述符的“套接字文件描述符”，专门用于被动监听客户的连接。
									如果sockfd没有被listen转为被动描述符的话，accept是无法将其用来监听客户连接的。
								
								
								- 有关套接字描述符的阻塞与非阻塞问题
								
									服务器程序调用socket得到“套接字文件描述符”时，如果socket的第2个参数type，没有指定
								SOCK_NONBLOCK的话，
									int socket(int domain, int type, int protocol);
									
									“套接字文件描述符”默认就是阻塞的，所以accept使用它来监听客户连接时，
								如果没有客户请求连接的话，accept函数就会阻塞，直到有客户连接位置。
									如果你不想阻塞，我们就可以在调用socket时，给type指定SOCK_NONBLOCK宏。
									
									
								疑问：在TCP/IP协议族中，只有TCP协议才有建立连接的要求，那么accept怎么知道你用的
									就是TCP协议呢？
									
									accept的第一个参数是socket返回的“套接字文件描述符”，它指向了socket所创建的套接字文件，
								创建套接字文件时，我们会通过参数1和参数2指定你所使用的协议，
									int socket(int domain, int type, int protocol);	
								
									比如将其指定为TCP协议，所以只要你在调用socket创建套接字文件时有指定通信协议，
								accept函数就可以通过“套接字文件描述符”知道套接字文件所使用的是不是TCP协议。


								int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);
							· addrlen：第二参数addr的大小，不过要求给的是地址。
									如何给地址？
									后面会代码演示。
								
								
							· addr：用于记录发起连接请求的那个客户的IP和端口（port）
							
									前面说过建立连接时，服务器这边的TCP协议会自动记录客户的ip和端口，如果是跨网通信的
								话，记录的就是客户的公网IP。

									如果服务器应用层需要用到客户ip和端口的话，可以给accept指定第二个参数addr，以获取
								TCP在连接时所自动记录客户IP和端口，如果不需要的就写NULL。
										int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);
									
									addr为struct sockaddr类型，有关这个结构体，我们在前面介绍过。	
									
									不过我们前面说过，虽然下层（内核）实际使用的是struct sockaddr结构体，但是由于这个
								结构体用起来不方便，因此应用层会使用更加便于操作的结构体，比如使用TCP/IP协议族通信时，
								应用层使用的就是struct sockaddr_in这个更加方便操作的结构体。
										
									所以我们应该定义struct sockaddr_in类型的addr，传递给accept函数时，将其强制转为
								struct sockaddr即可，与我们讲bind函数时的用法类似。
									

									例子：
									struct sockaddr_in clnaddr = {0};
									
									int clnsize = sizeof(clnaddr)
									cfd = accept(sockfd, (struct sockaddr *)&clnaddr, &clnsize);
									
									
									将clnaddr传递给accept后，accept函数会自动的讲TCP记录的客户ip和端口设置到clnaddr中，
								我们即可得到客户的ip和端口。
								
									通过之前对struct sockaddr_in成员的了解可知，clnaddr第二个成员放的是客户的端口号，
								第三个成员放的是客户的IP。
										
									struct sockaddr_in 
									{
											sa_family_t			sin_family;	//设置AF_***（地址族）
											__be16					sin_port;		//设置端口号
											struct in_addr	sin_addr;		//设置Ip
											
											/* 设置IP和端口时，这个成员用不到，这个成员的作用后面再解释， */
											unsigned char		__pad[__SOCK_SIZE__ - sizeof(short int) - 
												sizeof(unsigned short int) - sizeof(struct in_addr)];
									};
									
									
									
				2）代码演示
						
									
									
						

						
					
				3）如何使用得到的客户ip和端口
						比如我这里的使用方式是打印客户的ip和端口，此时必须调用ntohs和inet_ntoa函数进行端序转换。
					
					为什么要进行端序转换？
						客户的端口和ip是服务器这边的TCP协议，从客户端发送的网络数据包中提取出来的，网络数据包的
					端序属于网络端序，主机接收到数据后，如果你想要使用的话，就必须从网络端序转为主机端序。
					
					（a）ntohs：是htons的相反函数，将端口从网络端序转为主机端序
					（b）inet_ntoa：功能与inet_addr刚好相反，该函数有两个功能
					
							· 将IPV4的32位无符号整形数的ip，从网络端序转为主机端序
							
							· 将实际所用的无符号整形数的ip，转成人能识别的字符串形式的ip
					
					使用举例：
						struct sockaddr_in clnaddr = {0};

						int clnaddr_size = sizeof(clnaddr)
						cfd = accept(sockfd, (struct sockaddr *)&clnaddr, &clnaddr_size);
						
						printf("cln_port= %d, cln_addr=%s\n", ntohs(clnaddr.sin_port), inet_ntoa(clnaddr.sin_addr));
						
					
					代码演示

		（6）第5步：服务器调用read（recv）和write（send），收发数据，实现与客户的通信
		
					read和write的用法，我们在讲文件IO时已经介绍的非常清楚，我们这里着重介绍recv和send这两个函数，
				recv和send其实和read和write差不多，它们的前三个参数都是一样的，只是recv和send多了第四个参数。
					
					不管是使用read、write还是使用recv、send来实现TCP数据的收发，由于TCP建立连接时自动已经记录下
				了对方的IP和端口，所以使用这些函数实现数据收发时，只需要指定通信描述符即可，不需要指定对方
				的ip和端口。
						
					
				1）send函数
						
					（a）函数原型
							#include <sys/types.h>
							#include <sys/socket.h>
								
							ssize_t send(int sockfd, const void *buf, size_t len, int flags);
							
							· 功能：向对方发送数据
								其实也可以使用sendto函数，相比send来说多了两个参数，当sendto的后两个参数写NULL和0时，
							能完全等价于send。
									ssize_t sendto(int sockfd, const void *buf, size_t len, int flags, NULL, 0);

															
								类似TCP这种面向连接的通信，我们一般使用send而不是使用sendto，因为sendto用起来有点麻烦。
								类似UDP这种不需要连接的通信，必须使用sendto，不能使用send，后面介绍到udp时再详细介绍。
									
							· 返回值：成功返回发送的字节数，失败返回-1，ernno被设置
							
							
							
							ssize_t send(int sockfd, const void *buf, size_t len, int flags);
							· 参数：
								- sockefd：用于通信的通信描述符
								
										不要因为名字写的是sockfd，就认为一定是socket返回“套接字文件描述符”。
									在服务器这边，accept返回的才是通信描述符，所以服务器调用send发送数据时，第一个参数
									应该写accept所返回的通信描述符。
									

								- buf：应用缓存，用于存放你要发送的数据
										可以是任何你想发送的数据，比如结构体、int、float、字符、字符串等等。
										
										正规操作的话，应该使用结构体来封装数据。
										
										
								- len：buf缓存的大小
								
								- flags：一般设置0，表示这个参数用不到，此时send是阻塞发送的。
										
										阻塞发送的意思就是，如果数据发送不成功会一直阻塞，直到被某信号中断或者发送成功为止，
									不过一般来说，发送数据是不会阻塞的。
											
										当flags设置0时，send与write的功能完全一样，有关flags的其它设置，后面再介绍。
										
										
										
								
					（b）代码演示
							数据的发送和接收，
					
							收发数据的数据需要在网路中传输，所以同样要进行端序的转换。
							
							· 发送数据：将主机端序转为网络端序
							· 接收数据：将网络端序转为主机端序
							
							不过只有short、int、float等存储单元字节>1字节的数据，才有转换的需求。
							如果是char这种存储单元为一个字节的数据，不需要对端序进行转换。
							
							疑问：为什么存储单元为一个字节的数据，不需要进行端序的转换呢?
							有关这个问题，我们在《C语言深度解析》中讲的非常清楚，所以这里不再赘述。
							
							
							我们这里虽然介绍的是c程序的例子，但是实际上c++/java等调用相应的网络API实现通信时，应用
						程序同样需要进行端序的转换，与我们这里介绍的c程序的情况是一样的。
						
						
							前面介绍过，本机测试时其实是可以不进行端序转换的，但是对于正规网络通信来说，收发计算机
						的大小端序不一定相同，为了避免因端序不同所带来的通信错误，我们应该严格操作，收发数据时必须
						对端序进行转换。
							
							代码演示：服务器发送数据
							
							
							
							
							
						ssize_t send(int sockfd, const void *buf, size_t len, int flags);
							
					（c）flags的常见设置
							+ 0：表示用不上flags，此时send是阻塞发送数据的
							
							
							+ MSG_NOSIGNAL：send数据时，如果对方将“连接”关闭掉了，调用send的进程会被发送SIGPIPE信号，
								这个信号的默认处理方式是终止，所以收到这个信号的进程会被终止。
									
								如果给flags指定MSG_NOSIGNAL，表示当连接被关闭时不会产生该信号。
								
								从这里可看出，并不是只有写管道失败时才会产生SGIPIPE信号，网络通信时也会产生这个的信号。
							
							
							+ MSG_DONTWAIT：非阻塞发送
								
								
							+ MSG_OOB：表示发送的是带外数据
								有关带外数据后面再详细介绍。
								
								
							+ ...
								
							
							以上除了0以外，其它选项可以|操作，比如MSG_DONTWAIT | MSG_OOB。
							
							
							
							
							
							
							
							
				2）recv函数
				
					（a）函数原型
							 #include <sys/types.h>
							 #include <sys/socket.h>

							 ssize_t recv(int sockfd, void *buf, size_t len, int flags);
							
							· 功能：接收对方发送的数据
							
									我们也可以使用rcvfrom函数，当recvfrom函数的最后两个参数写NULL和0时，与recv的功能完全
								一样。
									ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags, NULL, 0);
									
									同样的，讲到udp时再详细介绍recvfrom。
									
									
							· 返回值：成功返回接收的字节数，失败返回-1，ernno被设置
									
									
							· 参数
								- sockfd：通信文件描述符
									
								- buf：应用缓存，用于存放接收的数据
								
								- len：buf的大小
								
								- flags：
									+ 0：默认设置，此时recv是阻塞接收的，0是常设置的值。
									
									+ MSG_DONTWAIT：非阻塞接收
									
									+ MSG_OOB：接收的是带外数据
									
									+ ...：其它选项不做介绍
									
									
									
									
					（b）代码演示

		（7）第6步：调用close或者shutdown关闭TCP的连接
					
					
				1）回顾断开连接时的四次握手
						
						图：
					
					
						TCP断开连接时，可以由客户和服务器任何一方发起。
					
					
						调用close或者sutdown函数断开连接时，四次握手的过程是由TCP自动完成的。
						
						
						
						
				1）使用close断开连接
				
					（a）服务器端调用close断开连接
					
							· close(accept返回的描述符);
							
								图：
								
								
							· 代码演示
								
								
								
								
								
								
					（b）客户端调用close断开连接
							· close(socket返回的描述符)
								
								图：
							
							· 代码演示
								写客户端代码时再介绍
								
								
								
					
					（c）close断开连接的缺点
					
							· 缺点1：会一次性将读写都关掉了
									如果我只想关写，但是读打开着，或者只想关读、但是写打开着，close做不到。
									
									
							· 缺点2：如果多个文件描述符指向了同一个连接时，如果只close关闭了其中某个文件描述符时，
								只要其它的fd还打开着，那么连接不会被断开，直到所有的描述符都被close后才断开连接。
								
								出现多个描述指向同一个连接的原因可能两个：
								- 通过dup方式复制出其它描述符								
									图：
									
								- 子进程继承了这个描述符，所以子进程的描述符也指向了连接
									
									图：
								
								
								
				2）shutdown函数
						有效的解决了close的缺点，所以以后断开连接时，建议使用更正规shutdown函数。
					
					（a） shutdown函数原型
								#include <sys/socket.h>

								int shutdown(int sockfd, int how);
							
							· 功能：可以按照要求关闭连接，而且不管有多少个描述符指向同一个连接，只要调用shutdown去
									操作了其中某个描述符，连接就会被立即断开。
								
							· 返回值：成功返回0，失败返回-1，ernno被设置
							
							· 参数
								- sokcfd：TCP服务器断开连接时，使用的是accept所返回的文件描述符
									
									客户端调用shutdown断开连接的情况，讲到客户端时再介绍。

									
								- how：如何断开连接
									+ SHUT_RD：只断开读连接
									+ SHUT_WR：只断开写连接
									+ SHUT_RDWR：读、写连接都断开
									
										
					（c）代码演示
							· 服务器shutdown
							
							
							· 客户端调用shutdown
								将客户端时在演示
							
							
							
							
			（8）回顾TCP通信服务器程序的编程流程
					图：
					
		4.6.1 实现TCP通信的客户端程序			
		
			（1）第1步：调用socket创建套接字文件，指定使用TCP协议
					
					
					int socket(int domain, int type, int protocol);
					
					参数如何设置？
					· domain：指定为PF_INET，表示使用的IPV4是TCP/IP协议族
					· type：指定为SOCK_STREAM，表示使用的是面向连接的可靠传输协议	
									在TCP/IP协议族中，只有TCP是面向连接的可靠传输协议，所以使用的是TCP协议。
									
					· protocol：0，不指定协议号。
					
					
						函数调用成功就“返回套接字文件描述符”，在客户端程序中，socket返回“套接字文件描述符”，直接
					用于通信。
						
						
						
			（2）第2步：调用connect主动向服务器发起三次握手，进行连接
					
						客户端调用connect主动发起连接请求，服务器调用accept被动接收请求，三次握手ok，连接
					就成功了。
						这三次握手是由TCP自动完成，我们只需要调用connect和accept这连个函数接口即可。
				
	
						
						连接成功后，服务器端的accept会返回专门与该客户通信的描述符，而客户端则直接使用socket返回
					套接字文件描述符来通信。
					
						图：
				
					
				（a）为什么客户端没有bind和listen
						
						· 为什么没有bind？
								
								我们之前说过，bind的目的是为了让套接字文件使用固定的ip和端口号来通信，但是只有TCP
							服务器有使用固定ip和端口的需求，但是于客户端来说，不需要固定的IP和端口，所以不需要调用
							bind函数来绑定，客户端只需使用自动分配的IP和端口即可。
								
								我们前面介绍过，客户端使用自动分配的端口号时，端口号的分配范围为49152~65535。
								
							疑问：如果客户程序非要bind绑定可以吗？
							答：当然可以，大家下去可以自己试试，尝试给客户端也绑定固定的ip和端口，不过对于客户端
								来说，没有什么意义。
						
						
						
						· 客户端程序为什么没有listen？
								对客户端程序来说，客户端永远都是主动向服务器发起连接请求的，没有被动监听别人连接的需求，
							因此根本就不需要所谓的被动文件描述符，因此根本就用不到listen函数。
									
							
					（b）connect函数	
							· 函数原型
								 #include <sys/types.h>         
								 #include <sys/socket.h>

								 int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
								
								- 功能：向服务器主动发起连接请求
								
								- 返回值：成功返回0，失败返回-1，ernno被设置
								
								- 参数
									+ sockfd：socket所返回的套接字文件描述符
													
									+ addrlen：参数2所指定的结构体变量的大小
									
									+ addr：用于设置你所要连接服务器的IP和端口。
									
											如果只是纯粹的局域网内部通信的话，ip就是局域网IP，但是如果是跨网
										通信的话，IP必须是服务器所在路由器的公网IP。

											为了方便操作，在应用层我们还是使用struct sockaddr_in来设置，然后传递给connect时，
										再强制换为struct sockaddr。

										struct sockaddr_in seraddr;
										
										addr.sin_family = AF_INET;    
										addr.sin_port		= htons(5006);//服务器程序的端口
										addr.sin_addr.s_addr = inet_addr("192.168.1.105");//服务器的ip地址
										
										cfd = connect(sockfd, (struct sockaddr *)&seraddr, sizeof(seraddr));										
		
										struct sockaddr_in {
											sa_family_t			sin_family;
											__be16					sin_port;
											struct in_addr	sin_addr;
											
						
										/* 填补相比struct sockaddr所缺的字节数，保障强制转换不要出错 */
											unsigned char		__pad[__SOCK_SIZE__ - sizeof(short int) - 
												sizeof(unsigned short int) - sizeof(struct in_addr)];
										};
										
	
						
						
					2）第3步：调用read（recv）和write（send）收发数据
					
							同样的，由于在建立TCP连接时，客户端的TCP协议会自动记录下服务器的ip和端口，调用这
						些函数收发数据时，我们不需要重新指定服务器的ip和端口，因为TCP有记录。
								
							代码演示：
							
							
							49152~65535：
							
							
							
					3）第4步：调用close或者shutdown关闭连接
						
							代码演示：
			
	4.7 总结下TCP通信
	
			TCP通信分为两步，
			
			第一步：建立连接，建立连接时，服务器和客户的TCP协议会自动记录下对方ip和端口
					当然，能够建立连接的前提是，服务器端绑定了固定的ip和端口，而且客户端知道这个固定的ip和端口，
				只有这样客户端才知道向谁请求连接，否则都不知道和谁连接，更不要谈连接成功了。
			
			第二步：使用通信描述符直接收发数据，此时会自动使用TCP记录的IP和端口
					
			
			为了弄清楚TCP通信的具体过程，我们分三种情况来看。
					
					
		4.7.1 本机通信
			图：
				


				
		4.7.2 局域网内跨机通信
			图：
			
			
			
			
			
			
		4.7.3 过路由器，跨网通信
			图：
			
			
			
			
	
	4.8 TCP服务器/客户模式
			对于TCP协议来说，只要你使用TCP协议，必然有一个服务器端，而其它的都是客户端，这一点是由TCP协议
		本身的特性所决定的，而不是“应用程序”来决定的，所以使用TCP协议通信时，是天然的服务器/客户模式。
			图：
			
			
			
		
		如果TCP客户之间想要通信，在TCP的服务器/客户模式下，只能通过服务器来中转。
		
		服务器为了同时与众多客户进行通信，可以有三种方式：
		（1）多线程
		
		（2）多进程
		
		（3）多路IO
			
			这三种方式的实现，后面在详细介绍。

5. UDP通信
		UDP是User Datagram Protocol的缩写，直译为用户数据报协议。
		
		
	5.1 UDP的特点 
	
		5.1.2 UDP是不可靠传输协议
				刚好与TCP相反，它是一种面向无连接的不可靠传输层协议，而且UDP每次发送的分组数据大小都是固定的。
				
				为什么UDP是不可靠传输？
				
			（1）不建立连接
			（2）没有应答机制
			（3）不会根据网络的好坏调整分组数据的大小
				
				其实有关UDP为什么是不可靠传输协议，我们在介绍TCP时就讲的很清楚了，之所以不是可靠传输协议，
			主要还是因为UDP没有连接和应答机制，导致UDP在发送数据时，根本不清楚通信线路的连通状态，所以UDP传
			输数据时，无法保证数据一定能发送给对方，因此UDP是不可靠传输协议，或者说是不可靠通信。

				
			
		5.1.2 每次传输数据时，必须指定对方的IP和端口
		
			（1）回顾TCP
						TCP建立连接时，服务器和客户端的TCP协议会自动记录下对方的IP和端口，后续调用recv、send来正
					式通信时，应用程序不再需要指定对方的Ip和端口，因为会自动使用TCP记录的IP和端口。
	
	
			（2）UDP
					对于UDP来说，UDP协议没有建立连接特性，所以UDP协议没有自动记录对方IP和端口的特点，因此每次发
				送数据时，应用程序必须亲自指定对方的IP和端口，只有这样才能将数据发送给对方。
					如果是跨网通信的话，指定的ip就是对方的公网ip。
				

			
	5.2 什么时候使用UDP呢
						
				对于数据量很大但是允许数据丢失的数据来说，可以使用UDP通信。
				比如像视频、音频等这类数据，尽管数据量很大，但是就算数据有所丢的话，对通信质量不会有太大影响，
			此时就可以使用UDP来传输。
			
				当然，我们在开发项目时，如果有现成的调用UDP的应用层协议，我们可以直接这些应用层协议，这些协议
			代码是可以到网上下载或者购买的，否者我们就自己亲自调用UDP来实现。
			
				比如我们在开发与视频监控相关的网络程序时（主要时客户端），往往会使用RSTP或者RTP应用层协议来传输
			监控视频数据，RSTP和RTP底层实际上使用的就是UDP协议。
			
		
	5.3 UDP的编程模型
			图：
			
			
			
			学习TCP通信时我们说过，TCP协议要求必须要有一个服务器，这一点是由TCP协议本身的特性所决定的。
			
			但是通过UDP的编程模型可以看出，UDP通信双方要做的事情一摸一样的，所以对于UDP通信的双方来说，不需要
		区分谁是服务器端、谁是客户端，通信双方的身份完全是对等的，所以UDP通信也被称为对等通信，或者叫
		“点对点”通信。
			
			同样的，UDP这种对等通信的特点，或者说点对点通信的特点，是由UDP协议本身的特性所决定的，与应用程序
		没有关系。

	5.4 UDP通信的例子程序
		
		写一个A程序，然后再写一个B程序，让这两个程序之间使用UDP通信。
			
		5.4.1 第1步：调用socket创建套接字文件
		
			（1）参数
					int socket(int domain, int type, int protocol);
					
					参数如何指定？
					1）domain：AF_INET，表示使用的是TCP/IP协议族
					2）type：SOCK_DGRAM，表示使用的是协议族中的无连接、不可靠、固定长度的数据报协议。
							在TCP/IP协议族里面只有UDP协议属于这种情况，所以使用的必然是UDP协议。
							
					3）protocol：0

			（2）代码演示
			
			
		5.4.2 第2步：bind绑定固定的ip和端口
				
				如果只是使用UDP发送数据，可以不绑定固定的ip和端口，如果要接收数据的话，必须绑定固定的ip和端口。
							
			疑问：为什么UDP接收数据时需要bind 固定的ip和端口？
			
				如果不绑定，每次使用的都是自动设置的ip和端口，自动设置的话，ip和端口就是不定的，如果每次都是
			变化的，发送数据端在指定IP和端口时就不知所应该写什么了。
				所以如果要接收数据，就必须绑定固定的IP和端口。
				
				代码演示：
				
				
				
		5.4.3 第3步：调用sendto和recvfrom函数，发送和接收数据
		
			（1）为什么没有listen和accept
						UDP没有连接的过程，listen和accept是TCP连接时才会用到函数，既然UDP没有连接，自然也就用不到了。
						
						
			（2）sendto
			
					1）函数原型
					  #include <sys/types.h>
						#include <sys/socket.h>

						ssize_t sendto(int sockfd, const void *buf, size_t len, int flags,
                      const struct sockaddr *dest_addr, socklen_t addrlen);

						· 功能：发送数据，当后两个参数为NULL和0时，功能等价于send，send专门用于TCP这种面向连接的通信，
								但对于像UDP这种非连接的通信，必须使用sendto，因为此时必须使用最后两个参数。
								
						· 返回值：成功返回发送的字节数，失败返回-1，errno被设置
						
						· 参数
							- sockfd：socket返回的套接字描述符，对于UDP来说，套接字描述符直接用于通信。
							
							- buf：存放数据的应用缓存
							
							- len：应用缓存的大小。
							
							- flags：一般写0，表示阻塞发送数据
									其它常用的选项与send的flags一样。
							
							- dest_addr：填写目标ip和端口
									前面就讲过，对于UDP来说，UDP没有连接的过程，所以没有自动记录对方的ip和端口，所以每
								次发送数据的时候，都需要指定对方的ip和端口。
	
							- addelen：dest_addr的大小

							
					2）代码演示
						
				
			（2）recvfrom
			
					1）函数原型								
							#include <sys/types.h>
							#include <sys/socket.h>

							ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags,
										struct sockaddr *src_addr, socklen_t *addrlen);
			
						· 功能：接收数据，最后两个参数与NULL和NULL时，功能与recv功能相同。
								UDP通信时，常使用的是recvfrom函数，因为需要用到后两个参数。
								
							
						· 返回值：成功返回接收到的字节数，失败返回-1，ernno被设置

						
						· 参数
							- sockfd：socket返回的套接字文件描述符
							
							- buf：应用缓存，用于存放接收到的数据
							
							- len：buf的大小
							
							- flags：一般写0，表示阻塞接收数据
									其它的常用设置同recv函数
							
							- src_addr：用于保存“数据发送方”的ip和端口，以便“接收方”回答对方
									如果是局域网通信，ip就是局域网ip，如果是广域网通信，ip就是对方的所在路由器的公网ip。		
								
									如果不需要回答对方数据的话，可以不用保存对方的ip和端口，这时recvfrom的最后两个参数
								写NULL，此时与recv函数的功能完全等价。
									
									
							- addrlen：src_addr的大小	
								
								
								
								
					2）代码演示		
		
					
				
			UDP因为没有“连接和应答”这种确认机制，所以UDP是不可靠通信，不过我们自己可以在应用层加入
		确认机制，以弥补UDP的补足。

			比如每次使用UDP通信发送数据给对方后，对方必须回答，如果对方没有回答或者回答数据有错，发送方就重发，
		以此保证UDP的通信的可靠性，这就是通过应用程序来弥补UDP的不可靠性。

	5.2 分析UDP的几种通信情况
	
		5.2.1 本机通信
		
		
		5.2.2 局域网内跨机通信
		
		
		5.2.3 过路由器，跨网通信
			
			UDP跨网通信的前提是，必须要知道对方的公网ip，暂时先假设发送者本来就知道。
	
			
			
			
	5.3 使用UDP通信搭建出服务器
	
			有同学可能会有疑问说，不对啊，不是说UDP是“对等通信”，没有服务器吗，怎么还可以使用UDP搭建服务器呢？
		
			我们说UDP没有服务器，这是站在UDP协议角度来说，但是并不是说我们自己写的“应用程序”，不能基
		于UDP来实现服务器，应用程序基于UDP实现服务器的时候，服务器的实现者是应用程序，而不是UDP协议。
			图：
		
			
			总之，使用UDP实现服务器时，服务器是由应用程序本身来构建的，而不是UDP协议，就算搭建出了服务器，
		但是使用UDP来实现“服务器”和“客户”的通信时，站在UDP协议的角度来说，任然还是对等通信。
		
		
			服务器如何同时与n多个客户通信？
			
		（1）多线程
		
		（2）多进程
		
		（3）多路IO
			
			
			
			
			
			
	5.3 如何实现两台普通计算机之间的跨网通信
			
			比如我的PC和我同事的PC之间想要进行跨网通信，方法有两种，
			
		· 第一种：通过服务器中转
		
		· 第二种：直接通信
	
		
		5.3.1 通过服务器中转
			（1）TCP
			
			
			（2）UDP
			
				我们举例子时，直接举跨网通信的例子。
				
				
				
		5.3.2 直接通信
		
			PC之间如果要直接通信的话，只能使用UDP通信。
			
			不过如果PC之间要进行UDP直通的话，也必须要有服务器程序的参与，否者pc1根本不能知道pc2的公网IP和端口。
				
				
			服务器的实现有两种，
			
			（1）UDP服务器方式
					图：



			（2）TCP服务器方式
					图：
	
	
					实际上QQ的实现使用的就是TCP/UDP相联合的方式
					
					TCP：用于管理所有的用户信息，以及转发文字聊天信息
					
					UDP：当客户双方进行视频通话时，由于视频通话的数据量太大，所以客户双方此时就使
							用UDP来点对点直接通信
		
6. 使用套接字来实现本机进程间的通信
		
		
	6.1 实现方式有两种
	
		（1）第1种：使用网络套接字
					比如使用TCP/IP协议族来实现，不管是使用TCP还是使用UDP都可以，只要将目标ip指定为本机IP或
				者127.0.0.1回环地址，即可实现本机进程间的通信。
					
					事实上使用实现网络通信的“网络套接字”来实现本机进程间通信，有点大材小用了，如果想要使用套接字来
				实现本机进程间通信的话，我们应该是使用“域套接字”，而不是“网络套接字”。
					
					实现本机进程间通信，“域套接字”的效率会高于“网络套接字”。
			
			
		（2）第2种：使用“域套接字”
				创建“套接字文件时”，如果指定的是“域通信协议族”的话，这个套接字文件就被称为“域套接字文件”，
			简称域套接字。
				
				域套接字不能实现跨进程间通信，只能用来实现“本机进程间通信”，而且还是专业的"本机间通信"。
				
				总结一下，到目前为止，本机进程间通信的方式有哪些？
				1）信号
				2）管道（无名、有名）
				3）system V IPC（消息队列、共享内存、无名信号量）
				4）域套接字
				
				
				
	6.2 域套接字的实现
				
		有两种，分别是
		· 字节流的“域套接字”
		· 数据报的“域套接字”
		
		
		6.2.1 字节流“域套接字”
		
			（1）编程模型
					编程模型与TCP的编程模型完全一样。
					
					虽然编程模型与TCP一样，但是还是有所不同的，其中最大的不同就是，
					
					绑定时设置的结构体是struct sockaddr_un，而不是 struct sockaddr_in
								struct sockaddr_un {
									sa_family_t sun_family;	/* AF_UNIX */
									char sun_path[UNIX_PATH_MAX];	/* pathname */
								};
						
						设置这个结构体时，
						sun_family = AF_UNIX 或者 AF_LOCAL
						sun_path = 一个文件路径名//注意不是IP和端口，域套接字实现本机进程间通信时，用不到ip和端口。
						
						bind绑定结构体的内容时，会创建“所设置路径名的”文件。
						
					疑问：这个文件起什么作用？
						简单理解就是，起到与ip和端口类似的作用。
					
					
			（2）代码演示：
						
						
						
						如果想要让服务器同时为多客户服务，有三种办法
						多线程
						多进程
						多路io
							
											
		6.2.2 数据报“域套接字”
		
			（1）编程模型同UDP
						
						bind时，设置的也是struct sockaddr_un，专门给“域通信协议族”使用的
						
						struct sockaddr_un {
							sa_family_t sun_family;	/* AF_UNIX */
							char sun_path[UNIX_PATH_MAX];	/* pathname */
						};
				
				
				
				
			（2）直接代码演示：
	
7. 广播
	
	7.1 什么是广播
			一个人发，然后其它所有人都接收，这就是广播。
			
			这就好比以前村里的大喇叭一样，村长说话全村人都听得见，这就是广播。
	
	
	7.2 广播的有限范围
	
			广播只能在局域网内部有效，广播数据是无法越过路由器的，也就是说路由器就是广播数据的边界。
		
			这里说的“局域网”其实是一个广义上的概念，我们这里说的“局域网”可以是我们常说的狭义上的局域网、
			或者城域网、广域网。
		
			
	7.3 广播的IP怎么写
	
			举例说明：
				我电脑的ip为192.168.1.105，所在的网段为192.168.1.0，把网段最后面的0全部变为1就是广播地址，
			所以我电脑所在局域网的广播ip就是192.168.1.255，如果对Ip地址不是很了解的话，
			请看《计算机体系结构体———网络篇》课程，对IP地址有详细介绍。
				
				使用192.168.1.255广播时，192.168.1.0网段里现有的所有计算机（除了发送者自己外），都将接收到
			广播的数据。
			
			
	7.4 广播在开发中用的多吗
	
			说实话，在我们实际开发中其实用的不多，只有在写一些框架代码的时候会用到。
			
			比如开发路由器时，路由器其实就会涉及到广播，而且必须用到广播，因为最起码它需要向范围内的所有计
		算机广播自己的wifi名称，只有这样我们才能在pc和手机上查看到wifi名称，如果连wifi名字都不知道，怎
		么连接呢。
		
		
			不过像这样的广播代码，基本都写在了框架代码中，尽管如此，对于学习网络编程来说，我们有义务了解广
		播，这对我们实际开发也是有一定帮助的。
		
			比如像开发路由器这种产品，虽然你在开发时不需要自己写广播的代码，但是既然开发路由器，就必须大致
		理解路由器的工作原理，其中就包括路由器的广播功能，如果你连广播都不理解的话，又怎么理解路由器的广
		播功能呢。
			
	
	7.5 局域网广播的实现
		
		7.5.1 编程模型 
			其实就是UDP的编程模型，广播使用的是UDP通信。

			不过与我们前面所讲UDP通信的唯一不同是，广播时指定的IP是广播IP。
			
			
		7.5.2 代码演示
				写一个广播发送程序，写一个接收程序，
				
				发送广播的计算机运行“广播发送程序”，其它所有的计算机运行“接收程序”，广播数据时，其它所有的计算
			机都将接收到广播数据。	
				图：
				
				
				具体的代码就不写了，一个是因为我的局域网就一台计算机，没办法演示，另一个是因为广播这个东西在实
			际开发中用到的很少，因此只要理解什么是广播即可，至于代码不需要掌握。
	
	
	
	
	7.6 组播
		除了广播外还有一个组播，组播和广播很像。
		
		什么是组播?
		广播是给其他所有计算机广播数据，而组播只对其它所有计算机中的某部分计算机广播数据。
			图：
			
			
			
		进行组播时所使用的的IP是组播IP。
			
		了解组播是怎么回事即可，不需要深入掌握。
			
			
			
			
			
			
			
8. 带外数据

9. 服务器如何实现同时为多客户服务

		我们这里只使用TCP通信来举例，有关基于UDP的为多客户服务的服务器，请大家下去后自己实现。

		
	9.1 多线程
		9.1.1 实现原理
			
			
			
		9.1.2 代码演示
		
			实现一个同时为多客户服务的服务器程序，服务器收到客户发送的数据后，就向客户回答“收到了”。

			
			
			多线程实现多客户的方式，其实是现在服务器框架实现多客户时的主流实现方式。
			

	9.2 多进程
	
		9.2.1 实现原理
		
		
		9.2.2 代码演示
		
			实现一个同时为多客户服务的服务器程序，服务器收到客户发送的数据后，就向客户回答“收到了”。
			
			
			多进程的方式现在很少了，基本都是多线程方式。
		
		
		
		
		
	9.3 多路io
	
		这里介绍原理，不进行代演示了。
		
		多路io有两种，分别是select和poll机制，他们的原理都是类似的。
		
		
		这种方式理论上也行，但是实际上真正的服务器并不采用这种方式来实现。
		
		
		
	9.4 了解服务器是如何同时为多客户服务的意义
			
			其实站在开发的角度来说意义不大，我们这里介绍这个主要目的，是想告诉大家服务器实现多客户的原理。
		
		我们的课程主要是面向嵌入式开发，不涉及服务器的开发，而且就算你是做服务器开发的，事实上服务器实现
		多客户的代码已经被服务器框架早就做好了（现成的），开发人员并不需要关心。
				
				
			1）B/S模式下的服务器（浏览器访问的web服务器）
			
					web服务器每连接一个客户，服务器就开辟一个线程与客户通信，以实现为多客户服务，
				但是这个实现多客户的代码是由web服务器框架提供的，网站开发者不需要关心。
				
				
				那开发网站做什么？
					
					要做的就是实现html页面(界面)，将html页面写好后，将其保存到web服务器的硬盘上，当有客户与服
				务器建立连接，访问web时，web会为该客户开辟一个服务的线程，该线程就会将你要访问的html页面发送
				给你的浏览器，然后显示出来。
					
					
			2）C/S模式下的服务器（APP访问的服务器）
			
					一样的，多客户的代码也是由服务器框架现成提供的，更多的我们这里就不再介绍了。
					
					我们在前面的课程就介绍过，现在的服务器往往都是B/S、C/S混合模式，至于这个混合模式是怎么实现，
				介绍起来稍微有点麻烦，我们目前课程也不针对这个方向，所以我们这里不在介绍，而且我们本身也不是
				做服务器开发的，也不是这方面的专家，所以也很难讲到位。
					
							


		
		
10. 其它的函数

	其实Linux所提供的网络编程API还有好些其它的，比如：
	
		getnameinfo(...)
		getaddrinfo(...)
		gethostname(...)
		gethosetaddr(...)
		setsockopt(...)
		...
		
	其实c++、java等库API，同样有以上这些类似功能的函数，只不过是以类的形式进行了封装。
	
	
	有关以上这些函数我们不再介绍，至于不再介绍的原因如下:
	
	（1）课程时间太久了
			我们的网络课程到目前为止，已经耗去相当长的时间，如果是再继续将这些函数，整个课程时间会拉的很长。
			
	
	（2）不属于本课程的核心内容
				
				本课程的核心目的是想让大家深入的理解什么是网络编程，如何编程实现TCP/UDP通信，如果大家把这个核
			心理解了，事实上网络编程就算学会了，至于以上的这些函数，其实只能算是“旁枝末节”的知识。

				课程永远都是有一个核心的，核心就是把核心知识讲清楚，而且对大家学习来说，拦路虎永远都是核心
			知识，如果你将核心知识搞定了，其它细枝末节的只是，就应该是由大家自学完成的，因为大家要清楚，别
			人的讲授只是引导，最终更广更深的学习，一定还是要回归到自学上。
				
				我们希望的是授之以渔，而不是授之以鱼，如果是授之以鱼的话，我们课程会有讲不完的知识点。
			
			
	（3）这些函数并不难（当然，并不是一点难度也没有）
	
				以上这些函数只是工具函数而已，这些工具函数的目的，只不过是想方便我们实现更加复杂的网络程序而已，
			
			这些函数最终都是基于我们之前所讲的核心功能来工作的，因此只要大家把之前的核心功能理解了，完全有能
			力自己弄明白。
			
				当然有关这些函数，我并不建议大家现在就去想办法弄明白，等到大家以后真的用到之后，再根据需求
			去学习，以需求来驱动学习，这样的学习效果会更好。
