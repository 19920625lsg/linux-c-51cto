
=========================================================================================================
=======================物联网、嵌入式技术课程5 之 《Linux系统编程、网络编程》============================
=========================================================================================================
					

					
出品：佳嵌工作室
---------------------------------------------------------------------------------------------------------
	“佳嵌工作室”致力于物联网、嵌入式产品以及‘物联网、嵌入式技术课程’的研发，希望所推出的技术课程，能够帮
助到正在努力学习物联网、嵌入式的同学，欢迎大家和我们一起共同学习，共同进步。
---------------------------------------------------------------------------------------------------------	

第11章 网络编程（网络IPC）

1. 本机进程间通信 与 网络通信

	1.1 本机进程间通信
			实现本机内部的进程间的通信，通信时需要使用专门IPC机制，比如信号、管道（无名、有名）、system V IPC
		（消息队列、共享内存、进程信号量），有关这些IPC的API在第8章“进程间通信”中，已经讲的非常清楚，这里不
		再赘述。
		
	1.2 网络通信
			网络通信也被称为网络IPC，直译就是网络进程间通信，简称网络通信，说白了就是跨机进程间的通信。
			图：
			
			
			在网络通信没有出现之前，那个时候只有“本机进程间通信”，直到后来人们发现两台不同计算机的进程间也
		有通信的需求，此时才发明了网络通信，以实现“跨机进程间通信”。
			
			所以可以简单的认为，网络通信其实就是“本机进程间通信”向“跨机进程间通信”扩展后的产物，只是这个扩展并
		不是那么容易的，为了实现跨机通信最起码：
			（1）通信协议的实现
			（2）各种通信设备的支持（网卡、路由器、光纤、电缆、基站等等）
				
				不过对于本章来说，我们重点关心的不是通信协议和中间的通信设备，这些东西都是别人早已实现好，
			（1）通信设备
					1）网卡：你的计算机肯定有
					2）路由器：没有路由器怎么上网，个人的路由器一般都自己买的
					3）光纤、电缆、基站等：由电信、移动、联通等网络运行商提供，我们无需操心
						
			（2）通信协议
						协议很早以前就已经被定义好了，至于协议栈的代码实现，Linux等系统也早已实现好，只要使相应的
					网络API调用即可。
						多数情况下协议栈代码属于OS的一部分，但是如果裸机需要网络通信时，裸机没有运行OS，此时只能运行
					独立的协议栈代码。
			
				对于本章来说，重点是学习系统提供的网络编程API，从而实现网络通信。				
				图：
				
		
2. 网络编程API 与 系统API	
		本章虽然叫网络编程API，不过由于网络的协议栈代码属于Linux OS的一部分，所以网络编程的API其实也是Linux
	所提供的系统API之一，只不过是专门被用于网络通信，所以我们单独的称为网络编程接口（API），但是你自己要知道，
	与前面章节介绍各种的API在本质上并没有什么差别，其实都是系统提供的系统API。
		
		搞清楚这一点后，大家不要过分的神话本章，本章的学习与前面章节的API学习相比，本质上并没有什么特殊
	的地方。
		

3. 本章的会严格掐好知识点的深度，避免形成极端

		本章的API虽然也是系统API，与其他系统API并无本质区别，但是毕竟是用于网络通信的，因此也不是一点基础
	知识都不要的。
	
		如果想要学习也好本章的话，大家必须具备一定的网络基础知识，如果没有的，大家在听本章的课程时，可能会
	有一定的障碍，因为我们所讲的内容不可能不涉及到这些网络知识。
		
		为了打好网络基础知识，所以大家学习本章之前，请一定先学习《计算机体系结构体――网络篇》的课程，打好
	网络基础知识之后，再来学习本章的内容，你会觉得本章的学习很容易。
		
		不过为了更好的讲解本章，在本章的开头，我们也会对《网络篇》里面的一些重要知识进行回顾。
	
		当然本章的名字叫“网络编程”，所以重点是讲如何使用这些API来编写网络通信的程序，而不是将网络原理，
	因此我们的课程会严格把握知识的深度，防止出现两种极端情况：
		
	（1）极端1：讲的过于简单
			基本只讲API的大概怎么用，参数怎么写，但是不会与网络相关的知识进行结合学习，按照这种方式来讲的话，
		大家可能好像觉得听懂了，但是仔细一想其实并没有理解，比如：
			1）跨网通信时，TCP和UDP各自是怎么实现，TCP有连接和UDP无连接有什么区别
			2）TCP会建立连接，到底什么是连接，为什么建立连接就能够实现可靠通信
			
			我们所写的例子程序虽然是局域网测试的，准确讲是本机测试的，但是我们会介绍TCP/UDP“跨网通信”的情况。
		
		
	（2）极端2：讲的太复杂
			比如深入分析数据封包格式，分析网络协议栈的源码等等，有关这些深入的内容我们本章不会涉及，因为如果
		讲这些内容的话，本章讲的就不是网络编程，而是网络原理。
			
			
			我们后面计划会出网络原理的课程，到时我们会讲封包格式以及协议的源码，同时通过抓取网络数据包来验
		证分析，不过前提是大家一定先打好网络的基础知识，只有当有了这些网络基础知识之后，到时候再去学习
		深入的网络原理时，所有的理解才会水到渠成的。
				
			所以本章的课程一定会介绍的比较深入，但是同时又不会深到让大家难以理解。

		
		
4.学习本章的意义
		学习本章非常有意义，
		
	（1）后面的课程会用到今天的内容
	
	（2）便于理解其它系统的网络API以及库提供的网络API
	
	（3）如果你未来想深入理解网络的话，如果没有本章这些知识作为基础，很难深入理解
		
	
	4.1 后面的课程会用到今天的内容
		后面进行Linunx嵌入式开发时，如果C程序需要涉及到网络通信时，会调用到今天所学的API
		
		既然会用到，重要性自然就不用多说了
	
	
	4.2 便于理解其它系统的网络API以及库提供的网络API
		
		（1）网络编程的接口有两种
				第一种：系统API
				
				第二种：库API，通过封装系统API实现
						当然库在封装系统提供的网络API时，往往可能还会进一步简化，就是把我们本章讲的很多步骤的函数，
					封装为一个函数，调用库接口往往更简洁，不过总体上你会发现其实实现方式都是一样的。
					
					
				1）C程序实现网络通信
				
					（a）直接调用系统提供网络API
							比如直接调用Linux或者windows的系统API。
							
					（b）直接调用C库的网络API
							不过这里说的C库并不是标准C库（因为标准C库并不提供网络编程的接口），而是一些特定c库，这些
						c库会提供网络编程接口。
							
						Linux嵌入式c程序想要通信的话，既可以调用C库提供的网络API，也可以直接Linux系统的网络API，
					不过在嵌入式开发里面，为了节省计算机的资源，往往会尽量避免运行额外的库，所以此时会直接调用
					Linux的网络API来实现。
						
						
				2）C++、java等程序实现网络通信
						基本都是直接调用它们的库接口来实现的，特别是java程序，java程序里面不能直接写C接口，所以必须
					使用java自己网络编程库接口。
					
						不过C++还好，因为c++兼容c，所以c++程序有三种选择
				（a）使用c++自己“类库”提供的网络API
				（b）使用某c库提供的网络API
				（c）直接使用Linux OS提供的网络API
						
						c++程序一般使用的都是“类库”的网络API。
			
			
		（2）为什么说学习本章，有助于理解其它形式的网络API
			
					不管是window、Linux等系统提供网络API，还是各种库通过封装OS的网络API从而提供的库API，
				其实用法几乎一样，因此学会本章Linux的网络API，非常有助于大家接触和学习其它形式的网络API。
				
					实际上你去学习windows的网络API时你会发现，它与Linux网络API几乎是差不多的，函数名称、功能、
				参数几乎没有什么区别。
					
					
					
	4.3 有利于深入学习和理解网络原理
		
				如果只是站在应用编程的角度的话，网络篇和本章的内容就够用了，但是如果你职业规划是想往网络方向
			深入发展的话，仅这些内容是不够的，但是想要深入理解网络原理，又不能一蹴而就，需要一定基础。
			
			而网络篇和本章网络编程其实就是深入学习网络原理的基础。
			
			
			
			

5. 本章知识结构
	1. 回顾《计算机体系结构体――网络篇》的部分内容
	2. 网络通信协议 与 网络编程接口
	3. 如何使用TCP/IP实现网络通信
	4. TCP通信
	5. UDP通信	
	6. 域套接字
	7. 广播
	8. 带外数据
	9. 服务器如何实现多客户




					
出品：佳嵌工作室
---------------------------------------------------------------------------------------------------------
	“佳嵌工作室”致力于物联网、嵌入式产品以及‘物联网、嵌入式技术课程’的研发，希望所推出的技术课程，能够帮
助到正在努力学习物联网、嵌入式的同学，欢迎大家和我们一起共同学习，共同进步。
---------------------------------------------------------------------------------------------------------	


1. 回顾《计算机体系结构体――网络篇》的部分知识


	1.1 TCP/IP协议栈的四层结构
			图：
			
			
			
			
	1.2 TCP/IP协议族的详细情况
			在前面的课程我们说过，TCP/IP协议是由不同子协议，按照以上四层结构组合在一起的协议家族。
		图：
		
		
		
		应用层想使用TCP/IP通信有三条路线：
		
		（1）tcp路线：应用层――>TCP――> ip ――>硬件接口
		
		（2）udp路线：应用层――>UDP――> ip ――>硬件接口
		
		（3）ip路线：应用层――> ip ――>硬件接口
					越过了TCP和UDP。
		
		
		
		
	1.3 数据传输的时的封包和拆包
		图：
	
	
			
		ip层封装的源IP和目标IP是怎么来的。
		
		（1）源ip：自动检测本机ip得到的
		（2）目标ip：由应用层（应用程序）或者传输层交给ip层的。
				
				为什么是应用层或者传输层交给IP层的？
				答：因为只有应用层或则传输层才知道你要将数据发送给谁（目标）。
			
	
	
	
	
	
出品：佳嵌工作室
---------------------------------------------------------------------------------------------------------
	“佳嵌工作室”致力于物联网、嵌入式产品以及‘物联网、嵌入式技术课程’的研发，希望所推出的技术课程，能够帮
助到正在努力学习物联网、嵌入式的同学，欢迎大家和我们一起共同学习，共同进步。
---------------------------------------------------------------------------------------------------------		
	
	1.4 回顾数据传输的几种情况
		
		1.4.1 目标ip == 源IP（本机通信）
			数据只在本机内通信，数据到ip层就回去了，不过网卡，也不经过链路层。
			
			图：
				
				
				
		1.4.2 目标ip != 源IP，但是目标IP网段 == 源IP网段（局域网通信）
				此时仅仅在局域网内通信，数据不会经过路由器到外网。
		
		
		（1）封包的过程
				
				
				
		
		（2）如何找到对方的
					图：
					
					
					
		

	
		1.4.3 目标ip网段 != 源ip网段（跨网通信）
				此时数据一定会过路由器，通信双方属于跨网通信

				
		（1）封包的过程	

					图：

					
					
					跨网通信时，目标IP一定要封装对方所在路由器的公网IP。
					ip同样的是由应用层或者传输层嫁给IP层封装的。
					
	
		
		（2）如何找到对方的
					跨网通信时，必须通过NAT转换才能找到对方。
					
				
				 图：
				
				
				
					服务器NAT转换所需的信息，必须由管理人员自动配置，但是客户端NAT转换记录的信息，是在向外主动发
				送信息时自动记录的。

					对方收到数据包后，会得到发送发方所在路由器的公网ip，然后即可原路返回数据。
					图：

					
					
					
									
				疑问：网上不是说发送数据和回答数据时，所走的路由器可能是不一样吗，但是如果原路返回的话路由器
					不就一样了吗？
				
					其实我们的这个图只是一个示意图，画的非常简略，路由器都是以集群形式存在的，某集群中的路由器
				都会记录相同信息，所以返回时不管走的是哪些路由器，返回时NAT所用的信息是一样的，因为所用的信息
				是一样的，所以相当于还是原路返回的。
			
					对于以上NAT转换的过程，不论是TCP通信还是UDP通信都是一样的，TCP和UDP的不同并不体现在底层的实际
				传输上，而是TCP和UDP协议本身的实现上。
				
	
	
	
	
	
	
	
	
	
	
	
出品：佳嵌工作室
---------------------------------------------------------------------------------------------------------
	“佳嵌工作室”致力于物联网、嵌入式产品以及‘物联网、嵌入式技术课程’的研发，希望所推出的技术课程，能够帮
助到正在努力学习物联网、嵌入式的同学，欢迎大家和我们一起共同学习，共同进步。
---------------------------------------------------------------------------------------------------------		
	
2. 网络通信协议 与 网络编程接口（API）
	
	2.1 是不是只有TCP/IP这一种网络通信协议
	
			不是的，其实有很多种，后面会介绍有大概哪些网络通信协议，只不过现在的互联网使用的主流协议是
		TCP/IP协议。
			
			所以正是由于存在着很多种的网络通信协议，因此各个OS（比如Linux）会同时支持多种网络通信协议，而不是
		只支持TCP/IP这一个。
		
	
	2.2 网络API 与 网络协议之间的关系
	
			以Linux为例，Linux所提供的网络API支持多种通信协议，只要给API指定不同的参数，就可以使用你想要使用的
		那个协议。
		
			我们本章讲的是TCP/IP，显然是希望使用TCP/IP来通信，所以调用网络API时需要通过参数来指定，我们使用的是
		TCP/IP协议。
		
		
	
3. 如何使用TCP/IP实现网络通信
			有三种方式：
	
		（1）tcp路线：应用层――>TCP――> ip ――>硬件接口
					封装传输层包头时，封装的是TCP协议的包头。
		
		（2）udp路线：应用层――>UDP――> ip ――>硬件接口
					封装传输层包头时，封装的是UDP协议的包头。
		
		（3）ip路线：应用层――> ip ――>硬件接口
					越过了TCP和UDP。
		
		本章只讲前两种，第三种我们不介绍，因为除非有什么特殊用途，否者第三种情况基本碰不到。

		
		
			
4. 使用TCP协议通信	
		
		TCP的全称叫Transmission Control Protocol，即传输控制协议，简称TCP。
		
		
	4.1 TCP协议的特点
			TCP协议是有序的、面向连接的、可靠的字节流传输层协议。
		
		
		4.1.1 什么是字节流 
				字节流的意思就是说，将数据分组发送时，分组数据的大小可以以字节为单位进行调整。
				
			（1）为什么要调整分组数据的字节数
			
					当网络状况不好，如果你还拼命的发送字节数很大的分组数据时，出错的可能性很高。
					这就好比道路状况本来就差，结果还大量的涌入车辆，出事的概率自然就很高，所以当道路状况很差时
				就应该减少汽车流量，当路况好转时在逐步的增加汽车流量。
					
					所以进行TCP通信时，如果TCP检测到网络不佳时，就会减少分组数据的字节数（把分组数据变小），
				网络状况好转时再逐步增加字节数，总之会根据网络的好坏来调整字节数，这个调整的机制被称为
				“滑动窗口机制”。
				
					之所以起名叫“滑动窗口机制”，是因为和“滑动窗口”调整通风状况的原理很相似，“滑动窗口机制”工作
				原理如下：	
				
				（1）当网络不好导致数据丢失时，数据每丢失一次，分组字节数减为以前的二分之一
						比如原本1000字节，现在变为500字节。
						
				（2）当网络状态恢复时
						1）如果目前分组大小 < 最初大小的二分之一时，每成功发送一个字节，字节数增加1倍
						
						2）如果目前分组大小 >= 最初大小的二分之一时，每成功发送一次，分组字节数只增加1字节，增加减缓了。
						
						
						
			（2）对比UDP
					DUP跟TCP不一样的，UDP的分组数据包是固定长度的数据报，并不会根据网络的好坏来进行调整。
					
			
					
		4.1.2 TCP协议为什么是可靠传输协议
		
			通过三点来保证：
				第一：三次握手建立连接
				
				第二：有应答机制，也就是将数据发送给对方后，对方必须应答是否发送成功
				
				第三：使用“滑动窗口”机制，根据网络的好坏，控制发送的分组数据的大小
			
			
			（1）三次握手建立连接
			
					1）三次握手
						图：
					
								这张图不仅画出了三次握手（三次通信），还出画出了双发收发数据时的应答机制，断开连接
							时四次握手。
								
								
						（a）三次握手
								只要三次握手成功，客户和服务器就建立了连接，否者连接没有建立成功，双方不能通信。
							
								・ 三次握手，一定是由客户方先发起的。
									为什么是一定是客户先发起的呢？
									
										因为只有服务器的IP和端口是固定不变、以及公开的，而客户端（pc）的ip和端口就不一定了，
									如果让服务器向客户主动发起握手请求，服务器根本就不知道客户的IP和端口多少，怎么主动
									连接呢。
										
										所以只能是客户主动向服务器发起握手请求，当服务器收到客户数据后，在数据包里面提取出
									客户的IP和端口后，服务器能够向客户回发数据。
										
										所以从这里我们可以看出，我们实现服务器程序时，必须想办法固定服务器的IP和端口，至于
									如何固定，我们后面在再介绍，其实很简单，只要调用bind函数即可实现。

									
									
								・ 为什么是三次握手，不是建立两次，不是四次、五次？
										这个是由TCP实现原理来决定的，这里不解释这个问题，大家只需知道三次握手成功后，客户和
									服务器即可成功建立连接，建立连接后即可正式通信。
										
										三次我握手的通信并不是正式通信，只是握手通信。
									
								
									疑问：怎么理解TCP的“连接”？
										后面回答这个问题。
								
				
								・ 如何实现TCP的三次握手
										调用相应的API来实现，后面再介绍。

										
						（b）应答机制
									就是将数据发送给对方后，不管对方是服务器还是客户，对方必须回答我是否收到数据，收到的数
								据是否正确，这就是应答机制。
			
						
							
						（c）四次握手断开连接
									
									发起者可以是服务器和客户任何一方，不像三次握手，一定要客户方先发起，为什么服务器也
								可以发起呢？
									
									因为断开连接时，连接已经建立了，在建立连接时服务器已经记录下客户的IP和端口，所以服务
								器可以主动向客户发起断开连接的请求。
								
									四次握手结束后，连接就断开了，断开的意思就是客户和服务器之间不能再进行通信。
									
									疑问：具体怎么断开连接呢？
									调用相应的API来实现，调用API后，四次握手由TCP自动完成。
									
									
							
							
出品：佳嵌工作室
---------------------------------------------------------------------------------------------------------
	“佳嵌工作室”致力于物联网、嵌入式产品以及‘物联网、嵌入式技术课程’的研发，希望所推出的技术课程，能够帮
助到正在努力学习物联网、嵌入式的同学，欢迎大家和我们一起共同学习，共同进步。
---------------------------------------------------------------------------------------------------------		
										
									
					2）三次握手建立连接的目的	
						
						第一：提高通信的可靠性
						第二：记录对方的ip和端口，正式通信时会自动的使用记录的ip和端口
						
						（a）提高通信的可靠性
						
							 ・ 疑问：为什么建立连接就可以提高通信的可靠性呢？
									
									要回答这个问题，就必须先明白到底什么是建立连接，其实从三次握手可以看出，所谓的建立连
								接其实就是相互成功问答三次，相互问答三次说白了就是相互打个招呼，“哎我要和你通信了”，
								对方说“好，没问题”，只要双方问答成功，就说明双方的通信线路是好的，此时再正式通信，双方
								就能进行可靠的数据传输，如果问答不成功就说明通信线路有问题，不能进行通信。

									这就好比我想往某个地方运输货物，但是我又怕走到半道发现道路有问题，导致半途而废，此时
								我就可以先去探探路，如果能够到达目的地，就说明道路是通的，然后我正式运输货物，如此一来
								就能保证运输是可靠的。

									所以不要把“三次握手建立连接”想得太复杂，这个“连接”说白了就是事先通信探探路，把路探通
								后在进行正式的数据传输，如此就能在相当程度上保证传输的可靠性。
									
							 ・ UDP
									udp不是这样的，udp在发送数据时，并不会通过连接先确认线路是不是通的，然后再发数据，
								对于UDP协议来说，数据发送方并不知道线路是不是通的。
								
									正是由于UDP不存在这种通过连接确认线路的机制，所以UDP属于不可靠通信。
									
					
						（b）记录对方的IP和端口
								客户与服务器建立连接后，各自的TCP都会记录好对方IP和端口，后面正式通信时就会自动使用记
							录的IP和端口。

							
			
			（2）有应答机制
					
					1）为什么应答机制能够TCP的可靠性
					
							因为如果发送给对方的分组数据有丢失、有错误，对方就会回答数据有错误，那么发送方会重发，
						以保证一定将正确的数据发送对方。
						
					
					2）UDP
							UDP没有应答机制，发送方完全不关心对方对于数据的接受状态，所以
							
							TCP：可靠通信，因为TCP完全清楚现在通信状态，可以保证一定可以把户数发送给对方，发送的
									数据一定是正确的。
									
							UDP：不可靠通信，因为UDP完全不清楚目前的通信状态，有点像种庄稼“凭天收”的感觉。
							
						
						
			（2）滑动窗口机制				
					可以根据网络状态调整分组数据大小，减少网络状况不好所带来的错误。
						
					UDP就没有这种机制，不管网络是好是外，每次发送的都是固定字节数的分组数据。
					

	
	4.3 什么时候使用TCP协议
	
			需要进行可靠传输时就使用TCP，比如好多现成的应用层协议就要求可靠传输，是以他们使用的就是TCP协议，
			
			（1）HTTP：专门用于访问WEB的“超文本传输”的应用层协议
			（2）SMTP：邮件传输的应用层协议
			（3）Telnet：远程登录协议
			（4）SNMP：简单网络管理协议
			（5）FTP：文件传输协议
			（6）TFTP：简单文件传输协议
			（7）NFS：网络文件系统协议
			
				如果你不想使用现成的应用层协议，或者压根就没有你要的应用层协议的话，我们就可以自己直接调用TCP
			来通信，本章讲TCP通信时，讲的就是应用程序如何直接调用TCP来通信。
			
				
				当然这些“应用层协议”不一定非要使用TCP/IP这种网络协议，只不过由于TCP/IP是主流网络通信协议，所以
			这些应用层协议下层对接的基本都是TCP/IP协议。

		
		


							
							
出品：佳嵌工作室
---------------------------------------------------------------------------------------------------------
	“佳嵌工作室”致力于物联网、嵌入式产品以及‘物联网、嵌入式技术课程’的研发，希望所推出的技术课程，能够帮
助到正在努力学习物联网、嵌入式的同学，欢迎大家和我们一起共同学习，共同进步。
---------------------------------------------------------------------------------------------------------		
										
										
	4.4 使用TCP通信时，TCP协议要求必须要有一个服务器端
			
			这一点是由TCP协议本身的特性决定的，只要你使用TCP协议来通信，就必须要有一个TCP服务器端。
	
			
			
		4.4.1 TCP服务器的大概工作过程
		
			（1）服务器会使用专门“文件描述符”来监听客户的“三次握手”，然后建立连接。
			
			（2）一旦连接建立成功后，服务器会分配一个专门的“通信文件描述符”，用于实现与该连接客户的通信
					
				
				由于建立连接时，双方的TCP协议都已经记住了对方IP和端口，所以双方正式通信时，TCP会自动使用记录
			的IP和端口，我们不需要重新指定对方的IP和端口。
			
			
			
		4.4.2 TCP编程模型				
				在编程模型里面，必须要有一方是TCP服务器，另一方是TCP客户。
				
				服务器只有一个，但是客户端有很多，不管客户端有多少个，客户端与服务器端的通信，都按照编程模型
			的描述来实现的。

				图：
				
				
				
	
	
		4.4.3 服务器是如何同时应对多客户的通信呢？
			
			
			（1）多线程 和 多进程
					图：
					
			
			
			（2）多路io
			
					图：



					
出品：佳嵌工作室
---------------------------------------------------------------------------------------------------------
	“佳嵌工作室”致力于物联网、嵌入式产品以及‘物联网、嵌入式技术课程’的研发，希望所推出的技术课程，能够帮
助到正在努力学习物联网、嵌入式的同学，欢迎大家和我们一起共同学习，共同进步。
---------------------------------------------------------------------------------------------------------		
					
	4.6 TCP通信代码举例

		・ 写一个TCP服务器程序
		
		・ 写一个客户端程序
			
			不过为了不要让例子太复杂，服务器程序目前只为一个客户服务，至于使用多进程、多线程以及多路io为多客
		户服务的情况，后面再介绍。
			
			
		4.6.1 实现TCP服务器程序
		
		（1）第1步：调用socket 网络API，创建套接字文件
				
				1）socket函数
					 #include <sys/types.h>
					 #include <sys/socket.h>

					 int socket(int domain, int type, int protocol);
				
				
				（a）功能：创建一个套接字文件，然后以文件形式来操作通信，不过套接字文件没有文件名。
							Linux有7种文件，套接字文件就是其中一种。
							
							socket翻译为中文就是“套接字”的意思，其实翻译为插座更合适些，因为socket本来就有插座的意思，
						使用socket创建一个通信的套接字文件，就好比插上了一个通信的插座，有了这个插座就可以和对方
						通信了。
							
							
				（b）返回值
				
						・ 成功：返回套接字文件描述符。
							
						・ 失败：返回-1，errno被设置
						
						
						
				（b）参数
						・ domian
														 族/范围
							int socket(int domain, int type, int protocol);
							
							- 作用：指定协议族
								
								为什么要指定协议族？
								
									因为你要使用的通信协议一定是属于某个协议族，所以如果不指定协议族，又怎么指定
								协议族中的某个具体协议呢。
										
									比如我们想用的是TCP协议，TCP属于TCP/IP协议族中的子协议，所以必须先通过domain指定
								TCP/IP协议族，不过TCP/IP协议族有两个版本，分别是IPV4是IPV6版本，我们目前使用的还是
								IPV4版本，因为Ipv6还未普及。
									
									IPV4是Internet Protocol Version4的缩写，直译为“网络协议第四版”，IPV4和IPV6这两个版
								本所使用的ip地址格式完全不同，
									IPV4：ip为32位
									IPV6：ip为128位
									
									不仅IPV4和IPV6的ip地址格式不同，其实所有不同网络协议族所使用ip地址格式都不相同。

									
							int socket(int domain, int type, int protocol);
							
							- domain可设置的常见宏值
							
									可设置的有：AF_UNIX, AF_LOCAL、AF_INET、AF_INET6、AF_IPX、AF_NETLINK、AF_APPLETALK
								AF_PACKET、AF_UNSPEC，有关每个宏的作用后面再解释，这里先介绍下这些“宏名”。
								
								
									AF是address family，表示地址家族的意思，由于每个网络协议族的ip地址格式完全不同，
								因此在指定ip地址格式时需要做区分，所以这些AF_***宏就是用于说明所使用的是什么协议的
								IP地址，
									
									
									这些个宏定义在了socket.h中，
									#define AF_UNSPEC	0
									#define AF_UNIX		1	/* Unix domain sockets 		*/
									#define AF_LOCAL	1	/* POSIX name for AF_UNIX	*/
									#define AF_INET		2	/* Internet IP Protocol 	*/
									#define AF_AX25		3	/* Amateur Radio AX.25 		*/
									...
								
								
									有同学可能会说不对呀，domain是用来指定协议族的吗，但是AF_***确是用来区分不同协议ip
								格式的，给domain指定AF_***合适吗？
									
									
									其实区分不同协议族应该使用PF_UNIX, PF_LOCAL、PF_INET、PF_INET6、PF_IPX、PF_NETLINK、
								PF_APPLETALK、PF_PACKET、PF_UNSPEC，PF就是protocol family的意思，意思是“协议家族”。
								
									PF_***与AF_***不同的只是前缀，不过AF_***与PF_***的值完全一样，比如AF_UNIX == PF_UNIX，
								所以给domain指定AF_***，与指定PF_***完全是一样的。
					
					
					
								疑问： 为什么AF_*** == PF_***?
								
									AF_***用于区分不同协议族的ip地址格式，而PF_***则用于区分不同的协议族，但是每个协议族的
								IP格式就一种，所以协议族与自己的IP格式其实是一对一的，因此如果你知道使用的是什么ip地址
								格式，其实你也就知道了使用的是什么协议族，所以使用AF_***也可以用于区分不同的协议族。
									
									不过为了更加正规一点，区分不同协议族的宏还是被命名为了PF_***，只不过它的值就是
								AF_***的值。
									
									#define PF_UNSPEC	AF_UNSPEC
									#define PF_UNIX		AF_UNIX
									#define PF_LOCAL	AF_LOCAL
									#define PF_INET		AF_INET
									#define PF_AX25		AF_AX25
									...
									
									int socket(int domain, int type, int protocol);
									
									总之希望大家理解，domain是用于指定协议族的，设置的宏可以是AF_***，也可以是PF_***，
								不过正规一点的话还是应该写PF_***，因为这个宏才是专门用来区分协议族的，而AF_***则是用
								来区分不同协议族的ip地址格式的。
									
									不过socket的手册里面写的都是AF_***，没有写PF_***。
								
								
								
								
							- domain的常见宏值，各自代表是什么协议族
									AF_UNIX, AF_LOCAL、AF_INET、AF_INET6、AF_IPX、AF_NETLINK、AF_APPLETALK
								AF_PACKET、AF_UNSPEC
							
									PF_UNIX, PF_LOCAL、PF_INET、PF_INET6、PF_IPX、PF_NETLINK、PF_APPLETALK、
								PF_PACKET、PF_UNSPEC
								
								
								+ PF_UNIX、PF_LOCAL：域通信协议族
										这两个宏值是一样（宏值都是1）。
										
										给domain指定该宏时就表示，你要使用的是“本机进程间通信”协议族，我们在讲第8章IPC
									时就说过，还有一种域套接字的IPC，也可以专门用来实现“本机进程间通信”。
										
										这个域就是本机的意思，当我们给socket的domain指定这个宏时，创建的就是域套接字文件。
										后面讲域套接字通信时，会具体的来使用这个宏。
								
										
										
								+ PF_INET：指定ipv4的TCP/IP协议族。
										我们本章要讲的TCP和UDP就是IPV4的TCP和UDP。
									
									
								+ PF_INET6：ipv6的TCP/IP协议族，目前还未普及使用，我们这里不讲。
									
									
								+ PF_IPX：novell协议族，几乎用不到，了解即可
								
										由美国Novell网络公司开发的一种专门针对局域网的“局域网通信协议”。
										
										这个协议的特点是效率较高，所以好多局域网游戏很喜欢使用这个协议来进行局域网通信，比如
									以前的局域网游戏CS，据说使用的就是novell协议族。
									
										之所以使用novell协议族，是因为CS的画面数据量太大，而且协同性要求很高，所以就选择了使
									用novell协议族这个高效率的局域网协议。
										
										现在互联网使用的都是TCP/IP协议，而novell和TCP/IP是两个完全不同的协议，所以使用
									novell协议族的局域网与使用TCP/IP协议族的互联网之间兼容性比较差，如果novell协议的
									局域网要接入TCP/IP的Internet的话，数据必须进行协议转换。
									
										所谓协议转换就是，
										novell局域网的数据包发向TCP/IP的互联网时，将novell协议族的数据包拆包，然后重新封包为
											TCP/IP协议的数据包。
										
										TCP/IP的互联网数据包发向novell局域网时，将TCP/IP协议族的数据包拆包，然后重新封包为
											novell协议的数据包。
										
										
										windows似乎并不是支持novell协议，但是Linux、unix这边是支持的。
										
										我怎么知道是支持的？
										既然我们在socket手册中查到了PF_IPX，就说明时肯定支持。
										
								
								+ PF_APPLETALK：苹果公司专为自己“苹果电脑”设计的局域网协议族。
									
			
			
								
								+ AF_UNSPEC：不指定具体协议族
											
											int socket(int domain, int type, int protocol);
								
										此时可以通过第三个参数protocol指定协议编号来告诉socket，你使用的是什么协议族中的
									哪个子协议。
										
										什么事协议编号？
										每个协议的唯一识别号，制订协议的人给的。
								


								
						
							
							
						int socket(int domain, int type, int protocol);						
						
						・ type：套接字类型，说白了就是进一步指定，你想要使用协议族中的那个子协议来通信。
								
								比如，如果你想使用TCP协议来通信，
								首先：将domain指定为PF_INET，表示使用的是IPV4的TCP/IP协议族
								其次：对type进行相应的设置，进一步表示我想使用的是TCP/IP协议族中的TCP协议。
							
							
							
								type的常见设置值：SOCK_STREAM、SOCK_DGRAM、SOCK_RDM、SOCK_NONBLOCK、SOCK_CLOEXEC
								
							- SOCK_STREAM：
									将type指定为SOCK_STREAM时，表示想使用的是“有序的、面向连接的、双向通信的、可靠的字
								节流通信”，并且支持带外数据。
									有关什么是带外数据后面再介绍。
									
									int socket(int domain, int type, int protocol);	
									
									如果domain被设置为PF_INET，type被设置为SOCK_STREAM，就表示你想使用TCP来通信，因为
								在TCP/IP协议族里面，只有TCP协议是“有序的、面向连接的、双向的、可靠的字节流通信”。
									
									使用TCP通信时TCP并不是孤立的，它还需要网络层和链路层协议的支持才能工作。
									
									如果type设置为SOCK_STREAM，但是domain指定为了其它协议族，那就表示使用的是其它“协议族”
								中类似TCP这样的可靠传输协议。
									
									
							- SOCK_DGRAM：
							
									将type指定为SOCK_DGRAM时，表示想使用的是“无连接、不可靠的、固定长度的数据报通信”。
										
									固定长度意思是说，分组数据的大小是固定的，不管网络好不好，不会自动去调整分组数据的
								大小，所以“固定长度数据报”其实就是“固定长度分组数据”的意思。
									
									当domain指定为PF_INET、type指定为SOCK_DGRAM时，就表示想使用的是TCP/IP协议族中的
								中的DUP协议，因为在TCP/IP协议族中，只有UDP是“无连接、不可靠的、固定长度的数据报通信”。
								
									同样的UDP不可能独立工作，需要网络层和链路层协议的支持。

									如果type设置为SOCK_DGRAM，但是domain指定为了其它协议族，那就表示使用的是其它“协议族”
								中类似UDP这样的不可靠传输协议。
									
									后面讲UDP时就会使用SOCK_DGRAM。
									
									
							- SOCK_RDM：表示想使用的是“原始网络通信”。
									
									int socket(int domain, int type, int protocol);	
									
									比如，当domain指定为TCP/IP协议族、type指定为SOCK_RDM时，就表示想使用ip协议来通信，使用
								IP协议来通信，其实就是原始的网络通信。
									
								为什么称为原始通信？	
									以TCP/IP协议族为例，TCP/IP之所以能够实现网络通信，最根本的原因是因为IP协议的存
								在，ip协议才是关键，只是原始的IP协议只能实现最基本的通信，还缺乏很多精细的功能，所以才
								多了基于IP工作的TCP和UDP，TCP/UDP弥补了IP缺失的精细功能。
								
									尽管ip提供的只是非常原始的通信，但是我们确实可以使用比较原始的IP协议来进通信，特别是
								当你不满意TCP和UDP的表现，你想实现一个比TCP和UDP更好的传输层协议时，你就可以直接使用
								ip协议，然后由自己的应用程序来实现符合自己要求的类似tcp/udp协议，不过我们几乎遇不到
								这种情况，这里了解下即可。
								
									如果type设置为SOCK_RDM，但是domain指定为了其它协议族，那就表示使用的是其它“协议族”
								中类似ip这样最基本的原始通信协议。
								
								
								int socket(int domain, int type, int protocol);	
							
							- SOCK_NONBLOCK：将socket返回的文件描述符指定为非阻塞的。
									
									如果不指定这个宏的话，使用socket返回“套接字文件描述符”时，不管是是用来“监听”还是用
								来通信，都是阻塞操作的，但是指定这个宏的话，就是非阻塞的。
										
									当然也可以使用fcntl来指定SOCK_NONBLOCK，至于fcntl怎么用，我们在高级IO讲的非常清楚。
									
									SOCK_NONBLOCK宏可以和前面的宏进行 | 运算，比如：
										SOCK_STREAM | SOCK_NONBLOCK
									
									
							- SOCK_CLOEXEC：表示一旦进程exec执行新程序后，自动关闭socket返回的“套接字文件描述符”。
								图：
								
								
								
								这个标志也是可以和前面的宏进行 | 运算的，不过一般不指定这个标志。
								
								SOCK_STREAM | SOCK_NONBLOCK | SOCK_CLOEXEC 
								
								
								
						int socket(int domain, int type, int protocol);		
						
						・ protocol：指定协议号		
						
								一般情况下protocol写0，表示使用domain和type所指定的协议。
								
								不过如果domain和type所对应的协议有好几个时，此时就需要通过具体的协议号来区分了，否者
							写0即可，表示domain和type所对应的协议就一个，不需要指定协议号来区分。
								
								
								疑问：在哪里可以查到协议号？
								所有协议的协议号都被保存在了/etc/protocols下。

								协议  编号
								ip 			0 
								icmp		1
								igmp		2
								tcp 		6
								udp 		17
								等
								
								socket(PF_INET, SOCK_STREAM, 0);		
								
								
				2）代码演示								
						
					
					
					
					
					
					
					
出品：佳嵌工作室
---------------------------------------------------------------------------------------------------------
	“佳嵌工作室”致力于物联网、嵌入式产品以及‘物联网、嵌入式技术课程’的研发，希望所推出的技术课程，能够帮
助到正在努力学习物联网、嵌入式的同学，欢迎大家和我们一起共同学习，共同进步。
---------------------------------------------------------------------------------------------------------		
						
		
		（2）第2步：调用bind 网络API，将套接字文件、ip和端口绑定到一起。
					图：

				
				1）bind函数
						#include <sys/types.h>          
						#include <sys/socket.h>

						int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
										
										
					（a）功能：将指定了通信协议（TCP）的套接字文件与IP以及端口绑定起来。
								
								注意，绑定的一定是自己的Ip和端口，不是对方的，比如对于TCP服务器来说，绑定的就是服务器自己
							的ip和端口。
							
								至于什么是绑定，为什么要绑定，我们后面再详细解释。
							
								
							
					（b）返回值：成功返回0，失败返回-1，errno被设置。
							
							
					（c）参数
							・ sockfd：套接字文件描述符，代表socket创建的套接字文件。
												既然要绑定套接字文件、ip和端口，肯定要有一个东西来代表套接字文件。
							
							・ addrlen：第二个参数所指定的结构体变量的大小
							
							・ addr：struct sockaddr结构体变量的地址，结构体成员用于设置你要绑定的ip和端口。
								
								- 结构体成员
								
									struct sockaddr {
										sa_family_t sa_family;
										char  			sa_data[14];
									}
									
									sa_family：指定AF_***，表示使用的什么协议族的IP，前面说过，协议族不同，ip格式就不同
									sa_data：存放ip和端口

										大家可以看出，如果将ip和端口直接写入sa_data数组中，虽然可以做到，但是操作起来有点麻烦，
									不过好在，我们可以使用更容易操作的struct sockaddr_in结构体来设置。
									
										不过这个结构体在在bind函数的手册中没有描述。
										
											struct sockaddr_in 
											{
													sa_family_t			sin_family;	//设置AF_***（地址族）
													__be16					sin_port;		//设置端口号
													struct in_addr	sin_addr;		//设置Ip
													
													/* 设置IP和端口时，这个成员用不到，这个成员的作用后面再解释， */
													unsigned char		__pad[__SOCK_SIZE__ - sizeof(short int) - 
														sizeof(unsigned short int) - sizeof(struct in_addr)];
											};
											
											struct in_addr 
											{
													__be32	s_addr; //__be32是32位的unsigned int，因为IPV4的ip是32位的无符号整形数
											};
											
										在struct sockaddr_in中，存放端口和ip的成员是分开的，所以设置起来很方便。
										
										使用struct sockaddr_in设置后，然后将其强制转为struct sockaddr类型，然后传递给bind
									函数即可。
										
										疑问：为什么要强制转换？
										bind要求的是struct sockaddr结构体，但是你设置的是struct sockaddr_in，自然要记性类
										型转换了。
										
										疑问：为什么这么麻烦，搞出了struct sockaddr和struct sockaddr_in这两个结构体类型？
										后面再解释。
																				

								
								- struct sockaddr_in的使用例子：
								
									struct sockaddr_in addr;
									
									addr.sin_family = AF_INET;//使用是IPV4 TCP/IP协议族的ip地址（32位）
									addr.sin_port		= htons(5006);//指定端口
									addr.sin_addr.s_addr = inet_addr("192.168.1.105");//指定ip地址
									
									ret = bind(sockfd, (struct sockaddr*)&addr, sizeof(addr));
									
									
									注意，如果是跨网通信时，绑定的一定是所在路由器的公网ip。
									
									bind会将sockfd代表的套接字文件与addr中设置的ip和端口绑定起来。
								
									有关htons和inet_addr这两个函数，我们后面会详细解释，目前我们先用起来。
									
									
									
									
				2）代码演示						
							
							
				
				
				
				
				3）有关bind的一些必须解释的问题
				
					（a）为什么要绑定，或者说绑定的目的是什么
					
								虽然bind函数看起来很简单，但是很多同学初学bind时基本都是似懂非懂，可能你感觉自己好
							像懂了，但是其实并不懂什么是绑定，以及为什么要绑定。
								
								调用socket创建套接字文件时，只是指定了所使用的协议（比如TCP协议），但是并没有指定通
							信时所需要ip地址和端口号。
									
							・ ip作用：ip是用来定位和找到对方的，如果没有IP就不叫网络通信了。
									
							・ 端口号的作用
								- 区分同一台计算机上不同的网络通信进程
									图：
									
								有了ip和端口后，对方首先通过ip找到目标计算机，然后再通过“端口”找到具体的网络通信进程。
								
									
							如果我们不明确的调用bind绑定一个固定的ip和端口的话，会怎么样？
								答：会被自动指定一个ip和端口，而且是不固定的，而且还不一定时你想用的iP和端口。
								
								
								
							自动指定ip和端口好不好？

						  ・ 对于TCP的服务器来说，自动指定ip和端口是不行的，为什么？
							
								因为客户端向服务器连接时，是由客户端主动发起三次握手请求的，如果服务器Ip和端口是变着的
							（不确定），此时客户端在向服务器请求连接时就抓瞎了，因为它根本就不知道服务器的ip和端口到
							底是多少，没办法建立连接。
							
								这就好比政府部门是服务器，我们这些群众是客户，如果政府部分的办公地址天天变来变去，我们这
							些客户不就抓瞎了吗，天天变，上哪联系政府去。
								
								所以对于TCP的服务器来说，必须调用bind函数给自己绑定固定的ip和端口号。
								
							到底什么是绑定？
								所以所谓绑定就是让套接字文件在通信时，使用固定的IP和端口。
							
							
						・ 对于TCP通信的客户端来说，自动指定ip和端口是常态
						
							疑问：客户端的IP和端口自动指定的话，服务器怎么知道客户的ip和端口是多少呢？
							
							客户与服务器建立连接时，服务器会从客户的数据包中提取出客户的ip和端口，并保存起来，如果
							是跨网通信，那么记录的就是客户所在路由器的公网Ip。
	
	
								
								
出品：佳嵌工作室
---------------------------------------------------------------------------------------------------------
	“佳嵌工作室”致力于物联网、嵌入式产品以及‘物联网、嵌入式技术课程’的研发，希望所推出的技术课程，能够帮
助到正在努力学习物联网、嵌入式的同学，欢迎大家和我们一起共同学习，共同进步。
---------------------------------------------------------------------------------------------------------		
									
								
					（b）htons函数和inet_addr函数		
					
								struct sockaddr_in addr;
								
								addr.sin_family = AF_INET;
								addr.sin_port		= htons(5006);
								addr.sin_addr.s_addr = inet_addr("192.168.1.105");
								
								ret = bind(sockfd, (struct sockaddr*)&addr, sizeof(addr));
								
								
							・ htons
								
								- 函数原型
									#include <arpa/inet.h>
								
									uint16_t htons(uint16_t hostshort);
								
									+ 功能：功能有两个
										1. 将端口号从“主机端序”转为“网络端序”
										2. 如果给的端口不是short，将其类型转为short型
									
										htons：是host to net short的缩写，
										
										host：主机端序，主机端序可能是大端序，也可能是小端序，视OS而定
										net：网络端序，网络端序都是固定使用大端序
										short：短整形
									
										疑问：什么是大端序和小端序？
										有关这个问题，我们在讲《C语言深度解析》时已经介绍的非常清楚，这里不再赘述。
									
									+ 参数：主机端序的端口号
									
									+ 返回值：该函数的调用永远都是成功的，返回转换后的端口号
									
									
								- 为什么要进行大小端序的转换？
									+ 网络通信的过程
										
									 发送计算机          网络           接收计算机
 										主机端序 ――――――> 网络端序 ―――――――> 主机端序
									
										发送计算机的端序与接收计算机的端序可能不一致，比如发送者是大端序，而接收者是小端序，
									如果通信时数据的端序处理不好，数据可能会出现乱码，甚至导致无法接收到数据。
									
										所以发送数据时，先从发送者的主机端序转成统一的网络端序，接收计算机接收到后，再统一
									的转成接收计算机的主机端序，如此接收者才能以正确的端序接收数据，否者就会出错。
									
									
									疑问：我没有调用htons函数，直接设置端口号（5006）好像也可以呢！
										
										因为我们写的程序是本机测试的，发送机和接收机都是同一台计算机，碰巧端序是一样的，
									所以不设置端序没有问题。
										
										而且就算你跨机测试时，不进行端序的转换的话，也有可能是正确的，因为有可能送计算机的
									端序和接收计算机的端序碰巧一样，但是如果不一样就出问题了。
									
										不过我们并不能保证发送和接收计算机的端序一定是一样的，所以不能冒这样的风险，我们一定
									要进行端序的转换。
							
							
								- htons的兄弟函数：htonl、ntohs、ltohs
									htonl：与htons唯一的区别是，转完的端口号时long，我们不使用这个函数，因为我们的端口号
											要的是short。
											
									ntohs：htons的相反情况，网络端序转为主机端序，后会用到
									ntohl：htonl的相反情况
										
										
								- 有关端口号的数值问题			
									addr.sin_port  = htons(5006);	
								
								
								 + 端口号的作用	
										用于区分同一台机器上的不同通信程序，对于同一台计算机来说，不同通信程序（可以是
									服务器、也可以客户端程序），他们的端口号都不能冲突，否者收发数据就出问题。
									图：	
									
									
									这就好比在同一层楼有两个房间叫101，客户就犯难了，不知道应该去按个房间。
									
									
									疑问：不同计算机的通信程序可以使用相同的端口号吗？
										当然可以，相互间毫无影响，这就好比1层有个101，2层也有个101，这是两个不同楼层的
									101房间，同名无所谓。
									
										所以A公司的计算机搭建web服务器端口是80，B公司服务器计算机搭建web同样是80端口，
									相互间并无干扰。
									
									
									+ 端口号的选择范围
										三个范围：0~1023、1024~49151、49152~65535。
									
									 0~1023：
											这个范围的端口最好不要用，因为这个范围的端口已经被世界公认的各种服务征用了，比如
										80就被web服务征用了，所以所有web服务器程序的端口都是固定的80。
										
										
										疑问：真的就不能用吗？
											我说的是最好不要用，但并没有说用了就一定会出问题，我们之所以建议不要用的原因是，
										如果使用这个范围的端口号的话，可能会遇到一些麻烦事。
										
											比如自己写了一个服务器程序，
										而且使用的是80端口，但是如果恰巧我又在计算机上安装了一个web服务器，web服务器
										程序默认使用的是就80端口，这下自己写的服务器程序的端口与安装的现成的web服务器的端口
										冲突了。
											web除了使用80端口，有些还是用8080端口。
											
											图：
										
										
										
										
											当然，如果你不安装web的话，其实也没什么，完全可以使用80端口，但是我们建议还是准守
										规则，不要使用这个范围的端口，因为保不齐你可能就安装了某些现成的全世界公认的服务器
										程序，如此一来就造成了端口的冲突，将会无法通信成功。
											
											总之我们自己在写服务器程序时，最好不要指定这个范围的端口号。
										
										
									1024~49151：
											自己实现服务器程序，建议使用这个范围的端口号，比如我写的TCP服务器所使用的5006，
										用的就是这个范围的端口号。
											
										疑问：当我们自己写的TCP服务器，在我们自己的PC机上测试运行时，难道指定5006就真的没有
											冲突的可能吗？
											
										说实话，还是有可能会冲突的，不过大家尽可以大胆使用，因为冲突的可能性很小，真要冲突了
										，我怀疑可能是大家的人品有问题^-^，那么为什么指定1024~49151范围的端口时几乎不可
										能冲突呢？										
										
										1. 全世界公认的有名的服务，使用的都是0~1023范围的端口，而不是这个范围的
										
										2. 这个范围的端口默认都是给自己写的服务器程序使用的，对于我的pc机来说，只有可能
											安装客户端
											程序（qq/微信客户端），几乎不会安装网络服务器程序（pc根本跑不动），所以这个范
											围的端口基本不可能会被什么服务器程序所使用，也就是我自己写的TCP服务器程序可能
											会使用。
												
												就算碰巧你的PC上安装了某个网络服务程序，使用了1024~49151中的某个端口，但是这个
											范围这么大，真想要冲突上也挺难的。


										3. 疑问：pc会安装很多的网络客户端程序（qq/微信客户端），万一某个客户端使用也是5006
											的话，这个客户端和我自己写的TCP服务器的端口5006，不就冲突了吗？
											
											Pc确实会大量安装客户端程序，但是客户端的端口都是自动分配的，而自动分配的端口范围为
											49152~65535，根本就不是1024~49151这个范围的，所以与客户端端口冲突的可能性不大。
										
											
									49152~65535：
											用于自动分配的，一般客户端程序不会绑定固定的ip和端口，因为客户端的Ip和端口都是
										自动分配的，在自动分配端口时，所分配的就是49152~65535范围的端口。
							
							
							
出品：佳嵌工作室
---------------------------------------------------------------------------------------------------------
	“佳嵌工作室”致力于物联网、嵌入式产品以及‘物联网、嵌入式技术课程’的研发，希望所推出的技术课程，能够帮
助到正在努力学习物联网、嵌入式的同学，欢迎大家和我们一起共同学习，共同进步。
---------------------------------------------------------------------------------------------------------		
									
						・ inet_addr函数			
								
								addr.sin_addr.s_addr = inet_addr("192.168.1.105");
							
								+ 函数原型
									#include <sys/socket.h>
									#include <netinet/in.h>
									#include <arpa/inet.h>

									in_addr_t inet_addr(const char *cp);
								 
								+ 功能：两个
									1. 将字符串形式的Ip"192.168.1.105"（点分十进制），转为IPV4的32位无符号整形数的ip
									2. 将无符号整形数的ip，从主机端序转为网络端序
									
										为什么要转换端序？
										与端口号端序的转换原因是一样的。
							 
								+ 参数：字符串形式的ip

								+ 返回值：永远成功，返回网络端序的、32位无符号整形数的ip。	
										
								+ 其它兄弟函数
										它的兄弟函数很多，虽然形态上有差异，实际上功能差不多，只是略有区别，这些函数并不难，
										不过由于时间关系，我不再一一详细介绍，等待真的用到其中某一个了，大家自己去学习和
										理解即可。
								
								
						・ 为什么区分struct sockaddr和struct sockaddr_in
						
								struct sockaddr {
									sa_family_t sa_family;
									char  			sa_data[14];
								}

								struct sockaddr_in {
									sa_family_t			sin_family;
									__be16					sin_port;
									struct in_addr	sin_addr;
									
				
								/* 填补相比struct sockaddr所缺的字节数，保障强制转换不要出错 */
									unsigned char		__pad[__SOCK_SIZE__ - sizeof(short int) - 
										sizeof(unsigned short int) - sizeof(struct in_addr)];
								};
								
								我们不管使用什么协议族来通信，底层统一使用struct sockaddr结构体。
								
							那么为什么会有struct sockaddr_in？
								struct sockaddr设置起来不方便，为了方便设置，所以有了sockaddr_in结构体类型。
							
							
								注意：sockaddr_in是专门给TCP/IP协议族使用的，如果是其它协议族，对应的是其它的设置结构体，
								比如“域通信协议族”使用的就是struct sockaddr_un结构体。

								
								
					・ 强制转换时发生了什么
							struct sockaddr_in addr;
							
							addr.sin_family = AF_INET;
							addr.sin_port		= htons(5006);
							addr.sin_addr.s_addr = inet_addr("192.168.1.105");
								
							ret = bind(sockfd, (struct sockaddr*)&addr, sizeof(addr));
							
							结构体内容并没有变，但是空间的解释方式变了，当我们将struct sockaddr_in强制转为
						struct sockaddr时候，struct sockaddr_in的后三个成员被强制解释为了struct sockaddr的sa_data
						成员，如此一来就把ip和端口给设置到了struct sockaddr是sa_data成员中。
							
							图：



							
							
							
							
							
							
							
出品：佳嵌工作室
---------------------------------------------------------------------------------------------------------
	“佳嵌工作室”致力于物联网、嵌入式产品以及‘物联网、嵌入式技术课程’的研发，希望所推出的技术课程，能够帮
助到正在努力学习物联网、嵌入式的同学，欢迎大家和我们一起共同学习，共同进步。
---------------------------------------------------------------------------------------------------------										
								
		（4）第3步：调用listen 网络API，将套接字文件描述符，从主动变为被动文件描述符
		
				1）listen函数
						#include <sys/types.h>          /* See NOTES */
						#include <sys/socket.h>

						int listen(int sockfd, int backlog);
					
					（a）功能：将套接字文件描述符，从主动文件描述符变为被动描述符，然后用于被动监听客户的连接
					
					（b）返回值：成功返回0，失败返回-1，ernno被设置
					
					（c）参数
							・ sockfd：socket所返回的套接字文件描述符
								socket返回的“套接字文件描述符”默认是主动的，如果你想让它变为被动的话，你需要自己调用
								listen函数来实现。
								
								
							・ backlog：指定队列的容量。
							
									这个队列用于记录正在连接，但是还没有连接完成的客户，一般将队列容量指定为2、3就可以了。
									这个容量并没有什么统一个设定值，一般来说只要小于30即可。
					
					
					
				2）代码演示
						
						
						
						
						不要因为listen有听的意思，就想当然的认为，listen就是用于被动监听客户连接的函数，事实上
					真正用于被动监听客户连接的函数，并不是listen，而是其它函数。
					
						listen的作用仅仅只是用于将“套接字文件描述符”变成被动描述符，以供“监听函数”用于被动监听客户
					连接而已。
						
						
							
						
							
				3）TCP服务器为什么要listen
					
					（a）一定要注意，只有TCP服务器才会调用listen
							图：编程模型
							
							
							
					（b）TCP服务器调用listen的目的
					
								TCP服务器监听客户连接时，是使用socket返回的“套接字文件描述符”来实现的，但是这个文件
							描述符默认是主动文件描述符，所以需要使用listen函数将其转为被动描述符，否者无法用于被动
							监听客户的连接。
							
							什么是主动描述符？
							使用主动描述符可以主动的向对方发送数据。
							
							被动描述符？
							只能被动的等别人主动想你发数据，然后再回答数据，不能主动的发送数据。
							
							
							
							为什么要将“套接字文件描述符”转为被动描述符后，才能监听连接。
							
								TCP服务器和客户端必须要建立连接，建立连接时的三次握手是由客户端主动先发起的，
							也就是由客户端率先主动向服务器发送三次握手的数据，而服务器这一端则被动的接收，然后回答。
								
								图：
								
								
								
								正式由于服务器在三次握手时的这一被动属性，所以使用“套接字文件描述符”监听客户连接时，
							描述符必须是被动的描述符。
							
								
								
								
							
							
出品：佳嵌工作室
---------------------------------------------------------------------------------------------------------
	“佳嵌工作室”致力于物联网、嵌入式产品以及‘物联网、嵌入式技术课程’的研发，希望所推出的技术课程，能够帮
助到正在努力学习物联网、嵌入式的同学，欢迎大家和我们一起共同学习，共同进步。
---------------------------------------------------------------------------------------------------------										
	
		（5）第4步：调用accept 网络API，被动监听客户的连接
				
				1）accept函数
						#include <sys/types.h>          /* See NOTES */
						#include <sys/socket.h>

						int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);

						
					（a）功能：被动监听客户发起三次握手的连接请求，三次握手成功，即建立连接成功。
								accept被动监听客户连接的过程，其实也被称为监听客户上线的过程。
									
								对于那些只连接了一半，还未连接完成的客户，会被记录到未完成队列中，队列的容量由
							listen函数的第二个参数（backlog）来指定。
								
								服务器调用accept函数监听客户连接，而客户端则是调用connect来连接请求的。
								
								一旦连接成功，服务器这边的TCP协议会记录客户的IP和端口，如果是跨网通信的，记录ip的就是
							客户所在路由器的公网Ip。
									
				
					（b）返回值：
							・ 成功：
									返回一个通信描述符，专门用于与该连接成功的客户的通信，总之后续服务器与该客户间
								正式通信，使用的就是accept返回的“通信描述符”来实现的。
											
							・ 失败：返回-1，errno被设置
						
							
						int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);
					（c）参数
							・ sockefd：已经被listen转为了被动描述符的“套接字文件描述符”，专门用于被动监听客户的连接。
									如果sockfd没有被listen转为被动描述符的话，accept是无法将其用来监听客户连接的。
								
								
								- 有关套接字描述符的阻塞与非阻塞问题
								
									服务器程序调用socket得到“套接字文件描述符”时，如果socket的第2个参数type，没有指定
								SOCK_NONBLOCK的话，
									int socket(int domain, int type, int protocol);
									
									“套接字文件描述符”默认就是阻塞的，所以accept使用它来监听客户连接时，
								如果没有客户请求连接的话，accept函数就会阻塞，直到有客户连接位置。
									如果你不想阻塞，我们就可以在调用socket时，给type指定SOCK_NONBLOCK宏。
									
									
								疑问：在TCP/IP协议族中，只有TCP协议才有建立连接的要求，那么accept怎么知道你用的
									就是TCP协议呢？
									
									accept的第一个参数是socket返回的“套接字文件描述符”，它指向了socket所创建的套接字文件，
								创建套接字文件时，我们会通过参数1和参数2指定你所使用的协议，
									int socket(int domain, int type, int protocol);	
								
									比如将其指定为TCP协议，所以只要你在调用socket创建套接字文件时有指定通信协议，
								accept函数就可以通过“套接字文件描述符”知道套接字文件所使用的是不是TCP协议。


								int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);
							・ addrlen：第二参数addr的大小，不过要求给的是地址。
									如何给地址？
									后面会代码演示。
								
								
							・ addr：用于记录发起连接请求的那个客户的IP和端口（port）
							
									前面说过建立连接时，服务器这边的TCP协议会自动记录客户的ip和端口，如果是跨网通信的
								话，记录的就是客户的公网IP。

									如果服务器应用层需要用到客户ip和端口的话，可以给accept指定第二个参数addr，以获取
								TCP在连接时所自动记录客户IP和端口，如果不需要的就写NULL。
										int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);
									
									addr为struct sockaddr类型，有关这个结构体，我们在前面介绍过。	
									
									不过我们前面说过，虽然下层（内核）实际使用的是struct sockaddr结构体，但是由于这个
								结构体用起来不方便，因此应用层会使用更加便于操作的结构体，比如使用TCP/IP协议族通信时，
								应用层使用的就是struct sockaddr_in这个更加方便操作的结构体。
										
									所以我们应该定义struct sockaddr_in类型的addr，传递给accept函数时，将其强制转为
								struct sockaddr即可，与我们讲bind函数时的用法类似。
									

									例子：
									struct sockaddr_in clnaddr = {0};
									
									int clnsize = sizeof(clnaddr)
									cfd = accept(sockfd, (struct sockaddr *)&clnaddr, &clnsize);
									
									
									将clnaddr传递给accept后，accept函数会自动的讲TCP记录的客户ip和端口设置到clnaddr中，
								我们即可得到客户的ip和端口。
								
									通过之前对struct sockaddr_in成员的了解可知，clnaddr第二个成员放的是客户的端口号，
								第三个成员放的是客户的IP。
										
									struct sockaddr_in 
									{
											sa_family_t			sin_family;	//设置AF_***（地址族）
											__be16					sin_port;		//设置端口号
											struct in_addr	sin_addr;		//设置Ip
											
											/* 设置IP和端口时，这个成员用不到，这个成员的作用后面再解释， */
											unsigned char		__pad[__SOCK_SIZE__ - sizeof(short int) - 
												sizeof(unsigned short int) - sizeof(struct in_addr)];
									};
									
									
									
				2）代码演示
						
									
									
						

						
					
				3）如何使用得到的客户ip和端口
						比如我这里的使用方式是打印客户的ip和端口，此时必须调用ntohs和inet_ntoa函数进行端序转换。
					
					为什么要进行端序转换？
						客户的端口和ip是服务器这边的TCP协议，从客户端发送的网络数据包中提取出来的，网络数据包的
					端序属于网络端序，主机接收到数据后，如果你想要使用的话，就必须从网络端序转为主机端序。
					
					（a）ntohs：是htons的相反函数，将端口从网络端序转为主机端序
					（b）inet_ntoa：功能与inet_addr刚好相反，该函数有两个功能
					
							・ 将IPV4的32位无符号整形数的ip，从网络端序转为主机端序
							
							・ 将实际所用的无符号整形数的ip，转成人能识别的字符串形式的ip
					
					使用举例：
						struct sockaddr_in clnaddr = {0};

						int clnaddr_size = sizeof(clnaddr)
						cfd = accept(sockfd, (struct sockaddr *)&clnaddr, &clnaddr_size);
						
						printf("cln_port= %d, cln_addr=%s\n", ntohs(clnaddr.sin_port), inet_ntoa(clnaddr.sin_addr));
						
					
					代码演示
					
					
									
									
									
									
							
出品：佳嵌工作室
---------------------------------------------------------------------------------------------------------
	“佳嵌工作室”致力于物联网、嵌入式产品以及‘物联网、嵌入式技术课程’的研发，希望所推出的技术课程，能够帮
助到正在努力学习物联网、嵌入式的同学，欢迎大家和我们一起共同学习，共同进步。
---------------------------------------------------------------------------------------------------------										
			
		（6）第5步：服务器调用read（recv）和write（send），收发数据，实现与客户的通信
		
					read和write的用法，我们在讲文件IO时已经介绍的非常清楚，我们这里着重介绍recv和send这两个函数，
				recv和send其实和read和write差不多，它们的前三个参数都是一样的，只是recv和send多了第四个参数。
					
					不管是使用read、write还是使用recv、send来实现TCP数据的收发，由于TCP建立连接时自动已经记录下
				了对方的IP和端口，所以使用这些函数实现数据收发时，只需要指定通信描述符即可，不需要指定对方
				的ip和端口。
						
					
				1）send函数
						
					（a）函数原型
							#include <sys/types.h>
							#include <sys/socket.h>
								
							ssize_t send(int sockfd, const void *buf, size_t len, int flags);
							
							・ 功能：向对方发送数据
								其实也可以使用sendto函数，相比send来说多了两个参数，当sendto的后两个参数写NULL和0时，
							能完全等价于send。
									ssize_t sendto(int sockfd, const void *buf, size_t len, int flags, NULL, 0);

															
								类似TCP这种面向连接的通信，我们一般使用send而不是使用sendto，因为sendto用起来有点麻烦。
								类似UDP这种不需要连接的通信，必须使用sendto，不能使用send，后面介绍到udp时再详细介绍。
									
							・ 返回值：成功返回发送的字节数，失败返回-1，ernno被设置
							
							
							
							ssize_t send(int sockfd, const void *buf, size_t len, int flags);
							・ 参数：
								- sockefd：用于通信的通信描述符
								
										不要因为名字写的是sockfd，就认为一定是socket返回“套接字文件描述符”。
									在服务器这边，accept返回的才是通信描述符，所以服务器调用send发送数据时，第一个参数
									应该写accept所返回的通信描述符。
									

								- buf：应用缓存，用于存放你要发送的数据
										可以是任何你想发送的数据，比如结构体、int、float、字符、字符串等等。
										
										正规操作的话，应该使用结构体来封装数据。
										
										
								- len：buf缓存的大小
								
								- flags：一般设置0，表示这个参数用不到，此时send是阻塞发送的。
										
										阻塞发送的意思就是，如果数据发送不成功会一直阻塞，直到被某信号中断或者发送成功为止，
									不过一般来说，发送数据是不会阻塞的。
											
										当flags设置0时，send与write的功能完全一样，有关flags的其它设置，后面再介绍。
										
										
										
								
					（b）代码演示
							数据的发送和接收，
					
							收发数据的数据需要在网路中传输，所以同样要进行端序的转换。
							
							・ 发送数据：将主机端序转为网络端序
							・ 接收数据：将网络端序转为主机端序
							
							不过只有short、int、float等存储单元字节>1字节的数据，才有转换的需求。
							如果是char这种存储单元为一个字节的数据，不需要对端序进行转换。
							
							疑问：为什么存储单元为一个字节的数据，不需要进行端序的转换呢?
							有关这个问题，我们在《C语言深度解析》中讲的非常清楚，所以这里不再赘述。
							
							
							我们这里虽然介绍的是c程序的例子，但是实际上c++/java等调用相应的网络API实现通信时，应用
						程序同样需要进行端序的转换，与我们这里介绍的c程序的情况是一样的。
						
						
							前面介绍过，本机测试时其实是可以不进行端序转换的，但是对于正规网络通信来说，收发计算机
						的大小端序不一定相同，为了避免因端序不同所带来的通信错误，我们应该严格操作，收发数据时必须
						对端序进行转换。
							
							代码演示：服务器发送数据
							
							
							
							
							
						ssize_t send(int sockfd, const void *buf, size_t len, int flags);
							
					（c）flags的常见设置
							+ 0：表示用不上flags，此时send是阻塞发送数据的
							
							
							+ MSG_NOSIGNAL：send数据时，如果对方将“连接”关闭掉了，调用send的进程会被发送SIGPIPE信号，
								这个信号的默认处理方式是终止，所以收到这个信号的进程会被终止。
									
								如果给flags指定MSG_NOSIGNAL，表示当连接被关闭时不会产生该信号。
								
								从这里可看出，并不是只有写管道失败时才会产生SGIPIPE信号，网络通信时也会产生这个的信号。
							
							
							+ MSG_DONTWAIT：非阻塞发送
								
								
							+ MSG_OOB：表示发送的是带外数据
								有关带外数据后面再详细介绍。
								
								
							+ ...
								
							
							以上除了0以外，其它选项可以|操作，比如MSG_DONTWAIT | MSG_OOB。
							
							
							
							
							
							
							
							
				2）recv函数
				
					（a）函数原型
							 #include <sys/types.h>
							 #include <sys/socket.h>

							 ssize_t recv(int sockfd, void *buf, size_t len, int flags);
							
							・ 功能：接收对方发送的数据
							
									我们也可以使用rcvfrom函数，当recvfrom函数的最后两个参数写NULL和0时，与recv的功能完全
								一样。
									ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags, NULL, 0);
									
									同样的，讲到udp时再详细介绍recvfrom。
									
									
							・ 返回值：成功返回接收的字节数，失败返回-1，ernno被设置
									
									
							・ 参数
								- sockfd：通信文件描述符
									
								- buf：应用缓存，用于存放接收的数据
								
								- len：buf的大小
								
								- flags：
									+ 0：默认设置，此时recv是阻塞接收的，0是常设置的值。
									
									+ MSG_DONTWAIT：非阻塞接收
									
									+ MSG_OOB：接收的是带外数据
									
									+ ...：其它选项不做介绍
									
									
									
									
					（b）代码演示
							
							
				
				
				
				
				
				
				
				
出品：佳嵌工作室
---------------------------------------------------------------------------------------------------------
	“佳嵌工作室”致力于物联网、嵌入式产品以及‘物联网、嵌入式技术课程’的研发，希望所推出的技术课程，能够帮
助到正在努力学习物联网、嵌入式的同学，欢迎大家和我们一起共同学习，共同进步。
---------------------------------------------------------------------------------------------------------										
					
				
		（7）第6步：调用close或者shutdown关闭TCP的连接
					
					
				1）回顾断开连接时的四次握手
						
						图：
					
					
						TCP断开连接时，可以由客户和服务器任何一方发起。
					
					
						调用close或者sutdown函数断开连接时，四次握手的过程是由TCP自动完成的。
						
						
						
						
				1）使用close断开连接
				
					（a）服务器端调用close断开连接
					
							・ close(accept返回的描述符);
							
								图：
								
								
							・ 代码演示
								
								
								
								
								
								
					（b）客户端调用close断开连接
							・ close(socket返回的描述符)
								
								图：
							
							・ 代码演示
								写客户端代码时再介绍
								
								
								
					
					（c）close断开连接的缺点
					
							・ 缺点1：会一次性将读写都关掉了
									如果我只想关写，但是读打开着，或者只想关读、但是写打开着，close做不到。
									
									
							・ 缺点2：如果多个文件描述符指向了同一个连接时，如果只close关闭了其中某个文件描述符时，
								只要其它的fd还打开着，那么连接不会被断开，直到所有的描述符都被close后才断开连接。
								
								出现多个描述指向同一个连接的原因可能两个：
								- 通过dup方式复制出其它描述符								
									图：
									
								- 子进程继承了这个描述符，所以子进程的描述符也指向了连接
									
									图：
								
								
								
				2）shutdown函数
						有效的解决了close的缺点，所以以后断开连接时，建议使用更正规shutdown函数。
					
					（a） shutdown函数原型
								#include <sys/socket.h>

								int shutdown(int sockfd, int how);
							
							・ 功能：可以按照要求关闭连接，而且不管有多少个描述符指向同一个连接，只要调用shutdown去
									操作了其中某个描述符，连接就会被立即断开。
								
							・ 返回值：成功返回0，失败返回-1，ernno被设置
							
							・ 参数
								- sokcfd：TCP服务器断开连接时，使用的是accept所返回的文件描述符
									
									客户端调用shutdown断开连接的情况，讲到客户端时再介绍。

									
								- how：如何断开连接
									+ SHUT_RD：只断开读连接
									+ SHUT_WR：只断开写连接
									+ SHUT_RDWR：读、写连接都断开
									
										
					（c）代码演示
							・ 服务器shutdown
							
							
							・ 客户端调用shutdown
								将客户端时在演示
							
							
							
							
			（8）回顾TCP通信服务器程序的编程流程
					图：
					
					
					
					
					
					
出品：佳嵌工作室
---------------------------------------------------------------------------------------------------------
	“佳嵌工作室”致力于物联网、嵌入式产品以及‘物联网、嵌入式技术课程’的研发，希望所推出的技术课程，能够帮
助到正在努力学习物联网、嵌入式的同学，欢迎大家和我们一起共同学习，共同进步。
---------------------------------------------------------------------------------------------------------										

		4.6.1 实现TCP通信的客户端程序			
		
			（1）第1步：调用socket创建套接字文件，指定使用TCP协议
					
					
					int socket(int domain, int type, int protocol);
					
					参数如何设置？
					・ domain：指定为PF_INET，表示使用的IPV4是TCP/IP协议族
					・ type：指定为SOCK_STREAM，表示使用的是面向连接的可靠传输协议	
									在TCP/IP协议族中，只有TCP是面向连接的可靠传输协议，所以使用的是TCP协议。
									
					・ protocol：0，不指定协议号。
					
					
						函数调用成功就“返回套接字文件描述符”，在客户端程序中，socket返回“套接字文件描述符”，直接
					用于通信。
						
						
						
			（2）第2步：调用connect主动向服务器发起三次握手，进行连接
					
						客户端调用connect主动发起连接请求，服务器调用accept被动接收请求，三次握手ok，连接
					就成功了。
						这三次握手是由TCP自动完成，我们只需要调用connect和accept这连个函数接口即可。
				
	
						
						连接成功后，服务器端的accept会返回专门与该客户通信的描述符，而客户端则直接使用socket返回
					套接字文件描述符来通信。
					
						图：
				
					
				（a）为什么客户端没有bind和listen
						
						・ 为什么没有bind？
								
								我们之前说过，bind的目的是为了让套接字文件使用固定的ip和端口号来通信，但是只有TCP
							服务器有使用固定ip和端口的需求，但是于客户端来说，不需要固定的IP和端口，所以不需要调用
							bind函数来绑定，客户端只需使用自动分配的IP和端口即可。
								
								我们前面介绍过，客户端使用自动分配的端口号时，端口号的分配范围为49152~65535。
								
							疑问：如果客户程序非要bind绑定可以吗？
							答：当然可以，大家下去可以自己试试，尝试给客户端也绑定固定的ip和端口，不过对于客户端
								来说，没有什么意义。
						
						
						
						・ 客户端程序为什么没有listen？
								对客户端程序来说，客户端永远都是主动向服务器发起连接请求的，没有被动监听别人连接的需求，
							因此根本就不需要所谓的被动文件描述符，因此根本就用不到listen函数。
									
							
					（b）connect函数	
							・ 函数原型
								 #include <sys/types.h>         
								 #include <sys/socket.h>

								 int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);
								
								- 功能：向服务器主动发起连接请求
								
								- 返回值：成功返回0，失败返回-1，ernno被设置
								
								- 参数
									+ sockfd：socket所返回的套接字文件描述符
													
									+ addrlen：参数2所指定的结构体变量的大小
									
									+ addr：用于设置你所要连接服务器的IP和端口。
									
											如果只是纯粹的局域网内部通信的话，ip就是局域网IP，但是如果是跨网
										通信的话，IP必须是服务器所在路由器的公网IP。

											为了方便操作，在应用层我们还是使用struct sockaddr_in来设置，然后传递给connect时，
										再强制换为struct sockaddr。

										struct sockaddr_in seraddr;
										
										addr.sin_family = AF_INET;    
										addr.sin_port		= htons(5006);//服务器程序的端口
										addr.sin_addr.s_addr = inet_addr("192.168.1.105");//服务器的ip地址
										
										cfd = connect(sockfd, (struct sockaddr *)&seraddr, sizeof(seraddr));										
		
										struct sockaddr_in {
											sa_family_t			sin_family;
											__be16					sin_port;
											struct in_addr	sin_addr;
											
						
										/* 填补相比struct sockaddr所缺的字节数，保障强制转换不要出错 */
											unsigned char		__pad[__SOCK_SIZE__ - sizeof(short int) - 
												sizeof(unsigned short int) - sizeof(struct in_addr)];
										};
										
	
						
						
					2）第3步：调用read（recv）和write（send）收发数据
					
							同样的，由于在建立TCP连接时，客户端的TCP协议会自动记录下服务器的ip和端口，调用这
						些函数收发数据时，我们不需要重新指定服务器的ip和端口，因为TCP有记录。
								
							代码演示：
							
							
							49152~65535：
							
							
							
					3）第4步：调用close或者shutdown关闭连接
						
							代码演示：
						
							
								
								
								
								
出品：佳嵌工作室
---------------------------------------------------------------------------------------------------------
	“佳嵌工作室”致力于物联网、嵌入式产品以及‘物联网、嵌入式技术课程’的研发，希望所推出的技术课程，能够帮
助到正在努力学习物联网、嵌入式的同学，欢迎大家和我们一起共同学习，共同进步。
---------------------------------------------------------------------------------------------------------										
							
	4.7 总结下TCP通信
	
			TCP通信分为两步，
			
			第一步：建立连接，建立连接时，服务器和客户的TCP协议会自动记录下对方ip和端口
					当然，能够建立连接的前提是，服务器端绑定了固定的ip和端口，而且客户端知道这个固定的ip和端口，
				只有这样客户端才知道向谁请求连接，否则都不知道和谁连接，更不要谈连接成功了。
			
			第二步：使用通信描述符直接收发数据，此时会自动使用TCP记录的IP和端口
					
			
			为了弄清楚TCP通信的具体过程，我们分三种情况来看。
					
					
		4.7.1 本机通信
			图：
				


				
		4.7.2 局域网内跨机通信
			图：
			
			
			
			
			
			
		4.7.3 过路由器，跨网通信
			图：
			
			
			
			
	
	4.8 TCP服务器/客户模式
			对于TCP协议来说，只要你使用TCP协议，必然有一个服务器端，而其它的都是客户端，这一点是由TCP协议
		本身的特性所决定的，而不是“应用程序”来决定的，所以使用TCP协议通信时，是天然的服务器/客户模式。
			图：
			
			
			
		
		如果TCP客户之间想要通信，在TCP的服务器/客户模式下，只能通过服务器来中转。
		
		服务器为了同时与众多客户进行通信，可以有三种方式：
		（1）多线程
		
		（2）多进程
		
		（3）多路IO
			
			这三种方式的实现，后面在详细介绍。
		
		
		
		
		
出品：佳嵌工作室
---------------------------------------------------------------------------------------------------------
	“佳嵌工作室”致力于物联网、嵌入式产品以及‘物联网、嵌入式技术课程’的研发，希望所推出的技术课程，能够帮
助到正在努力学习物联网、嵌入式的同学，欢迎大家和我们一起共同学习，共同进步。
---------------------------------------------------------------------------------------------------------										

	
5. UDP通信
		UDP是User Datagram Protocol的缩写，直译为用户数据报协议。
		
		
	5.1 UDP的特点 
	
		5.1.2 UDP是不可靠传输协议
				刚好与TCP相反，它是一种面向无连接的不可靠传输层协议，而且UDP每次发送的分组数据大小都是固定的。
				
				为什么UDP是不可靠传输？
				
			（1）不建立连接
			（2）没有应答机制
			（3）不会根据网络的好坏调整分组数据的大小
				
				其实有关UDP为什么是不可靠传输协议，我们在介绍TCP时就讲的很清楚了，之所以不是可靠传输协议，
			主要还是因为UDP没有连接和应答机制，导致UDP在发送数据时，根本不清楚通信线路的连通状态，所以UDP传
			输数据时，无法保证数据一定能发送给对方，因此UDP是不可靠传输协议，或者说是不可靠通信。

				
			
		5.1.2 每次传输数据时，必须指定对方的IP和端口
		
			（1）回顾TCP
						TCP建立连接时，服务器和客户端的TCP协议会自动记录下对方的IP和端口，后续调用recv、send来正
					式通信时，应用程序不再需要指定对方的Ip和端口，因为会自动使用TCP记录的IP和端口。
	
	
			（2）UDP
					对于UDP来说，UDP协议没有建立连接特性，所以UDP协议没有自动记录对方IP和端口的特点，因此每次发
				送数据时，应用程序必须亲自指定对方的IP和端口，只有这样才能将数据发送给对方。
					如果是跨网通信的话，指定的ip就是对方的公网ip。
				

			
	5.2 什么时候使用UDP呢
						
				对于数据量很大但是允许数据丢失的数据来说，可以使用UDP通信。
				比如像视频、音频等这类数据，尽管数据量很大，但是就算数据有所丢的话，对通信质量不会有太大影响，
			此时就可以使用UDP来传输。
			
				当然，我们在开发项目时，如果有现成的调用UDP的应用层协议，我们可以直接这些应用层协议，这些协议
			代码是可以到网上下载或者购买的，否者我们就自己亲自调用UDP来实现。
			
				比如我们在开发与视频监控相关的网络程序时（主要时客户端），往往会使用RSTP或者RTP应用层协议来传输
			监控视频数据，RSTP和RTP底层实际上使用的就是UDP协议。
			
		
	5.3 UDP的编程模型
			图：
			
			
			
			学习TCP通信时我们说过，TCP协议要求必须要有一个服务器，这一点是由TCP协议本身的特性所决定的。
			
			但是通过UDP的编程模型可以看出，UDP通信双方要做的事情一摸一样的，所以对于UDP通信的双方来说，不需要
		区分谁是服务器端、谁是客户端，通信双方的身份完全是对等的，所以UDP通信也被称为对等通信，或者叫
		“点对点”通信。
			
			同样的，UDP这种对等通信的特点，或者说点对点通信的特点，是由UDP协议本身的特性所决定的，与应用程序
		没有关系。
		
		
		
		
		
出品：佳嵌工作室
---------------------------------------------------------------------------------------------------------
	“佳嵌工作室”致力于物联网、嵌入式产品以及‘物联网、嵌入式技术课程’的研发，希望所推出的技术课程，能够帮
助到正在努力学习物联网、嵌入式的同学，欢迎大家和我们一起共同学习，共同进步。
---------------------------------------------------------------------------------------------------------										
		
	5.4 UDP通信的例子程序
		
		写一个A程序，然后再写一个B程序，让这两个程序之间使用UDP通信。
			
		5.4.1 第1步：调用socket创建套接字文件
		
			（1）参数
					int socket(int domain, int type, int protocol);
					
					参数如何指定？
					1）domain：AF_INET，表示使用的是TCP/IP协议族
					2）type：SOCK_DGRAM，表示使用的是协议族中的无连接、不可靠、固定长度的数据报协议。
							在TCP/IP协议族里面只有UDP协议属于这种情况，所以使用的必然是UDP协议。
							
					3）protocol：0

			（2）代码演示
			
			
		5.4.2 第2步：bind绑定固定的ip和端口
				
				如果只是使用UDP发送数据，可以不绑定固定的ip和端口，如果要接收数据的话，必须绑定固定的ip和端口。
							
			疑问：为什么UDP接收数据时需要bind 固定的ip和端口？
			
				如果不绑定，每次使用的都是自动设置的ip和端口，自动设置的话，ip和端口就是不定的，如果每次都是
			变化的，发送数据端在指定IP和端口时就不知所应该写什么了。
				所以如果要接收数据，就必须绑定固定的IP和端口。
				
				代码演示：
				
				
				
		5.4.3 第3步：调用sendto和recvfrom函数，发送和接收数据
		
			（1）为什么没有listen和accept
						UDP没有连接的过程，listen和accept是TCP连接时才会用到函数，既然UDP没有连接，自然也就用不到了。
						
						
			（2）sendto
			
					1）函数原型
					  #include <sys/types.h>
						#include <sys/socket.h>

						ssize_t sendto(int sockfd, const void *buf, size_t len, int flags,
                      const struct sockaddr *dest_addr, socklen_t addrlen);

						・ 功能：发送数据，当后两个参数为NULL和0时，功能等价于send，send专门用于TCP这种面向连接的通信，
								但对于像UDP这种非连接的通信，必须使用sendto，因为此时必须使用最后两个参数。
								
						・ 返回值：成功返回发送的字节数，失败返回-1，errno被设置
						
						・ 参数
							- sockfd：socket返回的套接字描述符，对于UDP来说，套接字描述符直接用于通信。
							
							- buf：存放数据的应用缓存
							
							- len：应用缓存的大小。
							
							- flags：一般写0，表示阻塞发送数据
									其它常用的选项与send的flags一样。
							
							- dest_addr：填写目标ip和端口
									前面就讲过，对于UDP来说，UDP没有连接的过程，所以没有自动记录对方的ip和端口，所以每
								次发送数据的时候，都需要指定对方的ip和端口。
	
							- addelen：dest_addr的大小

							
					2）代码演示
						
				
			（2）recvfrom
			
					1）函数原型								
							#include <sys/types.h>
							#include <sys/socket.h>

							ssize_t recvfrom(int sockfd, void *buf, size_t len, int flags,
										struct sockaddr *src_addr, socklen_t *addrlen);
			
						・ 功能：接收数据，最后两个参数与NULL和NULL时，功能与recv功能相同。
								UDP通信时，常使用的是recvfrom函数，因为需要用到后两个参数。
								
							
						・ 返回值：成功返回接收到的字节数，失败返回-1，ernno被设置

						
						・ 参数
							- sockfd：socket返回的套接字文件描述符
							
							- buf：应用缓存，用于存放接收到的数据
							
							- len：buf的大小
							
							- flags：一般写0，表示阻塞接收数据
									其它的常用设置同recv函数
							
							- src_addr：用于保存“数据发送方”的ip和端口，以便“接收方”回答对方
									如果是局域网通信，ip就是局域网ip，如果是广域网通信，ip就是对方的所在路由器的公网ip。		
								
									如果不需要回答对方数据的话，可以不用保存对方的ip和端口，这时recvfrom的最后两个参数
								写NULL，此时与recv函数的功能完全等价。
									
									
							- addrlen：src_addr的大小	
								
								
								
								
					2）代码演示		
		
					
				
			UDP因为没有“连接和应答”这种确认机制，所以UDP是不可靠通信，不过我们自己可以在应用层加入
		确认机制，以弥补UDP的补足。

			比如每次使用UDP通信发送数据给对方后，对方必须回答，如果对方没有回答或者回答数据有错，发送方就重发，
		以此保证UDP的通信的可靠性，这就是通过应用程序来弥补UDP的不可靠性。
		
			
			
					
		
出品：佳嵌工作室
---------------------------------------------------------------------------------------------------------
	“佳嵌工作室”致力于物联网、嵌入式产品以及‘物联网、嵌入式技术课程’的研发，希望所推出的技术课程，能够帮
助到正在努力学习物联网、嵌入式的同学，欢迎大家和我们一起共同学习，共同进步。
---------------------------------------------------------------------------------------------------------										
	
	5.2 分析UDP的几种通信情况
	
		5.2.1 本机通信
		
		
		5.2.2 局域网内跨机通信
		
		
		5.2.3 过路由器，跨网通信
			
			UDP跨网通信的前提是，必须要知道对方的公网ip，暂时先假设发送者本来就知道。
	
			
			
			
	5.3 使用UDP通信搭建出服务器
	
			有同学可能会有疑问说，不对啊，不是说UDP是“对等通信”，没有服务器吗，怎么还可以使用UDP搭建服务器呢？
		
			我们说UDP没有服务器，这是站在UDP协议角度来说，但是并不是说我们自己写的“应用程序”，不能基
		于UDP来实现服务器，应用程序基于UDP实现服务器的时候，服务器的实现者是应用程序，而不是UDP协议。
			图：
		
			
			总之，使用UDP实现服务器时，服务器是由应用程序本身来构建的，而不是UDP协议，就算搭建出了服务器，
		但是使用UDP来实现“服务器”和“客户”的通信时，站在UDP协议的角度来说，任然还是对等通信。
		
		
			服务器如何同时与n多个客户通信？
			
		（1）多线程
		
		（2）多进程
		
		（3）多路IO
			
			
			
			
			
			
	5.3 如何实现两台普通计算机之间的跨网通信
			
			比如我的PC和我同事的PC之间想要进行跨网通信，方法有两种，
			
		・ 第一种：通过服务器中转
		
		・ 第二种：直接通信
	
		
		5.3.1 通过服务器中转
			（1）TCP
			
			
			（2）UDP
			
				我们举例子时，直接举跨网通信的例子。
				
				
				
		5.3.2 直接通信
		
			PC之间如果要直接通信的话，只能使用UDP通信。
			
			不过如果PC之间要进行UDP直通的话，也必须要有服务器程序的参与，否者pc1根本不能知道pc2的公网IP和端口。
				
				
			服务器的实现有两种，
			
			（1）UDP服务器方式
					图：



			（2）TCP服务器方式
					图：
	
	
					实际上QQ的实现使用的就是TCP/UDP相联合的方式
					
					TCP：用于管理所有的用户信息，以及转发文字聊天信息
					
					UDP：当客户双方进行视频通话时，由于视频通话的数据量太大，所以客户双方此时就使
							用UDP来点对点直接通信

					
					
					
		
出品：佳嵌工作室
---------------------------------------------------------------------------------------------------------
	“佳嵌工作室”致力于物联网、嵌入式产品以及‘物联网、嵌入式技术课程’的研发，希望所推出的技术课程，能够帮
助到正在努力学习物联网、嵌入式的同学，欢迎大家和我们一起共同学习，共同进步。
---------------------------------------------------------------------------------------------------------										
						
					
6. 使用套接字来实现本机进程间的通信
		
		
	6.1 实现方式有两种
	
		（1）第1种：使用网络套接字
					比如使用TCP/IP协议族来实现，不管是使用TCP还是使用UDP都可以，只要将目标ip指定为本机IP或
				者127.0.0.1回环地址，即可实现本机进程间的通信。
					
					事实上使用实现网络通信的“网络套接字”来实现本机进程间通信，有点大材小用了，如果想要使用套接字来
				实现本机进程间通信的话，我们应该是使用“域套接字”，而不是“网络套接字”。
					
					实现本机进程间通信，“域套接字”的效率会高于“网络套接字”。
			
			
		（2）第2种：使用“域套接字”
				创建“套接字文件时”，如果指定的是“域通信协议族”的话，这个套接字文件就被称为“域套接字文件”，
			简称域套接字。
				
				域套接字不能实现跨进程间通信，只能用来实现“本机进程间通信”，而且还是专业的"本机间通信"。
				
				总结一下，到目前为止，本机进程间通信的方式有哪些？
				1）信号
				2）管道（无名、有名）
				3）system V IPC（消息队列、共享内存、无名信号量）
				4）域套接字
				
				
				
	6.2 域套接字的实现
				
		有两种，分别是
		・ 字节流的“域套接字”
		・ 数据报的“域套接字”
		
		
		6.2.1 字节流“域套接字”
		
			（1）编程模型
					编程模型与TCP的编程模型完全一样。
					
					虽然编程模型与TCP一样，但是还是有所不同的，其中最大的不同就是，
					
					绑定时设置的结构体是struct sockaddr_un，而不是 struct sockaddr_in
								struct sockaddr_un {
									sa_family_t sun_family;	/* AF_UNIX */
									char sun_path[UNIX_PATH_MAX];	/* pathname */
								};
						
						设置这个结构体时，
						sun_family = AF_UNIX 或者 AF_LOCAL
						sun_path = 一个文件路径名//注意不是IP和端口，域套接字实现本机进程间通信时，用不到ip和端口。
						
						bind绑定结构体的内容时，会创建“所设置路径名的”文件。
						
					疑问：这个文件起什么作用？
						简单理解就是，起到与ip和端口类似的作用。
					
					
			（2）代码演示：
						
						
						
						如果想要让服务器同时为多客户服务，有三种办法
						多线程
						多进程
						多路io
							
											
		6.2.2 数据报“域套接字”
		
			（1）编程模型同UDP
						
						bind时，设置的也是struct sockaddr_un，专门给“域通信协议族”使用的
						
						struct sockaddr_un {
							sa_family_t sun_family;	/* AF_UNIX */
							char sun_path[UNIX_PATH_MAX];	/* pathname */
						};
				
				
				
				
			（2）直接代码演示：
					
					




					
		
出品：佳嵌工作室
---------------------------------------------------------------------------------------------------------
	“佳嵌工作室”致力于物联网、嵌入式产品以及‘物联网、嵌入式技术课程’的研发，希望所推出的技术课程，能够帮
助到正在努力学习物联网、嵌入式的同学，欢迎大家和我们一起共同学习，共同进步。
---------------------------------------------------------------------------------------------------------															
			
7. 广播
	
	7.1 什么是广播
			一个人发，然后其它所有人都接收，这就是广播。
			
			这就好比以前村里的大喇叭一样，村长说话全村人都听得见，这就是广播。
	
	
	7.2 广播的有限范围
	
			广播只能在局域网内部有效，广播数据是无法越过路由器的，也就是说路由器就是广播数据的边界。
		
			这里说的“局域网”其实是一个广义上的概念，我们这里说的“局域网”可以是我们常说的狭义上的局域网、
			或者城域网、广域网。
		
			
	7.3 广播的IP怎么写
	
			举例说明：
				我电脑的ip为192.168.1.105，所在的网段为192.168.1.0，把网段最后面的0全部变为1就是广播地址，
			所以我电脑所在局域网的广播ip就是192.168.1.255，如果对Ip地址不是很了解的话，
			请看《计算机体系结构体―――网络篇》课程，对IP地址有详细介绍。
				
				使用192.168.1.255广播时，192.168.1.0网段里现有的所有计算机（除了发送者自己外），都将接收到
			广播的数据。
			
			
	7.4 广播在开发中用的多吗
	
			说实话，在我们实际开发中其实用的不多，只有在写一些框架代码的时候会用到。
			
			比如开发路由器时，路由器其实就会涉及到广播，而且必须用到广播，因为最起码它需要向范围内的所有计
		算机广播自己的wifi名称，只有这样我们才能在pc和手机上查看到wifi名称，如果连wifi名字都不知道，怎
		么连接呢。
		
		
			不过像这样的广播代码，基本都写在了框架代码中，尽管如此，对于学习网络编程来说，我们有义务了解广
		播，这对我们实际开发也是有一定帮助的。
		
			比如像开发路由器这种产品，虽然你在开发时不需要自己写广播的代码，但是既然开发路由器，就必须大致
		理解路由器的工作原理，其中就包括路由器的广播功能，如果你连广播都不理解的话，又怎么理解路由器的广
		播功能呢。
			
	
	7.5 局域网广播的实现
		
		7.5.1 编程模型 
			其实就是UDP的编程模型，广播使用的是UDP通信。

			不过与我们前面所讲UDP通信的唯一不同是，广播时指定的IP是广播IP。
			
			
		7.5.2 代码演示
				写一个广播发送程序，写一个接收程序，
				
				发送广播的计算机运行“广播发送程序”，其它所有的计算机运行“接收程序”，广播数据时，其它所有的计算
			机都将接收到广播数据。	
				图：
				
				
				具体的代码就不写了，一个是因为我的局域网就一台计算机，没办法演示，另一个是因为广播这个东西在实
			际开发中用到的很少，因此只要理解什么是广播即可，至于代码不需要掌握。
	
	
	
	
	7.6 组播
		除了广播外还有一个组播，组播和广播很像。
		
		什么是组播?
		广播是给其他所有计算机广播数据，而组播只对其它所有计算机中的某部分计算机广播数据。
			图：
			
			
			
		进行组播时所使用的的IP是组播IP。
			
		了解组播是怎么回事即可，不需要深入掌握。
			
			
			
			
			
			
			
8. 带外数据
	

	
	
	
		
出品：佳嵌工作室
---------------------------------------------------------------------------------------------------------
	“佳嵌工作室”致力于物联网、嵌入式产品以及‘物联网、嵌入式技术课程’的研发，希望所推出的技术课程，能够帮
助到正在努力学习物联网、嵌入式的同学，欢迎大家和我们一起共同学习，共同进步。
---------------------------------------------------------------------------------------------------------															
		
9. 服务器如何实现同时为多客户服务

		我们这里只使用TCP通信来举例，有关基于UDP的为多客户服务的服务器，请大家下去后自己实现。

		
	9.1 多线程
		9.1.1 实现原理
			
			
			
		9.1.2 代码演示
		
			实现一个同时为多客户服务的服务器程序，服务器收到客户发送的数据后，就向客户回答“收到了”。

			
			
			多线程实现多客户的方式，其实是现在服务器框架实现多客户时的主流实现方式。
			

	9.2 多进程
	
		9.2.1 实现原理
		
		
		9.2.2 代码演示
		
			实现一个同时为多客户服务的服务器程序，服务器收到客户发送的数据后，就向客户回答“收到了”。
			
			
			多进程的方式现在很少了，基本都是多线程方式。
		
		
		
		
		
	9.3 多路io
	
		这里介绍原理，不进行代演示了。
		
		多路io有两种，分别是select和poll机制，他们的原理都是类似的。
		
		
		这种方式理论上也行，但是实际上真正的服务器并不采用这种方式来实现。
		
		
		
	9.4 了解服务器是如何同时为多客户服务的意义
			
			其实站在开发的角度来说意义不大，我们这里介绍这个主要目的，是想告诉大家服务器实现多客户的原理。
		
		我们的课程主要是面向嵌入式开发，不涉及服务器的开发，而且就算你是做服务器开发的，事实上服务器实现
		多客户的代码已经被服务器框架早就做好了（现成的），开发人员并不需要关心。
				
				
			1）B/S模式下的服务器（浏览器访问的web服务器）
			
					web服务器每连接一个客户，服务器就开辟一个线程与客户通信，以实现为多客户服务，
				但是这个实现多客户的代码是由web服务器框架提供的，网站开发者不需要关心。
				
				
				那开发网站做什么？
					
					要做的就是实现html页面(界面)，将html页面写好后，将其保存到web服务器的硬盘上，当有客户与服
				务器建立连接，访问web时，web会为该客户开辟一个服务的线程，该线程就会将你要访问的html页面发送
				给你的浏览器，然后显示出来。
					
					
			2）C/S模式下的服务器（APP访问的服务器）
			
					一样的，多客户的代码也是由服务器框架现成提供的，更多的我们这里就不再介绍了。
					
					我们在前面的课程就介绍过，现在的服务器往往都是B/S、C/S混合模式，至于这个混合模式是怎么实现，
				介绍起来稍微有点麻烦，我们目前课程也不针对这个方向，所以我们这里不在介绍，而且我们本身也不是
				做服务器开发的，也不是这方面的专家，所以也很难讲到位。
					
							


		
		
10. 其它的函数

	其实Linux所提供的网络编程API还有好些其它的，比如：
	
		getnameinfo(...)
		getaddrinfo(...)
		gethostname(...)
		gethosetaddr(...)
		setsockopt(...)
		...
		
	其实c++、java等库API，同样有以上这些类似功能的函数，只不过是以类的形式进行了封装。
	
	
	有关以上这些函数我们不再介绍，至于不再介绍的原因如下:
	
	（1）课程时间太久了
			我们的网络课程到目前为止，已经耗去相当长的时间，如果是再继续将这些函数，整个课程时间会拉的很长。
			
	
	（2）不属于本课程的核心内容
				
				本课程的核心目的是想让大家深入的理解什么是网络编程，如何编程实现TCP/UDP通信，如果大家把这个核
			心理解了，事实上网络编程就算学会了，至于以上的这些函数，其实只能算是“旁枝末节”的知识。

				课程永远都是有一个核心的，核心就是把核心知识讲清楚，而且对大家学习来说，拦路虎永远都是核心
			知识，如果你将核心知识搞定了，其它细枝末节的只是，就应该是由大家自学完成的，因为大家要清楚，别
			人的讲授只是引导，最终更广更深的学习，一定还是要回归到自学上。
				
				我们希望的是授之以渔，而不是授之以鱼，如果是授之以鱼的话，我们课程会有讲不完的知识点。
			
			
	（3）这些函数并不难（当然，并不是一点难度也没有）
	
				以上这些函数只是工具函数而已，这些工具函数的目的，只不过是想方便我们实现更加复杂的网络程序而已，
			
			这些函数最终都是基于我们之前所讲的核心功能来工作的，因此只要大家把之前的核心功能理解了，完全有能
			力自己弄明白。
			
				当然有关这些函数，我并不建议大家现在就去想办法弄明白，等到大家以后真的用到之后，再根据需求
			去学习，以需求来驱动学习，这样的学习效果会更好。
				
				
				
			



