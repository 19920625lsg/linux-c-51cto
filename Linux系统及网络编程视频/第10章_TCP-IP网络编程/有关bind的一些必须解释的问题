# 3）有关bind的一些必须解释的问题
  + （a）为什么要绑定，或者说绑定的目的是什么  
    虽然bind函数看起来很简单，但是很多同学初学bind时基本都是似懂非懂，可能你感觉自己好像懂了，但是其实并不懂什么是绑定，以及为什么要绑定。

    调用socket创建套接字文件时，只是指定了所使用的协议（比如TCP协议），但是并没有指定通信时所需要ip地址和端口号。

    + ip作用：ip是用来定位和找到对方的，如果没有IP就不叫网络通信了。

    + 端口号的作用: 区分同一台计算机上不同的网络通信进程图：

    有了ip和端口后，对方首先通过ip找到目标计算机，然后再通过“端口”找到具体的网络通信进程。

    如果我们不明确的调用bind绑定一个固定的ip和端口的话，会怎么样？  
    答：会被自动指定一个ip和端口，而且是不固定的，而且还不一定时你想用的iP和端口。

    + 对于TCP的服务器来说,自动指定ip和端口好不好？自动指定ip和端口是不行的，为什么？  
      因为客户端向服务器连接时，是由客户端主动发起三次握手请求的，如果服务器Ip和端口是变着的（不确定），此时客户端在向服务器请求连接时就抓瞎了，因为它根本就不知道服务器的ip和端口到底是多少，没办法建立连接。

      这就好比政府部门是服务器，我们这些群众是客户，如果政府部分的办公地址天天变来变去，我们这些客户不就抓瞎了吗，天天变，上哪联系政府去。

      所以对于TCP的服务器来说，必须调用bind函数给自己绑定固定的ip和端口号。

    + 到底什么是绑定？  
      所以所谓绑定就是让套接字文件在通信时，使用固定的IP和端口  
      
    对于TCP通信的客户端来说，自动指定ip和端口是常态

    + 疑问：客户端的IP和端口自动指定的话，服务器怎么知道客户的ip和端口是多少呢？  

    客户与服务器建立连接时，服务器会从客户的数据包中提取出客户的ip和端口，并保存起来，如果
    是跨网通信，那么记录的就是客户所在路由器的公网Ip。

  + （b）htons函数和inet_addr函数		

    ```c
    struct sockaddr_in addr;

    addr.sin_family = AF_INET;
    addr.sin_port		= htons(5006);
    addr.sin_addr.s_addr = inet_addr("192.168.1.105");

    ret = bind(sockfd, (struct sockaddr*)&addr, sizeof(addr));
    ```

    + htons
      > 函数原型
      
      ```c
      #include <arpa/inet.h>
      uint16_t htons(uint16_t hostshort);
      ```

      + 功能：功能有两个
        + 1. 将端口号从“主机端序”转为“网络端序”
        + 2. 如果给的端口不是short，将其类型转为short型

        htons：是host to net short的缩写，
        + host：主机端序，主机端序可能是大端序，也可能是小端序，视OS而定
        + net：网络端序，网络端序都是固定使用大端序
        + short：短整形

        疑问：什么是大端序和小端序？有关这个问题，我们在讲《C语言深度解析》时已经介绍的非常清楚，这里不再赘述。

      + 参数：主机端序的端口号

      + 返回值：该函数的调用永远都是成功的，返回转换后的端口号

      + 为什么要进行大小端序的转换？
        + 网络通信的过程

          ```shell
          发送计算机          网络           接收计算机
           主机端序 ——————> 网络端序 ———————> 主机端序
          ```

          发送计算机的端序与接收计算机的端序可能不一致，比如发送者是大端序，而接收者是小端序，如果通信时数据的端序处理不好，数据可能会出现乱码，甚至导致无法接收到数据。

          所以发送数据时，先从发送者的主机端序转成统一的网络端序，接收计算机接收到后，再统一的转成接收计算机的主机端序，如此接收者才能以正确的端序接收数据，否者就会出错。

        + 疑问：我没有调用htons函数，直接设置端口号（5006）好像也可以呢！

          因为我们写的程序是本机测试的，发送机和接收机都是同一台计算机，碰巧端序是一样的，所以不设置端序没有问题。而且就算你跨机测试时，不进行端序的转换的话，也有可能是正确的，因为有可能送计算机的端序和接收计算机的端序碰巧一样，但是如果不一样就出问题了。不过我们并不能保证发送和接收计算机的端序一定是一样的，所以不能冒这样的风险，我们一定要进行端序的转换。
          
      + htons的兄弟函数：htonl、ntohs、ltohs
        + htonl：与htons唯一的区别是，转完的端口号时long，我们不使用这个函数，因为我们的端口号要的是short。
        + ntohs：htons的相反情况，网络端序转为主机端序，后会用到
        + ntohl：htonl的相反情况
      + 有关端口号的数值问题：`addr.sin_port  = htons(5006);	`
        + 端口号的作用	
        用于区分同一台机器上的不同通信程序，对于同一台计算机来说，不同通信程序（可以是服务器、也可以客户端程序），他们的端口号都不能冲突，否者收发数据就出问题。图：	
        这就好比在同一层楼有两个房间叫101，客户就犯难了，不知道应该去按个房间
        疑问：不同计算机的通信程序可以使用相同的端口号吗？  
        当然可以，相互间毫无影响，这就好比1层有个101，2层也有个101，这是两个不同楼层的101房间，同名无所谓。
        所以A公司的计算机搭建web服务器端口是80，B公司服务器计算机搭建web同样是80端口，相互间并无干扰。
        + 端口号的选择范围  
          > 三个范围：0~1023、1024~49151、49152~65535。
          + 0~1023：这个范围的端口最好不要用，因为这个范围的端口已经被世界公认的各种服务征用了，比如80就被web服务征用了，所以所有web服务器程序的端口都是固定的80。
          疑问：真的就不能用吗？  
          我说的是最好不要用，但并没有说用了就一定会出问题，我们之所以建议不要用的原因是，如果使用这个范围的端口号的话，可能会遇到一些麻烦事。比如自己写了一个服务器程序，而且使用的是80端口，但是如果恰巧我又在计算机上安装了一个web服务器，web服务器程序默认使用的是就80端口，这下自己写的服务器程序的端口与安装的现成的web服务器的端口冲突了。web除了使用80端口，有些还是用8080端口。图：

          当然，如果你不安装web的话，其实也没什么，完全可以使用80端口，但是我们建议还是准守规则，不要使用这个范围的端口，因为保不齐你可能就安装了某些现成的全世界公认的服务器程序，如此一来就造成了端口的冲突，将会无法通信成功。

          总之我们自己在写服务器程序时，最好不要指定这个范围的端口号。


        1024~49151：
            自己实现服务器程序，建议使用这个范围的端口号，比如我写的TCP服务器所使用的5006，
          用的就是这个范围的端口号。

          疑问：当我们自己写的TCP服务器，在我们自己的PC机上测试运行时，难道指定5006就真的没有
            冲突的可能吗？

          说实话，还是有可能会冲突的，不过大家尽可以大胆使用，因为冲突的可能性很小，真要冲突了
          ，我怀疑可能是大家的人品有问题^-^，那么为什么指定1024~49151范围的端口时几乎不可
          能冲突呢？										

          1. 全世界公认的有名的服务，使用的都是0~1023范围的端口，而不是这个范围的

          2. 这个范围的端口默认都是给自己写的服务器程序使用的，对于我的pc机来说，只有可能
            安装客户端
            程序（qq/微信客户端），几乎不会安装网络服务器程序（pc根本跑不动），所以这个范
            围的端口基本不可能会被什么服务器程序所使用，也就是我自己写的TCP服务器程序可能
            会使用。

              就算碰巧你的PC上安装了某个网络服务程序，使用了1024~49151中的某个端口，但是这个
            范围这么大，真想要冲突上也挺难的。


          3. 疑问：pc会安装很多的网络客户端程序（qq/微信客户端），万一某个客户端使用也是5006
            的话，这个客户端和我自己写的TCP服务器的端口5006，不就冲突了吗？

            Pc确实会大量安装客户端程序，但是客户端的端口都是自动分配的，而自动分配的端口范围为
            49152~65535，根本就不是1024~49151这个范围的，所以与客户端端口冲突的可能性不大。


        49152~65535：
            用于自动分配的，一般客户端程序不会绑定固定的ip和端口，因为客户端的Ip和端口都是
          自动分配的，在自动分配端口时，所分配的就是49152~65535范围的端口。

  · inet_addr函数			

      addr.sin_addr.s_addr = inet_addr("192.168.1.105");

      + 函数原型
        #include <sys/socket.h>
        #include <netinet/in.h>
        #include <arpa/inet.h>

        in_addr_t inet_addr(const char *cp);

      + 功能：两个
        1. 将字符串形式的Ip"192.168.1.105"（点分十进制），转为IPV4的32位无符号整形数的ip
        2. 将无符号整形数的ip，从主机端序转为网络端序

          为什么要转换端序？
          与端口号端序的转换原因是一样的。

      + 参数：字符串形式的ip

      + 返回值：永远成功，返回网络端序的、32位无符号整形数的ip。	

      + 其它兄弟函数
          它的兄弟函数很多，虽然形态上有差异，实际上功能差不多，只是略有区别，这些函数并不难，
          不过由于时间关系，我不再一一详细介绍，等待真的用到其中某一个了，大家自己去学习和
          理解即可。


  · 为什么区分struct sockaddr和struct sockaddr_in

      struct sockaddr {
        sa_family_t sa_family;
        char  			sa_data[14];
      }

      struct sockaddr_in {
        sa_family_t			sin_family;
        __be16					sin_port;
        struct in_addr	sin_addr;


      /* 填补相比struct sockaddr所缺的字节数，保障强制转换不要出错 */
        unsigned char		__pad[__SOCK_SIZE__ - sizeof(short int) - 
          sizeof(unsigned short int) - sizeof(struct in_addr)];
      };

    我们不管使用什么协议族来通信，底层统一使用struct sockaddr结构体。

    那么为什么会有struct sockaddr_in？struct sockaddr设置起来不方便，为了方便设置，所以有了sockaddr_in结构体类型。


    注意：sockaddr_in是专门给TCP/IP协议族使用的，如果是其它协议族，对应的是其它的设置结构体，比如“域通信协议族”使用的就是struct sockaddr_un结构体。



· 强制转换时发生了什么
    struct sockaddr_in addr;

    addr.sin_family = AF_INET;
    addr.sin_port		= htons(5006);
    addr.sin_addr.s_addr = inet_addr("192.168.1.105");

    ret = bind(sockfd, (struct sockaddr*)&addr, sizeof(addr));

    结构体内容并没有变，但是空间的解释方式变了，当我们将struct sockaddr_in强制转为struct sockaddr时候，struct sockaddr_in的后三个成员被强制解释为了struct sockaddr的sa_data成员，如此一来就把ip和端口给设置到了struct sockaddr是sa_data成员中。

    图：
