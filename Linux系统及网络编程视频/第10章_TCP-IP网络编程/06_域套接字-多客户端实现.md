# 更多通信方式和相关函数的介绍

## 6. 使用套接字来实现本机进程间的通信

### 6.1 实现方式有两种

+ （1）第1种：使用网络套接字  
  比如使用TCP/IP协议族来实现，不管是使用TCP还是使用UDP都可以，只要将目标ip指定为本机IP或者127.0.0.1回环地址，即可实现本机进程间的通信。

  事实上使用实现网络通信的“网络套接字”来实现本机进程间通信，有点大材小用了，如果想要使用套接字来实现本机进程间通信的话，我们应该是使用“域套接字”，而不是“网络套接字”。

  实现本机进程间通信，“域套接字”的效率会高于“网络套接字”。

+ （2）第2种：使用“域套接字”  
  创建“套接字文件时”，如果指定的是“域通信协议族”的话，这个套接字文件就被称为“域套接字文件”，简称域套接字。

  域套接字不能实现跨进程间通信，只能用来实现“本机进程间通信”，而且还是专业的"本机间通信"。

  总结一下，到目前为止，本机进程间通信的方式有哪些？
  + 1）信号
  + 2）管道（无名、有名）
  + 3）system V IPC（消息队列、共享内存、无名信号量）
  + 4）域套接字

### 6.2 域套接字的实现

有两种，分别是
+ 字节流的“域套接字”
+ 数据报的“域套接字”

#### 6.2.1 字节流“域套接字”

+ （1）编程模型同TCP  
  编程模型与TCP的编程模型完全一样。

  虽然编程模型与TCP一样，但是还是有所不同的，其中最大的不同就是，

  绑定时设置的结构体是struct sockaddr_un，而不是 struct sockaddr_in,同时需要引入头文件un.h `#include <sys/un.h>`

  ```c
  struct sockaddr_un {
    sa_family_t sun_family;	/* AF_UNIX */
    char sun_path[UNIX_PATH_MAX];	/* pathname */
  };
  ```

  设置这个结构体时，
  
  ```c
  sun_family = AF_UNIX 或者 AF_LOCAL
  sun_path = 一个文件路径名//注意不是IP和端口，域套接字实现本机进程间通信时，用不到ip和端口
  ```

  bind绑定结构体的内容时，会创建“所设置路径名的”文件。

  **疑问：这个文件起什么作用？简单理解就是，起到与ip和端口类似的作用**

+ （2）代码演示

  > 参考 [字节流“域套接字”](网络编程/域套接字/stream_LOCAL)或者[字节流“域套接字”自己的实现](my_code/域套接字/类TCP的字节流)

#### 6.2.2 数据报“域套接字”

+ （1）编程模型同UDP  

  bind时，设置的也是struct sockaddr_un，专门给“域通信协议族”使用的

  ```c
  struct sockaddr_un {
    sa_family_t sun_family;	/* AF_UNIX */
    char sun_path[UNIX_PATH_MAX];	/* pathname */
  };
  ```

+ （2）代码演示

  参考[数据报“域套接字”](网络编程/域套接字/dgram_LOCAL) 或 [数据报“域套接字”自己的实现](my_code/域套接字/类UDP的数据报)
  
  命令测试如下(注意此时的命令行传参只需要一个套接字文件路径了)：
  
  peer1.c
  
  ```shell
  gcc peer1.c -pthread -o peer1
  root@6fb4b72f0c7c:/workspace/linuxc/chapter10socket/DomainSocket/UDP# ./peer1 sock_peer2
  Please input student number:
  student number = 123
  student name = sdsf
  342
  Please input student name:
  sasdfe
  Please input student number:
  ```
  
  peer2.c
  
  ```shell
  gcc peer2.c -pthread -o peer2
  root@6fb4b72f0c7c:/workspace/linuxc/chapter10socket/DomainSocket/UDP# ./peer2 sock_peer1
  Please input student number:
  123
  Please input student name:
  sdsf
  Please input student number:
  student number = 342
  student name = sasdfe
  ```

## 7. 广播

### 7.1 什么是广播

一个人发，然后其它所有人都接收，这就是广播。

这就好比以前村里的大喇叭一样，村长说话全村人都听得见，这就是广播。


### 7.2 广播的有限范围

广播只能在局域网内部有效，广播数据是无法越过路由器的，也就是说路由器就是广播数据的边界。

这里说的“局域网”其实是一个广义上的概念，我们这里说的“局域网”可以是我们常说的狭义上的局域网、或者城域网、广域网。

### 7.3 广播的IP怎么写

举例说明：  
  我电脑的ip为192.168.1.105，所在的网段为192.168.1.0，把网段最后面的0全部变为1就是广播地址，所以我电脑所在局域网的广播ip就是192.168.1.255，如果对Ip地址不是很了解的话，请看《计算机体系结构体———网络篇》课程，对IP地址有详细介绍。

  使用192.168.1.255广播时，192.168.1.0网段里现有的所有计算机（除了发送者自己外），都将接收到广播的数据。

### 7.4 广播在开发中用的多吗

说实话，在我们实际开发中其实用的不多，只有在写一些框架代码的时候会用到。

比如开发路由器时，路由器其实就会涉及到广播，而且必须用到广播，因为最起码它需要向范围内的所有计算机广播自己的wifi名称，只有这样我们才能在pc和手机上查看到wifi名称，如果连wifi名字都不知道，怎么连接呢。

不过像这样的广播代码，基本都写在了框架代码中，尽管如此，对于学习网络编程来说，我们有义务了解广播，这对我们实际开发也是有一定帮助的。

比如像开发路由器这种产品，虽然你在开发时不需要自己写广播的代码，但是既然开发路由器，就必须大致理解路由器的工作原理，其中就包括路由器的广播功能，如果你连广播都不理解的话，又怎么理解路由器的广播功能呢。

### 7.5 局域网广播的实现

#### 7.5.1 编程模型 

其实就是UDP的编程模型，**广播使用的是UDP通信。不过与我们前面所讲UDP通信的唯一不同是，广播时指定的IP是广播IP**。

#### 7.5.2 代码演示

写一个广播发送程序，写一个接收程序，

发送广播的计算机运行“广播发送程序”，其它所有的计算机运行“接收程序”，广播数据时，其它所有的计算机都将接收到广播数据

具体的代码就不写了，一个是因为我的局域网就一台计算机，没办法演示，另一个是因为广播这个东西在实际开发中用到的很少，因此只要理解什么是广播即可，至于代码不需要掌握。

### 7.6 组播

除了广播外还有一个组播，组播和广播很像。

什么是组播?广播是给其他所有计算机广播数据，而组播只对其它所有计算机中的某部分计算机广播数据。图：

**进行组播时所使用的的IP是组播IP**。了解组播是怎么回事即可，不需要深入掌握。

## 8. 带外数据

## 9. 服务器如何实现同时为多客户服务

> 如果想要让服务器同时为多客户服务，有三种办法。我们这里只使用TCP通信来举例，有关基于UDP的为多客户服务的服务器，请大家下去后自己实现

+ 多线程
+ 多进程
+ 多路io

### 9.1 多线程

#### 9.1.1 实现原理

#### 9.1.2 代码演示

实现一个同时为多客户服务的服务器程序，服务器收到客户发送的数据后，就向客户回答“收到了”。

多线程实现多客户的方式，其实是现在服务器框架实现多客户时的主流实现方式。

完整代码参考 [服务器端实现多客户端连接之多线程实现](my_code/服务器端实现多客户端连接/多线程实现)

执行如下：

server.c

```c
root@6fb4b72f0c7c:/workspace/linuxc/chapter10socket/multi_clients#g cc TCP_server.c -pthread -o server
root@6fb4b72f0c7c:/workspace/linuxc/chapter10socket/multi_clients# gcc TCP_client.c -pthread -o client
root@6fb4b72f0c7c:/workspace/linuxc/chapter10socket/multi_clients# ./server 
cln_port= 36078, cln_addr=127.0.0.1
student number = 123
student name = lsg
cln_port= 36082, cln_addr=127.0.0.1
student number = 456
student name = wangrui
```

client.c 进程1

```shell
root@6fb4b72f0c7c:/workspace/linuxc/chapter10socket/multi_clients# ./client 
Please input student number:
123
Please input student name:
lsg
Please input student number:
server answer is--msg from server: recv ok!
```

client.c 进程2

```shell
root@6fb4b72f0c7c:/workspace/linuxc/chapter10socket/multi_clients# ./client 
Please input student number:
456
Please input student name:
wangrui
Please input student number:
server answer is--msg from server: recv ok!
```

### 9.2 多进程

#### 9.2.1 实现原理
#### 9.2.2 代码演示

实现一个同时为多客户服务的服务器程序，服务器收到客户发送的数据后，就向客户回答“收到了”。多进程的方式现在很少了，基本都是多线程方式。

### 9.3 多路io

这里介绍原理，不进行代演示了。多路io有两种，分别是select和poll机制，他们的原理都是类似的。这种方式理论上也行，但是实际上真正的服务器并不采用这种方式来实现。

### 9.4 了解服务器是如何同时为多客户服务的意义

其实站在开发的角度来说意义不大，我们这里介绍这个主要目的，是想告诉大家服务器实现多客户的原理

我们的课程主要是面向嵌入式开发，不涉及服务器的开发，而且就算你是做服务器开发的，事实上服务器实现多客户的代码已经被服务器框架早就做好了（现成的），开发人员并不需要关心

+ 1）B/S模式下的服务器（浏览器访问的web服务器）

  web服务器每连接一个客户，服务器就开辟一个线程与客户通信，以实现为多客户服务，但是这个实现多客户的代码是由web服务器框架提供的，网站开发者不需要关心

  那开发网站做什么？  
  要做的就是实现html页面(界面)，将html页面写好后，将其保存到web服务器的硬盘上，当有客户与服务器建立连接，访问web时，web会为该客户开辟一个服务的线程，该线程就会将你要访问的html页面发送给你的浏览器，然后显示出来。

+ 2）C/S模式下的服务器（APP访问的服务器）

  一样的，多客户的代码也是由服务器框架现成提供的，更多的我们这里就不再介绍了。

  我们在前面的课程就介绍过，现在的服务器往往都是B/S、C/S混合模式，至于这个混合模式是怎么实现，介绍起来稍微有点麻烦，我们目前课程也不针对这个方向，所以我们这里不在介绍，而且我们本身也不是做服务器开发的，也不是这方面的专家，所以也很难讲到位。

## 10. 其它的函数

其实Linux所提供的网络编程API还有好些其它的，比如：

  ```c
  getnameinfo(...)
  getaddrinfo(...)
  gethostname(...)
  gethosetaddr(...)
  setsockopt(...)
  ...
  ```

其实c++、java等库API，同样有以上这些类似功能的函数，只不过是以类的形式进行了封装。

有关以上这些函数我们不再介绍，至于不再介绍的原因如下:

+ （1）课程时间太久了  
  我们的网络课程到目前为止，已经耗去相当长的时间，如果是再继续将这些函数，整个课程时间会拉的很长。

+ （2）不属于本课程的核心内容

  本课程的核心目的是想让大家深入的理解什么是网络编程，如何编程实现TCP/UDP通信，如果大家把这个核心理解了，事实上网络编程就算学会了，至于以上的这些函数，其实只能算是“旁枝末节”的知识。

  课程永远都是有一个核心的，核心就是把核心知识讲清楚，而且对大家学习来说，拦路虎永远都是核心知识，如果你将核心知识搞定了，其它细枝末节的只是，就应该是由大家自学完成的，因为大家要清楚，别人的讲授只是引导，最终更广更深的学习，一定还是要回归到自学上。

  我们希望的是授之以渔，而不是授之以鱼，如果是授之以鱼的话，我们课程会有讲不完的知识点。

+ （3）这些函数并不难（当然，并不是一点难度也没有）

  以上这些函数只是工具函数而已，这些工具函数的目的，只不过是想方便我们实现更加复杂的网络程序而已，这些函数最终都是基于我们之前所讲的核心功能来工作的，因此只要大家把之前的核心功能理解了，完全有能力自己弄明白。

  当然有关这些函数，我并不建议大家现在就去想办法弄明白，等到大家以后真的用到之后，再根据需求去学习，以需求来驱动学习，这样的学习效果会更好。
