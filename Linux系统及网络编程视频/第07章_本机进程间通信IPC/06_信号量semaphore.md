# 5. system V IPC  之  信号量(或信号灯)semaphore

讲到信号量，千万不要和上一章的信号搞混了，虽然中文名都有信号二字，但他们的英文名完全不一样，

+ 信号：signal
+ 信号量：semaphore

所以它们是两个完全不同的东西。

## 5.1 学习信号量的意义

本小节介绍的是“进程信号量”，后面还会讲“c线程信号量”。

进程信号量这个东西刚开始理解会有点饶头，但是只要抓住它原理核心后，你会发现这个玩意是如此的简单。

我们介绍进程信号量，不仅仅是因为多进程的程序有可能会用到信号量，更是因为有助于我们理解其它类似的“信号量”概念，比如：

+ （1）Ucos系统的信号量
+ （2）c线程的信号量
+ （3）java进程和线程的信号量

随着学习的深入，你会发现不管是哪一种信号量，他们原理和目的都是一样的，只是各自应用的场合有所不同而已，因此如果你能把进程的信号量理解清楚，其它信号量的理解都不是事。

## 5.2 信号量的作用

作用就是，当多个进程/线程进行共享操作时，用于资源保护，以防止出现相互干扰的情况。

再间简洁一点，信号量用于“资源的保护“。

+ （1）进程信号量  
  实现的是进程所操作资源的保护

+ （2）线程信号量  
  实现的是线程所操作资源的保护。

### 5.2.1 什么是进程资源保护

我们讲的是进程的资源保护，实际上线程的资源保护也是类似的原理。

为了更直观的讲解，我们直接通过例子来介绍什么是“进程资源保护”。

#### （1）例子1：多进程操作共享内存

比如，多个进程同时向共享内存里面写数据时，可能会出现数据相互干扰的情况。

比如，某个进程写数据操作还没有写完时，进程的时间片就到了，然后被切换到另一个写“共享内存”的进程上运行，这个进程会接着往共享内存里面写数据，此时显然就把第一个进程写的数据给隔断，这就形成了数据相互干扰。

如果只是普通数据的话无所谓，但是如果是很重要的数据的话，这种干扰是无法接受。

#### （2）例子2：多进程操作文件

比如当多个进程同时共享向文件里面写数据时，同样会出现和共享写“共享内存”相同的情况. 

为了避免出现以上所说的相互干扰的问题，就需要加入资源保护的措施，保护的目的就是，保证每个进程在没有把数据读、写完整之前，其它进程不能进行读、写操作，以防止干扰别人  

疑问：资源保护，这个“资源”到底指的是谁？    
答：这个资源指的就是你操作的数据，保护的目的就是不要出现相互干扰，导致紊乱和错误数据的产生  

### 5.2.2 资源保护操作的种类

资源保护的操作分两种，一种叫互斥，另一个种叫同步  

#### （1）互斥

对于互斥操作来说，多进程共享操作时，多个进程间不关心谁先操作、谁后操作的先后顺序问题，它们只关心一件事，那就是我在操作时别人不能操作。

就算当前正在操作的进程它的时间片到了，切换到了其它进程上，但是当该进程检测到上一个进程还没有操作完时，该进程在当前的时间片内会休眠，直到再次切换会上一个进程，将操作完成后再切换回来，此时才能进行操作。图：

这跟上厕所时把门关起来是一样的，我在蹲坑时你不能蹲，你在蹲坑时我不能蹲，这就是互斥，至于蹲坑先后顺序并没有要求。

#### （2）同步

**同步其实本身就包含了互斥，不过同步不仅仅只互斥，同步对于谁先操作、谁后操作的先后顺序有要求**

比如规定A进程先写，然后是B进程写，然后是C进程写，绝对不能出现这操作顺序以外的顺序。

所以所谓同步就是，多个共享操作时，进程必须要有统一操作的步调，按照一定的顺序来操作。	

疑问：同步有意义吗？
答：我们讲共享内存时，例子代码不就需要同步吗。

#### （3）实现同步、互斥，其实就是加锁

这个很形象，我要操作我就上把锁，我上锁的过程中你就不能操作，直到我把锁打开了，你才能操作，你操作时也会加锁，加锁后我就不能操作了。

所以说信号量就是一个加锁机制，通过加锁来实现同步和互斥。

说到加锁，我们讲到后面“高级IO”时，我们还会讲到“文件锁”这个东西，顾名思义，文件锁就是专门用来给文件时上锁的，讲到时在详细介绍。

其实，不管是进程还是线程，都存在同步和互斥的问题，同步和互斥的目的其实就是为了实现“资源”的保护，不要让数据（资源）出现紊乱。

#### （4）疑问：信号量既然是一种加锁机制，为什么进程信号量会被归到了进程间通信里面呢？

资源保护时，某个进程的操作没有完全完成之前，别人是不能操作的，那么进程间必须相互知道对方的操作状态，必须会涉及到通信过程。

所以信号量实现资源保护的本质就是，通过通信让各个进程了解到操作状态，然后查看自己能不能操作。

## 5.3 使用信号量实现互斥

进程信号量既能实现进程的互斥，也能实现进程的同步，不过有些“资源保护机制”就只能实现互斥，而不能实现同步。

虽然我们这里主要是讲互斥，但是也会捎带的提到同步，为后面讲同步打基础。

### 5.3.1 需要互斥实现“资源保护”的例子

比如前面介绍的多个进程共享写同一个文件的例子，会了方便起见，例子中的进程只有两个  
这两个进程可以是亲缘进程，也可以是非亲缘进程，同样为了举例的方便，我们使用亲缘进程来演示  

+ （1）代码演示： 略 
+ （2）为什么会出现所演示的情况？  
  因为在切换进程时，往往只写了一个“hello”或者“hhhhh”后，就被切换到另一个进程，该进程会继续写数据，如此就对上一个进程所写数据产生了隔断。图：

### 5.3.2 进程信号量实现互斥的原理

#### （1）什么是进程信号量

简单理解的话，信号量其实是OS创建的一个共享变量，进程在进行操作之前，会先检查这个变量的值，这变量的值就是一个标记，通过这个标记就可以知道可不可以操作，以实现互斥。

#### （2）多值信号量和二值信号量

+ 1）二值信号量  
  也称**信号灯**一亮一灭很形象  
  同步和互斥时使用的都是二值信号量  
  二值信号量的值就两个，0和1，0表示不可以操作，1表示可以操作  
  通过对变量进行0、1标记，就可以防止出现相互干扰情况

+ 2）多值信号量  
  信号量的最大值>1，比如为3的话，信号量允许的值为0、1、2、3 
  多值信号量用的不是很多，所这里只简单的提一下  
  
+ （3）信号量集合  
  我们说信号量其实是一个OS创建的，供相关进程共享的int变量，只不过我们在调用相关API创建信号量时，我们创建的都是一个信号量集合，所谓集合就是可能会包含好多个信号量  
  + 用于互斥时，集合中只包含一个信号量    
  + 用于同步时，集合中会包含多个信号量，至于多少个，需要看情况  

+ （4）信号量的使用步骤  
  + 1）进程调用semget函数创建新的信号量集合，或者获取已有的信号量集合。
  + 2）调用semctl函数给集合中的每个信号量设置初始值
  + 3）调用semop函数，对集合中的信号量进行pv操作
    什么是pv操作？pv操作其实说白了就是加锁、解锁操作  
    + （a）P操作（加锁）：对信号量的值进行-1，如果信号量的值为0，p操作就会阻塞. 图：
    + （b）V操作（解锁）：对信号量的值进行+1，V操作不存在阻塞的问题. 图：
    总之通过pv操作（加锁、解锁），就能够实现互斥，以防止出现干扰。

    正如我们前面总结的，加锁、解锁就跟上厕所蹲坑把门栓起来，完事了再把门打开是一样的，上厕所时通过门栓的加锁和解锁，就实现了上厕所蹲坑的互斥，防止上厕所的相互干扰  
  + 4）调用semctl删除信号量集合  

### 5.3.3 信号量相关的API

#### （1）semget函数

##### 1）函数原型

```c
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/sem.h>
int semget(key_t key, int nsems, int semflg);
```

sem就是semaphore的缩写

+ （a）功能  
  > 根据key值创建新的、或者获取已有的信号量集合，并返回其标识符。
  + 实现互斥时：集合中只需要一个信号量
  + 实现同步时：集合中需要多个信号量

+ （b）参数  
  + key：设置同消息队列和共享内存。一般都使用ftok获取key值  
  + nsems：指定集合中信号量的个数  
    用于互斥时，数量都指定为1，因为只需要一个信号量  
    如果是同步的话就需要至多为多个，至于到底是多少个，讲到同步时再说  
  + semflg：设置同消息队列和共享内存。一般都设置为`0664|IPC_CREAT`

+ （c）返回值  
  + 调用成功则返回信号量集合的标识符
  + 失败则返回-1，并且errno被设置

##### 2）代码演示  [参考代码](my_ipc/mutex)

#### （2）semctl函数

##### 1）函数原型

```c
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/sem.h>

int semctl(int semid, int semnum, int cmd, ...);
```

+ （a）功能  
  根据cmd的要求对集合中的各个信号量进行控制，...表示它是一个变参函数，如果第四个参数用不到的话，可以省略不写。
+ （b）返回值
  + 调用成功返回非-1值  
  + 失败则返回-1，errno被设置  
+ （c）参数说明  
  + semid：信号量标识符。通过标识符就能找到信号量集合  
  + semnum：集合中某个信号量的编号  
    信号量的编号为非负整数，而且是自动从0开始编号的. 通过信号量编号就能找到集合中对应信号量，然后对这个具体的信号量进行控制操作  
  + cmd：控制选项  
    + IPC_STAT：将信号量的属性信息从内核读到第四个参数所以指定的struct semid_ds缓存中  
    + IPC_SET：修改属性信息，此时也会用到struct semid_ds结构体变量. 具体的修改方法同消息队列和共享内存  
    + IPC_RMID：删除信号量，当集合中所有的信号量都被删除后，信号量集合也就被删除了  
      删除操作时第四个参数用不到，所以第四个参数省略不写。比如：`semctl(semid, 0, IPC_RMID);`
    + SETVAL：通过第四个参数，给集合中semnu编号的信号量设置一个int初始值  
      在前面就说过，如果是二值信号量的话，设置初始值要么是0，要么是1，如果信号量的目的是互斥的话，基本都是设置为1  
      当设置为1后，多几个进程互斥操作时，那就是谁先运行就谁先操作  如果是同步的话，初值是1还是0，这要就要看具体的情况了  
    + 其它选项：省略
    + `...` 表示，如果用不到时可以省略不写  
    其中信号量的IPC_STAT、IPC_SET、IPC_RMID与消息队列和共享内存的IPC_STAT、IPC_SET、IPC_RMID是一样的  
    但是SETVAL确属于进程信号量所独有的选项, **对于信号量来说，IPC_RMID、SETVAL是最常用的两个选项**  

    通过前面cmd的介绍我们可以看出，第四个参数具体设置为什么其实是不一定的，比如

    + cmd为IPC_STAT：第四个参数应为struct semid_ds类型的缓存  
      有关struct semid_ds结构体我们不再介绍，因为与共享内存的struct shmid_ds，以及消息队列的struct msqid_ds结构体是类似的  
    + cmd为SETVAL：第四个参数应该设置为一个int的值，用于初始化信号量  
      从以上可以看出，第四个参数对应内容是变着的，为了应对这种变化就用到了一个联合体

      ```c
      union semun {
         int              val;
         struct semid_ds *buf;
         unsigned short  *array;  /* 不做要求 */
         struct seminfo  *__buf;  /* 不做要求 */
      };
      ```

      这个联合体类型并没有被定义在信号量相关的系统头文件中，我们使用这个联合体时，我们需要自己定义这个类型，至于联合体类型名可以自己定，不过一般都是直接沿用semun这个名字
      成员：
      + val：存放用于初始化信号量的值; 
      + buf：存放struct semid_ds结构体变量的地址

      有关联合体的详细讲解，请看《C深度解析课》这门课，联合体的介绍属于基础课程的内容，所以我们这里不再赘述。
      疑问：这个联合怎么用？

      + 例1：当需要指定struct semid_ds缓存时

        ```c
        union semun sem_un; //定义一个联合体变量
        struct semid_ds buff; //定义一个struct semid_ds缓存

        sem_un.buf = &buff;  //现在整个联合体的值就是buf中缩放的buff的地址
        semctl(semid, 0, IPC_STAT, sem_un); //这里将联合体传递给semctl函数，其实就是将buff的地址传递给了semctl函数
        ```

      + 例2：当需要指定信号量的int初始值时  

        ```c
        union semun sem_un;
        sem_un.val = 1;  //现在整个联合体的值就是1
        semctl(semid, 0, IPC_STAT, sem_un);
        ```

##### 2）代码演示	

+ （a）初始化信号量集合:其实就是给集合中的每个信号量设置一个初始值。
+ （b）删除信号量

代码参考 [semctl的使用](my_ipc/mutex_semctl)

结果：
+ 编译命令式为 `gcc main.c sem.c -o main`, 执行`./main`,观察生成的file文件，其中可以搜索到"hello hhhhh"和"hhhhh world"这样明显是进程抢占引起地打印混乱
+ 按下Ctrl+C后程序退出，临时文件semfile自动删除,用`ipcs -s`命令查看可以看到信号量集合也已经被自动清理

#### （3）semop函数

##### 1）函数原型

```c
#include <sys/types.h>
#include <sys/ipc.h>
#include <sys/sem.h>

int semop(int semid, struct sembuf *sops, unsigned nsops);
```

op是operate操作的意思。

+ （a）功能：对指定的信号量进行p操作、或者是v操作。
  + p操作：将信号量的值-1, 当信号量的值为0时，p操作默认是阻塞的。
  + v操作：将信号量的值+1v操作不存在阻塞的问题。

  对于二值信号量来说，v操作后，值就从0变为了1，这就表示我操作完了，其它进程运行时就可以进行p操作了。

+ （b）返回值：调用成功返回0，失败则返回-1，errno被设置。

+ （c）参数
  + semid：信号量集合的标识符。
  + sops：这个参数更好理解的写法是`struct sembuf sops[]`，第三个参数nsops就是用于指定数组元素个数的。

    每一个数组成员对应一个信号量，每一个元素都是一个struct sembuf结构体变量，内部成员的决定着：
    + 你要对集合中哪一个信号量进行操作
    + 要进行的是p操作呢，还是v操作

    结构体成员

    ```c
    struct sembuf
    {
      unsigned short sem_num;  
      short          sem_op;
      short          sem_flg;  
    }
    ```

    这个结构体不需要我们自己定义，因为在semop的头文件中已经定义了。

    如果你无法判断这个结构体是否需要我们自己定义，那你就不要定义，如果编译提示这个结构体类型不存在，就说明需要自己定义，编译通过就说明在系统头文件中早就定义好了。

    + sem_num：信号量编号，决定对集合中哪一个信号量进行pv操作
    + sem_op：设置为-1，表示想-1进行p操作，设置1表示想+1进行v操作
    + sem_flg：
      + IPC_NOWAIT  
        一般情况下，当信号量的值为0时进行p操作的话，semop的p操作会阻塞。如果你不想阻塞的话，可以指定这个选项，NOWAIT就是不阻塞的意思。
        不过除非某些特殊情况，否则我们不需要设置为非阻塞。

      + SEM_UNDO  
        功能是防止死锁. 还是以二值信号量为例，当进程在v操作之前就结束时，信号量的值就会一直保持为0，那么其它进程将永远无法p操作成功，会使得进程永远休眠下去，这造成就是死锁，但是设置了SEM_UNDO选项后，如果进程在结束时没有V操作的话，OS会自动帮忙V操作，防止死锁  
        死锁可以理解为人死了把锁的钥匙带到坟墓里去了，别人没有人能打开，除了上帝(OS)  

##### 2）代码演示

实现p v操作， [我实现的代码](my_ipc/mutex_semop_final)
结果分析:

+ 编译命令式为 `gcc main.c sem.c -o main`, 执行`./main`,观察生成的file文件，其中已经没有"hello hhhhh"和"hhhhh world"的打印了，可见pv操作成功将父子进程的多个write语句原子化了
+ 按下Ctrl+C后程序退出，临时文件semfile自动删除,用`ipcs -s`命令查看可以看到信号量集合也已经被自动清理

## 5.3 使用信号量实现同步

有了前面信号量互斥的铺垫，学习信号量同步时，你会发现同步并不难  

### 5.3.1 什么是同步

让多个进程按照固定的步调做事，我们前面就说过，同步本身就是互斥的。实现同步时，同步的进程可以是亲缘进程，也可以是非亲缘进程  

### 5.3.2 同步举例1

通过同步让三个亲缘进程按照顺序打印出111111、222222、333333  

我们这里通过这个例子是想告诉你什么是同步，所举的例子本身并没有什么实际的意义，至于在开发中，你自己使用信号量实现同步的目的是什么，这就由你自己来定了。

#### （1）代码演示

先看看没有同步时，三个亲进程的打印顺序。

#### （2）如何实现同步

+ 1）画图理解：

从刚才的分析中可以看出，有多少个进程需要同步，我们在集合中就需要创建对应数量的信号量。

+ 2）代码演示

  纠正之前删除信号量集合的错误说法：

  ```c
  int semctl(int semid, int semnum, int cmd, ...);
  ```

  删除信号量集合时，并不需要把所有的信号量都删除掉后才能删除，只需要指定semid和IPC_RMID就可以不把整个信号量集合删除，其中第二个参数semnum没有被用到，所以semnum的值可以随便写，不过我们一般都是把它写为0。

  所以删除整个信号量集合时，删除的写法可以统一的为：

  ```c
  semctl(semid, 0, IPC_RMID);
  ```

### 5.3.3 同步例子2：

使用信号量来解决共享内存的同步问题

+ （1）图：
+ （2）代码演示

从共享内存和信号量配合中可以看出，在实际的进程间通信中，不同种类的进程间通信往往是相互配合使用的。
