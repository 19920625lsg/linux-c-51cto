# 标准IO的三种缓冲

这个在讲第3章已经讲的非常清楚了，不过这里还是要再来回顾下；

+ 1）标准io函数对文件io函数进行封装时，标准io函数会开辟库缓存 图：

  调用数据时，库缓存会对数据进行缓冲。

+ 2）为什么需要对数据进行缓冲, 什么时缓冲？
就是不要讲缓存中的数据立即输出，先积压在缓存中，调用标准io时，为了不要频繁的调用文件io函数，标准io的缓存有三种缓冲

所谓缓冲就是，数据先在文件io的缓存中加压着，满足某种情况时，再调用文件io一次性调用文件io，将数据输出，然后标准io的缓存就得打了刷新(数据被清空)

直接调用文件IO时，数据没有缓冲（没有积压），只要缓存有数据就输出

缓冲的情况有三种:无缓冲、行缓冲、全缓冲

## 1）无缓冲

无积压，有一个就调用文件IO函数输出一个。

什么时候使用无缓存？

标准出错输出时，因为出错信息很重要，不能积压，需要直接输出打印，提示除了什么错误。

```c
fprintf(stderr, "open fail");
            |
            |
lbuf[1024] = "open fail";
write(2, lbuf, sizeof(lbuf));
```

不会积压，有个一个字符，就调用一次write输出。

## 2）行缓冲

### （a）什么是行缓冲？

标准io缓存会积压数据，所谓行缓冲就是，如果积压的数据满足一行时，就一次性调用write输出。

怎样算是一行，一般来说数据中跟\n就表示一行，就好比人说话，停顿了就表示一句话

### （b）什么时候合适使用行缓存

当使用标准输出，将数据打印到屏幕显示时，就是行缓冲

为什么是行缓冲？

打印到屏幕，涉及到人机交互，以一行为依据来进行交互时最合适的，如果无缓冲，有一个数据就调用write输出，这样效率又太低，关键是使用标准输出打印的都是普通信息，不像出错信息，不用那么着急显示出来，所以有挤压也很正常。

针对行缓冲的这种情况，什么时候会把缓存中的数据刷新输出？

+ 1）如果数据中有\n，\n表示这就是一句完整的话，标准IO缓存中的数据就会被刷新输出

  ```c
  fprintf(stdout, "hello\n"); //或者写成printf("hello\n");
              |
              |
  lbuf[1024] = "open fail";
  write(1, lbuf, sizeof(lbuf));
  ```

+ 2）如果没有`\n`，但是标准Io缓存被数据装满时，也会刷新输出

这就好比水盆的谁被装满溢出是一样的

一般这总情况很少见，因为标准io的缓存都很大，使用printf输出，不可能一次输出几千个字节，把标准Io的缓存都装满了

+ 3）既没有\n，标准IO的缓存也没有被填满，只要调用标准io函数fflsuh(stdout)刷新缓存，也会将积压数据调用文件write(1,...)输出。

+ 4）调用fclose（stdout）函数关闭时，也会刷新，因为fclose会自动调用fflsuh刷新。

## 3）全缓冲

向普通文件写数据时，标准IO的缓存就是全缓冲的

向普通文件输出时，需要先打开文件。

```c
fp = fopen("./file.txt", "r+");
            |
            |
            |struct FILE
            |{
            |  ...
            |   fd;
            |}
            |
fd = open("./file.txt", O_RDWR);

fp  ————> fd(3) ————————>./file.txt
```

### 1）缓存满，一般很少会把缓存填满的

为什么全缓冲规定要把缓存积压满在刷新输出，因为向文件输出数据时，往往要输出的数据量都很大，无缓冲肯定不行，效率太低，行缓存也不行，调用文件Io太频繁，最好是积压的越多越好，上限就是积压满后，一次性调用文件Io输出

```c
fprintf(fp, "hello wolrd\n", 12);
              |
              |
              |
lbuf[1024] = "hello wolrd\n";
write(3, lubuf, sizeof(lbuf));
```

### 2）调用fflsuh(stdout)刷新缓存，将积压数据输出。

向普通文件输出数据时，更多是调用fflsuh(stdout)主动刷新输出到文件。

### 3）调用fclose（stdout）函数关闭时，也会刷新，因为fclose会自动调用fflsuh刷新。

### 4）为什么使用exit、return正常终止进程时，为什么会刷新标准io缓存的原因？

使用exit、return正常终止时，exit会指定的调用flcose函数关闭标准io，而fclose关闭时又会自动的调用fflush刷洗标准io的缓存。

所以使用exit、return正常终止时，标准IO的缓存会被刷新。

基于同样的理由，调用_exit函数正常终止，肯定不会刷新缓存，只有exit函数才会去做这件事。