# 2. 进程（程序）的终止方式

进程终止方式有两种，一种是正常终止，另一种是异常终止。

+ 正常终止：好比人寿终正寝，正常老死。

+ 异常终止：好比人的非正常死亡。			

## 2.1 正常终止

进程主动调用终止函数/返回关键字所实现的结束，就是正常终止。

+ main调用return关键字结束
+ 程序任何位置调用exit函数结束
+ 程序任何位置调用_exit函数结束


### 1）main函数调用return关键字，实现正常终止

return关键字的作用是返回上一级函数，如果main函数的子函数调用return的话，返回的上一级是main函数。

如果main函数调用return的话，main函数所返回的上一级是启动代码。

main函数调用return有两种方式：

+ （a）显式调用
  比如：return 返回值；

  这个返回值也被称为进程的终止状态。

  + 返回值的意义
    返回值标记的了进程的终止状态，比如一般情况下。

    + return 0：正常结束
    + return -1：代表了某种操作失败
    + return -2：代表了另一种的操作失败

    当然什么值代表了什么操作失败，其实可以由程序员来自己规定。

    疑问：如果return时我不写返回值会怎样呢？  
    答：编译能过，但是有警告，因为与main函数的返回值要求不相符合。明确的写出return，但是又不写明返回值的话，返回值不定，所谓不定的意思是，main函数最后一次调用的子函数所返回的返回值是多少，main函数就会使用这个返回值来返回  

    演示：  
    使用`echo $?`可以查看程序运行后的，main函数的返回值。  
    如果main函数没有调用任何子函数，而且return又没有返回任何值的话，默认返回-1  

    `疑问：返回值不定，是不是很危险？`  
    不定这个词听着很危险，但其实并不危险，因为一般情况下根本用不到这个返回值，所以“不定”也不是什么大事。  
    一般我们都会显式写出return，而且都会返回一个返回值，主要是你不这么做，编译器报警高，所以还是按照严格的写法来写。  

    疑问：是谁来接收这个返回值的，这个返回值可以用做什么？  
    加到后面课程时再来解释。  

+ （b）隐式调用：就是不明写出return，当main函数中的最后一句代码执行完毕后，会默认的调用return返回，不过隐式return时，默认返回0。  

### 2）在程序的任意位置调用exit函数

注意，我这里说的是，在程序中任何位置调用exit都有效，也就说不管是在main函数中调用，还是在main的子函数中调用，甚至是在子函数的子函数中调用都是有效的。

其实，main函数调用return返回到启动代码后，启动代码也是调用exit函数来实现正常终止的。

+ （a）exit函数原型
  
  ```c
  #include <stdlib.h>
  void exit(int status);
  ```

  看到stdlib.h这个头文件，我们就知道exit函数是一个c库函数

  这个参数就是返回值(进程终止状态)

  main函数调用return将返回值返回给启动代码后，启动代码又会调用exit(返回值)，将返回值返回

+ （b）代码演示

### 3）在程序的任意位置调用_exit函数

  `_exit`是一个系统函数(系统API)，而exit是c库函数，exit就是调用`_exit`来实现的  
  既然exit也是靠调用`_exit`来实现的，那么我们也就可以直接调用`_exit`了   
  不过更多时候，我们调用的还是`exit`函数，因为`exit`对`_exit`封装后，`exit`额外还做了好些事情，至于做了些什么事情，这个留到后面再来解释  

+ （a）_exit函数原型

  ```c
  #include <unistd.h>
  void _exit(int status);
  ```

  用法与exit一样。

+ （b）代码演示

#### 4）return、exit和_exit的返回值问题

前面说过return、exit和_exit的返回值，也被称为进程终止状态。

+ （a）裸机时：
  + 只能调用return返回，因为没有OS时，不支持exit和_exit函数。

  + 裸机时，main的return到启动代码后，返回动作到启动代码就截止了。

  + 在裸机情况下，一般来说main函数所return的返回值，对启动代码来说没有太大意义

  所以在裸机下，main函数return返回什么值都无所谓，这也是为什么大家在写单片机的C程序时，会感觉到main函数return的返回值没什么意义。

  在早期的单片机c程序中，main函数的返回值类型往往都是void，不需要返回值，不过现在main函数的格式要求严格了，所以就算“启动代码”并不需要这个返回值，但是我们还是要写一个return 0，保证main函数有正确的格式，只有这样编译时才不会有格式警告。

+ （b）有OS时
  `return`、`exit`、`_exit`，使用哪种来返回都行

  但是我们推荐大家使用`return`、`exit`，因为`_exit`是Linux OS的系统调用，在windows就不支持了。

  + `return`

    ```c
              main函数           启动代码          
    return(0)  ——————>  exit(0)  ————————> _exit(0) ————> Linux OS
    ```

  + `exit`		 
    
    ```c
    exit(0)  ————————————> _exit(0) ————> Linux OS
    ```

  + `_exit`
    
    ```c
    _exit(0) ————>Linux OS
    ```
    
    有OS时，不管是采用哪种方式实现正常终止，返回值都会被返回给OS。

    疑问：将返回值返回给OS有什么意义呢？
    一般情况下没有意义，但是在有些特殊情况下是有意义的，只不过这种情况很少见，有关这个问题我们留到进程控制时再来详细解释。

## 2.2、异常终止

进程不是因为return、exit和_exit函数而终止的，而是被强行发送了一个信号，这个信号将进程给无条件终止了，这就是异常终止。

有关什么信号，在后面讲信号的章节，还会详细的介绍。

+ 1）自杀：自己调用abort函数，自己给自己发一个SIGABRT信号将自己杀死，杀人凶器是信号；代码演示：

+ 2）他杀：由别人发一个信号，将其杀死，杀人凶器也是信号
    思考：为什么按下ctrl+c，就可以将程序终止  
    演示：其实向终端输入ctrl+c时，就是在向我的进程发送某个信号，然后这个信号将我的程序给异常终止了  

## 2.3 atexit函数

### （0） 函数原型

  ```c
  #include <stdlib.h>

  int atexit(void (*function)(void));
  ```

  这是一个C库函数。


### （1）功能：注册（登记）进程终止处理函数，参数就是被登记“进程终止函数”的地址。

当进程无论什么时候正常终止时，会自动的去调用登记的进程终止处理函数，实现进程终止时的一些扫尾处理。

注意：我这里强调的是正常终止，不是异常终止。

### （2）返回值 

函数调用成功返回0，失败返回非零值，不会进行错误号设置。					

### （3）参数function

需要被注册的进程终止处理函数的地址。
如果你的C语言过关了的话，你一看就知道function为void (*)(void)的函数指针类型。

### （4）代码演示

#### 1）从例子可以看出，进程终止处理函数的注册顺序和调用顺序刚好相反。

为什么顺序刚好相反呢？  
这就是涉及到atxit函数的注册原理了。

调用atexit注册时，会将“进程终止处理函数”的函数地址压入进程栈中，当进程正常终止时，又会自动从栈中取出函数地址，并执行这个函数，实现进程的扫尾操作。

栈的特点是先进后出，先压栈的后调用，所以调用顺序刚好和注册顺序相反。

#### 2）在Linux下，调用atexit最多可以允许登记32个终止处理函数。	

#### 3）同一个函数如果被登记多次，自然也会被调用多次。

#### 4）在两种情况下，登记的进程终止处理函数不会被调用

+ （a）异常终止，不会调用

+ （b）直接调用_exit来正常终止时，不会调用

换句话说，只有使用return和exit来正常终止时，才会调用。

### （5）登记“进程终止处理函数”有什么意义？

我们有的时候需要在进程正常终止时，做一些扫尾操作，比如将链表数据保存到文件中。

不过如果不使用进程终止处理函数的话，这个操作有点困难，因为进程有时候可能是因为某个函数调用失败，然后在函数出错处理时调用exit(-1)终止的，但是你又无法预估哪一个函数会出错，并在出错时调用相应的函数实现链表数据的保存，那怎么办呢？

这个时候就可以注册进程终止处理函数来实现了，因为进程终止时，会自动的调用终止处理函数来实现进程的扫尾处理，比如将链表数据保存到文件中。

## 2.4 有OS时，进程从启动 到 正常终止的全过程

### 2.4.1 图示

思考：为什么_exit正常退出时，不会调用进程终止处理函数？  
因为只有调用exit时，才会去调用“进程终止处理函数”  

### 2.4.2 为什么调用exit、return正常终止时，会刷新标准io的缓存		

有关标准IO的库缓存的缓冲有三种，无缓冲、行缓冲、全缓冲，有关这三个是怎么回事，我们在第三章标准io中，已经讲得非常清楚了，不清楚的同学，请认真回看第三章。

#### （1）回顾行缓冲

标准输出（printf）的库缓存就是行缓冲的，在缓存中积压的数据，直到出现以下情况时，才会刷新输出，否则就一直挤压着。

+ 1）遇到\n时就刷新输出，\n表示这是一行，就好比句号表示一句话一样。演示：

+ 2）库缓存中数据满了，也会自动刷新输出，这就好比盆里的水满了溢出一样。不过一般来说，数据不可能多到能够把缓存装满的。

+ 3）调用标准fflush函数，主动刷新数据

+ 4）调用fclose关闭标准输出时，会自动调用fflush刷洗数据

#### （2）为什么调用exit正常终止时，会刷新标准io的缓存呢？

因为exit会调用fclose关闭所有的标准io，关闭时会自动调用fflush来刷新数据。

这里要注意：如果进程时异常终止的话，是不会刷新缓存区的，因为异常退出时，跟exit函数半毛钱关系都没有  

## 2.5 命令行参数

在命令行执行c程序时，可以输入命令行参数并传递给main函数的形参，然后进程就得到了命令行的参数。

其实在命令行执行c++、java程序时，也可以使用同样的方法，给进程传递命令行参数。

### （1）命令行参数的用处

我们在第2章时，实现了一个my_ls程序，用于模拟ls命令，显示文件属性，执行my_ls时，就需要跟接参数。

所有命令（程序：ls）的选项和参数，都是通过命令行参数得到的，所以对于命令行来说，命令行参数是很有用的东西。

### （2）代码演示		

第一个参数永远都是程序名。

### （3）将命令行参数传递给main函数形参的过程

```c
                        构建指针数组                  exec
./a.out *** *** ——————> 终端窗口进程 ——————> OS 内核 ——————> 启动代码 ——————> main函数形参
```
