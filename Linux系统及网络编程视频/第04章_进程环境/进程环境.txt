
课程内容：

1. 启动代码 
	
	1.1 启动代码的作用
			在上堂课就说过，顾名思意就是用来启动整个程序的代码，所有高级语言的程序，都有自己的启动代码。
			
			C程序运行时，最开始运行的是启动代码，启动代码再去调用main函数，然后整个C程序都已运行。
		
						.......
						   |
							 |
						 子函数
							 |
							 |
				    子函数  
							 |
							 |
						main函数
							 | 
							 |
						启动代码
		
			
				总之，高级语言程序 = 启动代码 + 自己代码。
											

				所以，C的启动代码其实才是整个c程序的开始代码，不过由于启动代码并不是我们自己写的，所以很多初学的同学并不知道还有启
			动代码这回事。
				
			疑问：启动代码都做了些什么呢？
			后面再介绍。
			
			
			
	1.2 启动代码是由谁提供的
	
		（1）启动代码一般都是由编译器提供的，一般有两种提供方式
				
				1）源码形式

						以源码形式提供时，编译器会将启动代码的源文件和自己程序的源文件一起编译。
						
																	 			 编译
							启动代码.c   ————————————————————————————> ***.o    \
																																	 \
																																		\  链接
																																		 ————>  可执行文件（可执行程序）
																																		/
																				 编译  				             /
							我的程序 ***.c ***.c ... ——————————> ***.o ***.o .../
							
							
							
						比如我们后面学习单片机时，像开发单片机这种没有OS的计算机的C程序时，启动代码一般是源码形式提供的，
					后面讲到单片机时，大家就能见到这种情况。
						
						当然像单片机这种没有OS的裸机程序的启动代码都很简单。
						
						
						
				2）二级制的.o（目标文件）形式
					直接以.o形式提供时，省去了我自己对“启动代码”的编译。

																							  启动代码
																							***.o ***.o    \
																										           \
					                                                      \  链接
																										             ————>  可执行文件（可执行程序）
																											          /
															        编译  				           /
					我的程序 ***.c ***.c ... ——————————> ***.o ***.o .../
	
	
					一般来说，如果开发的程序是运行在OS上时，那么编译器一般是以.o形式来提供启动代码，比如我们gcc a.c时，gcc就是以.o形
				式提供的，基于OS运行的程序的启动代码，相对而言，自然比较复杂些。
					
					gcc时加一个-v选项，查看gcc编译链接的详细情况时，可以看到有很多.o，这些.o就是gcc提供的启动代码。
					
					
		（2）gcc -v
		
					在一般情况下，不管是在命令行使用gcc命令（编译程序）方式编译还是使用IDE的图形界面方式编译，编译链接的中间过程都
				被省略了，当然图形化的编译方式，最终调用的还是gcc这种编译程序来实现的，只不过一个图形化调用的，另一个是在命令行输入
				命令来调用的，但是本质是一样的。
					
					由于编译的过程被屏蔽了，因此大家对启动代码基本没有什么感觉。
					
					演示：
					gcc -v a.c
					
					 /usr/lib/gcc/x86_64-linux-gnu/5/collect2 -plugin /usr/lib/gcc/x86_64-linux-gnu/5/liblto_plugin.so 
					 -plugin-opt=/usr/lib/gcc/x86_64-linux-gnu/5/lto-wrapper -plugin-opt=-fresolution=/tmp/ccgWwfyD.res 
					 -plugin-opt=-pass-through=-lgcc -plugin-opt=-pass-through=-lgcc_s -plugin-opt=-pass-through=-lc 
					 -plugin-opt=-pass-through=-lgcc -plugin-opt=-pass-through=-lgcc_s --sysroot=/ --build-id --eh-frame-hdr 
					 -m elf_x86_64 --hash-style=gnu --as-needed -dynamic-linker /lib64/ld-linux-x86-64.so.2 -z relro 
					 /usr/lib/gcc/x86_64-linux-gnu/5/../../../x86_64-linux-gnu/crt1.o 
					 /usr/lib/gcc/x86_64-linux-gnu/5/../../../x86_64-linux-gnu/crti.o 
					 /usr/lib/gcc/x86_64-linux-gnu/5/crtbegin.o 
					 -L/usr/lib/gcc/x86_64-linux-gnu/5 
					 -L/usr/lib/gcc/x86_64-linux-gnu/5/../../../x86_64-linux-gnu 
					 -L/usr/lib/gcc/x86_64-linux-gnu/5/../../../../lib -L/lib/x86_64-linux-gnu 
					 -L/lib/../lib -L/usr/lib/x86_64-linux-gnu 
					 -L/usr/lib/../lib -L/usr/lib/gcc/x86_64-linux-gnu/5/../../.. /tmp/ccZBIWKc.o 
					 -lgcc --as-needed -lgcc_s --no-as-needed -lc -lgcc --as-needed 
					 -lgcc_s --no-as-needed /usr/lib/gcc/x86_64-linux-gnu/5/crtend.o 
					 /usr/lib/gcc/x86_64-linux-gnu/5/../../../x86_64-linux-gnu/crtn.o

					
					在编译的详细信息里面，有很多的事先就被编译好的.o文件，这些.o文件就是用来生成启动代码的。
					
					gcc -v显示的详细信息，在讲《c语言深度解析》时，有过较为详细的介绍，不清楚的同学请看《c语言深度解析》。
					

					
	1.3 启动代码做了些什么			
			
			
		1.3.1 启动代码使用什么语言编写的 
					基本都是汇编写的。
			
			
		1.3.2 启动代码大致做了些什么呢？

				大致上有两件重要的事情：
				
				· 对c程序的内存空间进行布局，得到c程序运行所需要的内存空间结构。
			
				· 留下相应库接口
		
		
			（1）对c内存空间进行布局
					
						我们前面说过，c等高级语言程序在运行时，函数调用需要“栈”，启动代码就需要在c内存空间上建立“栈”，说白了就是从
					从c内存空间中划出一段空间，然后以“栈”的形式来进行管理。
					
					· 疑问：栈是怎么建立起来的？
							后面讲uboot移植时，uboot的最开始的汇编代码就是启动代码，其中有一段汇编代码就是用来建立栈空间的，讲到uboot时在
						来详细介绍。
							
							当然uboot比较特殊，平时进行c程序开发中，我们都不需要关心启动代码，因为都由编译器自动提供了，所以对于启动代码这个
						东西，我们不用深究，而且深究明白了也就那么点东西，对实际开发来说意义不大。
						
							因此关于启动代码，重点是理解什么是启动代码，它大概是一个什么样的存在。
							
							
					· 思考：为什么启动代码，基本都是使用汇编来编写？
					
							在程序的内存空间结构还没有布局起来之前，高级语言程序还无法运行，此时只能使用汇编，当利用汇编编写的启动代码
						将高级语言的内存空间结构建立起来后，自然就可以运行c/c++等高级语言的程序了。
					
					
				（2）为库的调用预留接口
						如果程序使用的是动态库的话，编译时，动态库代码并不会被直接编译到程序中，只会留下相应的接口，程序运行起来后，
					才会去对接库代码，为了能够对接动态库，启动代码会留下动态库的对接接口。
					
					
				（3）等等
						如果是c++等面向对象的启动代码的话，还会做一些其它的事情，我们这里就不介绍了。
				
		
	1.4 程序是如何运行起来的
		
			分两种情况来看，一种是裸机的情况，另一种是有OS的情况。
		
		
		1.4.1 裸机的情况 
		
					什么是裸机，就是没有OS。
					
					如果说你学过单片机（51、stm32）、ARM等裸机的话，那么你对我所要描述的裸机程序的运行过程不会陌生，当然不熟悉
				也没关系，因为原理本来不复杂。
					
					
					裸机也分两种情况，内存和硬盘一体式，以及内存和硬盘分开式。
					
					
			（1）内存和硬盘一体式
					
					1）典型的比如以51单片机，为了设计的方便，51没有单独的内存和单独硬盘，使用的是内存和硬盘功能二合一的norflash。
							
							像单片机这种，程序都是直接放在norflash上的，此时norflash既是内存也是硬盘，同时身兼两者的功能。
						
						
						（a）为什么能身兼内存的功能？
								因为norflash的访问速度很快，因此cpu能够直接从norflash上读取指令并执行，此时norflash就是一个内存。
						
						
						（b）为什么身兼硬盘的功能？
								因为norflash能够永久保存数据，设备关电后，数据依然存在，所以将程序下载到norflash后，关机重上电，程序依
							然还能运行。
							
							
							
					2）程序运行的过程
							图示：
					
						（a）在PC上使用安装好的IDE等开发环境，来编写、编译我们的源码程序，得到可执行程序（可执行文件）
						（b）在PC上运行下载程序，这个下载程序会通过数据线，将pc上编译好的程序下载到单片机的norflash中。
							
						（c）将norflash中的第一条指令的地址放到pc（计数器）中，通过pc中的地址，cpu就可以读取norflash中存放的指令并执行。
								
								每执行一条，pc就存放下一条指令的地址，如此循环往复下去，整个程序就运行起来了。
					
					
								
									
									
								如果你不理解什么是PC，不理解CPU的工作原理大概是怎样的，请看《计算机体系结构》硬件篇2——计算机组成这部分
							课程，里面有详细介绍。
							
							
				
				
			（2）内存和硬盘分开式		

						除了单片机这种，像pc、手机、平板、服务器这种我们常见的、传统的计算机，内存和硬盘都是分开的。
						
						
					1）为什么传统的计算机，硬盘和内存都是分开的
					
								因为像单片机这种内存和硬盘二合一的norflash形式，由于造价太高，只适合于单片机这种小容量的设备使用，
							如果是手机、PC、平板这样的设备，内存和硬盘都要求很大，norflash这种二合一形式价格很高，不合适。
						
						
								所以像手机、PC、平板、服务器，使用的还是传统的内存和硬盘分开的这种方式，既内存和硬盘各是各。
								
								
								我们后面要学习的ARM的2440和4412开发板，典型的就是属于这样的情况，所以ARM芯片可以用来设计手机、平板等，
							不过ARM很少用在PC和服务器上，因为PC和服务器使用的基本都是intel的芯片。
							
							
							1）传统的内存：cpu能够快速访问，但是掉电丢失数据
							
							2）传统的硬盘：可以容量做的很大，掉电不丢失数据，但是访问速度很慢
								
								各自的优点刚好是对方的缺点，所以二者相互配合使用，同样能起到与norflash一样的二合一的效果，而且容量更高，
							单位造价更低。
							
							
								目前手机、平板等小型设备，使用的是nandlfash这种电子硬盘，pc和服务器使用的基本都是磁盘这种机械硬盘，
							nandflash相比磁盘来说，更稳定，体积更小，当然价格要高很多，但是在未来当nandflash价格下降后，PC和服务器的
							硬盘肯定慢慢的会被nandflash取代，目前已经能够看到这样的趋势。
							
								当然如果norflash的价格也下降了的话，norflash这种内存硬盘二合一的形式，也许慢慢的也会变成主流，这也是未可知的。

								如果对内存、硬盘、norflash、nandlfash等存储概念不明白的话，请大家看《计算机体系结构》硬件篇3——存储器部分
							的课程。
					
								像内存和硬盘分开的这种情况，一般都要运行OS的，很少直接以裸机方式来来使用。

					
					
					2）内存和硬盘分开的这种情况，如果直接以裸机方式使用的话，程序是如何运行起来的
							
							两种：
							第一种：直接将下载到内存中，然后运行。
							第二种：先下载硬盘永久保存，开机时自动从硬盘中将代码拷贝到内存上，然后运行。
					

					
						（a）将程序直接下载到内存
									
									
									这种方式很简单，开发板上电后，在PC上运行下载程序，直接将pc上编译好的代码下载到内存上，在pc中存放第一
								条指令的地址，然后整个程序就运行起来了。
							
									这种方式最大的缺点就是掉电就没了，因为传统的内存掉电后数据就没了，所以这种方式只适合于平时的测试。
					

					
						
						（b）将程序下载到硬盘
								
								· 在PC上运行下载程序，将pc上编译好的程序下载到开发板硬盘上后，程序会被永久的保存起来。
								
								· 开机运行时，将硬盘上的代码拷贝到内存上
									裸机时，往往都是把代码全部拷贝到内存上。
								
								
								· pc指向内存中程序第一条指令，然后整个程序就运行起来了。
										
										疑问：是谁去让pc指向程序的第一条指令的？
										有关这个问题，我们这堂课就无法解释了，这个就留给单片机和ARM裸机的课程来解释。
						


								
								· 疑问1：到底是谁来实现这个拷贝的过程的
									
										有关这个问题，如果过在这里详细讲的话，将会是一个非常长话题，而且也很难说清楚，不过好在后面的ARM裸机课程，
									会进行非常详细介绍，所以详细情况，请看arm裸机课程。
									
										不过这里还是要简单的回答下，这个拷贝的过程需要我们自己写代码来实现。
									
									
									
									自己写的拷贝代码又是怎么运行起来的呢？
									同样，讲到ARM裸机课程时，再来解释。
				
				
		1.4.1 有OS的情况 		
				
				上OS的计算机，基本都是内存和硬盘分开式的情况。
				
				疑问1：为什么内存和硬盘分开式的计算机，基本都是要上OS呢？
				
					因为计算机资源相对丰富，有能力跑OS，如果不上系统直接裸机使用的话，这其实是在浪费计算机资源。
				
					这就好比人家本来就是当省长的料，但是非要让人家当村长，这就是在浪费人才资源。
					
				
				疑问2：OS是怎么运行启动起来的呢？
						OS也是一个程序，而且是一个很大的裸机程序（因为OS是直接运行在硬件上的），OS的运行过程其实就是前面讲的裸机程序
					的运行过程。
					
						OS的代码也是被永久的存放在了硬盘上，开机上电后，启动程序开始启动OS，启动时会将OS代码从硬盘拷贝到内存上，然后
					就运行起来了。OS和大多数裸机程序一样，都是开机自启动的。
					
					· windows的启动程序：bios
					· Linux的启动程序：uboot
						后面讲uboot移植的课程，会详讲uboot的工作原理。
					
						其实启动OS的“启动程序”跟我们自己写的拷贝代码的功能是一样的，只不过OS的启动程序会复杂很多，毕竟OS比如我们自己写
					的小裸机程序也复杂了很多。
						
						
					疑问：启动程序又是如何运行起来的呢？
						这个问题留到后面课程再来解释。
					
						当然本小节的重点并不是讲OS是怎么启动起来的，而是介绍基于OS运行的应用程序，是怎么在OS的支持下运行起来的。
					

				
					
			（1）有OS时，可执行程序都是直接放在了硬盘上
						
					· 如果开发的直接就是pc机程序的话
					
						在PC上编写、编译好后，可执行程序就放在了windows电脑的硬盘上，比如在C盘桌面上，然后在PC上直接运行即可。
					
					
					· 如果是Linux嵌入式开发的话
					
							在pc上编写、编译好程序后，需要将程序拷贝到开发板的硬盘上
				
							有了OS后，就有了文件系统，我们可以直接通过文件系统去访问硬盘上的各个目录，因此拷贝的过程非常简单，
						拷贝的过程其实就是从这个目录复制，然后粘贴到另外一个目录下的过程，与我们在Windows下复制粘贴的过程是
						一样的。
						
							其实在裸机上也可以安装文件系统，不过文件系统一般都是和OS配合工作的，有OS的时候，文件系统属于OS的一部分。
							
							
							
							
			（2）有OS时，程序如何运行起来

			
					1）有OS支持时，如何启动程序呢
						
						
						（a）裸机时，是怎么启动程序的呢？
								很简单，下载、或者上电后程序会立即执行（OS就是上电启动的），也就是说下载或者上电就是启动的动作，总之，我们
							不需要额外的动作去启动程序。
								
								关机程序就结束了，当然有OS的话，就算程序结束了，整个机器还是运行着的，因为OS还运行着。
						
						
							
						（b）有OS支持时，启动程序方式有三种
							
							· 双击快捷图标运行
							· 在命令行运行
								
							· 设置为开机自启动	
								所谓开机自启动，就是OS运行起来后，自动的将程序运行起来。
								
								不管使用哪一种方式来启动，启动后OS会将硬盘上的代码自动拷贝到内存上，然后让PC指向第一条指令，cpu取指执行，
							那么整个程序就运行起来了。
								
								
							· windows的情况
								
							· ubuntu的情况
								
								
							· ARM开发板
								- 图形界面：
										可能有，可能没有，如果运行的是像安卓这样的OS，就有图形界面，但是我们后面在进行Linux嵌入式开发时，开发板
									上运行的Linux系统就没有图形界面，因为我们运行的只是Linux OS的核心代码，核心代码没有图形界面。
										
										有同学可能有疑问，没有界面还有什么意义？
										有意义，因为很多嵌入式产品确实不需要图形界面，比如像路由器，路由器就不需要图形交互界面。
										
										有图形界面（安卓手机），可以通过快捷图标启动程序，没有的话就不行了。
										
										
								- 命令行
										我们后面在进行Linux嵌入式开发时，由于ARM开发板运行的Linux系统没有提供图形界面，那就只能通过命令行来
									操作了，而且命令行界面也是由PC提供的，因为开发板不像PC那么强大，提供不了，所以只能由PC来提供
									操作的命令行界面。
									
									
								- 开机自启动
										当嵌入式产品研发完毕，变成成品后，我们就需要将程序设置为开机自启动，以后嵌入式设备每次上电开机，Linux OS运
									行起来后后，会自动加载运行设置为了自启动的应用程序，当应用程序运行起来后，整个设备就在应用程序的控制下开始
									工作了。

									
							
					2）OS是怎么实现拷贝的
					
								对于我们自己写的裸机程序来说，我们需要自己写拷贝代码，开发板一上电，拷贝代码会自动运行，将硬盘上的程序拷
							贝到内存上运行起来。
								
								对于OS这个裸机程序来说，由启动程序来负责代码的拷贝。
								
								基于OS的应用程序运行时，它的拷贝的过程自然就由OS来实现。
					
					
							· OS具体是怎么实现拷贝的呢？
							
									不管使用哪一种方式来启动程序，启动后OS会调用exec函数（加载器），这个加载器去加载程序时，会自动的将硬盘上的
								代码拷贝到内存上运行起来，加载的过程其实就是拷贝的过程。
							
									只不过有OS时，特别是当OS有虚拟内存机制时，exec不会拷贝全部代码，只会拷贝当前运行所需要的代码，当这段代码
								运行完毕后，再拷贝另一段代码到内存中。

							
							
						3）总之，有了OS后吗，在OS的支持下，运行程序是一件很方便的事情
						
			
2. 进程（程序）的终止方式
		
		进程终止方式有两种，一种是正常终止，另一种是异常终止。
		
		· 正常终止：好比人寿终正寝，正常老死。
		
		· 异常终止：好比人的非正常死亡。			
	
		
	
	2.1 正常终止
		进程主动调用终止函数/返回关键字所实现的结束，就是正常终止。
		
		· main调用return关键字结束
		· 程序任何位置调用exit函数结束
		· 程序任何位置调用_exit函数结束
			
			
		1）main函数调用return关键字，实现正常终止
		
				return关键字的作用是返回上一级函数，如果main函数的子函数调用return的话，返回的上一级是main函数。
				如果main函数调用return的话，main函数所返回的上一级是启动代码。
				
				
				main函数调用return有两种方式：
				
			（a）显式调用
					比如：return 返回值；
					
					这个返回值也被称为进程的终止状态。
					
					· 返回值的意义
						返回值标记的了进程的终止状态，比如一般情况下。
					
						return 0：正常结束
						return -1：代表了某种操作失败
						return -2：代表了另一种的操作失败
						
						当然什么值代表了什么操作失败，其实可以由程序员来自己规定。
						
						疑问：如果return时我不写返回值会怎样呢？
						
						答：编译能过，但是有警告，因为与main函数的返回值要求不相符合。
							明确的写出return，但是又不写明返回值的话，返回值不定，所谓不定的意思是，main函数最后一次调用的子函数所返回
						的返回值是多少，main函数就会使用这个返回值来返回。
						
						演示：
						使用echo $?可以查看程序运行后的，main函数的返回值。
						
						
						
						如果main函数没有调用任何子函数，而且return又没有返回任何值的话，默认返回-1。
						
						
						疑问：返回值不定，是不是很危险？
							不定这个词听着很危险，但其实并不危险，因为一般情况下根本用不到这个返回值，所以“不定”也不是什么大事。
							
							一般我们都会显式写出return，而且都会返回一个返回值，主要是你不这么做，编译器报警高，所以还是按照
						严格的写法来写。
			
						
					· 疑问：是谁来接收这个返回值的，这个返回值可以用做什么？
							加到后面课程时再来解释。
							
							
							
				（b）隐式调用：就是不明写出return，当main函数中的最后一句代码执行完毕后，会默认的调用return返回，
						不过隐式return时，默认返回0。

						
			
		2）在程序的任意位置调用exit函数
				
				注意，我这里说的是，在程序中任何位置调用exit都有效，也就说不管是在main函数中调用，还是在main的子函数中调用，甚至
			是在子函数的子函数中调用都是有效的。
					
				其实，main函数调用return返回到启动代码后，启动代码也是调用exit函数来实现正常终止的。
				
		
			（a）exit函数原型
					#include <stdlib.h>
					
					void exit(int status);
						
						看到stdlib.h这个头文件，我们就知道exit函数是一个c库函数。
						
						
						这个参数就是返回值（进程终止状态）。
						
						main函数调用return将返回值返回给启动代码后，启动代码又会调用exit(返回值)，将返回值返回。
			
			
			
			（b）代码演示
			
		3）在程序的任意位置调用_exit函数
		
				_exit是一个系统函数（系统API），而exit是c库函数，exit就是调用_exit来实现的。
		
				既然exit也是靠调用_exit来实现的，那么我们也就可以直接调用_exit了。
				不过更多时候，我们调用的还是exit函数，因为exit对_exit封装后，exit额外还做了好些事情，至于做了些什么事情，这个留
			到后面再来解释。
				
				
			（a）_exit函数原型
					#include <unistd.h>
					void _exit(int status);
					
					用法与exit一样。
					
					
			（b）代码演示
				
					
				
		4）return、exit和_exit的返回值问题
	
				前面说过return、exit和_exit的返回值，也被称为进程终止状态。
				
			（a）裸机时：
					· 只能调用return返回，因为没有OS时，不支持exit和_exit函数。
						
					· 裸机时，main的return到启动代码后，返回动作到启动代码就截止了。
						
					· 在裸机情况下，一般来说main函数所return的返回值，对启动代码来说没有太大意义
						
							所以在裸机下，main函数return返回什么值都无所谓，这也是为什么大家在写单片机的C程序时，会感觉到main函数return
						的返回值没什么意义。
						
							在早期的单片机c程序中，main函数的返回值类型往往都是void，不需要返回值，不过现在main函数的格式要求严格了，
						所以就算“启动代码”并不需要这个返回值，但是我们还是要写一个return 0，保证main函数有正确的格式，只有这样编译时
						才不会有格式警告。
						
						
						
			（b）有OS时
					return、exit、_exit，使用哪种来返回都行。
					
					但是我们推荐大家使用return、exit，因为_exit是Linux OS的系统调用，在windows就不支持了。
					
					· return
					
						main函数           启动代码          
						return(0)  ——————>  exit(0)  ————————> _exit(0) ————> Linux OS
						
						
					· exit		 
								exit(0)  ————————————> _exit(0) ————> Linux OS
						
						
					· _exit
									_exit(0) ————>Linux OS
						
							有OS时，不管是采用哪种方式实现正常终止，返回值都会被返回给OS。
						
						
						
						疑问：将返回值返回给OS有什么意义呢？
							一般情况下没有意义，但是在有些特殊情况下是有意义的，只不过这种情况很少见，有关这个问题我们留到进程控制时再来
						详细解释。
			

			
	2.2、异常终止
			进程不是因为return、exit和_exit函数而终止的，而是被强行发送了一个信号，这个信号将进程给无条件终止了，这就是异常终止。
				
			有关什么信号，在后面讲信号的章节，还会详细的介绍。
			
			
		1）自杀：自己调用abort函数，自己给自己发一个SIGABRT信号将自己杀死，杀人凶器是信号；
				代码演示：
				
				
				
		2）他杀：由别人发一个信号，将其杀死，杀人凶器也是信号；	
		
				思考：为什么按下ctrl+c，就可以将程序终止。
				
				
				演示：
				
					其实向终端输入ctrl+c时，就是在向我的进程发送某个信号，然后这个信号将我的程序给异常终止了。

	2.3 atexit函数
		
		2.3.1 函数原型
		
				#include <stdlib.h>
			
				int atexit(void (*function)(void));
			
				这是一个C库函数。
					
					
			（1）功能：注册（登记）进程终止处理函数，参数就是被登记“进程终止函数”的地址。
							
						当进程无论什么时候正常终止时，会自动的去调用登记的进程终止处理函数，实现进程终止时的一些扫尾处理。
							
						注意：我这里强调的是正常终止，不是异常终止。
						
						
					
			（2）返回值 
					函数调用成功返回0，失败返回非零值，不会进行错误号设置。					
					
					
			（3）参数function
					需要被注册的进程终止处理函数的地址。
					如果你的C语言过关了的话，你一看就知道function为void (*)(void)的函数指针类型。


			（5）代码演示
						
						
						
						
		
						
					1）从例子可以看出，进程终止处理函数的注册顺序和调用顺序刚好相反。
						
						为什么顺序刚好相反呢？
							这就是涉及到atxit函数的注册原理了。
							
							调用atexit注册时，会将“进程终止处理函数”的函数地址压入进程栈中，当进程正常终止时，又会自动从栈中取出函数地址，
						并执行这个函数，实现进程的扫尾操作。
							
							栈的特点是先进后出，先压栈的后调用，所以调用顺序刚好和注册顺序相反。
							
							
					2）在Linux下，调用atexit最多可以允许登记32个终止处理函数。	
					
					3）同一个函数如果被登记多次，自然也会被调用多次。
					
					4）在两种情况下，登记的进程终止处理函数不会被调用
						（a）异常终止，不会调用
						
						
						（b）直接调用_exit来正常终止时，不会调用
						
						换句话说，只有使用return和exit来正常终止时，才会调用。
					

					
			（6）登记“进程终止处理函数”有什么意义？
							
					我们有的时候需要在进程正常终止时，做一些扫尾操作，比如将链表数据保存到文件中。
							
					不过如果不使用进程终止处理函数的话，这个操作有点困难，因为进程有时候可能是因为某个函数调用失败，然后在函数出错处
				理时调用exit(-1)终止的，但是你又无法预估哪一个函数会出错，并在出错时调用相应的函数实现链表数据的保存，那怎么办呢？
							
					这个时候就可以注册进程终止处理函数来实现了，因为进程终止时，会自动的调用终止处理函数来实现进程的扫尾处理，比如
				将链表数据保存到文件中。
					
			
	2.4 有OS时，进程从启动 到 正常终止的全过程
			
			
		2.4.1 图示
			
			
			
			
			
			
			思考：为什么_exit正常退出时，不会调用进程终止处理函数？
			因为只有调用exit时，才会去调用“进程终止处理函数”。
			
			
			
			
		2.4.2 为什么调用exit、return正常终止时，会刷新标准io的缓存		
				
				有关标准IO的库缓存的缓冲有三种，无缓冲、行缓冲、全缓冲，有关这三个是怎么回事，我们在第三章标准io中，已经讲得非常
			清楚了，不清楚的同学，请认真回看第三章。
				
				
			（1）回顾行缓冲
						标准输出（printf）的库缓存就是行缓冲的，在缓存中积压的数据，直到出现以下情况时，才会刷新输出，否则就一直挤压着。
				
					1）遇到\n时就刷新输出，\n表示这是一行，就好比句号表示一句话一样。
						演示：
						
						
						
					2）库缓存中数据满了，也会自动刷新输出，这就好比盆里的水满了溢出一样。
							不过一般来说，数据不可能多到能够把缓存装满的。
							
							
							
							
					3）调用标准fflush函数，主动刷新数据
					
					
					
					4）调用fclose关闭标准输出时，会自动调用fflush刷洗数据
					
					
			（2）为什么调用exit正常终止时，会刷新标准io的缓存呢？
			
					因为exit会调用fclose关闭所有的标准io，关闭时会自动调用fflush来刷新数据。
					
					演示：
				
					
				
					这里要注意：如果进程时异常终止的话，是不会刷新缓存区的，因为异常退出时，跟exit函数半毛钱关系都没有。
				
	
	2.5 命令行参数
	
			在命令行执行c程序时，可以输入命令行参数并传递给main函数的形参，然后进程就得到了命令行的参数。
			
			其实在命令行执行c++、java程序时，也可以使用同样的方法，给进程传递命令行参数。
			
			
		（1）命令行参数的用处
				我们在第2章时，实现了一个my_ls程序，用于模拟ls命令，显示文件属性，执行my_ls时，就需要跟接参数。
					
				所有命令（程序：ls）的选项和参数，都是通过命令行参数得到的，所以对于命令行来说，命令行参数是很有用的东西。
					
					
		（2）代码演示		
					
					
					第一个参数永远都是程序名。

					
		（3）将命令行参数传递给main函数形参的过程
																			
																	构建指针数组                  exec
				  ./a.out *** *** ——————> 终端窗口进程 ——————> OS 内核 ——————> 启动代码 ——————> main函数形参
		
			
			
				
3. 环境变量表		

	3.1 windows的环境变量	
			
			如果大家有因为学习java而安装过java所需的JDK（java开发工具包）的话，应该接触过环境变量这个东西，因为安装JDK时就需
		要为JDK设置windows下的path环境变量。
			
			
			
		3.1.1 为什么在命令行执行我自己的程序，需要指明路径
		
				我们这里以windows为例，其实在Linux下也是这样的，不过Linux的情况留到后面再说。
				
				在windows下，如果你不加路径的话，会道默认到当前路径下找程序，没有的话就找不到你的程序。

				
				
		3.1.2 能不能不加路径，我随便在什么目录下都可执行我的程序呢？
				
				当然可以，只要把程序所在路径，加入windows的path环境变量即可。
				
				加入后，随便在什么位置，都可以不加路径的执行这个程序。
					
				演示：
					
					
					
		3.1.3 为什么设置了path环境变量后，可以不加路径就能执行程序

			（1）path这个环境变量的作用
					
					专门记录各种可执行程序所在路径。
					
					
			（2）path记录后
			
						执行程序时（命令时）
					
					1）如果你有明确指定路径，那就直接到你指定的路径下找到程序并执行。
					
					
					2）如果没有明确指定路径，
							首先，在当前目录下找，如果不到这个程序，就会跑到path记录的各个路径下面去找，如果有的话就执行这个程序，
						如果没有就提示没有个这程序。
				
				
							所以，只要你把程序的所在路径加入path后，执行程序时就算不指定路径，系统也会自动到path记录的各个路径下搜索。
			
			
			（3）path的意义
					
					如果说你想在命令行下任何位置，都能随心所欲的执行程序的话，这个path环境变量是很有意义的。
					
						但是如果你是通过图形界面，双击快捷图标来打开程序的话，快捷图标可以自动找到所指向的程序并执行，所以对于图形
					界面这种操作方式来说，path的意义不是很大。
				
				
						一般来说，我们自己的安装的程序，都没有设置环境变量，所以如果想在命令行下执行的话，要么到当前目录下执行，要么加路径
					执行。
				
				
		
			（4）为什么执行mspaint时，也可以在任何位置不加路径执行
						
						演示：
						
						mspaint是windows自己提供的工具软件（画图），mspaint所在路径为c:\windows\system32，这个路径被系统自动的加入了
					path环境变量，所以也能够在任何位置，不加路径的执行程序。
					

		3.1.4 再来看看windows的环境变量
						
			（1）环境变量的组成
			
					环境变量 = 环境变量名 + 环境变量数据
						
					不管是环境变量名，还是环境变量数据，都是字符串。
			
					大多数环境变量的数据，基本都是路径。	
						
					
					
			（2）之前操作的Path是一早就存在的环境变量，我们可不可以添加新的环境变量
					
					当然可以，比如，
					演示：
				
					
					整个%环境变量名%，代表的就是该“环境变量”的数据，你可以认为%%就是用来获取环境变量数据。
				
						

			（3）环境变量被放在了哪里
					被存放在了“环境变量表”里面。
					
					
					
	3.2 环境变量表
	
		（1）什么是环境变量表
					用于存“放环境变量”的表，就是环境变量表。
					
					什么是环境变量呢？
					答：其实就是进程在运行时，会用到的一些字符串信息，环境表就好比是工具箱，里面放了各种
						进程运行时需要用到的“工具”，比如各种的路径。
						
						
						
		（2）环境变量文件
				
				最原始的“环境变量表”都被保存在了“环境变量文件”中。
				
				通过环境变量文件，实现了“环境变量”数据的永久保存。
				
				我们通过图形界面设置、修改windows“环境变量”时，修改、设置的内容，都会被永久保存到“环境变量文件”中。
					
				可不可以直接修改“环境变量文件”，实现永久修改？
				答：可以，不过在windows下，一般不会直接修改文件，而是通过图形界面来操作。
					
				
				
				
		（3）每个进程的环境变量表
					
					每一个进程都在自己的内存空间（堆空间）保存了一份自己的环境变量表。
						
					如果你认真学习过我们《C语言深度解析》这门课的话，对于程序内存空间的“堆、栈”应该非常清楚。
					
				· 每个进程空间中的环境变量表又是怎么来的？
					显然从环境变量文件中得来的。
					
					
					
		（3）如果某环境变量的数据有很多条，在环境变量表中，多条数据之间怎么区分
					
					在windows这边使用;分隔，Linux这边则使用:分隔。
					
					比如，windows的Path就有好多个数据（路径），这些数据在“环境变量表”中保存时，不同的数据之间会使用;分隔。			
					
					Path=%SystemRoot%\system32;%SystemRoot%;%SystemRoot%\System32\Wbem;%SYSTEMROOT%\System32\WindowsPowerShell\v1.0\

					w10提供的图形操作界面将;省去了，w10之前的系统还能在图形操作界面看到;，但是实际在环境表中保存时，多条数据之间
				是有;的。
					
					
					
		（4）在命令行执行我的hellword程序时，查找的是谁的“环境变量表”
					
				查找的是“命令行窗口进程”的“环境变量表”。
		
				疑问：helloword进程有“环境变量表”吗？
				答：当然有，因为我们说过，每个运行的进程都有自己的环境变量表，保存在自己的进程空间中。

				
		
		（5）为什么只有重新打开“命令行窗口”后， 新设置的“环境变量”才生效？
					
					因为新设置的环境变量，只是被保存到了windows的环境变量文件中，但是之前所打开的“命令行窗口”进程的“环境变量表”还
				没有得到更新，只有当重新打开后，才能更新。
					
					其实在w10以前更麻烦，更新了环境变量文件后，必须要重启系统才能生效，不过w10后不用这么麻烦了，只需要重新打开即可。

	3.3 Linux的环境变量
			Linux的环境变量与windows的环境变量在原理上其实是一样的。

			
		3.3.1 修改Linux的环境变量表

			（1）永久修改
			
					1）图形方式操作
						（a）windows
									通过图形界面来修改"环境变量"是最常见的操作方式。
								
						（b）ubuntu
									ubuntu跟windows一样，也提供了图形化的操作。
									不过在ubuntu这边，图形化修改“环境变量”的操作并不常见，老实讲我也没有用过ubuntu的图形界面来修改
								过环境变量，所以这里也不介绍了。
								
								
					2）直接修改“环境变量文件”
						
						（a）windows
								我们很少直接修改“环境变量文件”。
									
						（b）ubuntu（Linux）
								基本都是通过修改“环境变量文件”来实现的，不过有关如何修改Linux的环境变量文件，我们这里暂时不介绍，
							我们后面具体用到时，再来详细介绍。

						
						
			（2）临时修改
			
					· 什么是临时修改？
							就是只修改当前进程自己的“环境变量表”，其它不相关进程的“环境变量表”以及“环境变量文件”中数据，不会发生任何变化，
						当进程结束时，当前进程的“环境变量表”就被释放了，这就是临时修改。
						
								
					· 如何实现临时修改
					
						- 使用命令修改
							使用命令修改的话，改的是“命令行窗口进程”的环境变量表。
	
						- 通过API修改
							在我们自己所写程序里面调用API，修改的只是我自己程序的“环境变量表”。
							
							
							
					1）如何使用命令来修改“命令行窗口进程”的环境变量表
						
						（a）查看所有环境变量
						
								· Linux
									- 命令：export
										把当前“终端窗口进程”的所有环境变量全部显示出来。


								· windows
									- 命令：set
										把当前“终端窗口进程”的所有环境变量全部显示出来。
									
									
									
						（b）显示单个的环境变量
						
								· Linux
									- 命令：echo
									
									- 用法：echo $环境变量命令
										echo $PATH
										
										PATH是环境变量名，$PATH代表的就是PATH的环境变量数据，可以认为$就是用来获取环境变量数据的。
										
										在Linux，环境变量的多个数据之间使用:分隔，而在windows下，使用的是;来分隔。

										
								· windows
									- 命令：set
									
									- 用法：set 环境变量名   或者   set %环境变量名%
										
										set Path  或者 set %Path%
										

									
							（c）添加一个新的环境变量
									· Linux
										- 命令：export
										- 例子：export AA=wwwwwwwwwwww
											
												新环境变量名叫AA，环境数据为wwwwwwwwwwww，不过这个环境变量没有什么实际意义，仅仅就是为了演示如何来
											设置一个新的环境变量。
											演示：
									
												在Linux下，环境变量名往往喜欢一律大写，而在windows下不一定，有些大写有些小写。
										
												而且一般来说，很少有需要去设置一个新的环境变量。
												
												
									· windows
										- 命令set
										- 例子：set aa=wwwwwwwwwwww
										
										
										
										
							（d）修改已有环境变量
							
										（1）覆盖式修改
													覆盖原有数据，还是使用添加新环境变量的命令来操作，如果添加的“环境变量”之前就存在了，
												现在的数据会修改原来的数据。
												
												· Linux
													export AA=sssssssssss
												
												· windows
													set AA=sssssssssss
													
													
										（2）追加
												保留原有数据。
												
												· Linux
													- 例子1：
														export AA=$AA:dddddddddddd
															
															或者
														
														export AA=dddddddddddd:$AA
														
														
														
													- 例子2：将helloword程序的所在路径追加到PATH
	

												· windows
													- 例子1：
														set aa=%AA%;dddddddddddd	
															
															或者
												
														set aa=dddddddddddd;%AA%
												
												
													- 例子2
														
														将helloword.exe程序的所在路径追加到path

														
							（d）删除
									· Linux 
										unset AA
							
									· windows  
										set aa=
											
						
						（c）看一看Linux的环境变量有哪些
								
								演示：
									
																		
									其中，我们会经常用到的环境变量是PATH，与windows下的path的功能是一样的，当我们不带路径的去执行某个程序
								时，就会到PATH指定的路线下去找，找到后再执行，找不到就提示没有这个文件。
									
	
						（d）注意
									不管是在windows下还是在Linux下，在命令行下添加/修改环境变量时，改动的只是当前“命令行窗口进程”的环境变量表。
								所以，									
								
							· 当你在另一个窗口查看时，根本找不到这个修改。
							
							· 当你把当前窗口关闭后，当前“命令行窗口进程”的环境变量表也就被释放了，那么之前的修改自然也就无效了。

						
						
				2）通过API修改环境变量
					
						我们前面说过，对于我们自己所写的程序来说，我们可以调用API来修改自己所写程序的“环境变量表”。
						
						
				（a）获取环境表中的所有环境变量
						
						· environ全局变量
							
							char **environ;
							
							- environ与main函数的argv一样，指向的都是一个字符串指针数组。
								只不过，
								argv：与命令行参数有关
								environ：与环境变量表有关
									
									图：
								
								
							- 代码演示：

							
						· main函数的第三个参数
							- 代码演示
								
								
								
			
				（b）调用API：实现环境变量的添加、修改等
						
						· putenv、setenv：添加和修改环境变量
						
							- 函数原型
								#include <stdlib.h>
								
								int putenv(char *string);
								int setenv(const char *name, const char *value, int overwrite); 
								
							- 函数功能
								+ putenv：设置新的环境变量到环境表中。
											如果这环境变量之前就存在，那么这一次的数据会无条件覆盖之前的数据。
											如果不存在，就添加这个新的环境变量。
								
									string：新的环境变量，比如“name=value”。
								
								+ setenv函数：功能同上。
									
									name：环境变量的名字。
									value：环境变量值。
									overwrite：如果发现name环境变量以前就已经存在，会根据overwrite的值来决定是否覆盖，
														0：不覆盖
														!0：覆盖


								+ 函数返回值
									putenv函数：调用成功返回0，失败返回非0，errno被设置。
									setenv函数：调用成功返回0，失败返回-1，errno被设置。
									
							- 代码演示
								
													
						· unsetenv：删除环境变量函数
							- 函数原型
								#include <stdlib.h>
								
								int unsetenv(const char *name);
								
								+ 功能
									删除name指定名字的环境变量。
							
								+ 参数：char *name：环境变量名。
								
								+ 返回值：函数调用成功返回0，失败返回-1， errno被设置。
						
						
							- 代码演示
															
						
																
				（c）疑问：我自己所写程序的环境表是怎么来的
					
							我命令行窗口执行./a.out，那么a.out进程就属于“命令行窗口进程”的子进程，子进程的环境表是从父进程
						复制得到的，有关父子进程关系，后面的课程还会详细介绍。
							
							当有OS支持时，基本所有的进程都是由父进程“生”出来的:
							
							
							原始进程————>进程————————>进程————————>终端进程——————>a.out进程
														|            |             |
														|            |             |
														V            V             |
													进程				  进程          进程
														|            |             |
														|						 |             |
													 ...		      ...           ...
																				
						
							所以所有进程的“环境变量表”都是从父进程复制得到的，最原始进程的“环境变量表”则是从“环境变量文件”中读到的。
						
																  原始进程             子进程	            子进程						   子进程					 
							环境变量文件 ————> 进程环境表 ————————>进程环境表 ————————>进程环境表 ————————> 进程环境表 ————————>.....
									

						疑问1：最原始的进程从哪来的
						答：OS启动完毕后演变得到的。

									
						疑问2：如果我自己的进程有一个子进程的话，是不是也会继承我自己进程的环境表？
						答：是的，不过这个问题我们留到后面章节再来详讲。
										
									
						怎么验证这种继承关系？
						修改了命令行终端的环境表后，在该终端下运行我自己进程，如果我的进程环境表也被改了，自然就验证了这种继承关系。
							演示：										
							

							
							
							
							
	
	
4. c程序空间布局												

			1）什么是c程序的内存空间
			
				程序运行的大致过程：
				
				c程序运行时，是运行在内存上的，也就是说需要在内存上开辟出一块空间给c程序，然后将C代码会被从硬盘拷贝到内存空间上运行，
			至于说是不是将代码全部会被拷贝到内存上，这就不一定的了，
			
				· 有些是全部考别，早期计算机和现在的单片机往往都是这种
				
				· 有些是只拷贝当前要运行的那一部分，运行完了再拷贝其它部分
							当运行有OS，而且OS提供了虚拟内存机制时，基本都是这种的情况，有关虚拟内存机制的原理，请看
					《计算机体系结构》软件篇——操作系统的课程。
							所以具体是那种情况，还要看具体的实现。
					
						不过，我们这里重点是你要清楚，运行时需要要在内存开辟出一段空间，然后把代码从硬盘拷贝到内存上，
					那么所开辟出的这段内存空间，就是c程序的内存空间。程序的内存空间。
				
				
			2）c程序的内存空间结构
				
				（a）有结构的要求吗？
			
						有，这段空间必须布局为c程序运行所需的空间结构，c程序才能运行。
						
						比如程序在调用函数时需要用到“栈”这个东西，那么就必须在内存空间中构建出“栈”，否者c序程序没办法实现函数调用。
						
						
						如果空间没有布局好，进程将无法运行，因此进程空间（c程序的内存空间）也是非常重要的进程环境。
						这就好比你租了写字楼的某层开了家公司，但是这个空间肯定是需要被布局为你要的结构的，如果空间不布局的话，你公司
					怎么运作起来。
					
				（b）c的内存结构是谁来构建的
						由启动代码来搭建的，比如启动代码会把c内存空间的某一部分空间，构建为“栈”，也就是说以“栈”的方式来管理这片内存。
				
				
				（c）c程序的内存空间也其实也叫“进程空间”
						为什么？
							因为c程序在内存中运行起来后就是进程了，所以c程序的内存空间也其实也叫“进程空间”。
						
						
			c）不光是C程序
					所有超级语言的程序在运行时，都涉及内存空间的结构布局，不过它们的结构都是相似的，理解了C的内存空间布局，
				自然也理解其他程序的内存空间结构。
			

				
		c程序代码在内存上运行起来后，它就是一个进程，所以程序代码在内存上所占用的空间，也别称为进程空间。
	
	c程序空间时c程序运行的非常总要环境，没有没有在内伤布局出这个空间环境，程序将无法运行起来。
			
	原本打算还是简单介绍下的，但是由于这部分内容在C深度解析中，已经详细介绍过了，因此这里就不在介绍。
				



				
			
5. 库	

		我写程序时，是绝对不可能从零开始写代码的，都是要依赖被人所写的代码的，比如别人写的库，所以库也是程序非常重要的
	运行环境，没有库的支持，我们的程序根本做不了重要的事情。

		有关C语言库这一块，我们也在C深度解析课程中做了详细讲解，所以这里也将其省略。

		
		
		

		
		
		
		
		

		
		
		
		
		
		
		
		
			（1）回顾第3章标准IO的三种缓冲
					这个在讲第3章已经讲的非常清楚了，不过这里还是要再来回顾下；
		
		
					1）标准io函数对文件io函数进行封装时，标准io函数会开辟库缓存
							图：
							
								
							
							调用数据时，库缓存会对数据进行缓冲。
							
							
					2）为什么需要对数据进行缓冲
					
						（a）什么时缓冲？
								就是不要讲缓存中的数据立即输出，先积压在缓存中，
								
							调用标准io时，为了不要频繁的调用文件io函数，标准io的缓存有三种缓冲
							
								
							
							所谓缓冲就是，数据先在文件io的缓存中加压着，满足某种情况时，再调用文件io一次性调用文件io，将数据输出，
						然后标准io的缓存就得打了刷新（数据被清空）。
						
							直接调用文件IO时，数据没有缓冲（没有积压），只要缓存有数据就输出。	
							
							
							缓冲的情况有三种
							
					1）无缓冲
							无积压，有一个就调用文件IO函数输出一个。
							
							什么时候使用无缓存。
							标准出错输出时，因为出错信息很重要，不能积压，需要直接输出打印，提示除了什么错误。
							
							
							fprintf(stderr, "open fail");
										|
										|	
							lbuf[1024] = "open fail";
							write(2, lbuf, sizeof(lbuf));
							
							不会积压，有个一个字符，就调用一次write输出。
							
							
					2）行缓冲
					
						（a）什么事行缓冲
								标准io缓存会积压数据，所谓行缓冲就是，如果积压的数据满足一行时，就一次性调用write输出。
								怎样算是一行，一般来说数据中跟\n就表示一行，就好比人说话，停顿了就表示一句话。
					

						（b）什么时候合适使用行缓存
								
								当使用标准输出，将数据打印到屏幕显示时，就是行缓冲。
								为什么是行缓冲？
								打印到屏幕，涉及到人机交互，以一行为依据来进行交互时最合适的，如果无缓冲，有一个数据就调用write输出，这样
								效率又太低，关键是使用标准输出打印的都是普通信息，不像出错信息，不用那么着急显示出来，所以有挤压也很正常。
													
								针对行缓冲的这种情况，什么时候会把缓存中的数据刷新输出。
								
								1）如果数据中有\n，\n表示这就是一句完整的话，标准IO缓存中的数据就会被刷新输出
										fprintf(stdout, "hello\n"); //或者写成printf("hello\n");
													|
													|	
										lbuf[1024] = "open fail";
										write(1, lbuf, sizeof(lbuf));
									
								2）如果没有\n，但是标准Io缓存被数据装满时，也会刷新输出
										这就好比水盆的谁被装满溢出是一样的。
								
										一般这总情况很少见，因为标准io的缓存都很大，使用printf输出，不可能一次输出几千个字节，把标准Io的缓存都装
									满了。
								
								3）既没有\n，标准IO的缓存也没有被填满，只要调用标准io函数fflsuh(stdout)刷新缓存，也会将积压数据调用文
										件write(1,...)输出。
										
										
								4）调用fclose（stdout）函数关闭时，也会刷新，因为fclose会自动调用fflsuh刷新。
										

										
					3）全缓冲
							向普通文件写数据时，标准IO的缓存就是全缓冲的。

							向普通文件输出时，需要先打开文件。
							
								fp = fopen("./file.txt", "r+");
											|
											|
											|		struct FILE
											|		{
											|			...
											|    	fd;
											|		}
											|
								fd = open("./file.txt", O_RDWR);
								
								fp  ————> fd(3) ————————>./file.txt

								
							1）缓存满，一般很少会把缓存填满的
									为什么全缓冲规定要把缓存积压满在刷新输出，因为向文件输出数据时，往往要输出的数据量都很大，无缓冲肯定不行，
								效率太低，行缓存也不行，调用文件Io太频繁，最好是积压的越多越好，上限就是积压满后，一次性调用文件Io输出。
			
								fprintf(fp, "hello wolrd\n", 12);
										|
										|
										|
								lbuf[1024] = "hello wolrd\n";
								write(3, lubuf, sizeof(lbuf));

								
							2）调用fflsuh(stdout)刷新缓存，将积压数据输出。
								向普通文件输出数据时，更多是调用fflsuh(stdout)主动刷新输出到文件。
								
								
							3）调用fclose（stdout）函数关闭时，也会刷新，因为fclose会自动调用fflsuh刷新。
								
							
			（2）为什么使用exit、return正常终止进程时，为什么会刷新标准io缓存的原因
			
						使用exit、return正常终止时，exit会指定的调用flcose函数关闭标准io，而fclose关闭时又会自动的调用
					fflush刷洗标准io的缓存。

						所以使用exit、return正常终止时，标准IO的缓存会被刷新。
						
						基于同样的理由，调用_exit函数正常终止，肯定不会刷新缓存，只有exit函数才会去做这件事。
					
		
		
		
