# 1. 启动代码
	
# 1.1 启动代码的作用

在上堂课就说过，顾名思意就是用来启动整个程序的代码，所有高级语言的程序，都有自己的启动代码。

C程序运行时，最开始运行的是启动代码，启动代码再去调用main函数，然后整个C程序都已运行。

```c
.......
   |
   |
 子函数
   |
   |
 子函数  
   |
   |
 main函数
   | 
   |
启动代码
```

总之，高级语言程序 = 启动代码 + 自己代码。


所以，C的启动代码其实才是整个c程序的开始代码，不过由于启动代码并不是我们自己写的，所以很多初学的同学并不知道还有启动代码这回事。

疑问：启动代码都做了些什么呢？后面再介绍
			
## 1.2 启动代码是由谁提供的
	
### （1）启动代码一般都是由编译器提供的，一般有两种提供方式

+ 1）源码形式
   以源码形式提供时，编译器会将启动代码的源文件和自己程序的源文件一起编译。

  ```c
                               编译
    启动代码.c   ————————————————————————————> ***.o    \
                                                         \
                                                          \  链接
                                                           ————>  可执行文件（可执行程序）
                                                          /
                               编译  				             /
    我的程序 ***.c ***.c ... ——————————> ***.o ***.o .../
  ```

  比如我们后面学习单片机时，像开发单片机这种没有OS的计算机的C程序时，启动代码一般是源码形式提供的，后面讲到单片机时，大家就能见到这种情况

  当然像单片机这种没有OS的裸机程序的启动代码都很简单

+ 2）二级制的.o（目标文件）形式
  直接以.o形式提供时，省去了我自己对“启动代码”的编译。

  ```c
                                        启动代码
                                      ***.o ***.o    \
                                                       \
                                                        \ 链接
                                                         ————>  可执行文件（可执行程序）
                                                        /
                              编译  				           /
  我的程序 ***.c ***.c ... ——————————> ***.o ***.o .../
  ```


  一般来说，如果开发的程序是运行在OS上时，那么编译器一般是以.o形式来提供启动代码，比如我们gcc a.c时，gcc就是以.o形式提供的，基于OS运行的程序的启动代码，相对而言，自然比较复杂些

  gcc时加一个-v选项，查看gcc编译链接的详细情况时，可以看到有很多.o，这些.o就是gcc提供的启动代码

### （2）gcc -v

在一般情况下，不管是在命令行使用gcc命令（编译程序）方式编译还是使用IDE的图形界面方式编译，编译链接的中间过程都被省略了，当然图形化的编译方式，最终调用的还是gcc这种编译程序来实现的，只不过一个图形化调用的，另一个是在命令行输入命令来调用的，但是本质是一样的。

由于编译的过程被屏蔽了，因此大家对启动代码基本没有什么感觉。

演示：

```shell
gcc -v a.c
```

```shell
 /usr/lib/gcc/x86_64-linux-gnu/5/collect2 -plugin /usr/lib/gcc/x86_64-linux-gnu/5/liblto_plugin.so 
 -plugin-opt=/usr/lib/gcc/x86_64-linux-gnu/5/lto-wrapper -plugin-opt=-fresolution=/tmp/ccgWwfyD.res 
 -plugin-opt=-pass-through=-lgcc -plugin-opt=-pass-through=-lgcc_s -plugin-opt=-pass-through=-lc 
 -plugin-opt=-pass-through=-lgcc -plugin-opt=-pass-through=-lgcc_s --sysroot=/ --build-id --eh-frame-hdr 
 -m elf_x86_64 --hash-style=gnu --as-needed -dynamic-linker /lib64/ld-linux-x86-64.so.2 -z relro 
 /usr/lib/gcc/x86_64-linux-gnu/5/../../../x86_64-linux-gnu/crt1.o 
 /usr/lib/gcc/x86_64-linux-gnu/5/../../../x86_64-linux-gnu/crti.o 
 /usr/lib/gcc/x86_64-linux-gnu/5/crtbegin.o 
 -L/usr/lib/gcc/x86_64-linux-gnu/5 
 -L/usr/lib/gcc/x86_64-linux-gnu/5/../../../x86_64-linux-gnu 
 -L/usr/lib/gcc/x86_64-linux-gnu/5/../../../../lib -L/lib/x86_64-linux-gnu 
 -L/lib/../lib -L/usr/lib/x86_64-linux-gnu 
 -L/usr/lib/../lib -L/usr/lib/gcc/x86_64-linux-gnu/5/../../.. /tmp/ccZBIWKc.o 
 -lgcc --as-needed -lgcc_s --no-as-needed -lc -lgcc --as-needed 
 -lgcc_s --no-as-needed /usr/lib/gcc/x86_64-linux-gnu/5/crtend.o 
 /usr/lib/gcc/x86_64-linux-gnu/5/../../../x86_64-linux-gnu/crtn.o
```


在编译的详细信息里面，有很多的事先就被编译好的.o文件，这些.o文件就是用来生成启动代码的。

`gcc -v`显示的详细信息，在讲《c语言深度解析》时，有过较为详细的介绍，不清楚的同学请看《c语言深度解析》。

## 1.3 启动代码做了些什么			

### 1.3.1 启动代码使用什么语言编写的 

> 基本都是汇编写的

### 1.3.2 启动代码大致做了些什么呢？

大致上有两件重要的事情：

+ 对c程序的内存空间进行布局，得到c程序运行所需要的内存空间结构。

+ 留下相应库接口

#### （1）对c内存空间进行布局

  我们前面说过，c等高级语言程序在运行时，函数调用需要“栈”，启动代码就需要在c内存空间上建立“栈”，说白了就是从从c内存空间中划出一段空间，然后以“栈”的形式来进行管理

+ 疑问：栈是怎么建立起来的？
  后面讲uboot移植时，uboot的最开始的汇编代码就是启动代码，其中有一段汇编代码就是用来建立栈空间的，讲到uboot时在来详细介绍。

  当然uboot比较特殊，平时进行c程序开发中，我们都不需要关心启动代码，因为都由编译器自动提供了，所以对于启动代码这个东西，我们不用深究，而且深究明白了也就那么点东西，对实际开发来说意义不大。

  因此关于启动代码，重点是理解什么是启动代码，它大概是一个什么样的存在。

+ 思考：为什么启动代码，基本都是使用汇编来编写？
  在程序的内存空间结构还没有布局起来之前，高级语言程序还无法运行，此时只能使用汇编，当利用汇编编写的启动代码将高级语言的内存空间结构建立起来后，自然就可以运行c/c++等高级语言的程序了

#### （2）为库的调用预留接口

如果程序使用的是动态库的话，编译时，动态库代码并不会被直接编译到程序中，只会留下相应的接口，程序运行起来后，才会去对接库代码，为了能够对接动态库，启动代码会留下动态库的对接接口。

#### （3）等等

如果是c++等面向对象的启动代码的话，还会做一些其它的事情，我们这里就不介绍了。

## 1.4 程序是如何运行起来的

分两种情况来看，一种是裸机的情况，另一种是有OS的情况。

### 1.4.1 裸机的情况 

什么是裸机，就是没有OS。

如果说你学过单片机（51、stm32）、ARM等裸机的话，那么你对我所要描述的裸机程序的运行过程不会陌生，当然不熟悉也没关系，因为原理本来不复杂

裸机也分两种情况，内存和硬盘一体式，以及内存和硬盘分开式

#### （1）内存和硬盘一体式

+ 1）典型的比如以51单片机，为了设计的方便，51没有单独的内存和单独硬盘，使用的是内存和硬盘功能二合一的norflash
    像单片机这种，程序都是直接放在norflash上的，此时norflash既是内存也是硬盘，同时身兼两者的功能
  + （a）为什么能身兼内存的功能？
  
      因为norflash的访问速度很快，因此cpu能够直接从norflash上读取指令并执行，此时norflash就是一个内存。
  + （b）为什么身兼硬盘的功能？
      因为norflash能够永久保存数据，设备关电后，数据依然存在，所以将程序下载到norflash后，关机重上电，程序依然还能运行。

+ 2）程序运行的过程  图示：
  + （a）在PC上使用安装好的IDE等开发环境，来编写、编译我们的源码程序，得到可执行程序（可执行文件）
  + （b）在PC上运行下载程序，这个下载程序会通过数据线，将pc上编译好的程序下载到单片机的norflash中。
  + （c）将norflash中的第一条指令的地址放到pc（计数器）中，通过pc中的地址，cpu就可以读取norflash中存放的指令并执行。
    每执行一条，pc就存放下一条指令的地址，如此循环往复下去，整个程序就运行起来了
    如果你不理解什么是PC，不理解CPU的工作原理大概是怎样的，请看《计算机体系结构》硬件篇2——计算机组成这部分课程，里面有详细介绍

#### （2）内存和硬盘分开式		

除了单片机这种，像pc、手机、平板、服务器这种我们常见的、传统的计算机，内存和硬盘都是分开的。

+ 1）为什么传统的计算机，硬盘和内存都是分开的
  因为像单片机这种内存和硬盘二合一的norflash形式，由于造价太高，只适合于单片机这种小容量的设备使用，如果是手机、PC、平板这样的设备，内存和硬盘都要求很大，norflash这种二合一形式价格很高，不合适
  所以像手机、PC、平板、服务器，使用的还是传统的内存和硬盘分开的这种方式，既内存和硬盘各是各。
  我们后面要学习的ARM的2440和4412开发板，典型的就是属于这样的情况，所以ARM芯片可以用来设计手机、平板等，不过ARM很少用在PC和服务器上，因为PC和服务器使用的基本都是intel的芯片。

  + 1）传统的内存：cpu能够快速访问，但是掉电丢失数据
  + 2）传统的硬盘：可以容量做的很大，掉电不丢失数据，但是访问速度很慢

  各自的优点刚好是对方的缺点，所以二者相互配合使用，同样能起到与norflash一样的二合一的效果，而且容量更高，单位造价更低。


  目前手机、平板等小型设备，使用的是nandlfash这种电子硬盘，pc和服务器使用的基本都是磁盘这种机械硬盘，nandflash相比磁盘来说，更稳定，体积更小，当然价格要高很多，但是在未来当nandflash价格下降后，PC和服务器的硬盘肯定慢慢的会被nandflash取代，目前已经能够看到这样的趋势。

  当然如果norflash的价格也下降了的话，norflash这种内存硬盘二合一的形式，也许慢慢的也会变成主流，这也是未可知的。

  如果对内存、硬盘、norflash、nandlfash等存储概念不明白的话，请大家看《计算机体系结构》硬件篇3——存储器部分的课程。

  像内存和硬盘分开的这种情况，一般都要运行OS的，很少直接以裸机方式来来使用。

2）内存和硬盘分开的这种情况，如果直接以裸机方式使用的话，程序是如何运行起来的

    两种：
    第一种：直接将下载到内存中，然后运行。
    第二种：先下载硬盘永久保存，开机时自动从硬盘中将代码拷贝到内存上，然后运行。



  （a）将程序直接下载到内存


        这种方式很简单，开发板上电后，在PC上运行下载程序，直接将pc上编译好的代码下载到内存上，在pc中存放第一
      条指令的地址，然后整个程序就运行起来了。

        这种方式最大的缺点就是掉电就没了，因为传统的内存掉电后数据就没了，所以这种方式只适合于平时的测试。




  （b）将程序下载到硬盘

      · 在PC上运行下载程序，将pc上编译好的程序下载到开发板硬盘上后，程序会被永久的保存起来。

      · 开机运行时，将硬盘上的代码拷贝到内存上
        裸机时，往往都是把代码全部拷贝到内存上。


      · pc指向内存中程序第一条指令，然后整个程序就运行起来了。

          疑问：是谁去让pc指向程序的第一条指令的？
          有关这个问题，我们这堂课就无法解释了，这个就留给单片机和ARM裸机的课程来解释。




      · 疑问1：到底是谁来实现这个拷贝的过程的

          有关这个问题，如果过在这里详细讲的话，将会是一个非常长话题，而且也很难说清楚，不过好在后面的ARM裸机课程，
        会进行非常详细介绍，所以详细情况，请看arm裸机课程。

          不过这里还是要简单的回答下，这个拷贝的过程需要我们自己写代码来实现。



        自己写的拷贝代码又是怎么运行起来的呢？
        同样，讲到ARM裸机课程时，再来解释。


  1.4.1 有OS的情况 		

  上OS的计算机，基本都是内存和硬盘分开式的情况。

  疑问1：为什么内存和硬盘分开式的计算机，基本都是要上OS呢？

    因为计算机资源相对丰富，有能力跑OS，如果不上系统直接裸机使用的话，这其实是在浪费计算机资源。

    这就好比人家本来就是当省长的料，但是非要让人家当村长，这就是在浪费人才资源。


  疑问2：OS是怎么运行启动起来的呢？
      OS也是一个程序，而且是一个很大的裸机程序（因为OS是直接运行在硬件上的），OS的运行过程其实就是前面讲的裸机程序
    的运行过程。

      OS的代码也是被永久的存放在了硬盘上，开机上电后，启动程序开始启动OS，启动时会将OS代码从硬盘拷贝到内存上，然后
    就运行起来了。OS和大多数裸机程序一样，都是开机自启动的。

    · windows的启动程序：bios
    · Linux的启动程序：uboot
      后面讲uboot移植的课程，会详讲uboot的工作原理。

      其实启动OS的“启动程序”跟我们自己写的拷贝代码的功能是一样的，只不过OS的启动程序会复杂很多，毕竟OS比如我们自己写
    的小裸机程序也复杂了很多。


    疑问：启动程序又是如何运行起来的呢？
      这个问题留到后面课程再来解释。

      当然本小节的重点并不是讲OS是怎么启动起来的，而是介绍基于OS运行的应用程序，是怎么在OS的支持下运行起来的。




（1）有OS时，可执行程序都是直接放在了硬盘上

    · 如果开发的直接就是pc机程序的话

      在PC上编写、编译好后，可执行程序就放在了windows电脑的硬盘上，比如在C盘桌面上，然后在PC上直接运行即可。


    · 如果是Linux嵌入式开发的话

        在pc上编写、编译好程序后，需要将程序拷贝到开发板的硬盘上

        有了OS后，就有了文件系统，我们可以直接通过文件系统去访问硬盘上的各个目录，因此拷贝的过程非常简单，
      拷贝的过程其实就是从这个目录复制，然后粘贴到另外一个目录下的过程，与我们在Windows下复制粘贴的过程是
      一样的。

        其实在裸机上也可以安装文件系统，不过文件系统一般都是和OS配合工作的，有OS的时候，文件系统属于OS的一部分。




（2）有OS时，程序如何运行起来


    1）有OS支持时，如何启动程序呢


      （a）裸机时，是怎么启动程序的呢？
          很简单，下载、或者上电后程序会立即执行（OS就是上电启动的），也就是说下载或者上电就是启动的动作，总之，我们
        不需要额外的动作去启动程序。

          关机程序就结束了，当然有OS的话，就算程序结束了，整个机器还是运行着的，因为OS还运行着。



      （b）有OS支持时，启动程序方式有三种

        · 双击快捷图标运行
        · 在命令行运行

        · 设置为开机自启动	
          所谓开机自启动，就是OS运行起来后，自动的将程序运行起来。

          不管使用哪一种方式来启动，启动后OS会将硬盘上的代码自动拷贝到内存上，然后让PC指向第一条指令，cpu取指执行，
        那么整个程序就运行起来了。


        · windows的情况

        · ubuntu的情况


        · ARM开发板
          - 图形界面：
              可能有，可能没有，如果运行的是像安卓这样的OS，就有图形界面，但是我们后面在进行Linux嵌入式开发时，开发板
            上运行的Linux系统就没有图形界面，因为我们运行的只是Linux OS的核心代码，核心代码没有图形界面。

              有同学可能有疑问，没有界面还有什么意义？
              有意义，因为很多嵌入式产品确实不需要图形界面，比如像路由器，路由器就不需要图形交互界面。

              有图形界面（安卓手机），可以通过快捷图标启动程序，没有的话就不行了。


          - 命令行
              我们后面在进行Linux嵌入式开发时，由于ARM开发板运行的Linux系统没有提供图形界面，那就只能通过命令行来
            操作了，而且命令行界面也是由PC提供的，因为开发板不像PC那么强大，提供不了，所以只能由PC来提供
            操作的命令行界面。


          - 开机自启动
              当嵌入式产品研发完毕，变成成品后，我们就需要将程序设置为开机自启动，以后嵌入式设备每次上电开机，Linux OS运
            行起来后后，会自动加载运行设置为了自启动的应用程序，当应用程序运行起来后，整个设备就在应用程序的控制下开始
            工作了。



    2）OS是怎么实现拷贝的

          对于我们自己写的裸机程序来说，我们需要自己写拷贝代码，开发板一上电，拷贝代码会自动运行，将硬盘上的程序拷
        贝到内存上运行起来。

          对于OS这个裸机程序来说，由启动程序来负责代码的拷贝。

          基于OS的应用程序运行时，它的拷贝的过程自然就由OS来实现。


        · OS具体是怎么实现拷贝的呢？

            不管使用哪一种方式来启动程序，启动后OS会调用exec函数（加载器），这个加载器去加载程序时，会自动的将硬盘上的
          代码拷贝到内存上运行起来，加载的过程其实就是拷贝的过程。

            只不过有OS时，特别是当OS有虚拟内存机制时，exec不会拷贝全部代码，只会拷贝当前运行所需要的代码，当这段代码
          运行完毕后，再拷贝另一段代码到内存中。



      3）总之，有了OS后吗，在OS的支持下，运行程序是一件很方便的事情
