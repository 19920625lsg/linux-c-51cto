# 第01章 文件io
	
## 0. 文件io讲些什么
		
文件io这一章讲的是，如何调用Linux OS所提供的相关的OS API，实现文件的读写。
	
	
### 0.1 如何理解“文件IO”这个词
	
IO就是input output的意思，文件io就是文件输入输出，也就是文件读写。

读写的是什么？  
答：是数据  

不过读文件和写文件，到底哪一个是input，哪一个是output呢？  
答：input和output，其实是以CPU作为参考点来看的：

```txt
      o（写）  
C   ——————————>  文
P   <——————————  件
U      i（读）

```


疑问：为什么不能越过OS，直接操作文件呢？  

答：当有OS的时候，应用程序基于OS运行时，必须通过OS API假借OS之手，才能操作底层硬件，无法回避。  
			
### 0.2 本章所涉及的OS API（系统函数）有哪些

+ （1）open函数：打开文件
+ （2）close函数：关闭文件
+ （3）read函数：从打开的文件读数据
+ （4）write函数：向打开的文件写数据
+ （5）lseek函数：移动在文件中要读写的位置
+ （6）dup函数：文件读写位置重定位函数，本来是写到这个文件，重定位后可以写到另一个文件里面
+ （7）fcntl函数：文件描述符设置函数
+ （8）ioctl函数：一个特殊的函数

本章的函数，在后续课程中会频繁使用，所以这些函数一定要会用，但是不要去死记，函数参数很多，想记也记不住，涉及细节时，使用man查一查自然就知道了。
	
## 1 文件读写的简单例子
	
### 1.1 文件操作三步曲

+ （1）打开文件: open函数
+ （2）读、写等操作文件 : read、write函数
+ （3）关闭文件: close函数

使用man命令查看这些函数的详细说明。


### 1.2 程序演示

#### 1）open函数

+ （a）利用文件名，通过文件系统找到块设备上的文件. 图：
  + 文件系统就是一个程序代码，组织管理着块设备上的所有文件
  + 文件系统属于OS的一部分


+ （b）找到文件后，调用块设备驱动程序，打开文件驱动程序也是属于OS的一部分。
  + 打开成功：返回一个非负整数的操作符（文件描述符）
  + 打开失败：返回-1，表示打开失败

  使用fd存放返回值，便于我们使用这个返回值。文件打开成功后就可以操作文件了。

#### 2）write函数

利用打开成功后返回的，非负整数的文件描述符，向文件里面写数据。

#### 3）lseek函数

利用文件描述符，将文件读写的位置调整到文件头上。

为什么要调到文件头上？  
write时，文件读写的位置到了末尾了，read读末尾的话，读到的内容就是空的，看不到read的效果。

#### 4）read函数

从文件头上开始，读取指定长度的数据到buf中。printf打印显示，查看效果。

### 1.3 open打开文件时，open具体做了哪些事情

如果open打开失败的话（比如文件不存在就会导致失败），open啥也不会干就直接返回了。

但是如果open将文件打开成功的话，open具体做了哪些事情呢？

#### 1）记录打开文件的信息

+ （a）程序运行起来后就是一个进程了，OS会创建一个task_struct的结构体，记录进程运行时的各种信息，比如所打开文件的相关信息. 图：

+ （b）open将文件成功打开后，在task_struct中又会创建一些结构体（数据结构），用于记录当前进程目前所开文件的信息，

后续所有的文件操作，都需要依赖于这些信息，其中就包括指向打开文件的文件描述符。

#### 2）open函数会申请一段内存空间（内核缓存），后续读写文件时，用于临时缓存读写文件时的数据

图：

+ （a）什么是缓存？  
    就是开辟的一段内存空间，比如char buf[100]，这就是一段100字节的缓存空间，用于临时存放中转的数据。

+ （b）为什么叫内核缓存？  
    open是OS所提供的系统函数，属于OS内核的一部分，所以open函数所开辟的缓存空间，就是内核缓存  
    在我们的例子程序中，我定义了buf1和buf2这两个数组，这两个数组是我自己的应用程序定义的，因此就叫应用缓存. 图：
    其实定义的一切变量空间，比如int a，int b[30]等，都是缓存，都是用于临时缓存数据，只是我们以前没有这么叫过。

+ （c）open为什么要开内核缓存空间？    
  内存读写速度 > 磁盘读写速度的，有了在内存中开辟的内核缓存后，上层读写数据时，会直接读写缓存，速度会很快，至于缓存与磁盘上文件数据的交换，就留给下层去做，这样可以节省上层操作的时间  

+ （d）注意：open时只是开辟了内核缓存空间，里面并没有数据，只有当进行读写数据时，才会缓存读写的数据  

+ （e）读写时，缓存间数据的流动是怎样的？图：
