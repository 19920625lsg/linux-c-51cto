
9. 有关多线程时的信号问题
	
	
	9.1 所有的线程共享相同的信号处理方式
		
			在我之前的例子代码中，主线程将SIGINT信号的处理方式设置为了捕获，那么所有的次线程共享这一处理方式，
		如果其中某个次线程改变了该信号的处理方式，那么所有的线程将共享这一改变。
		
		
	
	9.2 “信号屏蔽字”和“未决信号字”
			
		9.2.1 回顾“信号屏蔽字”和“未决信号字”
			（1）图：
					
					
					至于“信号屏蔽字”和“未决信号字”是用来做什么的，这里不再介绍，因为在讲信号时，已经讲得非常清楚。
					
					
			（2）修改信号屏蔽字的函数
					int sigemptyset(sigset_t *set);
					int sigfillset(sigset_t *set);
					int sigaddset(sigset_t *set, int signum);
					int sigdelset(sigset_t *set, int signum);
					int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);
	
			
		9.2.2 没有次线程时
				此时整个进程只有一个主线程，整个进程的“信号屏蔽字”和“未决信号字”，就是主线程的“信号屏蔽字”
			和“未决信号字”。
				
				
		9.2.3 有次线程时
				每个次线程都有自己独立的“信号屏蔽字”和“未决信号字”，次线程的“信号屏蔽字”和“未决信号字”是从主线程
			的“信号屏蔽字”和“未决信号字”复制而来的，在复制时，
				
			（1）次线程的“信号屏蔽字”会保留从主线程“信号屏蔽字”所复制的值。
			
			（2）次线程的“未决信号字”会清空，也就是说不会保留所复制值。
			
				如果次线程对某些信号有特殊的“响应需求”的话，可以自己调用如下函数，修改次线程自己的“信号屏蔽字”，
			以实现将某个信号打开或者屏蔽。
					
					int sigemptyset(sigset_t *set);
					int sigfillset(sigset_t *set);
					int sigaddset(sigset_t *set, int signum);
					int sigdelset(sigset_t *set, int signum);
					int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);
			
	
	9.3 多线程时是如何响应信号？
	
		（1）进程收到信号后，进程会找到某一个没有屏蔽该信号的线程去处理在这个信号
					找哪一个线程，由进程说了算。
				
		（2）如果所有的线程都屏蔽了该信号的话，信号发生时，进程会将未决信号记录到某个线程的“未决信号字”中。
					同样的，找哪一个线程，由进程说了算。
		
		（3）当线程收到进程判给它的信号后，而且如果该信号的处理方式还是捕获的话
		
					这个线程在运行时会被中断，然后去执行信号捕获函数，当信号捕获函数执行完毕后，才会
				返回被中断的线程，接着执行。
					
					图：
