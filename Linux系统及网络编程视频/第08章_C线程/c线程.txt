第9章 c线程

	
1. 快速认识下c线程
	
	代码演示：
		
		

2. 为什么会有线程？
		在上世纪60年代，也就是操作系统刚问世不久时，那个时候的OS只有进程没有线程，直到到了80年代才开始
	有了线程这个东西。
		
		为什么有线程这个东西呢？
		主要是人们开始发现，进程有缺点，为了弥补进程的缺点，就发明了线程这个东西，需要注意的是，我说的是
	弥补而不是替代，也就是说线程不会把进程给干掉，线程也是基于进程而实现的，是没办法干掉进程的。


3. 进程的缺点
		我们在前面的课程说过，为了让每个进程有一个安全的独立进程空间，OS使用了虚拟内存机制，通过虚拟内
	存机制，能够让每一个进程都有完全独立的进程空间。
		
		
		
		这种独立的进程空间最大的优点就是，可以很好地保证每一个进程的安全，不被其它进程所攻击或者干扰，
	但是突出的优点往往又会导致另外的缺点。
		
		
		拥有独立进程空间的进程有两大明显的缺点，
	（1）进程间切换的计算机资源开销很大，切换效率非常低
	（2）进程间数据共享的开销也很大
		
		
	3.1 进程间切换的计算机资源开销很大，切换效率非常低
			
			OS是通过虚拟内存机制来实现进程空间独立的，进程在并发运行时需要相互间的切换，切换时必
		然需要涉及虚拟内存机制的控制，但是虚拟内存机制比较复杂，所以在进行进程间切换时，
		会耗费高昂的cpu、缓存(cache)、内存等计算机资源，也非常耗费切换时间。
		
			总之，进程切换的开销很大，有关进程间切换的开销问题，目前因为课程定位问题，我们目前只能以这种笼
		统的方式来解释，不过也确实没有深入介绍的必要，对于大家来说，你只需要清楚进程切换时的计算机资源
		开销是很大就行。
				
				
	3.2 进程间数据共享的开销也很大
	
			当程序涉及多进程时，往往会涉及到进程间的通信，但是由于进程空间的独立性，OS提供了各种各样的通信
		机制，这些通信机制共同原理就是，通过OS来转发进程间的数据，但是调用OS提供的这些通信机制的函数时，
		这些OS函数的运行也是需要消耗相当cpu、内存等计算机资源的，同时也很耗费时间。

			因此，对于我们有OS的计算机来说，虽然进程是必不可少的，但是进程确又不能太多，进程太多会导致计算
		机资源被剧烈消耗，此时你会发现你的计算机非常的卡。

4. 因为进程的缺点，使得早期只有进程的OS存在着非常大的问题
		
		
		在早期，当OS只有进程时，应用程序通过创建子进程来得到多进程的目的大致有两个：
		
		
	（1）目的1：创建子进程，执行新程序
	
	（2）目的2：创建子进程得到多进程，通过多进程并发实现多线任务
			1）同时阻塞的读鼠标和键盘时，如果单线的话会想互影响，需要两线任务来实现。
			2）读写管道时，读操作是阻塞的，为了避免读操作影响写操作，也需要两线任务同时进行。
			3）等等：多线任务的例子很多
			
			
		对于第一种目的，执行新程序时必须创建子进程，这个无法逃避的。
			
		但是对于第二种目的来说，如果使用多进程来实现就存在巨大的问题，因为几乎所有的程序都涉及多线任务的
	操作，而且好些程序往往都是十几个任务以上，如果此时使用多进程来实现多线任务的，这就大致大量进程的产生。
	
		比如计算机运行了100个程序，假设每个程序平均10多个任务，如果全部采用多进程来实现，计算机最终要运行
	的进程就多达上100个。
	
		
		所以在早期使用多进程来实现程序的多线任务时，往往导致计算机进程数量暴增，而进程切换和进程间通信
	的计算机资源开销又很大，因此往往导致计算机非常卡顿，程序的运行效率非常低。
		
		
		当人们认识到进程缺点所带来的巨大问题后，大家就开始思考，能不能使用另一种方式来实现程序的“多线任务”，
	而不是使用多进程来实现，到了上世纪80年代人们就发明了线程这个东西，以弥补多进程实现多线任务的缺点。
		

	
	
5. 线程为什么能弥补进程的缺点

		首先我们需要明白，线程与进程一样，线程和进程会被OS统一调度，所以所有的线程和进程都是一起并发运行的，
	如果线程不是并发的，是不可能实现程序的多线任务的。
		
		有了线程以后，凡是程序涉及到多线任务时，都使用多线程来实现，使用多线程来实现时，线程间的切换和数据
	通信的开销非常低，正因为开销非常低，因此线程还有另一个名称，叫“轻量级的进程”。
	
		总结的讲，说白了线程就是为了多线任务而生的，多线程的多线二字，不就是多线任务的多线二字吗。
	
		
		疑问：使用线程来实现时，线程也需要切换和通信，为什么线程的切换和通信开销就很低呢？
		
		
		
		
		
	5.1 为什么线程切换的开销很低
	
			使用多进程来实现程序的多线任务，多线并发运行时，涉及到的是进程间的切换，我们前面就说过，进程间
		切换时开销非常大。
			
			但是使用多线程来实现多线任务时，由于线程本质上它只是程序（进程）的一个函数，只不过线程函数
		与普通函数的区别是，普通函数时单线的运行关系，而线程函数被注册为线程后，是多线并发运行。
			图：
				
				
			对于普通函数来说，只有当相互调动时才会涉及函数间的切换，但是对于线程函数来说，只要运行的时间片
		到了就会切换，但是不管是那种函数间的切换，进程自己函数的切换只是进程内部的事情，不涉及进程间切换，
		就省去了进程间切换的巨大开销。
			图：

			
			如果是不同进程的线程之间需要切换的话，还是会涉及到进程间的切换了，但是不管怎们说，线程的出
		现，至少为程序内部多线任务之间的切换，省去了大笔的进程切换所导致“资源开销”。
			
			
			疑问：线程切换不一样需要开销？
				刚说过，线程的切换其实就是函数间的切换，函数切换当然也需要开销，但是这些开销相比进程间
			切换的开销来说，已经非常小了。
			
	
	
	5.2 为什么线程间数据通信的开销很低
			线程的本质就是函数，请问大家函数之间如果想要数据共享（通信）的话，应该怎么办？
			
			函数间通信有两种方式：
			（1）具有相互调用关系函数来说
					使用函数传参来通信。
					
			（2）对于没有调用关系的函数来说
					使用全局变量来通信。
						A函数 ————> 全局变量 ————> B函数
						
					所以说全局变量的作用是什么？
					就是用来实现无调用关系的函数间通信的。
						
		
					进程中所有的线程函数除了相互并发运行外，没有调用关系，所以线程函数间想要数据共享的话，
				就使用全局变量来通信。
					
					从这里可以看出，进程内部的线程间进行数据共享非常容易，使用全局变量即可，根本不需要调用什么
				OS提供的通信机制，所以线程间通信的开销自然就非常的低。
	
	5.3 是不是有了线程后，进程就不需要了
				
				有关这个问题，我们在前面就已经回答过，线程是不可能完全替代掉进程的，只有在多线任务时会替代进程，
			但是运行新程序的时，我们还是必须创建子进程。
				
				本小节再次提这个问题，是想重点会回答一下，为什么线程不可能完全替换掉进程。
				
				通过前面的讲解，我们知道线程的本质是函数，函数运行需要内存空间，这个内存空间怎么来，
			事实上线程运行的内存空间就是进程的内存空间，因此线程运行时必须依赖于进程的存在，如果没有进程所
			提供的内存空间这个资源，线程根本无法运行。
				图：
				
				
				
				换句话说，线程作为函数，只是进程的一个部分而已，线程是不可能脱离进程而独立存在。
				
				所以同一个进程中的所有线程，都是运行在相同的进程空间中的，换句话说同一个进程中所有线程共
			相同的进程空间。
			
				这里请大家再思考下，为什么程序（进程）的函数能够通过全局变量来通信，就是因为全局变量、函数
			等全部都在同一个进程空间中，既然进程空间是大家共享的，那么所有的函数，自然就能共享访问在共享
			空间中所开辟出来的全局变量。
				
				对于进程中的所有函数来说（包括线程函数)，进程中几乎所有的资源都是共享的，比如打开的文件描述，
			所有可以被调用的子函数，进程的当前工作目录，进程uid、gid，进程PID等等。
			

			
	5.4 线程自己独立的属性
	
			进程中的所有线程会共享进程提供资源（全局变量、工作目录、打开的文件描述符、子函数等等），但是每
		个线程作为一个单独的执行体，也有属于自己的独立的东西。
			
		（1）每个线程拥有自己独立的线程ID（TID）
			
		（2）每个线程有独立的切换状态
				1）在切换时，当前线程被中断的那条指令的地址
					
				2）线程切换时相关的运行状态

					当线程切换时，必须保存以上信息，以便切换回来后还原现场，从中断处继续运行。
					
					这就好比我正在工作，突然有人来找我，此时我么就被中断了，我就需要保存好我的工作现场，等我
				回来时再还原工作现场，以便接着做。
					
					
		（3）有自己独立的函数栈
					其实每一个函数都有自己的函数栈，所有的函数栈都开辟于进程空间的进程栈。
				
					函数栈的作用就是用来保存函数局部变量的，既然所有的线程函数都有自己的独立的函数栈，自然就有自
				己独立的局部变量。
				
					线程函数的函数栈，我们往往也称为线程栈。
				
		（4）自己独立的错误号
					线程函数的错误号是独立的，所以线程函数出错时，错误号并不是通过设置errno实现的，而是直接将
				错误号返回。
				
		（5）每一个线程有自己独立的信号屏蔽字和未决信号集
				后面还会在介绍。
				
				
		（6）每个线程有自己独立的tack_struct结构体
					
					我们说进程在运行的过程中，OS会为每个进程开辟一个task_struct结构体变量用于存放进程所涉及
				到的各种管理信息，同样的为了管理线程，也会为线程开辟一个task_struct变量，只不过适用于存放
				线程的管理信息的。
				

6. 我们自己写的程序，什么时候使用多线程和多进程
	
	6.1 线程
			程序涉及多线任务时，使用线程。
			
			
	6.2 进程			
			程序涉及到运行新程序时，必须使用多进程，不过一般来说，如果不是大型软件和框架的话，我们的程序并不
		需要执行新程序。
			
			
			
			创建子进程执行新程序，大多都是OS操心的事，比如通过命令行或者图形界面启动程序，此时就涉及到要
		运行一个新的程序，根据我们进程控制章节的学习，父进程（命令行、图形界面）就会创建子进程并加
		载执行新程序。
	
7. 线程控制相关的函数
		
		实现多进程的时候有进程控制，进程控制涉及到的函数有fork、exec、wait、exit等函数，实现多线程的时候，
	同样有线程控制函数，这些线程控制函数有：
		
		pthread_create、pthread_join、 pthread_detach、pthread_cancel、pthread_exit等。
		
		
	7.1 线程函数是由谁提供的
			
			进程控制的fork、exec等函数都是由os系统提供的，那线程函数是由谁提供的呢？
			
			原本线程函数也可以完全由OS来实现，但是后来为了不给OS增加负担，同时也为了提高线程的灵活性，
		后来的线程就不在由OS提供，而是由单独的线程库来提供，不过线程库在实现时，也是调用了相应的系统API的
		，也就是说线程的核心实现也是离不开OS支持的。
			
			
		7.1.1 线程库
			
			（1）c线程函数
						由c线程库提供，注意这个c线程库并不是C标准库，而是POSIX C库的一部分，有关标准C库和POSIX库
					是什么关系，我们在《C深度解析》这门课中讲C库时，有详细的介绍，不清楚的请看这部分内容。
						
						我们通过man手册就可以查看这个函数是属于什么库的。
						演示：
						
						
						我们本章所学习的c线程库，其实windows也是支持的，也就是说学习我们本章后，你在windows下
					的c程序中同样可以调用这些函数来实现c线程。
						演示：
						
						
						
						我们本章所讲的posix的c线程库，是由美国一些标准组织制定，并有相应c语言和unix、Linux维护团队
					开发的。		
					
			（2）java、c++、c#的线程函数
					由他们自己的线程库来实现的。
					
					这些语言的线程库，是由这些语言的维护团队来开发的。
					
					
		7.1.2 线程库和OS系统API的关系
		
					线程库函数实际上也是封住OS的相应API来实现的，如果线程库运行在Linux这边的话，线程库其实就是
				通过调用Linux的clone()等系统函数实现的。
					
					将线程函数注册为线程时，其实就是通过调用这类系统API，然后去模拟我们的进程来实现的，正是因为是
				模拟进程来实现的，所以线程函数才能进程一样，一起被并发运行。
		
		
		7.1.3 可不可以自己实现线程库
				
				如果你有能力，你完全可以自己调用系统API，然后封装做出自己的c/c++/java线程库，不过就个人来说，
			很少人会这么做，一个是因为个人很难有这样的能力，就算勉强实现也是一堆bug，另一个是已经有前辈做
			好的、完善的、免费的线程库，个人做线程库基本没有任何经济价值，换句话不挣钱做它干什么。
		
				
				虽然个人很少自己做，但是不少大公司因为自己的独特的需求，往往会开发出自己公司的线程库，专供自己
			公司使用，不过一般来说这样的情况很少，我们很难遇到。
		
				不过就算遇到了也没关系，不管谁实现的，线程的原理都是一样的，学会了一种线程库函数的使用，使用
			其它线程库时，很快就能上手。
				
				
		7.1.4 学习本章的意义。
			
			（1）c程序经常涉及到多线任务的问题，所以c线程在实际开发中会被经常用到，所以本章必须学
						当然要注意，你要使用多线程的话，必须要OS支持，如果没有OS支持，在裸机上是不能使用多线程库的。
					如果你在裸机上想要实现多线任务，必须想起它办法。
			
			
			（2）所有的线程库的原理和使用方式都是类似，学习本章有助于学习其它语言的线程库
			
						不管是c的线程函数，还是c++、java、c#的线程函数，它们的实现原理都是类似的，顶多就是所用语言和
					具体的细节不太一样，大体上都是一样的，你理解了C线程函数，在学习其它语言的线程库函数就会容易很多。
						
						当然java、c++的线程函数会比c的线程复杂一些。
	
	7.2 c线程控制函数
	
		7.2.1 线程库和函数手册的安装

			所有的线程函数，都可以通过man手册查到的，比如man pthread_create。
			
			如果说你不能查到的话，说明的你的ubuntu没有安装线程库和对应的线程库函数手册，我们需要自己在线安装，
			
			
			sudo apt-get install glibc-doc :安装线程库
			sudo apt-get install manpages-posix-dev：安装线程库的函数手册
			
			
		7.2.2 pthread_create
		
			（1）函数原型
					#include <pthread.h>
					
					int pthread_create(pthread_t *thread, const pthread_attr_t *attr,
						void *(*start_routine) (void *), void *arg);
		
					1）功能
							把void *(*start_routine) (void *)函数注册为一个线程函数，该函数一旦注册成功，这个函数
						就以次线程的方式开始并发运行起来，如果不注册的话，这个函数就是一个普通函数。
							
							凡是使用pthread_create注册的线程，都是次线程，次线程会和主线程一起并发运行。
							
						疑问：谁是主线程？
							main函数的那条线就是主线程，如果一个次线程都没有创建的话，整个进程就只有一个主
						线程，这个主线程也是整个进程。
								
					
					2）返回值
							成功返回0，失败返回非零错误号。
						
						
					3）参数
						（a）thread
								存放线程的TID。
						
						（b）attr
								用于设置线程属性，设置线程属性的目的是为了实现某些特殊功能，如果设置为NULL，表示
							不设置特有的属性，使用线程默认属性所提供的功能即可。
							
								正常情况下，线程默认属性所提供的功能就已经够用了，所以这个参数我们都是设置为NULL。
								
						（c）start_routine：要注册为线程的函数地址
									函数类型为void *(*) (void *)，pthread_create它会把这个函数注册为线程，如果不注册，
								线程函数就是一个普通的函数。
									
									线程函数需要我们自己定义，比如：
									void *pth_fun(void *pth_arg)
									{
										...//线程要做的事情
									}
									
									pth_fun和pth_arg的命名由自己决定。
									
									
						（d）arg
									传递给线程函数的参数，这个参数会传递给pth_arg，如果参数很多的话，我们做成一个结构体，
								然后把结构体变量的地址传过去。
									
									如果你不想传递参数的话，你可以设置为NULL。
					
					
				（2）代码演示				
						创建两个次线程，主线程和两个次线程一起的向同一个文件中写"hello ” “world\n"。

						
						
						说一说需要强调的地方？
						
						1）gcc编译时，必须跟-pthread选项，因为像线程库这类的不常用库，gcc不会默认链接，需要我们明
							确指定链接，如果不明确指定链接，编译链接时会报找不到线程函数的错误。
						
						
						2）main函数调用子函数时，子函数属于主线程这条线，次线程调用子函数时，子函数属于次线程这条线。
						
						3）次线程结束了，对整个进程没有任何影响，但是主线程代表了整个进程的存在，如果主线程结束了，
							整个进程也就结束了，进程都没了线程自然也没了，所以主线程一定不能死。
							
						
						4）C线程函数的启动与c++/java线程函数启动的略微有所不同
						
							（a）c++/java的线程函数被注册为线程后不会立即启动，需要单独调用某个启动函数来启动，
										而c线程函数一旦被pthread_create注册为线程后会立即被启动运行。
							
							（b）c++、java等面向对象的函数，都被封装在类里面，包括线程函数也是如此，而c这种面
									向过程语言的函数，全部都裸露在外的。
				
		7.2.2 pthread_cancel
			
			（1）函数原型
					#include <pthread.h>
					
					int pthread_cancel(pthread_t thread);
					
					1）功能
						 当次线程是死循环时，可以调动这个函数主动取消该线程。
						
					2）返回值
							成功返回0，失败返回非零错误号。
							
							
					2）参数
						thread：要取消线程的TID
					
					
			（2）代码演示
					
					
					
		7.2.3 pthread_exit
			（1）函数原型
					#include <pthread.h>
					
					void pthread_exit(void *retval); 
					
					1）功能
							线程调用这个函数时，可以主动退出（终止）。
							
							这类似于exit函数，不过exit是终止整个进程的，而pthread_exit是终止次线程的。
							如果你在次线程里面调用错误，调用的是exit，整个进程就终止了。
							
							事实上线程也可以通过调动return来退出（终止），不过return和pthread_exit之间有一定的
						区别，具体有什么区别，我们后面再讲。
						
						
					2）返回值
							成功返回0，失败返回非零错误号。
							
					3）参数
							retval：线程结束时的返回值。
							
							如果返回值很多时，就封装成一个结构体，返回结构体变量的地址即可。
							
			（2）代码演示
							
			
			
		7.2.4 pthread_self
			（1）函数原型
					#include <pthread.h>

					pthread_t pthread_self(void);

					1）功能
							线程获取自己的TID，类似于进程调用getpid()获取自己的PID一样。
							
					2）返回值
						成功返回线程TID，失败返回非零错误号。
						
					
			（2）代码演示	
											
		7.2.5 pthread_join
		
			（1）函数原型
					#include <pthread.h>
					
					int pthread_join(pthread_t thread, void **retval);
					
					1）功能：阻塞等待tid为thread的次线程结束，结束时该函数会回收次线程所占用的所有资源（存储空间）。
					
							这个函数只对次线程有意义，对主线程没有意义，因为主线程结束时真个进程就结束了，整个进程资源
						会由父进程回收。
						
							疑问：线程所用内存资源本身就是来自于进程空间，既然进程结束后，整个进程的资源都会被回收掉，
								次线程结束时干嘛要回收资源，等进程结束后一并回收不就得了吗？
								
							答：有些程序（进程）一旦运行后将会长期运行，不会结束，所以次线程在结束时必须回收资源，如果
								不回收，每结束一个次线程就导致一部分资源被占用，慢慢累积会使得整个进程资源越用越少，最好
								导致进程崩溃，所以次线程结束时，必须回收次线程资源。
								
								这个函数一般都是由主线程调用，以回收相关次线程的资源，当然次线程也是可以调用这个函数来回
							收其它次线程资源的。
					
					
					2）返回值
							成功返回0，失败返回错误号。
					
							
					3）参数
						（a）thread：指定要回收次线程的TID
						（b）retval：次线程函数返回的返回值
							
							
							
			（2）代码演示
					
					
					如果线程是被pthread_cancel取消掉的，自动返回-1。
					
					
					
					
					
		7.2.6 pthread_detach	
		
			（1）函数原型
					#include <pthread.h>
					
					int pthread_detach(pthread_t thread);
					
					1）功能
							如果次线程的资源不希望别人调用pthread_join函数来回收的话，而是希望自己在结束时，自动回收
						资源的话，就可以调用这个函数。
							
							这个函数的功能就是分离次线程，让次线程在结束时自动回收资源。
						
					2）返回值
							成功返回0，失败返回错误号。
							
					3）参数
							thread：你要分离的那个次线程的TID。
						
						
			（2）代码演示
					
					pthread_join和pthread_detach作为两种不同的线程资源回收方式，我们只能二选择其一。
		
					
					
					
					
		7.2.7 注册线程退出处理函数
					
					讲进程时，我们说过可以注册进程退出处理函数，其实我们同样可以注册线程退出处理函数，线程
				在退出时会自动调用，实现线程的扫尾处理。
				
				atexit();
				
				exit
				
			（1）注册函数	
					void pthread_cleanup_push(void (*routine)(void *), void *arg);
					void pthread_cleanup_pop(int execute);
				
				
					1）功能
						（a）pthread_cleanup_push
									将类型为void (*routine)(void *)函数注册为“线程退出处理函数”，arg为传递给退出处理函数
								的参数。
						
									注册的原理就是将处理函数地址压入线程栈。
									我们可以反复调用该函数注册多个退出处理函数，但是一般一个就够了。
						
						（b）pthread_cleanup_pop
									执行这个函数时，
									· 如果参数写!0：会将压入栈中的推出处理函数地址弹出，然后调用退出函数进行线程的扫尾处理。
									· 如果参数写0：不弹出调用
										
										如果注册了多个线程退出处理函数的话，由于栈先进后出的特点，所以注册压栈的顺序与弹
									栈调动的顺序刚好相反。
													
										这个函数必须和pthread_cleanup_push配对出现，有一个pthread_cleanup_push，就必须要
									对应有一个pthread_cleanup_pop，就算这个函数调用不到也必须写，否者编译时不通过，
									这就好比{}是成对出现的，缺一个都会报错。
								
							
							
							
					2）代码演示
							
							
							
					
					
					3）弹栈线程退出处理函数的几种条件
					
						（a）调用thread_cleanup_pop(!0)，主动弹栈

						（b）如果线程是被别人调用pthread_cancel取消的，也会弹栈
								
						（c）如果线程是调用pthread_exit函数退出的，也会弹栈
									注意，如果线程时调用return退出的话，是不会自动弹栈的，要弹栈的话，必须主动调动
								thread_cleanup_pop(!0)。
										
8. 线程的属性设置

		可以设置的线程属性有，
		· 设置绑定属性
		· 设置分离属性
		· 设置线程堆栈属性
		· 设置线程调度优先级属性
			等等

		如果我们什么属性都不设置，那么线程使用的就是默认属性，事实上默认属性所提供的功能就已经足够我们使用了，
	因此一般不需要设置什么特别的属性。
		
		C线程中设置属性的函数非常多，基本每一种属性都有独立的设置函数，由于很少进行属性设置，因此我们这里
	就不做详细讲解，这里只举一个设置分离属性来实现线程分离的例子。

		将线程分离有两种方法：
		· 调用pthread_detach函数实现
		· 通过设置分离属性实现
		
			事实上使用pthread_detach更方便些，不过我们这里还是要介绍第二种方式，主要是想向大家演示一下是
		如何来设置C线程属性，你把这个例子理解了，实际上其它属性的设置都是类似的操作，自己上网查阅资料就
		能实现。
		
		
	7.1 分离属性设置的步骤
	
		（1）定义一个变量来存放新属性
					pthread_attr_t attr;
					
					pthread_attr_t 这个类型实际上是一个结构体，被typedef重命名了。
					
					
		（2）调用int pthread_attr_init(pthread_attr_t *attr); 初始化一下attr结构体变量
					
					pthread_attr_init(&attr);
					成功返回0，失败返回错误号。
		
					
					
		（3）调用int pthread_attr_setdetachstate(pthread_attr_t *attr, int detachstate);
					预设分离属性。
					
					例子：
					pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED);
					指定PTHREAD_CREATE_DETACHED宏后，pthread_attr_setdetachstate函数会自动的将分离属性相关的
				数据设置到attr结构体变量的各个成员中。
				
					如果想要预设其它属性，就必须调用其它属性相关的函数来实现，这里不再举例。
				
		
		（4）调动pthread_create创建线程时，将attr传递给pthread_create，将线程分离
					pthread_create(&pth, &attr, pth_fun, &arg);
					
					
		（5）删除属性设置
				int pthread_attr_destroy(pthread_attr_t *attr);
		
				pthread_attr_destroy(&attr);
				成功返回0，失败返回错误号。
				
				
	7.2 代码演示
				
8. 线程的资源（数据）保护	
		
	8.1 进程的资源保护
	
			对于进程来说，由于每个进程空间是完全独立的，相互间不可能篡改对方进程空间的数据，所以进程空间
		内部的数据（资源）保护的非常到位，不需要加什么额外的保护机制。
		
			只有当它们共享操作第三方资源时才会涉及到资源保护问题，比如共享操作第三方文件（或者共享内存）
		的数据时，才会使用到进程信号量这样的资源保护机制。

			我们在讲进程IPC的时候就说过，虽然进程信号量被划到“IPC”中，但是进程信号量的作用实际上是借助通信
		来实现资源（数据）保护。

			对于进程来说，因为进程空间的独立性，因此进程资源的保护很到位，反倒是进程间共享数据很困难，因此
		OS提供了管道、消息队列等进程间通信机制。

			这就好比两人闹矛盾，老死不相往来，相互间完全隔绝，各自的私人秘密保护的很好，但是相互间通信反倒
		成了难事。
	
	
	8.2 线程的资源保护
	
			对于线程来说，由于进程内部的所有线程共享进程空间，因此线程间使用全局变量即可实现数据共享，数据
		通信的实现非常容易，不过数据共享越是容易，数据相互篡改的危险性就越高，因此对于线程来说，需要重
		点考虑如何保护资源（数据），防止相互篡改。
			
			这就好比两个人关系非常好，好到穿一条裤子，好到什么秘密都分享，相互间共享秘密不是问题了，但是
		各自秘密的保护反倒成了问题。
		
		
		总结：
		（1）进程：进程空间天然是独立的，因此进程间资源的保护是天然的（现成的），需要重点关心的进程间的通信
		（2）线程：多线程天然的共享进程空间，因此线程数据共享是天然的（现成的），需要重点关心的是资源的保护
			
			
			
	
	8.3 线程的资源保护机制
			
			C线程的资源保护机制有
			· 互斥锁
			· 信号量
			· 条件变量
				等
			
			我们这里重点介绍的是互斥锁、信号量、条件变量。
			
			这三种资源保护机制，不仅在C线程里面有，在c++、java等的线程里面同样有，它们的实现原理和工作目的
		都是类似的，所以学习c线程的资源保护机制，非常有利于大家理解c++/java等线程的资源保护机制。
			
								
		8.3.1 互斥锁
				互斥锁的作用就是用来实现互斥的，至于什么是互斥，我们这里不再赘述，因为互斥的概念我们在讲进程
			信号量的时候，已经介绍的非常清楚。
			
				尽管一个进程的互斥，另一个是线程的互斥，但是它们的原理都是一样的。
	
	
			（1）互斥锁使用的步骤
					1）定义一个互斥锁（变量）					
					2）初始化互斥锁：预设互斥锁的初始值
					3）加锁解锁
					4）进程退出时销毁互斥锁

					
			（2）互斥锁函数
			
					1）初始化互斥锁的函数
						（a）函数原型	
								#include <pthread.h>
							
								int pthread_mutex_init(pthread_mutex_t *restrict mutex, 
																									const pthread_mutexattr_t *restrict attr);
								
								· 功能：初始化定义的互斥锁
										什么是初始化，就是设置互斥锁所需要的值。
													
								· 返回值
										总是返回0，所以这个函数不需要进行出错处理。
										
										
								· 参数
									- mutex：互斥锁，需要我们自己定义。
										比如：pthread_mutex_t mutex;
											
										pthread_mutex_t是一个结构体类型，所以mutex实际上是一个结构体变量。
										
									- attr：互斥锁的属性
											设置NULL表示使用默认属性，除非我们想要实现一些互斥锁的特殊功能，否则默认属
										性就够用了。
									
											如果你真想设置互斥锁属性的话，其设置方法与设置线程属性是类似的，由于很少用到，
										我这里就不在介绍，大家目前也没有必要了解，哪一天你用到了，有今天的知识作为基础，
										你自己都能研究搞定，就算我这里讲了，东西太多会把大家搞糊涂了，反倒会起到反效果。
							
							
							

						（b）代码演示
								在我们之前例子中，多线程向同一个文件写"hello "、"world\n"时，存在hello hello world
							这种情况，出现这种情况的原因是因为线程在相互切换时，数据相互干扰导致的。
								图：
								
								
								我们先使用互斥锁来解决这个问题，看一下解决的原理。
								图：
						
						
						
						
						
						
						

					2）加锁解锁函数
						（a）函数原型
								#include <pthread.h>
							
								int pthread_mutex_lock(pthread_mutex_t *mutex);
								int pthread_mutex_unlock(pthread_mutex_t *mutex);
								
								· 功能
									- pthread_mutex_lock：阻塞加锁
											如果锁没有解开时，当前线程尝试加锁时会阻塞，直到加锁成功为止。
											
										兄弟函数：pthread_mutex_trylock(pthread_mutex_t *mutex)
										非阻塞加锁，加锁成功是最好，如果不成功就错误返回，不会阻塞。
										
										这个函数了解即可，不需要掌握，如果感兴趣，下去后可以自己试验。
										
										
									- pthread_mutex_unlock：解锁，解锁不会阻塞
									
								· 返回值
									成功返回0，失败返回错误号。
									
								· 参数
									mutex：需要加锁和解锁的互斥锁
							
						（b）代码演示
					
					
					
					
				
					3）pthread_mutex_destroy
						（a）函数原型
							#include <pthread.h>
							
							int pthread_mutex_destroy(pthread_mutex_t *mutex);
						
						（b）功能：销毁互斥锁
									所谓销毁，说白了就是删除互斥锁相关的数据，释放互斥锁数据所占用的各种内存资源。
						
						（c）返回值：成功返回0，失败返回非零错误号
						
						（d）代码演示
					
													
													
													
													
					4）再说说互斥锁
					
						（a）初始化互斥锁有两种方法
								· 第1种：使用pthread_mutex_init实现
								
								· 第2种：定义互斥锁时直接初始化实现
										pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;
											与
										pthread_mutex_init(&mutex, NULL);
										的功能时一样的，都是将互斥锁设置为快锁，什么是“快锁”，后面再解释。
										
										代码演示：
										
										
										怎么理解pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER ？
										这句话的本来面目是：
										struct mutex*** mutex = {**,**,**,...};
										
										这个是典型的结构体变量的初始化，pthread_mutex_t其实就是对struct mutex*** typedef后
									的类型，PTHREAD_MUTEX_INITIALIZER的宏值为{**,**,**,...}就。
								
							（b）请问，以下写法对不对：
									pthread_mutex_t mutex;
									mutex = PTHREAD_MUTEX_INITIALIZER;
									
										等价于
									struct mutex*** mutex;
									mutex = {**,**,**,...};
									
									说白了这就是在尝试给结构体变量进行整体赋值，我们讲c时说过，结构体变量是不能够整体赋
								值的，所以写法是错误的。
									如果你想给结构体变量赋值的话，只能一个一个的给结构体成员赋值来实现。
									
									其实我们调用pthread_mutex_init函数来初始化互斥锁时，这个函数设置初始值的方式，就是
								给mutex这个结构体变量的成员一个一个的赋值来实现的。
								
									所以说：
									· 调用pthread_mutex_init函数来给mutex设置初始值时，实现的本质是结构体赋值。
									· 使用pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER方式给mutex设置初始值时，
										实现的本质是结构体初始化。
								
								
						· 有关PTHREAD_MUTEX_INITIALIZER宏
						
								实际上除了这个宏外，还有两个宏，分别是：
									PTHREAD_ERRORCHECK_MUTEX_INITIALIZER_NP
									PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP
						
						
								- PTHREAD_MUTEX_INITIALIZER：快速互斥锁（或叫阻塞互斥锁），简称快锁。
									快锁的特点是：
									+ 加锁不成功是会阻塞，如果不想阻塞必须使用pthread_mutex_trylock来加锁，而不是
										pthread_mutex_lock。
									
									+ 对于同一把快锁来说，不能多次加锁，否者会出错
									+ 已经解锁的快锁也不能再次解锁，否者会出错

								- PTHREAD_ERRORCHECK_MUTEX_INITIALIZER_NP：检错互斥锁
									使用pthread_mutex_lock加锁时，如果加锁不成功不会阻塞，会直接出错返回。
									加锁不成功就直接错误返回，所以才被称为“检错互斥锁”。
									
								- PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP：递归互斥锁。
									特点：
									+ 同一把锁可多次枷锁，每加一次锁，加锁次数就会加1
									+ 解锁时，解锁的顺序刚好与加锁顺序相反，每解锁一次，加锁次数就会减1。
									
									正是由于可以重复的加锁和解锁，所以才被称为递归加锁。
								
								我们要求掌握的快锁，常用的也是快锁，至于检错锁和递归锁了解即可。
								
								
						· pthread_mutex_init(&mutex, NULL)设置是什么锁
								前面说过，当第二个参数为NULL时，默认设置的是快锁。
								
								如果你想通过pthread_mutex_init函数，将mutex初始化出“检错锁”和“递归锁”的话，我们必须通过
							第二个参数进行相应的属性设置来实现，不过我们这里就不介绍了。
							
								如果你真想使用“检错锁”和“递归锁”，建议还是使用直接初始化的方式，这样会更方便。
									pthread_mutex_t mutex = PTHREAD_ERRORCHECK_MUTEX_INITIALIZER_NP;
									pthread_mutex_t mutex = PTHREAD_RECURSIVE_MUTEX_INITIALIZER_NP;
		
		8.3.2 线程信号量 
			（1）进程信号量与线程信号量
		
						线程的信号量与进程的信号量几乎完全相同，只不过一个是给进程用的，另一个是给线程用的。
						
						我们使用进程信号量时，我们自己往往还需要二次封装，线程的信号量函数则不需要，直接就可以
					使用，所以线程的信号量使用起来更加容易，应该说使用难度非常低。
				
				
			（2）二值信号量和多值信号量
			
						对于线程信号量来说，也分为二值信号量和多值信号量，同样的我们这里只讲二值信号量。
					使用二值信号量时，往往用来实现“互斥”和“同步”。
			
						如果想实现互斥的话，更多的还是使用前面讲的互斥锁来实现，因为线程互斥锁提供了更多可自供
					选择的功能，比如可以设置为“检错锁”、“递归锁”等。
			
						如果你只是想实现简单互斥的话，不管是使用线程互斥锁的“快锁”来实现，还是使用线程信号量来
					实现，最终所实现的互斥效果都是一样的。
					
			
			（3）信号量的使用步骤
			
					1）定义信号量集合
						（a）用于互斥时，集合中只需要一个信号量。
						（b）用于同步时，有几个线程需要同步，集合中就需要包含几个信号量
						
					2）初始化集合中的每个信号量
							设置初始值，二值信号量的初始值要么是0、要么是1。
						
						（a）如果是用于互斥，基本都是设置为1
						（b）如果是用于同步，看具体情况
						
							与我们讲进程信号量时的情况是一样的。
						
					3）p、v操作
						p操作：信号量值-1
						V操作：信号量值+1
						
					4）进程结束时，删除线程信号量集合
			
					
					
					
			（4）线程信号量相关的函数
					
					1）初始化信号量的函数

						（a）函数原型
								#include <semaphore.h>
								
								int sem_init(sem_t *sem, int pshared, unsigned int value);
						
								· 功能
									初始化线程信号量集合中的某个信号量，给它设置一个初始值。
						
								· 返回值
									成功返回0，失败返回-1，errno被设置。
									注意信号量的错误号不是返回的，而是设置到errno中。
								
								· 参数
									- sem：信号量集合中的某个信号量
									
												信号量集合需要我们自己定义，
												
												比如：sem_t sem[3]，
												线程信号量集合其实就是一个数组，数组每个元素就是一个信号量。
												
												sem[0]：第一个信号量
												sem[1]：第二个信号量
												sem[2]：第三个信号量
												
												sem_init(&sem[0], int pshared, unsigned int value);
									
											线程信号量集合其实就是自定义的一个数组，而进程信号量集合则是通过semget函数创建的。
											
											我们只要把数组定义为全局变量，所有的线程即可共享使用，不像进程信号量，需要semid
										才能实现共享操作。
										
										
									- pshared：
									  + 0：给线程使用
									  + !0：可以给进程使用
										   不过对于进程来说，我们更多的还是使用进程信号量，因为线程信号量用到
										 进程上时，存在一些不稳定的情况。
								
									- value：初始化值
									 对于二值信号量来说，要么是1，要么是0。
		
		
		
		
		
		
						（b）代码演示
						
								· 使用信号量实现互斥，让多个线程向同一文件写“hello” “world\n”时不要出
									现hello hello world的情况。
									
									实现互斥时，信号量集合中只需要一个信号量，而且初始值需要被设置为1。
									sem_t sem[1]。//定义信号量集合，集合只有一个元素
									
									sem_init(&sem[0], 0, 1);
									
									for(i=0;i<1;i++)
									{
										if(i == 0) sem_init(&sem[i], 0, 1);
										else sem_init(&sem[i], 0, 0); 
									}
									
									代码演示：
									
								
	
					3）P操作
						（a）函数原型
								#include <semaphore.h>
								
								int sem_wait(sem_t *sem);//阻塞p操作
					
								
							· 功能：阻塞p操作集合中某个信号量，值-1
								如果能够p操作成功最好，否则就阻塞直到p操作操作成功为止。
								
								
							· 返回值：成功返回0，失败返回-1，errno被设置。
							
							· 参数：p操作的某个信号量。
								比如：sem_wait(&sem[0]);
							
							· sem_wait的兄弟函数
									
									int sem_trywait(sem_t *sem)：不阻塞
										如果能够p操作就p操作，如果不能p操作就出错返回，不会阻塞。
									
									int sem_timedwait(sem_t *sem, const struct timespec *abs_timeout);
										可以设置阻塞时间，如果能够p操作就p操作，不能就阻塞，如果在设置的时间内好没有
										p操作成功就是出错返回，不再阻塞。
									
									这两个函数了解即可，不需要掌握，如果你真的用到了，自己举一反三即可搞定。
								
									
						（b）代码演示
									
									
									
									
					4）v操作
						（a）函数原型
								#include <semaphore.h>
	
								int sem_post(sem_t *sem);
						
								· 功能：对某个信号量进行v操作，v操作不存在阻塞问题。
										v操作成功后，信号量的值会+1
								
								· 返回值：成功返回0，失败返回-1，errno被设置。
								
						（b）代码演示
								sem_post(&sem[0]);
						
								
								
						
					2）删除信号量
						（a）函数原型
									#include <semaphore.h>
									
									int sem_destroy(sem_t *sem);
								
							 · 功能：删除某个信号量，把所有信号量都删除后，信号量集合就被销毁。
							 
									这与删除进程信号量集合有所不同，对于进程信号量集合来说，只要删除一个信号量，整个集合
								即被删除，但是对于线程信号量来说，需要一个一个的删除，当所有信号量都删除完后，集合才被
								删除完毕。

								
						（b）代码演示
						
						
						
										
			（5）使用线程信号量，实现线程之间的同步					
						
						比如有三个线程（1主线程，2个次线程），分别打印333333、222222、111111，使用同步让他们顺序
					的打印111111、222222、333333。

						
					· 使用信号量实现同步
					
							使用进程信号量实现进程同步时，有多少个进程需要同步，集合中就需要包含几个信号量。
							
							同样的，使用线程信号量实现同步时，有几个线程需要同步，集合中就需要包含几个信号量。
								
							图：
						
					
		8.3.3 条件变量
		
		（1）线程配合工作的例子	
		
				例子：主线程对va变量循环+1，次线程发现va==5时，打印va的值并将va清0，如果va的值!=5就什
							么都不做。
						
							像这种多线程通过共享数据然后配合工作的例子很多，虽然我举的例子很简单，但是足以说明多
						线程相互配合的情况。
						
						
					采用最笨的实现方法：次线程循环检测va的值，然后做出相应的响应。
					图：
					
					代码演示：
					
					

				
					这种循环检测的方法虽然简单，但是存在很大的问题，那就是当va不满足时，次线程会一直在不停的循
				环检测，cpu执行次线程的while时其实是在空转，白白浪费cpu的资源。
					
					最好的方式是，当va条件不满足时就应该让次线程休眠（阻塞），等主线程将va准备好时，主动通知
				次线程，将它唤醒，像这样的解决方式，我们就可以使用条件变量来实现。
				
				
					c++和java等线程同样有条件变量机制，条件变量的作用也是一样的，所以如果你理解c线程的条件变量，
				不难理解c++/java的条件变量。
				
				
		（2）条件变量的作用
					多线程配合工作时，当线程检测到某条件不满足时就休眠，直到别的线程将条件准备好，然后通过条件
				变量将其唤醒。
					
					条件变量需要在互斥锁的配合下才能工作。
					
					
					
		（3）条件变量的使用步骤
				1）定义一个条件变量（全局变量）
					由于条件变量需要互斥锁的配合，所以还需要定义一个线程互斥锁。
					
					如何配合，代码演示时再说。
				
				2）初始化条件变量
				
				3）使用条件变量
				
				4）删除条件变量
					也需要把互斥锁删除。
					
					
					
					
		（4）相关函数
		
				1）初始化条件变量的函数
				
					（a）函数原型
							#include <pthread.h>
					
							int pthread_cond_init(pthread_cond_t *restrict cond,const pthread_condattr_t *restrict attr);
					
						· 功能
								初始化条件变量，与互斥锁的初始化类似。
								pthread_cond_t cond; //定义条件变量
								pthread_cond_init(&cond, NULL); //第二个参数为NULL，表示不设置条件变量的属性。
								
								也可以直接初始化：
								pthread_cond_t cond = PTHREAD_COND_INITIALIZER;//与互斥锁的初始化的原理是一样的
							
							
						· 返回值：成功返回0，失败返回非零错误号

						· 参数
							- cond：条件变量
							- attr：用于设置条件变量的属性，设置为NULL，表示使用默认属性
						
					（b）代码演示
							
							
							
							
				2）等待条件的函数
				
					（a）函数原型
							#include <pthread.h>
							
							int pthread_cond_wait(pthread_cond_t *restrict cond, pthread_mutex_t *restrict mutex);	
						
							· 功能：
									检测条件变量cond，如果cond没有被设置，表示条件还不满足，别人还没有对cond进行设置，此时
								pthread_cond_wait会休眠（阻塞），直到别的线程设置cond表示条件准备好后，才会被唤醒。
								
							· 返回值：成功返回0，失败返回非零错误号
							
							· 参数
								- cond：条件变量
								- mutex：和条件变量配合使用的互斥锁
					
					
					（b）代码演示		
							
						
					（c）pthread_cond_wait的兄弟函数
							int pthread_cond_timedwait(pthread_cond_t *restrict cond, \
										        pthread_mutex_t *restrict mutex, const struct timespec *restrict abstime);
								
									多了第三个参数，用于设置阻塞时间，如果条件不满足时休眠（阻塞），但是不会一直休眠，
								当时间超时后，如果cond还没有被设置，函数不再休眠。
			
									
									
				3）设置条件变量的函数		
				
					（a）函数原型
							#include <pthread.h>
							
							int pthread_cond_signal(pthread_cond_t *cond);
							
							
						· 功能
								当线程将某个数据准备好时，就可以调用该函数去设置cond，表示条件准备好了，
							pthread_cond_wait检测到cond被设置后就不再休眠（被唤醒），线程继续运行，使用别的线程
							准备好的数据来做事。
								
								当调用pthread_cond_wait函数等待条件满足的线程只有一个时，就是用pthread_cond_signal
							来唤醒，如果说有好多线程都调用pthread_cond_wait在等待时，使用
								int pthread_cond_broadcast(pthread_cond_t *cond);
								
								它可以将所有调用pthread_cond_wait而休眠的线程都唤醒。
				
				
					（b）代码演示
							
									
							
							调用pthread_cond_signal去设置条件变量，相当是给pthread_cond_wait发送了一个线程间专
						用的信号，通知调用pthread_cond_wait的线程，某某条件满足了，不要再睡了，赶紧做事吧。
							
							
							
							
				4）删除条件变量									
					（a）函数原型
							#include <pthread.h>
							
							int pthread_cond_destroy(pthread_cond_t *cond);
						
						
					（b）代码演示
							
9. 有关多线程时的信号问题
	
	
	9.1 所有的线程共享相同的信号处理方式
		
			在我之前的例子代码中，主线程将SIGINT信号的处理方式设置为了捕获，那么所有的次线程共享这一处理方式，
		如果其中某个次线程改变了该信号的处理方式，那么所有的线程将共享这一改变。
		
		
	
	9.2 “信号屏蔽字”和“未决信号字”
			
		9.2.1 回顾“信号屏蔽字”和“未决信号字”
			（1）图：
					
					
					至于“信号屏蔽字”和“未决信号字”是用来做什么的，这里不再介绍，因为在讲信号时，已经讲得非常清楚。
					
					
			（2）修改信号屏蔽字的函数
					int sigemptyset(sigset_t *set);
					int sigfillset(sigset_t *set);
					int sigaddset(sigset_t *set, int signum);
					int sigdelset(sigset_t *set, int signum);
					int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);
	
			
		9.2.2 没有次线程时
				此时整个进程只有一个主线程，整个进程的“信号屏蔽字”和“未决信号字”，就是主线程的“信号屏蔽字”
			和“未决信号字”。
				
				
		9.2.3 有次线程时
				每个次线程都有自己独立的“信号屏蔽字”和“未决信号字”，次线程的“信号屏蔽字”和“未决信号字”是从主线程
			的“信号屏蔽字”和“未决信号字”复制而来的，在复制时，
				
			（1）次线程的“信号屏蔽字”会保留从主线程“信号屏蔽字”所复制的值。
			
			（2）次线程的“未决信号字”会清空，也就是说不会保留所复制值。
			
				如果次线程对某些信号有特殊的“响应需求”的话，可以自己调用如下函数，修改次线程自己的“信号屏蔽字”，
			以实现将某个信号打开或者屏蔽。
					
					int sigemptyset(sigset_t *set);
					int sigfillset(sigset_t *set);
					int sigaddset(sigset_t *set, int signum);
					int sigdelset(sigset_t *set, int signum);
					int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);
			
	
	9.3 多线程时是如何响应信号？
	
		（1）进程收到信号后，进程会找到某一个没有屏蔽该信号的线程去处理在这个信号
					找哪一个线程，由进程说了算。
				
		（2）如果所有的线程都屏蔽了该信号的话，信号发生时，进程会将未决信号记录到某个线程的“未决信号字”中。
					同样的，找哪一个线程，由进程说了算。
		
		（3）当线程收到进程判给它的信号后，而且如果该信号的处理方式还是捕获的话
		
					这个线程在运行时会被中断，然后去执行信号捕获函数，当信号捕获函数执行完毕后，才会
				返回被中断的线程，接着执行。
					
					图：
