3. 枚举
	其实没有枚举这个东西也是可以的，很多人做了多年c开发，几乎就没有怎么用过枚举，但是也照样开发的很好，
但是在很多C的源码中，枚举的使用频率还是非常高的，因此需要理解枚举是什么，而且枚举也确实有自己的优点，
我们也鼓励大家在自己的代码中多使用枚举。
	在c、c++、java等其它语言中都是有的。

3.1 枚举怎么来的
	枚举来自于宏定义的不够完美，当然有了枚举后，并不会因此就把宏定义给干掉了，因为在普通情况下，宏定义使
用起来还是非常方便的，不过在某些情况下，使用枚举则会更好些。
	
3.2 宏定义的问题
3.2.1 宏定义是散列的
	#define SUN		0
	#define MON 	1
	#define TUE 	2
	#define WEN   3
	#define THU   4
	#define FRI		5
	#define SAT		6
	
	这些宏定义是散列的，事实上对于一般的宏定义来说，相互之间没有什么关系，所以散列着并没有什么大不了的，
但是对于相互间有关联的宏来说，散列着不利于代码的辨识。

	比如一周的7天，一年的12个月、一个月的30天等宏定义，相互间是有关联的，散列着不利于体现它们之间的相
互关系。


3.2.2 宏定义传参问题
	前面“星期宏”的类型为int型，在传递这些宏时，形参类型就为整形。
	
	void fun(int weekDay)
	{
		pritnf("%s\n", weekDay);
	}
	
	fun(SUN);
	fun(TUE);
	...
	fun(SAT);
	
		fun(100)也是没有问题的，因为100也为int，但是100并不是一周的某一天，并不符合我们传参需求，假如
	传递100是提醒我们，参数不符合要求，那是不是更好呢？显然宏是做不到的，但是枚举能做到。
	
3.2.3 枚举的优势
	宏定义散列的问题，传递宏时参数不符合要求的问题，都可以被枚举解决。
	
	
3.3 枚举的详细情况
3.3.1 枚举类型的定义
	enum week   
	{
		SUM,   //与#define SUM 0 等价 
		MON,   //与#define MON 1 等价
		TUE,
		WEN,
		THU,
		FRI,
		SAT,
	};
		
	以上为一个为枚举类型
（1）enum：枚举关键字，类似union、struct
（2）week：枚举类型的名字
（3）{...}：{}中的为枚举元素（枚举值）
		每一个枚举元素等效于#define定义，比如里面的SUM等效于#define SUM 0，但是与宏不同的是，SUM、MON等
	被{}集中在了一起，不再是散列的,枚举的这种集中化的管理，可以让我们代码具有更高的识别度，让代码变的
	更加的优美。
	
		通过week这个名字，我们一看就知道SUM、MON等就是一周的每一天。
		
3.3.2 枚举元素
（1）枚举元素的值	
		直接通过列子来介绍。
		
		1）enum week{SUM, MON, TUE, WEN, THU, FRI, SAT};
			都没明确给值时，默认情况为，第一个SUM为0，第二个MON为1，第三个TUE为2，后面的依次类推即可。
		
		
		2）enum week{SUM=2, MON, TUE=5, WEN, THU=10, FRI, SAT};		             
				MON=3        
				WEN=6       
				FRI=11  
				SAT=12
		
		3）枚举元素的值必须为整形
			enum week{SUM, MON=12.56, TUE, WEN, THU, FRI, SAT};
			编译时会报错。
			
			这也是枚举的一个缺点，不能指定浮点、字符串、等等，但是宏定义可以：
			#define A   12.56
			#define B   "hello world"
			#define C   PI
			
			宏和枚举各有优缺，是一个相互弥补的关系。
			
			
（2）枚举元素的使用
			每一个枚举元素与宏定义一样，可以被直接使用的，比如
			printf("%d\n", SUM);
			
			int a = SUM + SAT;

			
（3）每一个枚举元素是一个符号常量，不能被赋值
		前面说过，每一个枚举值与#define是等效的，所以每一个枚举值和宏定义一样，都是一个符号常量，不能被赋值。
		
		SUM = 100;
		SAT = 200;
		
		都无法编译通过。
		
3.3.2 枚举变量
（1）如何定义枚举变量
		enum week   
		{
			SUM,   
			MON,   
			TUE,
			WEN,
			THU,
			FRI,
			SAT,
		}weekday;   
	
		或者： 
		enum week weekday;
		
		weekday为枚举变量。

		
（2）给枚举变量给值
		可以通过初始化或者赋值来给值。
		
		一般情况下，枚举变量只能给自己类型中的枚举值，比如：
		enum week weekday = SUM;  //初始化 
		weekday = MON;						//赋值
		weekday = FRI; 
		...
		
		不能给枚举类型以外的值，比如：
		weekday = 1; //编译器会报错
		
		比如使用VC++这个IDE来测试，weekday = 1是不能编译通过的。
		
		
		正是由于这一特点，传参时如果将宏替换为枚举值的话，如果传递是“非枚举值的话”，就会帮我们报错，比如：
			#include "stdafx.h" //这个是VC++特有的头文件，在codeblocks下不需要
			#include <stdio.h>
			
			enum Week 
			{
				SUM,
				MON,
				TUE,
				WEN,
				THU,
				FRI,
				SAT,
			};
			
			void fun(enum Week weekday)
			{
				printf("今天是周%d\n", weekday);
			}

			int main(void)
			{	
				fun(WEN);	

				return 0;
			}
			
			如果将fun(WEN)改为fun(100)的话，是无法编译通过的，可以帮我们预防传递错误参数，提高排错效率。
			
			
			不过不幸的是，枚举变量以上的这一特点，只有某些编译器才支持，而有些编译器不支持，VC++使用的是
			windows编译器，支持这一特点，但是gcc编译器并不支持，所以将weekday = 1复制到codeblocks和linux下时，
			确可以编译通过，所以在gcc编译器下，fun(100)这个传参也是能够编译通过。
		
		
3.3.3 总结：何时使用枚举
	当值为整形，而且相互间有关联时，建议使用枚举，你非要使用宏定义也是可以的，但是如果是字符串、浮点数等等，
就不能使用枚举，只能使用宏定义。
	至于传参这个问题，由于不同的编译器会有不同的情况，因此传参时我们不做硬性规定，传递宏定义和枚举都可以。