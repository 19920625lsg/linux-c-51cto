# 2. 宏定义			
## 2.1 宏定义的用途
### （1）减少重复劳动
比如，程序中有很多地方都要用到100这个数，当需要将100修改为200时，就需要到每个引用100的地方将100改为200，这就是重复劳动。  
此时最好就将100定义为宏，`#define NUM 100`,如果需要将100修改为200时，只要修改NUM即可，在预处理时NUM自动就会被替换为200。

### （2）方便阅读
我们在定义每个宏时，宏名都是有一定含义的，而不是随便定义的，有意义的宏名能够帮助我们阅读和理解代码，比如：  
`#define PI 3.14`一看这个宏名你就知道这是圆周率，如果在程序中直接写3.14的话，很难理解这个数字的含义。  

### （3）简化复杂表达式
简化使用调用。  
`#define AREA(a,b) (((a)+(b))*((a)-(b)))/a*b`
在代码中直接调用AREA带参宏，显然简化了代码，向这类的简化复杂表达式的宏，在复杂C源码中非常多，由于这类宏的宏体复杂，往往也成为了很多同学阅读复杂C源码的障碍之一。  

### （4）与条件编译配合使用
```c
#define ARM

#ifdef ARM 
...

#endif
```
							
## 2.2 宏的种类
宏有两种，一种是有宏体宏，另一种是无宏体宏。  

+  `无宏体宏`：`#define X86`
+  `有宏体宏`：`#define NUM 100，#define AREA(r) (r)*(r)*3.14`

### 2.2.1 无宏体宏

#### （1）什么是无宏体宏
只有宏名、没有宏体。

#### （2）定义形式
`#define 宏名`

#### （3）举例
`#define X86`  
预编译完后，由于这个宏没有宏体，所以宏直接替换为空，空就是啥也没有。

#### （4）这种宏有作用吗
有作用，后面讲到条件编译时再介绍。


### 2.2.2 有宏体宏	
有宏体宏分为两种，一种是无参宏，另一种是有参宏。

+ **无参宏**：没有参数，`#define NUM 100`
+ **有参宏**：有参数，`#define AREA(r) (r)*(r)*3.14`

#### （1）无参宏		
##### 1）定义形式	
`#define 宏名 宏体`

##### 2）举例
```c
 #define     YES        1
 #define     NO     	0
 #define     PI      	3.1415926
 #define     OUT     	printf(“Hello,World”);
```  

预处理后，宏名会被替换为宏体。



#### （2）带参宏

##### 1）定义形式	
`#define  宏名(参数表)	宏体`


##### 2）举例
```c
#define  S(a,b)  a*b*10

int main(void)
{
	int va;

	va = S(3,2); //3对应a，2对应b

	printf("va = %d\n", va);

	return 0;
}
```  

预编译处理时，将宏体中的a和b，使用参数中的3和2来替换。  

`va = S(a, b)` ——————> `va = 3*2*10`  


##### 3）带参宏需要注意之处

+ 1）宏名和参数列表之间不能有空格  
	`#define  S (a,b)  a*b*10`       
	由于S和(a, b)之间有空格，宏名变为了S，宏体变为了(a,b) a*b*10，含义发生了变化。


+ 2）写带参宏的时，不要吝啬括号  
	`#define  S(a,b)  a*b*10`   
	其实这个带参宏是有缺点的，如果参数写成如下形式的话，替换后结果可能就完全背离了你的本意。    
　　　　　　 　a　　b         
　　　　　　S(x+1, y+2) ——————————————> `x+1*y+2*10`  

	对于预编译器来说，它再处理宏定义时，它并不知道你的使用意图是什么，它只会忠实的进行替换工作，但是替换之后是否能够达到你要的效果，这个就不一定了。

	**怎么解决？**    
	为了避免这种情况，大家在定义带参宏时不要吝啬括号。  

	`#define  S(a,b)  ((a)*(b)*10)   //为了保险起见，对整个宏体最好也加一个()。`

	`S(x+1, y+2) ——————————————> ((x+1)*(y+2)*10)`



##### 4）带参宏 与 函数			
这两个玩意儿长得很像，但实际上是两个完全不同的东西。

+ 1）例子
```c
#include <stdio.h>

#define  S(a,b)  a*b*10

void s(int a, int b)
{
	return a*b*10;
}

int main(void)
{
	int va1, va2;
	va1 = S(3, 2); //引用带参宏
	va2 = s(3, 2); //调用函数
	printf("va1 = %d, va2 = %d\n", va1, va2);
	return 0;
}
```

仅仅从调用来看，这两个东西确实长得很像，如果将宏也定义为小写的话，仅看调用的话，很难看出这个到底谁是函数谁宏定义。

为了能够让大家快速的区分带参宏和函数，大家在定义宏的时候，**宏名一定要大写**，否则在阅读代码时，很容易与函数搞混，非常不利于代码的阅读和理解。


+ 2）二者的区别
二者是有着本质区别的：

  + （a）带参宏
	+  处理阶段：预编译   
		宏只是一个供我们程序员识别的一个符号，一旦预编译之后带参宏就会消失了，取而代之的是宏体。    
	+  参数列表  
		带参宏的形参是没有类型的，我们使用int 、float等类型只有一个目的，就是使用类型来开辟一个变量空间，变量空间的字节数和存储格式是由类型来决定的，所以定义变量时必须要有类型说明。    
		而带参宏的参数仅仅只起到替换说明的作用，不需要开辟空间来存放实参的值，既然不需要开辟空间，那就不需要类型的说明。  


  + （b）函数
	+ 处理阶段：由编译、汇编、链接阶段处理  
	  在“预编译阶段”是不会处理函数这个东西的，在预编译前后，函数没有任何变化。  
	  + 编译：将c形式的函数编译为汇编形式的函数。  
	  + 汇编：将汇编形式的函数，转为二进制指令的函数  
	  + 链接：进行符号统一和重定位  

	+ 函数是一个独立体，有调用的过程    
	  运行函数时涉及调用的过程，  
	  + 调用时：从当前函数跳转到被调用的函数，开辟形参和自动局部变量时，涉及压栈操作。  
	  + 调用结束：返回到调用函数，释放函数的形参和自动局部变量的空间时，涉及弹栈操作  

	+ 函数的参数列表    
	  函数的形参是需要被开辟空间的，所以必须要要有类型说明。  
			
		
## 2.3 宏的一些值得强调的地方

### 2.3.1 预处理完之后，宏定义和宏引用都会消失

```c
#define NUM  100  //宏定义，预处理后消失

int main
{
	int a;
	a = NUM;  //宏引用，预处理后被替换为宏体，宏引用消失
	return 0；
}
```


### 2.3.2 宏名的字母一般习惯大写，以便与变量名、函数名相区别
有关宏名大写的习惯并不是没事找事，如果宏名小写的话，会很容易和正常的变量和函数混淆。

#### （1）小写的无参宏很容易和变量混淆
```c
#define pi 3.14

int a = 10;

int main(void)
{
	int c = a + pi;

	return 0;
}
```

如果pi不大写的话，仅看使用的位置，很难判断出pie是宏还是变量。


#### （2）小写的带参数宏很容易和函数混淆
```c
#define area(a, b)  ((a)*(b))

int main(void)
{
	int c = area(10, 20); //仅看调用的位置，很难判断area是一个宏还是一个函数。

	return 0;
}
```


#### （3）宏名与变量和函数混淆到底有什么不好

我们在实际开发时，不管是因为调试还是代码维护的原因，我们都需要阅读别人的源码，或者别人阅读自己的源码，或者自己阅读自己的源码（程序写大了自己都糊涂了），阅读代码时我们不可能每个函数都去查看它的定义，我们需要通过名字快速识别然后了解它的作用，但是如果你把宏和变量函数都定义成小写的话，阅读宏时就很容易误解为变量和函数，但是实际上它们之间是有本质区别的，这种理解的错误就非常容易给我们代码阅读带来很多的困惑，进而影响代码的调试和维护。  

正是基于这样的道理，我们这里要求大家尽量将宏写成大写的，而且一定要见名识意。  

`疑问`：难道真的没有小写的宏吗？   
其实也不是，在少数某些特殊情况下，还真有定义为小写的，但是这种情况比较少见。  
比如大家在学习标准IO函数时，有三个宏（stdio.h）：  
     stdin：标准输入（从键盘输入数据）  
     stdout：标准输出  
     stderr：标注出错输出   
     ![三个小写的宏](https://i.loli.net/2019/03/13/5c8878a93f57d.jpg)  
这三个宏其实就是小写的，之所以写成小写，应该是历史遗留问题。  
除了少数的特例之外，对于宏来说，我们要都要大写。  


### 2.3.3 宏定义不是C语句，不必在行末加分号

这个在前面就介绍过，不过以下例子的`;`算什么
`#define STUDENT struct student{int a; int b;};`
例子中的分号只是宏体struct student{int a; int b;};的一个组成部分而已。



### 2.3.4 所有预编译的代码都是独占一行的（不能多行）
`#define STUDENT struct student{int a; int b;};`

为了独占一行，我把结构体写在了一行中，但是这样子不方便理解，我们往往会把它改成如下形式  
```c
#define STUDENT struct student{\
	int a; \
	int b;\
};
```

加了\（连行符）后，其实这几行在同一行中。


### 2.3.5 宏的作用域 与 `#undef`
正常情况下的宏作用域为从定义为位置开始，一直到文件的末尾。如果你希望结束宏的作用域的话，可以使用`#undef`这个预编译关键字。

`a.c`
```c
#define NUM 100 

int fun();

int main(void)
{
	int a = NUM;

	return 0;
}

#undef NUM

int fun()
{
	int a = NUM;//这里将无法使用这个宏
}
```

这里虽然是以.c文件来举的例子，但是如果将宏定义在.h中时，它作用域以及#undef的用法也是一样的。    
对于#undef这个预编译关键字来说，在我们自己的代码中用的比较少，但是大家在阅读OS、库、框架等复杂C源码时，不时的还是会见到这个关键字。  	

### 2.3.6 定义宏时可以嵌套引用其它的宏，但是不能嵌套引用自己

#### （1）嵌套其它宏
```c
#define   WIDTH   	80
#define   LENGTH   	(WIDTH)+40
#define   AREA		WIDTH*(LENGTH)

int main(void)
{
	int a = AREA;

	return 0;
}
```


`请问：如下写法正确吗?`
```c
#define   AREA		WIDTH*(LENGTH)
#define   WIDTH   	80
#define   LENGTH   	(WIDTH)+40

int main(void)
{
	int a = AREA; // WIDTH*(LENGTH) ————>80*(LENGTH) ————>>80*40

	return 0;
}
```

这个写法是正确的，只要宏引用的位置在定义位置的作用域范围内就行。    
显然AREA的引用都在AREA、WIDTH、LENGTH作用域内，所以AREA的引用在替换时，完全不存在任何问题。    
`int a = AREA ——> int a = WIDTH*(LENGTH) ——> int a = 80*(80+40)`    
所以只要宏引用的位置都在“宏定义”的作用域范围内，对于有嵌套关系的几个宏来说，它们的先后关系不存在任何影响。  

#### （2）为什么不能嵌套自己
```c
#define  AREA	  AREA*10

int main(void)
{
	int a = AREA;

	return 0;
}
```

进行宏替换：    
`int a = AREA ————> int a = AREA * 10`  

从这个例子可以看出，嵌套自己时在预编译器做完替换后，最后还剩一个宏名，这个宏名无法再被替换，最后留给第二阶段编译时，将变成一个无法识别的符号，从而报错。所以宏不能嵌套自己，这个函数不一样，函数嵌套调用自己是递归，宏嵌套引用自己就是犯错。    


### 2.3.7 只作字符替换，不做正确性检查

#### （1）为什么不做正确性检查
预编译器处理宏时，预编译器只关心替换的事情，至于替换的宏体的写法是否正确，预编译器本身并不做检查，因为判断写法是否正确的这件事情是由第二阶段的编译来做的。  

#### （2）例子	
a.c

```c
#define NUM 100WEE

int main(void)
{		
	int a = NUM;

	return 0;
}
```

例子中整形数100WEE的写法完全是错的，但是在预编译时根本不会提示任何错误，预编译器会忠实的将NUM换为100WEE，  
演示：`gcc -E a.c -o a.i  //仅预编译`  
但是后续编译时就会报无法识别100WEE的错误。  
演示：`gcc -S a.i -o a.s`  

	
## 2.4 预定义宏
`__DATE__`、`__FILE__`、`__LINE__`、`__TIME__`、`__func__`等，其实预定义宏不止这些，不过这里我们就只介绍这些。

### 2.4.1 什么是预定义宏
预定义宏，也可以称为编译器内置宏，这个宏并没有定义在哪个.h文件中，所以不能再哪个.h中找到这些玩意。进行预编译时，当预编译器看到这些玩意时，会自动处理这些预定义宏。其实将这些预定义宏称为预编译关键字，可能更好些。

### 2.4.2 作用
#### （1）__DATE__：代表预处理的日期
当预处理器检测到__DATE__后，会将其替换为"月 日 年"的字符串形式的时间，时间格式是西方人习惯的格式。

#### （2）__FILE__：代表当前预编译正在处理的那个源文件的文件名
当预处理器检测到__FILE__后，会将其替换为"***.c"的文件名。

#### （3）__LINE__：代表__LINE__当前所在行的行号
当预处理器检测到__LINE__后，会将其替换为__LINE__当前所在行的行号（整形）。


#### （4）__TIME__：代表对源文件进行预编译时的时间
当预处理器检测到__TIME__后，会将其替换为“hh：mm：ss”格式的时间。

#### （5）__func__：当前__func__所在函数的函数名 
不过这个在预编译阶段不会被处理，而是留到编译阶段处理。

#### （6）例子
helloworld.c
```c
#include <stdio.h>

int main(void)
{       
	printf("预编译的日期:%s\n", __DATE__);
	printf("预编译的文件:%s\n", __FILE__);
	printf("当前所在行号:%d\n", __LINE__);
	printf("预编译的时间:%s\n", __TIME__);
	printf("当前所在函数:%s\n", __func__);

	return 0;
}
```

查看预编译结果：
```c
int main(void)
{
	 printf("预编译的日期:%s\n", "Jul  5 2018");  //替换为了日期
	 printf("预编译的文件:%s\n", "helloworld.c"); //替换为了文件名
	 printf("当前所在行号:%d\n", 7);              //替换为了__LINE__所在的行号
	 printf("预编译的时间:%s\n", "02:21:08");     //替换为了预编译的时间
	 printf("当前所在函数:%s\n", __func__);　　　　//没有替换，到第二阶段编译时再处理，__func__代表的函数名是main

	 return 0;
}

```

打印结果：    

	预编译的日期:Jul  5 2018  
	预编译的文件:helloworld.c  
	当前所在行号:7  
	预编译的时间:02:28:15  
	当前所在函数:main  


除了`__func__`外，其它几个都可以定义相应的变量来存放，比如。
```c
int line = __LINE__;
char date[] = __DATE__;
```

### 2.4.3 预定义宏的意义 与 调试宏					

#### （1）意义
常常用于调试打印、跟踪代码用。  

当一个程序写大了后，在调试程序的功能性错误时，往往需要打印信息来跟踪代码，看看程序是运行到什么位置时才出现了功能性错误，以方便我们调试。  
`printf("%s %d %s\n", __FILE__, __LINE__, __func__);`  
当然如果不需要显示文件名和函数名的话，其实直接打印行号就可以了。  
`printf("%d\n", __LINE__);`  

#### （2）调试宏
在每个需要打印的地方都写printf会非常的麻烦，因此我们可以把它写成调试宏。  

##### 1）例子：
```c
#include <stdio.h>

//调试宏，DEBUG的名字可以自己随便起
#define DEBUG printf("%s %d %s\n", __FILE__, __LINE__, __func__);

void exchange(int *p1, int *p2)
{      
	DEBUG
	int tmp = 0;
	DEBUG

	tmp = *p1;
	DEBUG
	*p1 = *p2;
	DEBUG
	*p2 = tmp;
	DEBUG
}

int main(void)
{       
	int a = 10; 
	int b = 30; 

	DEBUG							
	exchange(&a, &b);
	DEBUG

	printf("a=%d, b=%d\n", a, b);

	DEBUG

	return 0;
}
```

通过打印信息来跟踪程序，其实有些时候比“单步运行调试”更好用，因为单步运行调试在某些情况其实很麻烦，不如打印信息来的好使。


##### 2）如果你想打印自定义信息的话，我们还可以将调试宏定义为带参宏
`#define DEBUG(s1, s2) printf(s1, s2);`
在程序中使用时，可以指定你要任何打印的调试信息。
```c
DEBUG("%d\n", va); //你想写什么，可以由你自己决定。
DEBUG("%s\n", str);
```

`疑问`：感觉这也不比直接写printf("%d\n", va)更方便呀？  
不直接使用printf，而是写成DEBUG(s1, s2)带参宏的形式，可以方便我们使用“条件编译”来快速打开和关闭调试宏，后面将再介绍这个问题。
