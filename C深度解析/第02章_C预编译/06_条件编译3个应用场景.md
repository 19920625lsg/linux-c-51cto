# 3.7 具体是什么时候会用到条件编译呢
前面介绍过，大致用在三类地方：
+ （1）文件内容被重复include时，去掉重包含的内容
+ （2）帮助我们的程序的跨平台
+ （3）辅助调试程序
## 3.7.1 文件内容被重复include时，去掉重包含的内容
我们以include 头文件来举例介绍  
当一个C/C++工程文件写复杂后，在一个.c/.cpp中往往可能会包含十几个头文件，误操作使得同一个头文件重复包含多次，这其实是很正常的。重复include的话，预编译器处理#include时，会把同一个头文件的内容重复的复制（包含）到.c中.  
但是我们知道头文件中往往会有`struct ***`等类型的定义，重复包含后，会导致在同一个.c中有重复的结构体类型定义，我们在第一章就说过，`在同一个c文件中不能有重复的类型构体定义`，第二阶段编译时，会报重复定义的错误。  
但是实际上我们在重复inlcude同一头文件时，并没有报错误，那是因为头文件中加入了#ifndef条件编译，所以说#ifndef其中有一个很重要的用途就是用于防止文件被被重复包含。    
			
			（1）以C标准库的头文件stdio.h头为例
					1）windows下stdio.h
					
						#ifndef _STDIO_H_
						#define	_STDIO_H_
						
						//头文件的内容
						...
						
						#endif //头文件的结尾
						
					2）Linux下的stdio.h头文件
						#ifndef _STDIO_H
						#define _STDIO_H       1 
						
						//头文件的内容
						...
						
						#endif
						
						疑问：都是stdio.h，但是它们的宏咋不一样呢，一个叫_STDIO_H_，_STDIO_H？
						答：如果你仔细阅读这两个stdio.h的话，你会发现这它们里面的内容也不一样，这个并不奇怪，说明它们是由
						不同团队编写的，一个是用在windows这边，另一个是用在Linux这边。
						
							尽管二者内容有所区别，但是所要实现的事情都是一样的，不然的话你在Liunx下c程序调用了printf函数，
						结果这个程序到了Windows就不能调用printf了，这就扯淡了。
						
						疑问：宏的头尾怎么都带_呢？
							这个是库、OS的标识符的命名习惯，目的是方便识别，因为你一看到带_打头和结尾你就知道，那一定是库、
						或者OS等标识符。
							
							我们自己的应用程序尽量不要使用这种命名格式，以便与库、OS、框架等的标识符进行区别。
										
					3）使用#ifndef来防止文件重复包含的原理
						举例理解，比如：
								a.c
								#include <stdio.h>
								#include <stdio.h>	
								int main()
								{
									...
								}
									
						（a）第一步：预编译器到相关路径找到include所指定的.h文件，然后将所有.h文件中的内容复制到a.c中，替换掉
								#include <***.h>
								
									注意，重复的.h的内容会被全部复制到.c中。
									
									a.c 
									/* stdio.h */
									#ifndef _STDIO_H_
									#define	_STDIO_H_
									
									头文件的所有内容
								
									#endif
									
									/* stdio.h */
									#ifndef _STDIO_H_
									#define	_STDIO_H_
								
									头文件的所有内容
								
									#endif

									int main()
									{
										...
									}
									
						
						（b）第二步：处理条件编译，去掉重复的内容
								口述：
                
								#ifndef的原理很简单，其实就是先重复包含内容，然后再通过#ifndef将重复的内容去掉。
								
					4）说说“防止头文件内容重复宏”的命名
						（a）不同的头文件中该宏的宏名是不相同的
						
								如果相同的话，就会导致其它头文件无法正常被包含。
								
								比如：假如stdio.h和stdlib.h中“防止文件内容重复的宏”相同的话。
									
									/* stdio.h */
									#ifndef _STDIO_H_
									#define	_STDIO_H_
								
									...
								
									#endif
									
									
									/* stdlib.h */
									#ifndef _STDIO_H_
									#define	_STDIO_H_
								
									...
								
									#endif
										
										当相同时，第一次包含stdio.h时会定义_STDIO_H_，第二次包含stdlib.h时发现这个宏已经被定义了，
									导致stdlib.h的内容被丢弃。

						（b）如何防止宏名冲突呢？
								每个头文件的文件名基本都会不相同的，所以只要你在宏名里面参入文件名，就一定不会重名。
							比如对于我们自己写的头文件来说，可以按照如下方式命名这个宏。
								
								比如：
								student.h
								#ifndef H_STUDENT_H
								#define H_STUDENT_H
								
								...
								
								#endif
							
								或者命名为：STUDENT_H_INCLUDED
								
								你也可以有你自己的自定义命名方式，不管你怎么命名，只要名字中包含“文件名”，该宏不会重名。
								
								当然，如果是使用IDE来创建头文件的话，IDE会自动根据你的头文件名字生成该宏，IDE也会提示你，你可以
							自己修改，但是如果你是使用存文本来编写.h的话，这个宏就需要我们自己定义了。

			#ifndef
				
		（2）条件编译作用2 ———— 帮助我们的程序（c/c++）实现跨环境（平台）
					
					我们在正式介绍之前，我们先了解下有关“跨平台”是怎么回事。

				1）什么是跨平台
						所谓的跨平台，就是让“同一个程序”能够应对多个环境，可以在多个环境下运行，
					这就好比两栖战车，既能在水上环境跑，又能在陆地跑，能够适应不同环境。
						
						这个“环境”主要包含两个方面，一个软件系统环境，另一个是硬件系统环境，
            
					（a）软件系统：主要指OS
							比如有的是windows的，有的是unix的。
							不同的系统本身又分为了很多不同的版本，比如以windows为例，有xp、w7、w8、w10等，unix和Linux自然也存
						在类似的情况。
						
					（b）硬件系统：主要指cpu
							比如有的是Intel的，有的是AMD的，有的是ARM的，同一类型下的CPU也分为不同的版本（架构）。				

						程序跨环境时，环境主要指的就是这两方面。
						
						· 裸机程序跨环境：跨的是硬件环境
							比如这个程序本来是在某个CPU上运行的，现在要到另一个CPU上运行，这时程序就涉及到跨硬件环境运行。

						· 非裸机程序跨环境：软件系统和硬件系统环境都涉及
							非裸机程序，指的就是需要基于OS运行的程序。
							
								比如本来是在ARM（CPU） Linux（os）上运行C程序，现在要到Intel(cpu) windows（OS）上运行，跨环境时，
							即垮了硬件环境，又跨了软件环境。

				2）不同语言所写的程序，是如何实现跨平台的
						语言大致分为两类，编译型语言和解释型语言，不过有关更详细的介绍，请大家看我们的
						
						《计算机体系结构——编译器》
						《计算机体系结构——解释器》
						《计算机体系结构——语言、算法》
							的课程。
					
						不过我们这里因为课程的需要，也简单回顾下。

					（a）编译型语言
					
							· 什么是编译型语言
									如果语言所写的程序能够被直接编译为对应环境的、被cpu直接运行的机器指令
								(存放在了可执行文件中)的话，那么像这类的语言就是编译型语言。

																			编译型语言所写的程序
																						/  \
																					 /    \
																					/      \
											针对windows、Intel /  编译  \ 针对Linux、ARM
												   环境的编译器 /          \ 环境的编译器
																			 /            \
																			/              \
																		 /                \
																	a.exe               a.out
																 windows		         Linux    OS
																 Intel                ARM     CPU
				
										编译型语言哪些：汇编、c、c++、Delphi、Pascal等都是编译型语言。
					
							· 如何实现“编译型语言程序”的跨环境
							
										从上图看出，对于“编译型语言程序”来说，跨环境的核心靠的是编译器，你想让程序在不同的环境上运行，
									就需要使用针对不同环境的编译器来重新编译。

									疑问：对于编译型语言所写程序的跨环境来说，是不是只要换一个针对不同环境的编译器就可以了？
										
										如果不需要修改源码的话，直接换一个编译器就可以了，但是如果需要修改源码的话，就需要先修改源码，
									然后再使用不同环境的编译器来重新编译。
										
										我们这里介绍使用“条件编译”来实现c/c++跨平台，其实就与C/C++跨平台时源码的修改有关。
										
										修改源码、然后编译得到不同环境的可执行程序，其实就是我们常说的移植的过程。

					（b）解释型语言
								Java、JavaScript、VBScript、Perl、Python、Ruby、C#等都是解释型语言，你想知道某门语言是编译型的还是解释型的，自己上网搜索一下就行了。

							· 什么是解释型语言
									
									如果语言所写程序需要被“虚拟机(解释器)”解释才能执行的话，这类语言就是解释型语言。
									java就是典型的解释型语言，所以我们这里就以java为例来详细的介绍下解释型语言。
									java程序被编译后，所得到的并不是可以被直接运行的机器指令，而是一些java字节码（java伪指令），这些字节码放在了.class字节码文件中，我们编译java程序时所看到的各种.class文件，就是这么来的，运行java程序时，运行的也是.class文件。
									运行.class文件时，其实就是运行里面存放的字节码，但是字节码不是机器指令，不能被CPU直接执行，因此字节码需要被“虚拟机”解释（翻译为）为机器指令后，CPU才能执行。
									虚拟机：就是一个翻译软件，将字节码翻译（解释）为对应环境的机器指令，虚拟机也被称解释器。
										不过要注意的是，虚拟机在翻译时是一句一句进行的，也就是每翻译一句CPU就执行一句，并不是一次性翻译完毕，然后再一次性执行。
									
															java文本程序
																	|
																	| 编译
																	|
																	V
														 java字节码程序
																 / \
																/   \
															 /     \
															/       \  
														 /         \
														/           \
													 /  					 \  									
										Windows JVM      Linux JVM     虚拟机：应对不同环境，虚拟机将字节码解释为真正的机器指令，然后运行
										 windows           Linux       OS
											Intel             ARM				 CPU		
								
									
									有些解释型语言所编写的程序是被直接解释的，都不用被编译为字节码。

							· 解释型语言所写的程序，是如何实现跨平台
									从java的运行模型中可以看出，解释型语言实现跨环境的核心靠的是虚拟机。
									在java的世界里有一句名言，“叫做一次编译到处运行”，只要在相关环境中安装了该环境的java虚拟机，之前所编译好的同一份java字节码文件可以在不同环境的虚拟机上运行。
									总之，对于解释性语言所写的程序来说，跨环境靠的是虚拟机。
									
									疑问：虚拟机是“编译型语言”写的，还是“解释型语言”写的？
									答：肯定是编译型语言写的，如果虚拟机是由解释型语言写的，那么虚拟机这个软件在运行时，又需要另一个虚拟机来解析，如此这就陷入了一种死循环。其实有好些个虚拟机，基本都是使用c/c++来实现的。
							
					（c）编译型语言 与 解释型语言的对比
					
							· 跨平台性
							
								- 解释型语言的跨平台
									解释型语言的跨平台性相对会更好些，因为可以一次编译到处运行，跨平台这件事完全交给虚拟机就可以了。
									
									
									疑问：安装虚拟机这个软件会不会很麻烦吗？
										现在很多的OS会自带常见的虚拟机，比如java虚拟机、c#虚拟机，就算OS没有自带也不需要用户自己安装，
									比如以java虚拟机为例，别人在发布java程序时，一并就带了java虚拟机，安装java程序时会自动安装java
									虚拟机。
									
										所以对于用户来说，虚拟机这个软件完全是透明的，用户完全不需要关心。
						
									
								- 编译型语言的跨平台
										编译型语言所写程序的跨平台性稍微比较差些，因为你必须使用针对不同环境的编译器来重新编译，而且
									有时可能还需要修改源码。
										
										从以上的对比可以看出，解释型语言与编译型语言相比来说，解释型语言的跨平台性更好些。
										
										
							
							· 运行效率
									编译型语言的运行效率更高，因为编译型语言所写的程序，会被一次性编译为对应环境的、可以被直接执
								行机器指令，而不需要运行额外的虚拟机来解释，所以效率自然高。
		
		
		
									解释型和编译型语言各有优缺，各有属于自己的应用场合，很多人喜欢过分的夸大解释型语言的优点，
								认为除了解释型语言外，其它编译型语言都是多余的，都是垃圾，这种想法是不对的。
									
									别的不说，最起码一点，如果没有“编译型语言”所写“虚拟机”的话，解释型语言所写的程序就不可能被解释，
								所以说编译型语言和解释性语言，各有各的应用场合，在各自的应用场合下，各自都有不可替代的作用。
									
									疑问：有关编译型语言和解释型语言的应用场合？
									答：请看“《计算机体系结构——软件篇》语言、算法”的课程。
									
						
						
								总结：
								解释性语言：跨平台性更好，但是运行效率相对较差
								编译型语言：跨平台性较差些，但是运行效率会更好些
						
												
				3）c/c++程序如何实现跨平台
						c/c++属于典型的编译型语言，跨平台时大致分两种情况。
						
						第一种：跨平台时不需要修改源码
								直接换一个针对另一个环境的编译器来重新编译即可。
							
						第二种：需要修改源代码
								先修改源代码，然后再换编译器实现重新编译。
							
							
						（a）第一种：不需要修改源码，直接换一个环境的编译器重新编译
									
								· 什么样的C/C++程序跨平台时，不需要修改源码
										只要程序不包含“平台差异代码”，包含的都是“通用代码”的话，跨平台时，不需要修改源码。
									
									
									疑问：什么样的代码是“通用代码”?
										如果代码是如下两种情况的话，就是通用代码。
										
									- 代码只涉及c/c++基本语法
										只要不同环境支持该语言，那么基本语法都是支持的。
									
									- 当代码调用了库函数时，只要该库是不同平台都支持的通用库的话，调用库函数的代码也是通用代码
											比如C标准库就是一个通用库，windows、Linux、Unix等OS都支持，所以在程序中调用c标准库的
										printf函数时，不管是windows、Linux、unix都支持，所以跨平台时printf函数不需要修改。
											
									
								· 例子
											#include <stdio.h>
											
											int main(void)
											{
												int a = 100;
												
												/* 只与基本语法归相关的代码 */
												while(1)
												{
													a = a + 10; 
													if(a==100) break;
												}
												
												printf("a = %d\n", a); //不同环境都支持的通用库函数接口
												
												
												return 0;
											} 
											
											以上这个是通用代码，跨平台时不管是在windows下、还是在Linux下运行，这个通用代码时不需要
										修改源码的，换编译器重新编译即可。
											演示：
											

											
																 C应用程序
																		|
																		|
																	库API(通用库)
 												          /   \
														     /     \  
														    /       \
												       /         \
												   C标准库     C标准库     都支持printf
                       	     |            |
														 |OS API      |OS API
														 |            |
												   Windows      Linux											
                         硬件(CPU等)	  硬件(CPU等)		 							
												
												
												由于C标准库几乎被大多数的OS支持，所以C程序中有printf、scanf、malloc等时，不管在什么平
											台下都能用，跨平台时不需要修改。
											
												如果平台不支持你要的库，但是你还想用，你就必须自己来搞定这个库，有两种搞定方法，
											第一种：在该环境下安装对应的库
											第二种：直接将库和“可执行程序”放在一起，发布程序时一起发布
												
					
									
						（b）第二种：需要修改源码								
									跨平台时为了减少麻烦，我们建议在程序中最好尽量只写通用代码，如此一来跨平台时源码就不用修改了。
									
									但是问题是，有些时候只能做到80%~90%是通用代码，程序中有10%~20%的与平台相关的代码。
									
									比如因为某些特殊原因，C程序中需要直接调用OS API，但是不同的OS的OS API又有区别，与OS API相关的
								代码就是典型的平台相关的代码。
				
									
									这里以windows、Linux为例，为了让我们的C/C++程序能够很好的面对windows、Linux，有如下两种解决办法：
								第一种：写两份独立的功能完全相同的程序，一份专门针对Windows，另一分专门针对Linux
								第二种：只写一份代码，使用条件编译来处理平台相关的代码。
									
								· 写两份独立的C程序，一个针对Windows，另一个针对Linux
									
									
									- 在windows下运行的C程序
	
										#include <windows.h>  //windows OS API所需的头文件

										int main(void)
										{
												/* 通用代码 */
												int i = 0;

												while(1)
												{
														if(i>100) break;
														else i++;
												}

												/* 平台相关代码：windows的操作文件的OS API */
												HANDLE hfile = CreateFile(".\file", GENERIC_READ | GENERIC_WRITE, FILE_SHARE_WRITE \
												| FILE_SHARE_READ, NULL, OPEN_EXISTING, NULL, NULL);
												int dwRead = 0;
												WriteFile(hfile, &i, sizeof(i), &dwRead, 0);   //将i写到file中

												return 0;
										}
		
																		windows环境编译器
										windows的C程序 ————————————————> 在windows下的可执行程序
										
									
								
									- 在Linux下运行的C程序
	
										/* Linux的OS API所需的头文件 */
										#include <sys/types.h>
										#include <sys/stat.h>
										#include <unistd.h>
										#include <fcntl.h>

										int main(void)
										{
												/* 通用代码 */
												int i = 0;

												while(1)
												{   
														if(i>100) break;
														else i++;
												}   
												
												/* 平台相关代码：Linux的操作文件的OS API */
												int fd = open("./file", O_RDWR | O_CREAT, 0774);
												write(fd, &i, sizeof(i));  //将i写到file

												return 0;
										}
						
									
															  Linux环境编译器       
									Linux的C程序 ————————————————> 在Linux下的可执行程序
								
								
										
								· 这种方式的缺点
										由于%80~%90都是相同的通用代码，仅为了那一点平台相关代码的不同，就要写两份独立的程序，显然是
									不是很合适，最起码很浪费时间，如果写一份就能搞定的话，这是最好的。
									
										不过如果80%的代码都是平台相关代码，只有20%是通用代码的话，此时写两份完全独立的程序其实更划算。
											
								
								
							· 只写一份代码，使用条件编译来兼容。					
									这里举一个非常简单的例子，这个例子不具有实用性，但是确实能够说明说明“条件编译”对于跨平台的重
								要性。
										
									#define WINDOWS

									#ifdef WINDOWS
									# include <windows.h>
									#elif defined LINUX
									# include <sys/types.h>
									# include <sys/stat.h>
									# include <unistd.h>
									# include <fcntl.h>
									#endif


									int main(void)
									{
											/* 通用代码 */
											int i = 0;

											while(1)
											{
													if(i>100) break;
													else i++;
											}


									#ifdef WINDOWS
											/* 平台相关代码：windows的操作文件的OS API */
											HANDLE hfile = CreateFileA(".\file", GENERIC_READ | GENERIC_WRITE, FILE_SHARE_WRITE \
													| FILE_SHARE_READ, NULL, OPEN_EXISTING, NULL, NULL);
											int dwRead = 0;
											WrieFile(hfile, &i, sizeof(i), &dwRead, 0);   //将i写到file中

									#elif defined LINUX
											/* 平台相关代码：Linux的操作文件的OS API */
											int fd = open("./file", O_RDWR | O_CREAT, 0774);
											write(fd, &i, sizeof(i));  //将i写到file中

									#endif

											return 0;
									}
									
								- 修改代码中的宏，然后通过“条件编译”来保留对应平台的代码
								- 使用对应平台的编译器来重新编译
									
									在真实开发中修改源码时，其实不仅仅只会打开和关闭条件编译，有时还需要修改代码中其它相关数据。
									
								
				4）java有条件编译吗，java程序跨平台时需要修改源码吗？
				
						前面说过，只要环境安装了java虚拟机，java只需要一次编译即可到处运行，通过“只需要编译一次”的这句话
					我们就能感觉到，java程序跨平台时，其实不需要修改源码。
						
						
						
						为什么java程序跨平台时不需要改源码？
						
							因为在java程序的代码中涉及的通用代码，没有平台相关的代码，跨平台完全由“虚拟机”来完成，总之java被设计
						为了一种跨平台性非常好的语言。
						
							正是由于java是一个跨平台性非常好的语言，所以当初借鉴C来设计java时，设计者果断去掉了C中“条件编译”，
						总之这里就是想告诉大家，java是没有条件编译这个玩意的，不过有类似可以模拟“C条件编译”东西。
		

		（3）条件编译用途3————调试程序
		
					条件编译在调试中的作用：
				· 注销代码
				· 开、关调试宏
				
				
				1）注销代码
					（a）使用// /* */来注销代码
								使用//、/* */注释代码时，说白了就是告诉“预编译器”把这些代码当做注释来处理。
						
							· 单行注销：使用//来注释
							· 多行注销（代码块注销）：使用/*  */
										使用/* */对代码块注释，其实并不是很方便，因为当你打开代码块时需要将/* */都删掉。
									特别是当/* */注销的代码特别长时，会很不方便。
								
							
					（b）使用条件编译来注销代码
							· 单句代码的注销还是使用//来注销，因为单句使用//更方便				
					
							· 代码块的注销，使用条件编译更方便
								例子：
	
								#if 0    //0就是注销（去掉）代码，1就保留代码
								
								int fun(int va)
								{
									int a = 100;
									
									return a*va;
								}
								
								#endif
		
								int main(void)
								{
									int ret = 0;
									
									#if 0
									ret = fun(1000);
									
									printf("ret = %d\n", ret);
									#endif 
									
									retutn 0;
								}
		
								
				2）开、关调试宏								
						有关调试宏我们在前面就讲过，这里我们使用条件编译来快速的打开和关闭调试宏。
						
						直接代码演示
						#include <stdio.h>
						 
						#ifdef DEBUG1
						# define DBG1 printf("%s %d %s\n", __FILE__, __LINE__, __func__);  
						#else
						# define DBG1
						#endif


						#ifdef DEBUG2
						# define DBG2(info1, info2) printf(info1, info2);                                               
						#else
						# define DBG2(info1, info2)
						#endif
							
						void exchange(int *p1, int *p2)
						{      
							DBG1
							int tmp = 0;
							DBG1
							
							tmp = *p1;
							DBG1
							*p1 = *p2;
							DBG1
							*p2 = tmp;
							DBG1
						}
																		
						int main(void)
						{       
							int a = 10; 
							int b = 30; 
							
							DBG2("%s\n", "1111");
							
							DBG1							
							exchange(&a, &b);
							DBG1
							
							printf("a=%d, b=%d\n", a, b);
						
							DBG1
						
							return 0;
						}
	
						通过条件编译可以将调试宏快速可打开和关闭，方便快速查看调试结果，等调试完毕后，我们再将
					程序中的调试宏删掉。

					
