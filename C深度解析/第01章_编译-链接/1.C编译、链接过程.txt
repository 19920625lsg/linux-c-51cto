
=====================================-==============================================================================
============================物联网、嵌入式技术课程 之 《C深度解析》========================================
====================================================================================================================
					
出品：佳嵌工作室
--------------------------------------------------------------------------------------------------------------------
	“佳嵌工作室”致力于物联网、嵌入式产品以及‘物联网、嵌入式技术课程’的研发，希望所推出的技术课程，能够帮助到正在努力
	学习物联网、嵌入式的同学，欢迎大家和我们一起共同学习，共同进步。
--------------------------------------------------------------------------------------------------------------------


1. 课程定位（适合哪些同学学习）

		课程名字叫《C深度解析》，也就是说本门课不是C入门课程，如果你C语言一点都不会的话，这个课程不适合大家进行C入门
	的学习，但是如果你有学习过C语言，但是C语言一直不温不火，想要提升自己C语言的实力，这个课程很适合你。
		
		大家把本门课程学完之后，你完全可以成为C语言高手，虽然不是高高手，但是成为高手还是没问题的。
		
		学习本门课，不仅仅只为了学习C，实际上有些内容对其它语言来说，也是这样的，比如第1章中的c内存结构体，虽然讲的是
	C的内存结构，但是实际上其它语言的程序在运行时，它的内存结构也是这样的。

		大家如果能够把c真正的学好、学精，事实上你完全能找到一份中等偏上的工作了，当然如果你想找一个更好的工作，
	仅仅学通C还是不够的。

	
	
2. 后续C相关的其它课程 
		有两个，分别是《c经典面试题详解》和《c图形界面》。
		
	（1）为什么出《c经典面试题详解》
			不用多说，这就是为C面试准备的
			
			
	（2）为什么出《c图形界面》
			其实C的图形界面库用的不多，因为图形界面各种控件之间的关系，典型的是面向对象的关系，所以像C++和java这种面向
		对象语言的图形界面库，用的才是最多的。
		
			既然c图形界面库用的不多，那我们为什么还要讲呢？两个原因：
			
			1）比如你想写一个界面，但是你又不会c++和java，只会c，那么此时就可以使用c图形界面库来开发界面。
			
			2）讲C图形界面库，还有一个重要原因就是，我们想借着讲C图形界面库，把图形界面的原理给大家讲清楚
					
					估计很多同学对于图形界面库比较蒙圈，特别是里面分什么c、c++、java、c#等不同语言的图形库，它们之间到底
				是什么关系，有什么异同，我们会借助C图形界面库来把这些问题都讲清楚。
		

	
2. 课程章节安排
	
	2.1 课程目录
		（1）C语言的编译过程与c程序的内存结构（存储映像）		
		（2）预处理详细介绍
		（3）存储类、作用域、生命周期、链接属性		
		（4）指针、函数	
		（5）c函数库
		（6）数组与字符串				
		（7）结构体、联合体、枚举				
		（8）c语言中无法独立成章的知识
		（9）C语言的位操作
		（10）使用c来进行应用开发时，所涉及的一些其它相关知识

		
	2.2 章节内容介绍	
	
		（1）C语言的编译过程与c程序内存结构（存储映像）	
				1）IDE 与 源文件开发方式的异同
				2）编译的详细过程
				3）编译器集合的组成
				4）gcc -v，编译信息的详细分析
				5）可重定位目标文件（.o）格式介绍
				6）链接器链接时，符号解析和重定位做了什么事情
				7）可执行目标文件的格式，以及可执行目标文件的加载、执行
				8）程序内存结构介绍，代码和数据(常量、变量)是如何存放在程序的内存结构中的
				
				这一章所讲的内容，对后面每一章都有知识辐射，如果大家能够把这一章真正的理解到位，后面章节的很多知识理解起来
			非常容易，所以第一章是非常重要的核心章节。
				
		（2）预处理详细介绍
				1）宏定义
				2）条件编译
				3）头文件包含
					<> ""、为什么include很少包含.c文件，头文件中的#ifndef XXX  #define XXX      #endif条件编译的作用。
					
				4）一些特殊的预编译关键字
								
		（3）存储类、作用域、生命周期、链接属性
					这一章与第1章是紧密联系的，所以如果大家把第1章理解好了，这一章说白了只是在讲解细节知识而已。
					
					1）介绍什么是存储类、作用域、生命周期、连接属性
					2）介绍extern、static、auto、register等等关键字，与存储类、作用域、生命周期、连接属性之间关系
					3）介绍什么是无链接、内链接、外链接、
					4）介绍为什么函数一定要声明，函数声明的目的到底是什么，不进行函数声明行不行
					等等
					
		（4）指针、函数
				指针
				1）指针概念（一级指针与多级指针）
				2）指针的强制转换到底做了什么
				3）野指针、段错误
				4）const与指针
				等
					
				函数
				1）函数指针 与 指针函数
						指针的概念本身很简单，我们常说指针难，并不是指针概念难，而是指针与函数、数组、字符串、结构体等相结
					合后，里面有很多不易理解的地方，如果你只是理解了指针本身的概念的话，实际上你的指针并没有学会。
				
				2）指针与函数传参
				3）函数调用时栈的活动记录
				4）回调函数：C语言模拟面向对象的思想时，与回调函数密不可分
				5）递归函数
				6）内联函数
				7）const与函数传参
				9）结构体与函数传参、返回值
				
				
				
		（5）c函数库
				1）c静态库与动态库
				2）如何制作自己的静态库与动态库（windows和Linux）
				3）静态库和动态库是如何链接到我们的程序中的
				4）什么是动态库的显示加载和隐式加载
				5）为什么使用库时，需要包含它的头文件
				6）c标准函数库都包含哪些子库
				7）c标准函数库与posix c函数库关系

	
		（6）数组与字符串
				1）数组的构建原理（多维数组是怎么基于一维数组引申出来的）
				2）数组指针与指针数组
				3）如何使用多级指针构建多维数组，并与传统的多维数组进行对比
				4）数组与sizeof和strlen
				5）字符串与数组
				6）字符串指针
					char *p = “hello”，对比char buf[] = "hello"，以此回顾第1章介绍的常量这个东西。
					
					字符串与sizeof和strlen
					
				7）字符串指针数组 与 main函数的argv参数
						字符串指针数组与NULL结尾。
						
						
		（7）结构体、联合体、枚举		
				1）结构体的传参
				2）结构体的强制转换
				3）结构体的对齐
				4）结构体与回调函数相结合，模拟面向对象的思想
					举实例介绍面c这种模拟面向对象思想，在构建复杂c工程项目时的好处。
				
				5）共用体与实际应用
				6）枚举与实际应用
					
					
		（8）c语言中无法独立成章的知识
	
				控制台程序和app程序
				1）数据的溢出
				2）大小端序
				3）逗号表达式
				4）void的作用是什么
				5）NULL、\0、null、0的异同
				
				6）转义字符
				7）typedef 与 ***_t类型
					typedef与宏、与数组、与结构体、与const等
					

				8）为什么scanf要求变量取地址，而printf不用
				
				9）main函数是谁调用的，main函数的参数到底有什么用、main的返回值给了谁
				
				10）字、半字等概念

				11）程序的优化
				
				12）程序的调试
				13）switch
					case前的指令是不执行的
					case中想定义局部变量，需要使用代码块
				

		（9）C语言的位操作
				&、|、~、^等
				
				
		（10）使用c来进行应用开发时，所涉及的其它相关知识
				1）多线程
				2）网络
				3）数据库
				4）数据结构
					单链接、双链表、内核链表
					
					
					
					
	2.3 知识铺垫			
		
		2.3.1 我们应该如何学习本章
				学习本章的重点是理解，而不是记忆，大家要做的只是理解和消化本章，提升你的功力，在以后的工作学习中，当遇
			到一些比较难搞定的问题时，能够通过本章所理解的内容，引导你搞定一些深入的东西，找到解决方案，那么本章的学
			习目的就达到了。
					
					应该说不仅是本章，整个《C深度解析》这么课也是都以理解为主，不提倡死记硬背。
			
				
				为了能够让大家能够更好的理解课程内容，在有些名词的表述上可能会比较通俗，不是很准确，比如后面提到的
			“cpu的类型”这个词，其实指的是“cpu架构”，但是绝大多数同学并不知道什么是cpu架构，而作为应用工程师而言，我们
			又无需了解cpu架构方面的知识，为了方便理解就说成了"cpu类型"。
			
				类似的情况在后续课程能会有不少，如果你知道准确名词最好不过，如果不知道的话，就先按照我们的表述来理解，当然
			有疑问的话可以提出，我们很乐意回答。
				
				
		2.3.2 windows 和 Linux的命令行 
				本课程涉及到windows和linux命令行的使用，有关命令行，请看《Linux基础》这么课，在里面有详细介绍windows和linux
			命令行以及各种命令。
	
	
		2.3.3 IDE ——— Codeblocks
			在课程中，我们还不时的用到了Codeblocks这个IDE，我这里给出IDE的网盘地址，大家自行下载。
			链接：https://pan.baidu.com/s/1wbUUO0TKdX26MvxrHHLZtA 密码：k941
			
			Codeblocks主要是用来对比学习的，不需要深入熟悉这个IDE，安装完后，汉不汉化无所谓，使用英文版的也挺好。
	
	
		2.3.4 extern 和 static的作用
				本章会频繁的讲到extern和static这两个关键字，但是对于很多C底子比较差的同学来说，对这两个关键字不是很熟
			悉，所以这里要大概的介绍下，做点铺垫。
			
		（1）static
				
				1）修饰函数
						static修饰函数时表示，该函数只在本文件有效，也就是只能被本文件的其它函数调，其它文件不能调
					用（引用）。
						
						例子：
						a.c                       b.c
						
						int fun1(void)       			static void fun(int stu_num)
						{													{
							fun(100);//不能引用				......									
						
						}													}
						
						static就像是一把锁，把函数fun的有效范围锁在了b.c，其它.c看不见这个函数，自然无法调用。
						
						疑问：为什么static能锁住函数？
						答：因为static将函数名这个符号变成了“本地符号”，“本地符号”只在本文件可见，其它文件是看不见的，本章
						后续还会详细的介绍什么是本地符号，这里只是在做知识铺垫。
			
			
				2）修饰变量
					1）static修饰局部变量
						改变的是局部变量的存储位置，从栈变为静态存储区，与“本地符号”什么的没有关系。
						
						比如：
						int fun(int va)
						{
							int a; 
							int b = 100;
							
							...
						}
						
							a、b为“自动局部变量”，空间开辟于栈中，也许你对“自动局部变量”这个名字不熟悉，但是对所讲的这种情况绝对
						不陌生。
						
						加static修饰：
						int fun(int va)
						{
							static int a; 
							static int b = 100;
							
							...
						}
						
						a/b变为了“静态局部变量”，a/b的空间开辟于静态存储区，而不再是栈。
						（a）如果没有初始化的话，比如a就没有初始化，a的空间在静态区中的.bss区
						（b）如果有初始化的话，比如b就有初始化，b的空间在静态区中的.data区
						
						疑问：老师，我不懂什么是静态区，什么是静态区中的.data、.bss？
						答：不要紧，本章会深入介绍，这里只是想做点铺底，给大家建立起一点基础，后面学习起来就事半功倍了。
						
					2）static修饰全局变量
						与修饰函数一样，让全局变量只在本文件有效，其它文件无法引用。
						
						比如
						a.c                       b.c
						gVa = 200;//不能引用      static int gVa = 100;
						                          
																			int fun(void)
																			{
																				......
																			}
						
						
						b.c中的gVa被static修饰后，和被static修饰的函数一样，gVa变为了本地符号，只在本文件有效，不能被其它
						文件使用。
						
						static修饰全局变量时，与全局变量的存储位置无关系，全局变量的空间本来就是在静态存储区，加不加static，
						并不能改变存储位置，static只是改变了符号的有效范围，变为了本地符号。
						
						大家可以看出，static这个关键好像有点乱，没有固定套路，修饰变量和函数时，所起的作用不同，这个应该说
						是当初设计c语法时没有设计好导致的，使得static的用法有点乱，不过没关系，跟着我们的课程往后走，熟悉了后，
						你会发现其实很简单。
						
						
		（2）extern						
				1）修饰函数
					extern修饰的函数，表示除了能被本文件引用外，还可以被其它的文件引用，在其它文件中是可见的，只不过在其它
				文件中引用时，需要做声明，刚好与static相反。
					
						a.c                       				b.c
						extern void fun(int stu_num);			
						
						
						extern int a_fun(void)						extern void fun(int stu_num)
						{																	{
							fun(100);						     		 				......	
						}																	}
						
					
						
						事实上extern不需要明确写出，因为默认就是extern的，也就是说定义和声明可以写成如下形式。
						a.c                       				b.c
						void fun(int stu_num);						
																							
						int a_fun(void)										void fun(int stu_num)
						{																	{
							fun(100);						     		 				......	
						}																	}
						
					
						疑问：extern到底做了什么事情？
						答：extern修饰函数时，与static修饰函数时的作用刚好相反，extern修饰函数时表示，函数名是一个“全局符号”，
						“全局符号”的特点是，除了本文件可以引用外，在其它文件中也是“可见”的，只不过其它文件使用时，需要做声明，
						注意声明也必须是extern的，至于为什么，后面会详细解释。
						
						
				2）修饰变量
						extern修饰变量时，主要用于修饰全局变量，extern修饰局部变量的情况非常少见，所以暂不介绍。
						
						修饰全局变量时，与修饰函数一样，其实就是将全局变量名这个符号标记为“全局符号”，对其它文件来说也是可见的，
					不过同样的，其它文件引用时，需要做声明。
						
						a.c                       				b.c
						
						extern int gva;										extern int gVa = 100;
						                          
						gVa=200;//引用										int fun(void)
																							{
																								......
																							}
						
							声明时不能初始化。
							同样的extern可以省略，因为默认就是extern修饰的。
							有关extern的其它情况，后续课程涉及到时再介绍，目前就讲这些，还是那句话，目的只是想做点铺垫。
						
	
	
出品：佳嵌工作室
--------------------------------------------------------------------------------------------------------------------
	“佳嵌工作室”致力于物联网、嵌入式产品以及‘物联网、嵌入式技术课程’的研发，希望所推出的技术课程，能够帮助到正在努力
学习物联网、嵌入式的同学，欢迎大家和我们一起共同学习，共同进步。
--------------------------------------------------------------------------------------------------------------------		
		
第1章、C语言编译过程与内存结构

0. 内容安排
	1. IDE开发方式 与 源文件开发方式	
	2. c程序的详细编译过程		
	3. 静态链接 与 动态链接
	4. 目标文件种类
	5. 可重定位目标文件
	6. 可执行目标文件
	7. 内存结构（存储映像）
		
		
	
1. IDE开发方式 与 源文件开发方式

	1.1 演示
		1.1.1 IDE方式
			使用codeblocks IDE来演示。
							
					
		1.1.2 源文件开发方式
				其实就是编辑与编译分开操作的方式。
		
			（1）windows
					1）使用txt编辑器来编辑
						
					2）使用codeblocks IDE所提供的编译器来编译
							
					3）演示
								
						
						如果想在任意位置都可以编译我们的程序的话，我们需要将编译器所在目录加入windows的环境
					变量，有关环境变量，我们在《Linux系统编程、网络编程》有详细介绍。
					
						
			（2）ubuntu
					1）使用ubuntu的VI或者gedit编辑器来编辑
					
					2）使用ubuntu自带的gcc编译器来编译		
					
					3）演示
						
				总结：
				（a）ubuntu安装好后，会自带c编译器gcc，不过windows没有自带c编译器，所以我使用的是codeblocks所带的编译器
				（b）ubuntu下gcc的安装目录有加入环境变量，因此可以在任何路径下运行gcc。

						
							
								
出品：佳嵌工作室
----------------------------------------------------------------------------------------------------------------------------
	“佳嵌工作室”致力于物联网、嵌入式产品以及‘物联网、嵌入式技术课程’的研发，希望所推出的技术课程，能够帮助到正在努力
学习物联网、嵌入式的同学，欢迎大家和我们一起共同学习，共同进步。
----------------------------------------------------------------------------------------------------------------------------		
								
	1.2 源文件开发方式
	
		1.2.1 什么是源文件开发方式
				其实就是编辑、编译是分开发的方式，
			
				编辑：使用单独的编辑器来编写程序
				编译：在命令执行编译程序（命令）来编译所写的C程序
			
					
		1.2.2 分开的开发方式，其实有不少麻烦之处

		（1）你需要安装两个东西，一个是编辑器、另一个是编译器
	
		（2）使用单独编辑器，也有缺点
					
					使用的编辑器不见得时专门针对程序开发的编辑器，使用起来很麻烦，你比如直接使windows自带的txt
				文本编辑器写程序的话，老实讲用起来糟心，因为它不是为程序编写而生的。
					
					如果你觉得txt这个编辑器不好，可以下载一个你觉比较好的其它的编辑器，就算是这样，这编辑器相比IDE的
				编辑器来说，也差了一些，毕竟IDE的编辑器是专门针对程序开发的。
				
				
		（3）自己安装编译器也很麻烦
				可执行程序运行时，会涉及运行环境问题，环境涉及两方面，
				OS
				cpu
				
				如果你的程序是在windows（os）x86（cpu）上运行，就必须使用面向windows x86的编译器编译，
				如果你的程序是在Linux arm上运行的，必须使用Linux arm的编译器，
				如果你的程序是在windows arm 或者 linux x86上运行的，分别使用对应环境的编译器
				面对其它的OS和cpu时，道理是一样的。


				自己下载编译器程序，需要我们自己去甄别不同的环境，然后下载针对不同环境的编译器，而且OS和cpu还分为了
			不同的种类和版本，还挺麻烦。
			
				所以这种分开的方式，特是对于小白同学来说，增加了学习的难度。
			
					
		（4）命令行的使用也很麻烦
				编辑、编译分开开发的话，必须在命令行执行编译器程序来编译，而不是图形化界面的操作，但是对于很多小白同学
			来说，命令行根本不熟悉，无疑增加了难度。
			
			
				正是由于存在以上问题，才有了后来的IDE方式。

			
	1.2 IDE方式
			IDE方式其实就是将编辑器和编译器二合一后的结果。
			IDE方式很好的解决了编辑和编译分开情况所带来的麻烦，怎么解决的呢？
			
		1.2.1 只需一次性安装IDE即可
				一次性安装好IDE后，IDE就自带了编辑器和编译器。
			
		1.2.2 IDE自带的编辑器更加专业，更加人性化
				因为IDE自带编辑器，是专门适合程序开发的编辑器，比如我们在程序开发的时候，语法关键字的自动提示，一般的
			编辑器是没有的，但是IDE提供的编辑器就会有。
				
				我们在写程序时往往记不住关键字，特别是c++和java这种面向对象语言的开发，类里面包含很多的成员，如果编
			辑器不提供自动提示功能，这会非常痛苦。
			
				特别是涉及到界面开发时，会进行到控件的拖拽，如果不使用IDE提供的专门的编辑器的话，普通编辑器根本不提供
			控件拖拽的功能。
				
				
		1.2.3 不涉及编译器的选型问题
				安装某个环境（windows x86）的IDE时，IDE自带的就是这个环境的编译器，不需要操心编译器的选型。

				编译器并不是一个独立的程序，而是由众多程序组合在一起的一个程序集合，我们安装IDE时，
			编译器集合会被自动包含在IDE的安装目录下。
				
				举例：codeblocks、vc++、eclipse
		
				如果你觉得这个编译不好，实际上你可以自己下载其它的编译器，然后将它包含到IDE的安装目录下，
			然后在IDE里面做设置，使用这个新的编译器即可。
				设置举例：codeblocks
				
				不过一般不会这么做，你要是觉得这个编译器不好，还不如干脆就换一个新版本的IDE，会自动带新的编译器。
			
	
	 1.2.4 编译程序时，调用编译器的过程是IDE自动完成的，而且是图形化操作，不需要使用命令行来操作
			
			比如以codeblocks为例，只需要点击编译运行的按钮即可，IDE会自动的调用编译器程序来编译，
			演示：
			
			图形界面调用编译器，与我们在命令行调用编译器程序来编译是一样的，但是IDE提供的图形化方式显然更方便。


			
			
	1.3 综合对比
	
		1.3.1 IDE是主流
					因为IDE确实更方便，特别是像开发c++/java/c#/python等这类面向对象语言的程序时，基本只能使用IDE方式来操作，
				因为必须使用IDE的自动提示功能。
		
		
		1.3.2 分开方式难道就没有用了吗
		
				不是的，对于底层框架类代码的开发来说，还是有用的，因为底层框架类的代码基本都是使用C、汇编这类语言来
			实现的，不涉及类成员的提示，不涉及界面控件的拖拽，完全可以使用这种方式来开发。
				
				其实就算是开发框架代码，如果使用IDE方式的话，其实会更方便些，不过对于很多有能力的程序员来说，在开发框
			架代码时，有些还是喜欢使用编辑、编译分开的方式，为什么？
			
				1）他们有能力这么做
						其实编辑、编译分开的方式，并不是谁想使用就能用的，这种方式对于能力要求较高，比如最起码一点，命令行
					必须要会，但是就命令行这一点，不少开发者可能就被难住了。
					
				2）分开的方式更自由
						IDE做的越好就越傻瓜化，傻瓜的好处是，对程序员来说使用特别简单，但是坏处是，IDE帮你自动做了太多的设
					置，但是有些设置根本就不是你想要的，所以很多大牛不喜欢IDE的自作主张，所以他们更喜欢自己做主，而编辑编
					译分开始的方式，就完全可以按照自己的想法来，不用受到IDE的干扰。
							
							
							
		1.4 进行Linux嵌入式开发，为什么会使用编辑、编译分开的开发方式呢？
		
			（1）因为进行Linux嵌入式开发时，所开发的大多都是C程序，而且大多不涉及界面问题（因为好多嵌入式设备没有界面）
					，这种情况与开发框架非常类似，所以适合使用这种情况。
							
			（2）ubuntu自带的vi（命令行编辑器）和gedit（图形编辑器）用起来还可以，而且安装好ubuntu后，会
					自带针对当前环境的c编译器gcc，无需自己安装，所以省去了一些麻烦。
					
						当然后续开发在arm上运行的嵌入式程序时，还是需要我们自己安装针对Linux、arm环境的编译器。
						
					
			（3）编辑、编译分开开发的方式，依赖于命令行的使用，而Linux嵌入式开发有一个最大的特点就是，要求我们必须会
					Linux的命令行，所以对于Linux开发者来说，命令行的使用是小意思。
					
					
			（4）编辑、编译分开的开发方式，是本源开发方式，通过使用这种开发方式，可以更好的理解一些本质性的
					问题，在一定程度上，有助于提升大家的能力，所以我们鼓励使用分开开发的方式。
					
					
	1.5 如果Linux嵌入式开发也涉及到c++、java的话，使用什么开发方式呢
		
		1.5.1 嵌入式开发会用到c++/java吗？	
		
			会，因为虽然不少Linux嵌入式产品不需要图形界面，但是有些还是要的，此时我们会使用c++的qt图形库或者
		java的图形库来开发。
			
			其实基本使用的是c++/QT来开发的，因为java需要运行虚拟机这个东西，比较吃计算机资源。
			如果开发的是与安卓相关的嵌入式产品的话，会用到java。
			
				
		1.5.2 在Linux怎么进行c++/java开发
			前面说过开发c++/java等面向对象语言的程序时，都是使用IDE来开发的。							
				
			所以如果在Linux嵌入式开发中，涉及到c++/java程序的开发时，我们还是需要安装相应的IDE来开发，使用编辑、编译
		分开方式，基本不可能。
		
				


				
				
				
出品：佳嵌工作室
----------------------------------------------------------------------------------------------------------------------------
	“佳嵌工作室”致力于物联网、嵌入式产品以及‘物联网、嵌入式技术课程’的研发，希望所推出的技术课程，能够帮助到正在努力
学习物联网、嵌入式的同学，欢迎大家和我们一起共同学习，共同进步。
----------------------------------------------------------------------------------------------------------------------------					
	
2. c程序的编译过程			
		我们这里虽然介绍的是c程序的编译过程，但是实际上所有编译型语言的编译过程，大致是类似的。
		
		
	2.1 编译的四个过程
		
			其实这四个过程我们在《计算机题结构体——编译器》篇有介绍过，在本章中，我们需要再一次提到这四个过程。
				
			我们平时编译时，不管是通过IDE图形界面来编译的，还是通过命令行来编译的，我们感觉编译一下就
		完成了，然后就得到了你要的针对某OS和某CPU的二进制可执行文件（机器指令的文件），但是实际上中间隐藏了
		四个过程，这四个过程被默默的处理了。
			
			编译四个过程：预处理、编译、汇编、链接
			
			四个过程中的“编译”，特指其中的某个过程，这四个过程合在一起，我们也统称为编译，所以“编译”二字到底
		指的是第二个过程，还是全部过程的统称，这个就要看说话的“语境”了。
			
			其实统称的“编译”，完整的称法应该叫“编译链接”，只是简称为编译而已。
			
			如果这四个过程是一次性编译完成的，这个四个过程分别会产生相应的文件，只不过中间产生的文件都是过渡性的临
		时文件，使用完成后就会被删除。
		
			四个过程的总览图：
				
				

			2.1.1 预编译（预处理）
				之所以叫预编译，表示为正式的编译做准备，预编译也被称为预处理。
								
								
								  预处理（预编译）
				（1）**.c  ————————————————> **.i
							如果编译过程是一次性完成的话，.i文件只是一个过渡性文件，
							
							.i被称为扩展后的c源码文件
								
							·为什么还叫c源码文件呢？
									因为预处理后，只是宏定义等东西不见了，但是C源码依然还在，比如main函数，各种自己
								写的子函数，依然存在，所以还是被称为c源码文件。
								
									打开.i文件后，我们是能够看的懂的，所以.i文件时ascii文件。
									后面会演示给大家看。
									
							
				（2）预编译是以单个文件为单位来进行的
							a.c ——————> a.i
							b.c ——————> b.i
								
							当然**.i的这个名字并不是固定的。
							
							
				（3）预处理做了什么处理
						1）宏替换：将宏替换为真实的宏体，比如
							程序性中有使用NUM这个宏，这个宏的定义为#define NUM 100，程序中所有的NUM都会被替换为100。
							
							
						2）包含头文件
							将include包含的.h头文件内容，全部复制到.c文件中，因为头文件中定义了类型、宏、函数声明等等，
						这些都是函数调用会用到的，你调用某个函数时，就必须包含这个函数要的头文件。

							疑问：头文件那么多内容，都包含进去的话，不会太多了吗？
							编译时，编译器只使用要用的东西，用完后包含的内容都会被丢弃，实际上并不占空间。
							
							
						3）条件编译
								处理#if  #endif 这类的东西
							
							
						4）处理一些特殊的预处理关键字
					
							有关预处理的宏定义、头文件包含、条件编译、特殊预处理关键字，会在后面专门的《预处理》章节中讲到。
									
					
		2.2.2 编译
			             编译
			（1）***.i ————————> ***.s
					.s：汇编文件
				
				
			（2）同样也是以单个文件为单位来进行的
				
			（3）编译做了什么
					将c语法的c源码，翻译为汇编语法的汇编源码。
					
			（4）.s是ascii码文件
					因为汇编也是人能看懂的文字编码形式，所以.s汇编文件也是ASCII码文件。
		
		
		2.2.3 汇编
											汇编
			（1）***.s ——————————————> ***.o
					.o文件是纯二进制文件
						因为.o中放的是纯二进制的机器指令，所以我们打开后看不懂。
				
	
			（2）同样也是以文件为单位来进行的
				
				
			（3）汇编做什么
						将ASCII的汇编源码，翻译为能够被CPU执行的机器指令，.o文件中放的就是机器指令。
					但是.o文件还无法运行，需要链接后才能运行。
					

						
		2.2.4 链接
					
					***1.o ——————————\
													  \
					***2.o ____________\ a.out（可执行文件）
														 /
					....							/
													 /
					***n.o —————————/
					
					
			（1）链接（连接）做了什么
					1）将众多的.o合成一个完整的可执行文件
							.o实现相互依赖的，比如a.o中调用的函数，被定义在了b.o中，如果不链接在一起的话，是无法工
						作的。
							
					2）链接时，需要加入额外的启动代码
							这个启动代码并不是我们自己写的，main函数是由启动代码调用的，我们的程序是从启动代码开始运行
						的，后面会介绍启动代码是怎么来的。
						
						
					3）链接为一个可执行文件时，需要进行符号解析和地址重定位
							后面会介绍什么事符号解析和地址重定位。
						
						
			（2）Linux下可执行文件命名问题
						在windows下，可执行的尾缀时.exe，但是在Linux下，可执行文件没有固定的尾缀。

						
			（3）如果整个C工程就一个.c，最后得到的只有一个.o，此时还需要链接吗，可不可以直接执行呢？
						同样的要链接后才能运行，因为链接后才有启动代码和重定位后的地址，否者无法运行。


						
						
			
			
			
				

		2.2 了解编译器集合
				我们在前面就说过，编译器并不是一个单独的程序，而是一堆程序的集合。
				
				为了更好的了解编译的四个过程，我们需要大概的弄清楚“编译器集合”组成。
			
				对于“编译器集合”的组成，我们作为应用软件开发者了解到本章介绍的程度就可以了，至于更加深入的内容，
			那就是“编译器开发者”和“逆向破解者”所应该掌握的内容。
			
				所以对于更多更深内容，如果是站在应用开发角度的话，我们不建议大家再去更加深入，作为应用开发来说，再深入
			的话意义不大。
				
				
			2.2.1 codeblocks的编译器集合
			
				（1）codeblocks安装目录
						
						codeblocks的编译器集合就放在它的安装目录下。
						
						
						
						
				（2）编译的四个过程，必须用到的基本程序
							cpp、cc1、as、collect2/ld、gcc
							
							gcc编译时四个过程自动完成，我们既然已经知道了这四个过程，那么我们就自己一步一步实现这四个过程，
						然后得到最终的可执行文件。
						
							我们讲这四个过程的主要目的是什么呢？
							· 熟悉这四个编译过程，了解每个过程做了什么事
							· 了解每个过程调用了编译器集合中什么程序
							
							
							疑问：老师，你怎么知道编译四过程使用的就是cpp、cc1、as、collect2、gcc这些程序呢？
							我们后面再来回答这个问题。
							
							
							
					1）cpp(MingW\bin\)
					
						（a）预编译程序（预编译器、预处理器）：实现预编译
								为了方便我们查看预编译后的结果，我们先在.c中加入宏、条件编译、头文件包含。
									
									
						（b）演示
								cpp helloworld.c -o helloworld.i
									
								 o选项用于指定目标文件，表示将预处理后的结果保存到.i文件中。
									
									
								- 验证.i文件是不是ascii文件。
									
								- 验证预处理后.c中的宏、include、条件编译，在.i中还能否见到。
									
									
					2）cc1（MingW\libexec\gcc\mingw32\4.9.2\）
						
						（a）编译程序（编译器）：将C源码翻译为汇编源码
							
						（b）演示
									..\libexec\gcc\mingw32\4.9.2\cc1 helloworld.i -o helloworld.s
								
								验证.s文件是不是ASCII文件。
							
							
						（c）cc1值得注意的地方
						
									其实cc1本身也包含cpp预处理的功能，也就是说可以直接使用cc1将.c——>.s，cc1会完成之前的预处理的
								功能。
										
										..\libexec\gcc\mingw32\4.9.2\cc1 helloworld.c -o helloworld.s
									
									不过以上命令并不能被成功执行，因为还缺参数，他会提示找不到头文件，至于缺什么参数，
								我们这里就不关心了。
									
									
									
					3）as（MingW\bin\）					
						（a）汇编程序（汇编器）：将汇编源码翻译为纯二进制的机器指令，放到.o文件中

						（b）演示
									as helloworld.s -o helloworld.o
									
									
									
					4）ld、collect2
								ld路径：MingW\bin\、MinGW\mingw32\bin
								collect2路径：MingW\libexec\gcc\mingw32\4.9.2\collect2
					
					
						（a）链接程序（链接器（静态链接器））
									将所有的.o文件（自己的、编译器提供的）和库（动态库、静态库）链接在一起，得到可以运行的可
								执行文件。
							
						（b）collect2 和 ld之间的关系
								collect2是对ld进一步封装得到的，这两个都可以用于链接。
							
							
						（c）演示
									实际上我们完全可以自己调用collect2和ld这两个程序（命令）来进行链接，但是链接并不是一件
								容易的事情，链接的时候需要跟大量的参数和选项，这些参数和选项我们自己并不清楚，所以我们
								自己调用collect2 和 ld来链接的话，实际上操作起来比较困难。
									
									所以链接的话，我们直接使用gcc程序来链接，gcc会自动调用collect2或者ld来链接，并且自动
								指定需要的各种的选项和参数，我们并不是需要关心。
									
									gcc helloworld.o -o helloworld
									或者
									gcc helloworld.o  （如果不指定可执行文件名字的话，默认为a.exe）
									
														
					5）gcc/mingW32-gcc/g++/c++
							前面演示过，其实gcc/mingWgcc/g++这几个都能编译c程序。
							
							
						（a）gcc/mingW32-gcc/g++/c++关系
									其中mingW32-gcc是对gcc继续做封装后得到的。
						
									c++/g++是用来编译c++程序的，但是由于c++程序兼容c，所以c++/g++也能编译c程序。
									
									正式因为编译集合中包含了g++，所以我们也能使用codeblocks来写c++程序的，而且codeblocks这个
								IDE本身好像就是c++写的。
								
								
							
						（b）gcc/mingW32-gcc/g++/c++程序的作用
								
									gcc/mingW32-gcc/g++/c++其实是总的调度程序，它按照需求去调用cpp/cc1/as/collect2/ld等程序，
								完成对应四个过程。	
									
									
								为什么要一个总的调度程序？
									通过前面的讲解知道，虽然我们能够自己调用cpp/cc1/as/collect2/ld来完成四个过程，
								得到最后的可执行文件，但是存在如下缺点。
								
								
								- 每个阶段的程序名都不一样，不方便记忆
										第一阶段叫cpp，第二阶段叫cc1等，老实讲，时间久了我也忘了。
									
										有了gcc这个总调度程序后，不管是哪个阶段，对于我们来说，只需要记住gcc这一个程序即可。
										
										你想实现那个阶段，通过gcc即可实现，通过给gcc指定不同的选项，gcc可以自动调用cpp/cc1/as
									/collect2/ld中所需要的程序来实现对应的过程。

									
								- 如果每个阶段都我们自己亲自执行cpp/cc1/as/collect2/ld这些程序来编译的话，速度太慢了
									
										有了gcc后，虽然可以通过指定选项，分别实现每个过程，但是实际上也可以调用gcc一次性快速完成
									四个过程，gcc会自动调用cpp/cc1/as/collect2/ld来完成。
									
										一次性完成时，中间产生的.i/.s/.o都是临时文件，编译后会被自动删除，这些文件我们并不关心，
									我们关心的只是最后的可执行文件。
										
										使用gcc这个总调度程序，一次性完成所有过程时，编译速度非常快，用起来非常方便。
										
								
								
								
								
								
出品：佳嵌工作室
----------------------------------------------------------------------------------------------------------------------------
	“佳嵌工作室”致力于物联网、嵌入式产品以及‘物联网、嵌入式技术课程’的研发，希望所推出的技术课程，能够帮助到正在努力
学习物联网、嵌入式的同学，欢迎大家和我们一起共同学习，共同进步。
----------------------------------------------------------------------------------------------------------------------------								
											
								
						（c）gcc/mingW32-gcc/g++/c++的各种选项
								它们几个的使用方式都是一样的，所以我们就以gcc为例来讲。
								
									gcc的选项很多，先介绍常用的E/S/c/g选项，然后在介绍其它一些个不常用选项。
									至于其它的非常不常用的选项，我们这里不介绍，用到时大家自己研究搞定。
									
								-E
									+ 只得到.i的扩展c源文件
										
									+ 演示
										gcc -E helloworld.c -o helloworld.i
			
										gcc会自动调用cpp或者cc1来进行预处理。
										
										如果不写目标文件，就直接输出到控制台。
										
										疑问：gcc -o helloworld.i -E helloworld.c，这么写可以吗？
										
								
								- S	
									+ 只编译到.s文件
										
									+ 演示
										
										gcc -S helloworld.i -o helloworld.s
										gcc会自动调用cc1，将.i编译为.s。
										
										如果不写目标文件，会自动保存为同名的.s文件
										
										
										
										疑问：gcc -S helloworld.c -o helloworld.s 可以吗？
										可以，gcc自动调用cc1时，cc1先预编译，然后再编译。

								- c	
									+ 只编译得到.o文件
										
									+ 演示
										1）gcc -c helloworld.s -o helloworld.o
											自动调用as进行汇编，将.s中的汇编源码翻译为机器指令，并保存到.o文件中。
											
										2）gcc -c helloworld.i -o helloworld.o
											（a）调用cc1编译得到临时.s
											（b）调用as将.s汇编得到.o
										
										3）gcc -c helloworld.c -o helloworld.o
											（a）调用cc1预编译、编译得到临时的.s
											（b）调用as将.s汇编得到.o
										
										
									+ 如果不写目标文件，会自动的保存为同名的.o文件
			
									
								- 直接得到可执行文件
									
									+ 演示
										gcc helloworld.c **.c -o helloworld.exe
										gcc helloworld.i **.i -o helloworld.exe
										gcc helloworld.s **.s -o helloworld.exe
										gcc helloworld.o **.o -o helloworld.exe

								-g
									如果要进行debug调试的话，通过指定-g选项，会加入调试信息，没有调试信息是无法进行调试的。
									
									debug调试：后面的课程再介绍。
								
								
								-	其它不常用选项
								
									+ O0/O1/O2/Os/O3： 指定优化级别，O0< O1 < O2 < Os < O3
											gcc hellowolrd.c -o helloworld.exe -O3
											
										如果不指定有优化级别的话，默认就是O1级别，有关优化的更多情况，后面章节再介绍。
									
									
									+ Wall： 
											gcc hellowolrd.c -o helloworld -Wall
											
											表示编译时将所有的警告信息都显示出来，如果不指定的话，默认只显示重要的警告，不重要的警告
										就不显示。
											
											比如，有一个变量定义了但是没有使用，就是一个不重要的警告。
											如果指定了-Wall选项，会警告你没有使用，否者不提示这个警告。
											
											
											警告真的不重要吗？
											
											初学c的时候，老师会告诉你警告没关系，但是在实际开发中警告是不能有的，为什么？
											
											对于程序的警告来说，虽然不是“编译链接”严重错误，但是在程序的运行过程中，这些警告可能会演变为
											威胁程序正常运行的错误，所以警告是程序的隐患，因此在实际开发中，编译时必须将警告排除。
	
									
									+ s：对可执行文件进行瘦身
											
											gcc hellowolrd.c -o helloworld -s
									
											不指定-s时，可执行文件都会包含调试等信息，用以实现程序的调试，但是当程序被调试没有bug后
										发布时，发布的程序就不再需要这些信息了，指定-s选项后，gcc编译时会对可执行文件进行瘦身，以
										去掉这些信息。
										
											演示：
										
										
									+ std：指定编译时准守的语言标准，c的标准目前有c89、c90、c99、c11
									
										gcc helloworld.c -o helloworld -std=c11	//编译时，按照c11标准来解析c语法格式

											语言在发展的过程中，每过一段时间就会修改、增加语法特性，然后重新指定语法标准，编译器在编译
										时就是按照标准来翻译语言的语法格式，c语言也是这样的。
										
											如果gcc时指定某个c标准的话，就会使用该标准来编译，如果不指定的话，就使用gcc默认设置的标准
										来编译。
										
											一般来说，新的标准都是兼容旧标准的，但是反过来就不行，如果你的程序使用了最新标准的语法特性，
										而在编译时指定的确是旧标准的话，就会编译出错，因为旧标准没有这些新的特性。
										
										
											不过一般来说我们不用关心标准问题，因为我们使用的都是最常见c语法特性，不管哪个标准都是支持的，
										所以不用指定特定的标准，gcc设置的默认标准就支持。

									
									+v：显示编译过程的详细信息
									
										演示：gcc helloworld.c -o helloworld -v  //显示预处理、编译、汇编、链接，所有过程的详细信息。
										
										
										回答之前的问题：我怎么知道编译时使用的是as、cc1、collect2、ld这些程序的？
										通过加-v选项，阅读编译过程的详细信息知道的，后面会分析这些详细信息。
										
										
										
										疑问：单个过程可以加-v吗？
										可以，显示的就是单个过程的详细信息，比如
										
										gcc -E helloworld.c -o helloworld.i -v //只显示预处理的详细信息。

	
	
					6）IDE的编译器设置
					
							如果我们自己在命令行中调用编译器程序来编译的话，可以在命令行直接指定选项和参数，比如：
							gcc helloworld.c -Wall -g
							
							但是如果是通过IDE来编译的话，编译器是由IDE来调用的，如果你想指定-Wall、-g等选项的话，就不能直接给了，
						我们需要先设置给IDE，IDE调用编译器时，再由IDE给编译器指定这些选项。
							
							演示：IDE编译器相关的设置。
							我们这里还是使用codeblocks来举例。
							
							
							
			（3）编译器集合中的一些其它程序							
						比如nm、strip、objdump、ar、readelf、debug等，其它的不用了解，我们用不到。
						
						
						有关它们的作用，后面介绍ubuntu下的gcc时再来讲。




						
出品：佳嵌工作室
----------------------------------------------------------------------------------------------------------------------------
	“佳嵌工作室”致力于物联网、嵌入式产品以及‘物联网、嵌入式技术课程’的研发，希望所推出的技术课程，能够帮助到正在努力
学习物联网、嵌入式的同学，欢迎大家和我们一起共同学习，共同进步。
----------------------------------------------------------------------------------------------------------------------------								

					
		2.2.1 ubuntu（Linux）下的GCC编译器集合
				ubuntu的GCC编译器集合，在安装ubuntu时就自带了，实际上和codeblocks安装目录MingW目录下的GCC编译器集合一样，
			都是GNU组织开发的，只不过codeblocks这边是面向windows的，而ubuntu这边的GCC是面向Linux的。
			
				注意区分大写的GCC和小写的gcc。
				GCC：指编译器集合
				gcc：指集合中的gcc程序
			
				正是由于都是由GNU开发的，所以集合中的程序名字是一样的，有了前面codeblocks GCC的基础，ubuntu的GCC非
			常容易。
			

			（1）编译时，必须用到的基本程序
						cpp、cc1、as、collect2/ld、gcc									
							
					2）cpp（/usr/bin/）：预编译
							通过which可以查看cpp的安装目录。
									
						（a）man手册查看
								
						（b）演示
								cpp helloword.c -o helloword.i
								
								不指定目标文件，会直接将预处理后的结果输出到控制台（命令行）。
		
								
					3）cc1（/usr/lib/gcc/x86_64-linux-gnu/5/cc1）：编译
							无法通过which查看cc1的安装目录，因为cc1的安装目录没有加入环境变量。
							
							
						（a）man手册查看
								查看不了，因为安装没有cc1的手册
							
								
						（b）演示
								/usr/lib/gcc/x86_64-linux-gnu/5/cc1 helloword.i -o helloword.s
								
								为什么要加路径？
								因为cc1所在的路径，没有加入Linux的环境变量。
							
								
					4）as（/usr/bin/as）：汇编编译
						（a）man  as
						
						（b）演示
								as helloword.s -o helloword.o
						
								不指定目标文件，会自动保存到同名的目标文件。
							
							
					5）collect2/ld：链接
							· ld：/usr/bin/ld
							· collect2：/usr/lib/gcc/x86_64-linux-gnu/5/collect2
						
							同样的，如果直接使用collect2/ld来链接的话，我们需要自己指定很多的选项和参数，所以我们一般不自己
						调用collect2/ld来链接，而是使用gcc来链接（gcc自动调用collect2/ld）。
							
							gcc helloword.o -o helloword
							
							不指定可执行文件的名字，就默认为a.out。
							
							不要以为默认的名字时a.out，就认为Linux可执行文件的尾缀是.out，Linux下的可执行文件并没有尾缀要求。
							
							我们后面会介绍默认的a.out这个名字是怎么来的。
							
							
					6）gcc
							使用gcc这个总的调度程序，gcc会自动调用cpp、cc1、as、collect2/ld等程序。
							可以避免直接使用cpp、cc1、as、collect2/ld等程序所带来的麻烦。
							
						（a）E
								+ 只得到.i扩展c源文件
									
									gcc -E helloworld.c -o helloworld.i
									
								+ 如果不写目标文件，就直接输出到控制台。
									
								+ file查看.i文件类型
									
									
						（b）S	
								+ 只编译到.s文件
									
								+ 演示
									gcc -S helloworld.i -o helloworld.s
									gcc -S helloworld.c -o helloworld.s 
		
									同样的，如果不写目标文件，会自动保存为同名的.s文件
								
								+ file查看.s文件类型
						
						（c）c	
								+ 只编译得到.o文件
									
								+ 演示
									1）gcc -c helloworld.s -o helloworld.o
									2）gcc -c helloworld.i -o helloworld.o
									3）gcc -c helloworld.c -o helloworld.o

									如果不写目标文件，会自动的保存为同名的.o文件
								
								+ file查看.o文件类型
								
								
						（d）直接得到可执行文件
							
								+ 演示
									gcc helloworld.c -o helloworld
									gcc helloworld.i -o helloworld
									gcc helloworld.s -o helloworld
									gcc helloworld.o -o helloworld
									
								+ 如果不写可执行文件，会自动保存为a.out文件。
									
								+ file查看可执行文件类型
						
						（e）其它选项：O1/O2/Os/O3、Wall、g等选项
									与前面介绍的是一样的。
									
							
			（2）编译器集合中的其它程序：nm、strip、objdump、ar、readelf、debug
						这程序都在/usr/bin/目录下，可以使用witch命令查看所在的目录。
							
							
						1）nm：查看.o、可执行文件中的各种符号
							演示：
								nm helloworld.o
								
								nm helloworld
							
								
						2）strip：对可执行文件进行瘦身
								给gcc指定-s选项时，gcc就是调用strip来瘦身的。
								
								我们也可以gcc时先不指定-s，然后自己主动使用strip来瘦身。
								

						3）objdump：反汇编，将机器指令反翻译为可以被人识别的汇编指令，这就反汇编
							· 演示
								- 对.o文件进行反汇编
									objdump -D hellowolrd.o >  hw1.s
											
									>：将反汇编结果保存到dmphelloworld1.s中。
								
								- 对可执行文件进行反汇编
									objdump -D hellowolrd > dmphelloworld2.s
					
					
							· 反汇编的意义
							
									其实对于做应用程序开发的我们来说，反汇编的意义不大，但是对于做逆向开发的人来说，这就很
								有意义，因为做逆向开发的人，需要分析二进制的机器指令，但是纯二进制的机器指令很难阅读，
								所以必须将二进制机器指令反翻译为ascii的汇编指令，才能阅读。
									
									不知道什么是逆向开发的同学，请看《计算机体系结构——行业篇》的内容。
									
							· 介绍objdump的目的。
								- 有必要了解
								- 本章后面可能会用到
								- 后续可能会出逆向的课，到时候就会用到反汇编命令
										
									
						3）ar：用来制作静态库文件，讲c函数库时再介绍。
									
								
						4）readelf：读取elf格式信息
								后面用到时在介绍。
							
						5）debug
								调试程序用的，后面课程介绍。
				
		
		
		
		
			
			
			
			
						
出品：佳嵌工作室
----------------------------------------------------------------------------------------------------------------------------
	“佳嵌工作室”致力于物联网、嵌入式产品以及‘物联网、嵌入式技术课程’的研发，希望所推出的技术课程，能够帮助到正在努力
学习物联网、嵌入式的同学，欢迎大家和我们一起共同学习，共同进步。
----------------------------------------------------------------------------------------------------------------------------								
			
				（2）gcc -v	
				
					（a）演示
							gcc helloword.c -o helloworld -v
					
					
					（b）分析gcc -v的详细信息的意义
							
								首先我们需要清楚一点，我们并不能完全弄清楚gcc -v的所有信息，因为毕竟我们并不是GCC编译器集合的
							实现者，对于这些信息，他们才是最清楚的。
							
								由于我们不能将所有的信息都搞清楚，所以我们只分析关键信息。
								
								虽然我们不能将所有信息都全部弄清楚，但是分析里面的关键信息还是非常有意义的，我们可以通过这些信息
							弄清楚很多事情，比如：
							
							· 通过这些信息，我就知道gcc其实最终还是调用cc1/as/collect2等程序来实现编译的四个过程的。
							· 知道c的启动代码是怎么来的
							· 知道为什么在程序中调用printf、scanf、malloc等函数时，我们不需要主动链接这些函数的动态库，但是依然
								能够使用这些函数
								
								
					（c）gcc helloword.c -o helloworld -v详细信息分析
							
							
							Using built-in specs. //编译链接详细信息
							COLLECT_GCC=gcc  			//编译时所调用的总调度程序
							
							gcc编译得到的可执行文件的运行环境，
							cpu：64位x86， OS：linux， gnu：gcc的开发组织
							Target: x86_64-linux-gnu 
							
							
							gcc配置信息：
							1. 什么是gcc配置信息
									gcc也是一个程序，也是被别人开发出来的，应该是c/c++语言写的。
							
									编写gcc这个编译器程序的人，在编译gcc时所给的信息就是配置信息，这些信息会决定编译gcc哪些代码，
								不编译哪些代码，最终得到针对某个环境（OS/CPU）的gcc可执行程序。
							
							2. gcc程序如何面对众多环境的
									gnu开发的gcc可以面对很多的环境，比如windows x86环境，Linux x86环境，Linux arm环境。
								
									编写gcc的人，为了让程序能够应对各种环境（OS、cpu），gcc程序里面会包含应对各个环境的代码，
								如果你想得到针对某个环境gcc可执行程序，就必须只编译针对该环境的代码，其它代码不编译。
								
								
							3. 如何选择只编译gcc程序针对某个环境的代码
							
									通过条件编译来选择，通过条件编译这的东西，就可以在预编译阶段决定你要保留哪些代码，放弃哪些代码，
								编译时只编译你保留的代码。
									
									举一个简单的例子
									比如：
									
									gcc.c
									
									#define X86_LINUX
									
									
									#ifdef X86_LINUX
									针对x86、Linux环境的代码。
									#endif
									
									
									#ifdef ARM_LINUX
									针对arm、Linux环境的代码。
									#endif
								
								
									#ifdef X86_WINDOWS
									针对X86、windows环境的代码。
									#endif
									
									通过条件编译所需的宏，就能让条件编译保留和编译只针对某个环境的代码。
									
									
										但是由于c条件编译使用的宏实在是太多了，所以我们不可能自己一个一个的定义这些宏，所以就需要
									通过配置信息自动生成需要的宏。
										
										配置信息保存在哪里呢？
										配置信息保存在配置文件中，我们配置信息时，其实就是修改配置文件中的内容。
										
										运行配置文件时，根据配置信息的要求，会自动生成需要的宏定义，并把这些宏定义保存到相应
									的.h（头文件）中。
									
										再将.h给c/c++程序，预处理时，条件编译根据.h中定义的宏定义，就能决定保留和编译哪些代码。
										编译时就只编译保留的代码，最后就得到了针对某个环境的gcc可执行程序，不过这些配置信息会保留
									gcc中，gcc -v时会显示出来。
									
										通过了解gcc的配置信息，可以大概的知道一些gcc的特性。
													
										
							4. 了解gcc 条件编译和配置信息 的意义
							
								（1）有助于我们后面学习c语言"条件编译"相关的内容
								
								（2）复杂的c/c++程序，都会涉及到条件编译和配置信息
										gcc也是一个复杂的c/c++程序，所以必然涉及条件编译和配置信息。
										
										如果不理解条件编译和配置信息的话，我们很难实现复杂c程序和看懂别人写的复杂c程序。
										
										我们后面讲uboot和linux内核时，里面会有大量的条件编译，编译时必须修改配置信息，通过配置信息
									去打开和关闭uboot/linux内核的条件编译，选择那些代码保留，那些代码忽略，然后编译保留的代码，
									得到针对某个环境（OS/CPU）的可执行程序。
							
							
							
							6. gcc配置信息
								gcc的配置文件，这句话仅仅只是向我们表明，gcc的配置信息其实是来源于这个文件，这个配置文件并不在
								我的电脑上，而是在gcc开发者的电脑上，编译gcc时gcc开发者会去设置这个配置文件。
								Configured with: ../src/configure 
								
								
								gcc bug报告说明书：如果你发现了gcc的bug，需要按照README.Bugs说明书的要求来提交gcc的bug
								--with-bugurl=file:///usr/share/doc/gcc-5/README.Bugs 
														
														
								gcc编译器集合所支持的语言，不过想要编译java等其它语言，需要下载相应的插件
								--enable-languages=c,ada,c++,java,go,d,fortran,objc,obj-c++ 		
								
								路径固定前缀，也就是说gcc所使用到的路径都是/usr打头的，换句话说gcc所
								用到的文件，都在这个/usr目录下。
								--prefix=/usr 
								
								....
								
								GCC编译器集合“自带库”所在目录
								--libdir=/usr/lib 
								
								...
								
								使用gcc编译带界面的java程序，图形界面底层调用的是ubuntu的gtk基础图形库
								--enable-java-awt=gtk  

							
								gcc可以编译java，但是java程序运行需要相应的运行环境（最起码要有个java虚拟机jvm）
								以下信息描述的就是java的运行环境
								--with-java-home=/usr/lib/jvm/java-1.5.0-gcj-5-amd64/jre 
								--enable-java-home 
								--with-jvm-root-dir=/usr/lib/jvm/java-1.5.0-gcj-5-amd64 
								--with-jvm-jar-dir=/usr/lib/jvm-exports/java-1.5.0-gcj-5-amd64 
								--with-arch-directory=amd64 
								--with-ecj-jar=/usr/share/java/eclipse-ecj.jar 
								--enable-objc-gc 
							
								
								gcc所运行的cpu的cpu架构，对于cpu架构的详细信息，对于应用开发者来说，我们不需要进行详细的了解
								这些是做硬件、微电子、编译器开发者应该详细了解的内容
								--enable-multiarch 
								--disable-werror 
								--with-arch-32=i686 
								--with-abi=m64 
								--with-multilib-list=m32,m64,mx32 
								--enable-multilib 
								--with-tune=generic									
								--enable-checking=release
								--build=x86_64-linux-gnu 
								
								
								//gcc本身的运行环境：cpu：64位intel X86 cpu  OS：Linux 
								--host=x86_64-linux-gnu  
								
								gcc编译出的可执行程的运行环境
								gcc helloworld.c -o helloworld，helloworld的运行环境为cpu：64位intel X86 cpu  OS：Linux 
								--target=x86_64-linux-gnu 

							
							
							--------------------------------------------------------------
							
								gcc版本，与gcc所运行的ubuntu的版本（ubuntu是Linux发行版操作系统）
								gcc version 5.4.0 20160609 (Ubuntu 5.4.0-6ubuntu1~16.04.9) 
								
								
								gcc基本选项，
								-march=x86-64：intel 64位 x86 cpu
								-mtune=generic：编译得到的机器指令，属于通用指令集（同款的不同型号的cpu都支持的指令集）
									如果需要指定某型号cpu的特殊指令集时，就不能写成generic，而要写特殊指令集名称
								COLLECT_GCC_OPTIONS='-o' 'helloworld' '-v' '-mtune=generic' '-march=x86-64'
							
								
								预编译、编译
								干货信息为：cc1 helloworld.c -o /tmp/ccV9xVOr.s
								/usr/lib/gcc/x86_64-linux-gnu/5/cc1 -quiet -v -imultiarch x86_64-linux-gnu 
							  helloworld.c -quiet -dumpbase helloworld.c -mtune=generic -march=x86-64 -auxbase 
								helloworld -version -fstack-protector-strong -Wformat -Wformat-security -o 
								/tmp/ccV9xVOr.s
							 
								... 
									
									
									
								包含""所指定的头文件：到程序员自己指定的路径下去搜索
								#include "..." search starts here:
								
								
								包含<>所指定的头文件：到系统指定的路径下去找
								#include <...> search starts here: 
								/usr/lib/gcc/x86_64-linux-gnu/5/include
								/usr/local/include
								/usr/lib/gcc/x86_64-linux-gnu/5/include-fixed
								/usr/include/x86_64-linux-gnu
								/usr/include
								End of search list.
							
							
								... 
							
								
								汇编：由于as的路径已经被加入到了环境变量中，因此调用as时，并不需要指定as的路径。
								生成ccV9xVOr.s汇编文件是一个临时文件，/tmp目录专门用于存放Linux系统所生成的临时文件，
								一旦编译得到了可执行文件，这个ccV9xVOr.s将会别删除
								as -v --64 -o /tmp/ccyIcm4A.o /tmp/ccV9xVOr.s
								
								
								...
							 
							 
								 
								 
								链接
								collect2为链接器，由于collect2的路径没有加入环境变量，因此需要我们自己指明
								collect2所在的路径。
								/usr/lib/gcc/x86_64-linux-gnu/5/collect2
								
								
								collect2的选项和参数
								...
								
								给程序指定动态链接器：程序运行起来后，用于加载动态库
								-dynamic-linker /lib64/ld-linux-x86-64.so.2 
								
								...
								
								最终生成的可执行文件
								-o helloworld 
								
								
								crt1.o、crti.o、crtbegin.o：用于生成程序的“启动代码”，这三个.o是由GCC编译器集合提供的
								（由GCC开发者编写的），crt就是c/c++ run time的意思，翻译为中文就是“运行时环境”。
								
									启动代码的作用：搭建c/c++的运行环境
									
									crt1.o：汇编写的。
									· 里面的_start是整个程序的开始（入口）
									· main函数是由crt1.o调用
									· c/c++函数运行所需要的栈，是由crt1.o建立的
									crti.o：在调用main之前，实现c的一些初始化工作，比如全局变量初始化
									crtbegin.o：在调用main之前，实现c++的一些初始化，比如调用全局构造函数，创建全局对象
								/usr/lib/gcc/x86_64-linux-gnu/5/../../../x86_64-linux-gnu/crt1.o 
								/usr/lib/gcc/x86_64-linux-gnu/5/../../../x86_64-linux-gnu/crti.o 
								/usr/lib/gcc/x86_64-linux-gnu/5/crtbegin.o 
								
								
								
								
								指定所有库所在路径，后面链接“库”时就到这些路径下寻找，后面讲c函数库时，会介绍-L选项
								-L/usr/lib/gcc/x86_64-linux-gnu/5 
								-L/usr/lib/gcc/x86_64-linux-gnu/5/../../../x86_64-linux-gnu 
								-L/usr/lib/gcc/x86_64-linux-gnu/5/../../../../lib 
								-L/lib/x86_64-linux-gnu -L/lib/../lib 
								-L/usr/lib/x86_64-linux-gnu -L/usr/lib/../lib 
								-L/usr/lib/gcc/x86_64-linux-gnu/5/../../.. 
								
								
								链接自己的.o：ccyIcm4A.o，是之前as汇编helloworld.c时，所得到的临时.o文件
								我们这里自己的.o只有一个，如果源文件有很多.c的话，对应的这里就会有很多的.o
								/tmp/ccyIcm4A.o
								
								...
								
								
								链接libc库
								其实libc只是c标准函数库中的一个子库，libc只包含printf、scanf、strcpy、malloc、time等这些常用函数，
								正是因为gcc有自动链接libc这个常用函数库，所以我们才能在程序中使用这些常用函数，而不会报错说倒找
								不到这些函数。
								
								但是像c标准函数库中的其它函数就不行了，比如使用数学函数，我们必须自己在gcc时自己加-lm去链接
								c标准函数库的子库——数学库（比如：gcc ***.c -o *** -lm）， 
								否者无法使用数学库函数，数学库中的函数属于非常用函数，gcc是不会帮你自动链接数学库的。
								-lc 
								
								...
								
								
								
								crtend.o、crtn.o：用于生成扫尾代码，程序运行结束时，做一些扫尾工作，这两个.o也是由gcc
									开发者编写的，为了方便描述，我们往往将扫尾代码认为是启动代码的一部分。
									
								crtend.o：扫尾做什么？比如调用c++析构函数，释放全局对象的空间
								crtn.o：扫尾做什么？比如，接收main函数的返回值并处理
									- 如果程序是裸机运行的，返回值到扫尾代码这里就结束了，裸机时返回值的意义不大
									- 如果程序是基于OS运行的，扫尾代码会将返回值交给OS									
								/usr/lib/gcc/x86_64-linux-gnu/5/crtend.o 
								/usr/lib/gcc/x86_64-linux-gnu/5/../../../x86_64-linux-gnu/crtn.o

								
								
								
								/* 简化后的链接过程，链接时，各个模块的顺序很重要 */
								collect2    //链接程序
								
								-dynamic-linker  /lib64/ld-linux-x86-64.so.2 //动态链接器
								
								crt1.o  crti.o  crtbegin.o  //启动代码
								
								ccyIcm4A.o  								//自己程序的.o，这里目前只有一个
								
								-lc 												//libc，常用c函数库——c标准库的子库
								
								crtend.o  crtn.o 						//扫尾代码
				
				
	
						7.总结gcc -v显示的详细信息
							
							（1）如果四个过程都有的话
										详细信息就是：gcc配置信息 + cc1信息(预处理+编译) + as信息 + collect2信息 
							
							（2）如果只是某个过程的话
									 比如：gcc -S helloworld.i -o helloworld.s -v
									 
									 详细信息就是：gcc配置信息 + 单个过程的信息
									

									
					8. 再说说启动代码 
						（1）启动代码是由“一个汇编文件+其它的.c文件”构成的，启动代码并不是我们程序员写的
								· 广义上，“汇编文件+其它的.c文件”都是启动代码。
									
								· 狭义上，“汇编文件”才是启动代码
			
			
						（2）启动代码的作用
								其中的核心作用就是，在内存中建立c程序运行所需的“堆和栈”，堆和栈其实就是程序运行时所需的运行环境之一，
							所谓运行环境，就是程序运行时必须要的支撑，就跟人一样，人活着也需要环境（生活环境/工作环境）的支撑，
							否则就麻烦了。
								
								程序运行起来后就变成了动态运行的程序——进程，所以程序的运行环境，也被称为“进程环境”，进程环境不仅仅
							只有“堆和栈”，还需要其它的，我们在《Linux系统编程/网络编程》第4章，将会详细的介绍什么“进程环境”，
							所以需环境有哪些。
				
			
						（3）我想看启动代码的源码，怎么办？
									如果想看启动代码的话，也主要是汇编部分，因为.c部分，会根据程序运行时有无OS支持，会有很大的区别。
									
									比如单片机没有OS，它的启动代码.c部分与有OS时启动代码的.c部分有很大区别，不仅.c，汇编部分也有
								区别，只不过区别没有那么大而已。
									
									.c部分我们就不关心了，如果你想看启动代码汇编部分，完全可以看单片机c程序的启动代码汇编部分。
									
									
									当有OS支持时，编译器提供的启动代码大都会被做成现成的.o，我们是看不到源码的，基本只有在裸
								机程序中才能看到启动代码汇编部分的源码，.c源码也能看见。
									
									所谓裸机程序就是没有OS支持的程序，比如绝大多数单片机程序就是典型的裸机程序，为什么呢？
								因为单片机很少运行OS，由于单片机开发的特殊性，有时候我们往往需要修改启动代码汇编部分，所以编译器
								会提供汇编启动代码的源码，所以完全可以通过看单片机的汇编启动代码，从而了解C的汇编启动代码干了什么
								事情。
									
									在有OS支持时，启动代码是不需要修改的，所以人家才以.o心事提供。
									
									
									讲单片机时，我们会分析单片机c程序的汇编启动代码，所以到时候你就知道它到底做了些什么事情，它是
								怎么去建立堆和栈的，建立堆和栈的代码长什么样子，那时你就不会再对启动代码感到神秘了。
								
									图：大概看看单片机的汇编启动代码长什么样子
										
										...
										/* 设置堆栈指针，堆栈的大小 */
										Stack_Size      EQU     0x00000400

										AREA    STACK, NOINIT, READWRITE, ALIGN=3
										Stack_Mem       SPACE   Stack_Size
										__initial_sp


										; <h> Heap Configuration
										;   <o>  Heap Size (in Bytes) <0x0-0xFFFFFFFF:8>
										; </h>

										Heap_Size       EQU     0x00000200

																		AREA    HEAP, NOINIT, READWRITE, ALIGN=3
										__heap_base
										Heap_Mem        SPACE   Heap_Size
										__heap_limit

																		PRESERVE8
																		THUMB

										...
										
								
									当然后续课程讲Uboot移植时，由于Uboot也是一个裸机程序，我们也能够看到Uboot的汇编启动代码
								的源码，你也能知道启动代码到底做了些什么事情，总之对于启动代码不要感到神秘，也没什么可神秘的。
									
									不仅c程序，所有高级语言所写的程序，都是需要启动代码的，启动代码要做的事情也都是类似的。
								
									当然就算你不了解启代码是咋回事，对于我们开发来说，也不会有什么太大的问题，但是如果你能了解什么
								是启动代码，大概做了些什么事情，当然是最好的了，因为这非常有助于你去理解与之相关的一些其它的深
								入问题。
									
						
						
出品：佳嵌工作室
----------------------------------------------------------------------------------------------------------------------------
	“佳嵌工作室”致力于物联网、嵌入式产品以及‘物联网、嵌入式技术课程’的研发，希望所推出的技术课程，能够帮助到正在努力
学习物联网、嵌入式的同学，欢迎大家和我们一起共同学习，共同进步。
----------------------------------------------------------------------------------------------------------------------------								
							
						
3. 静态链接 与 动态链接
	什么是链接，链接其实就是连接的意思，将所有相关的东西连接起来。
	
		简单理解静态连接和动态链接：
		静态链接：编译时完成链接
		动态链接：程序运行起来后，根据需求再去链接，这就是动态链接

			
		3.1 静态链接
			3.1.1 什么是静态链接
					所谓静态链接，其实就是在编译时，调用ld/collect2链接程序，将所有的.o中的机器指令整合到一起
				，然后保存到可执行文件中。
					
					
			3.1.2 什么时候用到静态链接呢？
					编译时用到，编译时的链接就是静态链接，所以链接程序ld/collect2，也可以称为静态链接器。

			
			3.1.3 静态链接时做了什么事
					两件事，符号解析 和 重定位。
					接下来就大概的介绍一下这两件事，为后面的详细介绍打基础。
			
				（1）符号解析
						（a）符号解析的作用
								符号解析的目的就是将符号的引用（使用）和符号的定义联系起来。
								
								
						（b）例子
										a.c                    b.c
									
									  fun(100);              void fun(int a)
									                         {
																						...
																					 }
											|                     |
											|                     |
											V                     V
										 a.o	 <——静态链接———> b.o
										 
								引用符号fun<————— 联系————>定义符号fun
										
										
								为了方便实现符号解析，编译得到.o文件时，每个.o文件都会包含符号一张的符号表。
								符号表记录什么？
								· 记录本模块定义了些什么符号
								· 记录本模块引用了些什么符号

								旁注：单个.c文件，也被称为一个模块，整个工程就是以模块为单位来进行组织的，模块化组织很重要，
								不进行模块化在组织的话，就只能将所有内容全写到一个文件中，对于大型c程序来说，显然很难操作。
								
									但是模块化组织有一个麻烦事就是，你需要将所有的模块合成一个完整的可执行程序，这个合成的麻烦事
								就是由collect2/ld来承担的。
								
								
				（2）重定位
						（a）重定位作用
									将.o文件中每个机器指令的逻辑地址，重定位为（转为）实际运行的地址。
									
								· 如果是裸机运行的：运行的地址就是内存的物理地址。
								· 如果是基于OS运行的：运行地址就是虚拟内存的地址
									不过虚拟内存机制，最终还是会将虚拟地址会转为物理地址。
									
									怎么理解重定位这三个字？
										简单理解就是，之前的地址不对，重新定位新地址，就好比导航时目的地址弄错了，重新定位一个新的目
									的地址，这就是“重定位”的含义。
									
									
						（b）.o中的逻辑地址
									逻辑地址只是理论上的，这个地址是无法被cpu取指运行的，因为逻辑地址即不是实际的物理地址，也不是
								虚拟内存的虚拟地址，它只是在编译时临时给的一个编号。
									
									.o中的每个节（.text/.rodata/.data等），逻辑地址都是从0开始的。
									
									演示：查看helloworld.o的逻辑地址
										但是由于.o是纯二进制文件，很难被阅读，所以需要将它反汇编为ascii的汇编。
										反汇编时，每条二进制的机器指令，会被翻译为对应的每条汇编指令，是一一对应的关系。
										
										反汇编：objdump -D helloworld.o > hw1.s
										查看逻辑地址：
										
										旁注1：在64位系统下，地址是64位的，所以十六进制的0地址有16个0。
										旁注2：我们这里只关心地址问题，有关.o文件的更多内容，我们这里不做介绍。
									
										
						（c）可执行程序中的运行地址				
									我们这里编译出的可执行文件helloworld，是运行在Linux的虚拟内存上的，所以重定位后的运行地址是
								“虚拟地址”。
									
									在Linux下，链接器重定位后的虚拟地址是多少呢？
									32位系统，64系统。
								
								· 32位Linux系统
									在32位Linux里面，虚拟地址是32位的，也就是4个字节。
									
									在32位的Linux下，重定位后，
									- 虚拟地址从0x08048000开始。0x08048000：32位
									- 每个节不再是从0开始的，节之间的虚拟地址是挨着的
									
									
									反汇编：objdump -D helloworld.o > hw1.s(名字由自己定)
									查看逻辑地址：
									
									
									旁注：同样的，我们这里只关心地址问题，有关可执行文件的更多内容，我们这里不做介绍。
								
								
								· 64位系Linux统
									在64位Linux里面，虚拟地址是64位的，也就是8个字节。
									
									在64位的Linux下，重定位后，
									- 虚拟地址从0x0000000000400000开始。0x0000000000400000：64位
									- 每个节不再是从0开始的，节之间的虚拟地址是挨着的
									
									反汇编：objdump -D helloworld > hw2.s
									查看逻辑地址：
									
								
					
		3.2 动态链接
			3.2.1 什么是动态链接
						所谓动态链接，就是在编译的时候只留下调用接口，当程序真正运行的时候，才去链接执行，动态
					链接这件事不是在编译时发生的，是在程序动态运行时发生的，所以叫称为动态链接。
			
			
			3.2.2 什么时候用到动态链接呢？
			
						使用动态库时，动态库就是动态链接的。
						
						比如程序中调用printf函数，这个函数基本都是动态库提供的，程序编译后代码里面是没有printf函数
					代码的，只有printf这个接口，当程序运行起来后，再去动态链接printf所在的动态库，那么程序就能调用
					printf函数了。
						
						如何理解这里说的接口？
						站在ascii的c源码角度来说，这个接口就是printf函数名，但是程序被编译为二进制后，printf就变成了一个
					地址，所以站在二进制的角度来说，接口就是函数第一条指令的地址。
					
					
			3.2.3 动态链接的实现者是谁
						动态链接由动态链接器来实现的，回顾gcc -v显示的链接信息
						collect2   
						
						动态链接器
						-dynamic-linker /lib64/ld-linux-x86-64.so.2（链接（加载）动态库）   
						
						......
						

						在后面的《c函数库》讲动态库的隐式与显示加载时，会详细的介绍到这里所讲问题。
			

			
			
			
出品：佳嵌工作室
----------------------------------------------------------------------------------------------------------------------------
	“佳嵌工作室”致力于物联网、嵌入式产品以及‘物联网、嵌入式技术课程’的研发，希望所推出的技术课程，能够帮助到正在努力
学习物联网、嵌入式的同学，欢迎大家和我们一起共同学习，共同进步。
----------------------------------------------------------------------------------------------------------------------------								
					
		3.3 静态库 与 动态库	
			
			3.3.1 如何得到库
				
					1）先写好一堆的.c文件（.c：我们所需要的各种工具函数）
						
					2）将这些.c编译为对应的.o

					3）将所有的这些.o打包为一个仓库文件（静态库或者动态库）	
						静态库：按照静态库的方式打包
						动态库：按照动态库的方式打包
							
						因为打包的规则不同，所以得到库也是不同的，
						
						
			3.3.2 二者的共性
					都是事先做好的.o仓库。
					
					库这个东西很好，如果没有库这个东西的话，每次都要自己重复实现这些工具函数，这会非常的麻烦。
				比如如果没有库提供printf的话，些个简单的helloworld，printf函数还需要自己实现，这就扯淡了。
					
					
			3.3.3 二者的区别
					这两种库的链接方式不同。
					
					· 静态库：静态链接：由静态链接器(collect2/ld)来实现
		
					· 动态库：动态链接：由动态链接器来实现

					
				（1）静态库
						1）链接静态库 与 链接一般的.o没有区别
								比如，如果printf函数是由静态库来提供的话，那就需要连接printf所在的静态库。
								
								静态库是.o的集合，printf在其中的某个.o中，链接静态库时，使用printf这个符号去搜索静态库中所有
							的.o，如果找到了printf所在的.o，将其链接到自己的程序中。
								
								
						2）静态库缺点
								链接静态库时，其实就是将库中.o的代码包含到自己的程序中，每个程序链接静态库后，都会包含一份独立
							的代码，当这些程序都运行起来时，所有这些重复的代码都需要占独立的存储空间，显然很浪费计算机资源。
								图：
								
								
								
								
				（2）动态库
						主要是为了解决静态库的缺点而存在的。
				
						1）链接动态库
								在链接动态库时，collect2/ld不会将动态库中.o的代码直接静态链接（复制）到自己程序中，只会留下调
							用接口。
							
								程序运行时再去将动态库（链接）加载到内存中，然后就能调用动态库的函数（代码）了。
						
						2）动态库的优点
							不管多少程序使用了这个动态库，这些程序只会共享使用同一份的动态库，因此动态库也被称为共享库。
							图：
							
							
							
							
							疑问：动态库的代码是被全部加载到内存中的吗？
							是的，因为动态库并不知道你的程序需要使用哪个函数，所以整个动态库都会被加载到内存中。
								
							
						2）回顾gcc -v显示的链接信息
		
								collect2   
								
								动态库链接器
								-dynamic-linker /lib64/ld-linux-x86-64.so.2   
								
								ccyIcm4A.o //我的.o中有调用printf函数
								
								-lc //链接libc.so动态库(c常用函数的动态库)，printf就被包含在了libc.so这个动态库中
									
									
								动态库工作的过程：过程描述的不严谨，但是它的原理确实是这样的。
								
								· 程序运行起来后，“动态链接器”一看你想链接的是libc.so动态库，首先检查内存中有没有这个动态库，
									- 如果没有
											到硬盘上找到libc.so库，将所有代码加载（动态链接）到内存中，并得到整个动态库在内存中的
										起始地址。
											
									- 如果有
											说明之前有人已经加载过了，所以不再加载，直接得到动态库在内存中的起始地址即可。
								
								
								· 调用动态库的prinf函数
									
									疑问：是怎么找到动态库中的printf函数的？
									与调用普通的函数一样，就是通过地址跳转找到。
									图：
									
									
									
									疑问：是怎么知道printf函数体的地址的？
										printf的地址 =  printf的相对地址 + 动态库加载时的地址
									
									- 相对地址
									
										编译时并不知道动态库会加载到什么位置，编译器其实并不知道printf函数第一条指令的绝对
										地址，所以编译时printf只是一个相对地址，
										图：
										
										
										什么是相对地址？
										printf函数第一条指令相对于动态库头的距离。
										
										
								 - 绝对地址 
									动态链接器加载动态库后，会得到动态库在内存中的起始地址（绝对地址）。
									
									printf相对地址 + 动态库绝对地址 == printf的绝对地址
									如此就能调用到动态库中的printf函数。
									
									图：
										
								
				（3）静态库 与 动态库的名字尾缀
					
 					1）静态库名字尾缀
						· windows：尾缀为.lib
						· Linux：尾缀为.a
					
					2）动态库名字尾缀
						· windows：尾缀为.dll
						· Linux：尾缀为.so
									

									
									
						
出品：佳嵌工作室
----------------------------------------------------------------------------------------------------------------------------
	“佳嵌工作室”致力于物联网、嵌入式产品以及‘物联网、嵌入式技术课程’的研发，希望所推出的技术课程，能够帮助到正在努力
学习物联网、嵌入式的同学，欢迎大家和我们一起共同学习，共同进步。
----------------------------------------------------------------------------------------------------------------------------												
									
4. 目标文件 

	4.1 目标文件种类
		有三种：
		
		· 可重定位目标文件
		· 可执行目标文件
		· 共享目标文件

		4.1.1 可重定位目标文件
				被用于静态链接的文件，都是可重定位目标文件。
				
				根据这个概念，静态库文件(.a/.lib)和.o文件都是“可重定位目标文件”，因为它们都是静态链接的。

			疑问：为什么称为“可重定位”？
				因为静态连接时，逻辑地址需要被重定位为运行地址，所以就被称为可重定位目标文件。
			
				
				
							
		4.1.2 可执行目标文件
				可以被执行的文件就是“可执行目标文件”，其实就是我们常说的“可执行文件/可执行程序”。
						
						
		4.1.3 共享目标文件
				被动态链接的文件其实就是共享目标文件，其实就是动态库，因为动态库是动态链接的。
						
				因为动态库被共享使用的特性，因此也被称为共享库，所以动态库文件也被称为了共享目标文件。
		
		
	4.2 目标文件格式
			各不同运行环境之间(OS)，目标文件的格式是不同的，所以针对不同环境的目标文件，格式是不一样的。
		这就好比不同公司的规章制度肯定有区别。
			
			疑问：目标文件格式有什么用？
			格式规定了目标文件中指令和数据的组成结构，每个环境（OS）只认自己的格式。
			
			虽然不同的格式之间有区别，但是大体上都是类似的。
		
		
		4.2.1 裸机目标文件
			如果你的程序最终是运行在裸机上的话，裸机目标文件的格式为.bin格式。
			
			我们学习后面的arm裸机时，程序就是裸机运行的，所以那时编译出的目标文件都是.bin格式的。
			
			
		4.2.2 unix系统的目标文件格式
			（1）早期unix
						使用的a.out格式，因为这个历史遗留，现在再unix下编译时，如果不指定可执行文件的名字的话，
					默认起名为a.out，这个名字就来自于a.out这个格式名。
					
						Linux的父亲是Unix，因此对于Linux来说，编译时如果不指定可执行文件名的话，默认也起名为a.out，
					要注意，尽管起名为a.out，但是Linux系统目标文件的格式并不是a.out格式，仅仅只是沿用了a.out这个名字而已。
			
			
			（2）system V unix
					unix升级到第5版本时，a.out格式变为了COFF格式（Common Object File Format：一般目标文件格式）。
			
			
			（3）现代Unix
					已经改用ELF格式（Excutable and Linkable Format：可执行可链接格式）。
					
		4.2.3 windows
				windows是PE格式（Portable Excutable：可移植、可执行格式），由Unix COFF格式格式演变而来。
			
			
		4.2.4 Linux
				与现代的Unix一样的，使用的也是ELF格式，虽然在Linux下，编译时默认的可执行文件的名字是a.out，
			但是其实目标文件的格式是ELF（可执行可链接格式）。
				
				如何理解ELF（可执行可链接格式）的含义？
			（1）可重定位目标文件、共享目标文件：可以被链接
			（2）可执行目标文件：可以被执行
			
			我们这边的程序是运行在Linux系统上的，因此我们要接触的是Linux的ELF格式。
			

	
5. 可重定位目标文件

	5.1 如何得到“可重定位目标文件”
	
		5.1.1 如何得到.o文件
	
								cpp、cc1预编译         cc1编译               as汇编
				***.c —————————————————>a.i————————————————>a.s———————————————————> ***.o
	
					经过以上流程后就能得到.o文件，得到.o后，在.o中放的都是机器指令。
					
					我们在前面讲过，在没有链接之前，.o中的机器指令是无法执行的。
			
			
			
		5.1.2 如何得到“静态库文件”
			（1）先从各.c得到各个.o文件
				
			（2）将各.o文件打包成静态库
						
					后面介绍c库时，会讲如何具体制作静态库。
			
			
	5.2 ELF格式可重定位目标文件的组成结构
			
			前面就是说过，在Linux下面，目标文件的格式都是ELF格式，所以接下来我们就看看ELF格式的“可重定位目标文件”，
		它的指令和数据的组成结构是怎样的。
			
			图：
			
			
			
			
				
			（1）总共13个节
			（2）每个节都有一个编号
						从ELF头开始编号，编号从0开始，编号的作用就是用来索引（找到）不同节的。
			
			（3）每个.o的都是这样的结构
						链接时要做的就是，将ELF格式的.o全部合成为一个完整的ELF格式可执行文件，后面在详细介绍。
					
					
			（4）前面说过，.o中每个节的逻辑地址都是从0开始的
			
			
			
			
			
			
			
			
			
		5.2.1 ELF头（ELF格式头）
		
			（1）格式头放什内容？
					放ELF格式所需要的一些基本信息，比如
			
					1）系统所规定的字的大小
						64 OS：字大小是64bit
						32 OS：字大小是32bit
				
					2）字节顺序（字节序）
						用于说明系统是大端序的还是小端序的。
					
					3）其它
						1）ELF格式头的大小
						2）目标文件类型（可重定位目标文件、可执行目标文件、共享目标文件）
						3）CPU架构：说明编译出来的机器指令是运行在什么CPU上的
						4）等等
						
						
				（2）使用readelf，查看“可重定位目标文件”的ELF头信息
						readelf：读取目标文件的ELF格式信息的，跟-h选项的话，就是查看ELF格式头信息。
						
						演示：
						readelf -h 目标文件
						
				ELF Header:
					Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00//ELF魔数，7f是固定的，45 4C 46为ELF的ascii码
					Class:                             ELF64 //表示该ELF格式面对的是64位系统，在32位系统里面就是ELF32
					Data:                              2's complement, little endian//数据按小端序存储
					Version:                           1 (current)   //ELF头版本号
					OS/ABI:                            UNIX - System V  
					ABI Version:                       0  
					Type:                              REL (Relocatable file)//目标文件类型，这里标注的是“可重定位目标文件”
					Machine:                           Advanced Micro Devices X86-64//cpu类别
					Version:                           0x1 //目标文件版本号
					Entry point address:               0x0 //起始地址（入口地址），前面说过.o逻辑地址是从0开始的
					Start of program headers:          0 (bytes into file)
					Start of section headers:          672 (bytes into file)
					Flags:                             0x0
					Size of this header:               64 (bytes) 
					Size of program headers:           0 
					Number of program headers:         0
					Size of section headers:           64 (bytes)
					Number of section headers:         13
					Section header string table index: 10
			
			
			
		5.2.2 .text
			放所有函数的机器指令，不过某些常量也会直接和指令一起存在.text当中。
			
			.text：也是只读节
			
			比如：
			
			int main(void)
			{
				int a = 20;

				a = a + 100; //表达式中的100会直接和指令放在一起
			}
			
			
		5.2.3 .rodata
			只读数据节，放只读数据（放某些常量数据）。
			
			比如：
				int a = 100;
				printf("%d", a);
				
				char *p = "hello world";
			格式字符串"%d"和"hello world"这两个字符串常量，都放在了.rodata中。
			
			
		5.2.4 .data 
			存放已初始化了的静态变量，比如：
		
			（1）初始化了全局变量
					int a = 100; //初始化了的全局变量，a就是在.data节中
					
					int main(void)
					{
						printf("%d\n", a);
					}
					
					
			（2）初始化了的静态局部变量
			
					int main(void)
					{
						static int b = 101;//已经初始化了的静态局部变量，后面讲static关键字时还会介绍到
					
						printf("%d", a);
					}
					
					初始化了的静态局部变量的空间就开辟在.data中。
					
					注意：如果没有static的话，b就是自动局部变量，b空间开辟于栈中。
					
						但是只有程序运行起来后才有栈这个东西，因此作为还处在编译阶段的.o来说，自动局部变量还不存在，或者说
					还只是以函数代码的形式存在于.text中。
					
						当程序运行起来有了栈之后，该函数的代码会在栈中开辟自动局部变量的空间，并将数据101存入开辟的空间。
			
			
		5.2.5 .bss
				放未初始化的静态变量，比如
			
			（a）未初始化的全局变量
					int a; //未初始化了的全局变量
					
					int main(void)
					{
						printf("%d", a);
					}
			
			（b）未初始化的静态局部变量
			
					int main(void)
					{
						static int b;//未初始化的静态局部变量
						
						printf("%d", a);
					}			
			
				由于没有初始化数据，所以其实不占用空间，因此在.o中，.bss只是一个占位符，只有当程序真正运行起来后，才会
			在内存上真正的开辟.bss的空间，并在.bss空间中开辟a和b的空间，并制自动初始化为0。
				
				所以在.o中，.bss只是一个理论上的存在。

				.o为什么没有开辟.bss空间？
				没有实际要存放的数据，开辟空间只是浪费空间。
				你要知道.o这个文件是存在我们的电脑硬盘上的，.o如果有.bss空间的话，.bss是要占硬盘空间的。
				
				
		
		5.2.6 .symtab：符号表
					
					
			（1）symtab记录什么
					有关符号表，我们在天面大致的提过。
					每一个.o文件都有一个符号表，用于存放.o中所定义和引用的全局符号信息（函数和全局变量的符号信息）。
					
					比如a.c
					int a = 100;
					
					int fun(int a)
					{
						...
					}
					
					extern int b; //定义在了b.c中
					
					int main(void)
					{
						b = 10000;
						
						fun2(1000); //fun2定义在了c.c中
					}
					
					a.c -> a.o
					b.c -> b.o
					c.c -> c.o
					
					a.o的.symtab符号表就记录如下符号的信息。
					1）a.o中定义的符号信息
						a：a.o自己定义的全局变量符号
						fun：a.o自己定义的函数符号
						main：a.o自己定义的函数符号
						
						
					2）a.o中引用的符号信息
						b：a.o引用的在b.o中定义的全局变量符号
						fun2：a.o引用的在c.o中定义的fun2函数符号
						
						
			（2）注意：.symtab符号表并不记录符号的名字
							.symtab记录符号的基本信息，符号是否有定义，符号对应的空间在哪个节中等，但是符号的名字本身并不存在
						符号表中。
							
						疑问：符号的名字记录在了哪里呢？
						后面回答。

						
			（3）.symtab符号表的意义
			
						众多的.o之所以能被链接在一起，这张符号表所记录的信息功不可没。
						
						比如，a.o中引用的b和fun2，被定义在了b.o中，将a.o和b.o链接在一起时，必须查看各个.o中的.symtab表，
					才能将各自符号的定义和引用关联起来。
						
						
						注意：符号表并不记录自动局部变量的符号。
							
							int fun()
							{
								int a = 100;
								...
							}
							
						为什么不记录自动局部变量的符号？
							自动局部变量是在程序运行起来有了栈以后才有的，在编译阶段fun函数的int a = 100，在fun函数中只是压栈
						和弹栈的代码。
							
							当程序运行起来有了栈后，当fun函数开始运行时，fun的压栈代码会开辟自动局部变量的空间，fun函数结束
						时会调用弹栈代码自动释放空间。
						
							但是如果是static修饰的静态局部变量的话，符号表中会记录符号，因为在编译阶段就会处理静态局部变量。
						
			
		5.2.6 .rel.text	
				将多个.o链接到一起时，每个.o的.text会被整合为一个.text，整合.text时就必须依赖.rel.text所记录的一些有关
			.text中指令的位置信息，至于具体的位置信息是怎么样的，我们这里不需要知道。
			
			
		5.2.7 .rel.data
				将多个.o链接到一起时，每个.o的.data会被整合为一个.data，整合到一起时，就必须要依赖.rel.data所记录的一
			些有关.data的信息，具体什么信息我们这里不需要掌握。
			
			
		5.2.8 .debug
			符号调试表，记录调试信息，编译时必须加-g选项，编译时才会在.debug节中加入调试信息。
				
				
		5.2.9 .line 
			存放代码行号，因为调试的时候往往需要显示源码的行号。
			
			只有gcc编译时加了-g选项后，才会加入行号信息。
				
				
		5.2.10 .strtab
			字符串表，比如：
			.symtab、.debug所用到符号名字、每个节的节名字(比如.text等)、源文件名字(***.c)等，都存在.strtab中
			
			比如：
			.text\0.rodata\0......fun\0main\0
		
		
			疑问：全都放在一起，怎么查找呢？
		
		
		5.2.11 节头部表
			描述目标文件中的每个节的某些相关信息，对于节头部表来说，我们这里不在介绍。
				
		
		
		
		
		
			
出品：佳嵌工作室
----------------------------------------------------------------------------------------------------------------------------
	“佳嵌工作室”致力于物联网、嵌入式产品以及‘物联网、嵌入式技术课程’的研发，希望所推出的技术课程，能够帮助到正在努力
学习物联网、嵌入式的同学，欢迎大家和我们一起共同学习，共同进步。
----------------------------------------------------------------------------------------------------------------------------								
			
	5.3 .symtab符号表
		
		.symtab中记录的符号是从.s文件来的，所以.s这个汇编文件很关键。
		
		5.3.1 .symtab所记录符号的种类
			
				a.c                                     b.c    

				extern int a_va1 = 100;              	  int b_va1 = 300;   
				static float a_va2 = 200.0;
				
				static void a_fun2(void) 								int b_fun2(void)
				{																				{
					a_va2 += 100;														...
				}																				}
				
				extern int a_fun1(int a)                int main(void)
				{																			 	{
					b_va1 = b_va1+100;											fun1(100);
					b_fun1();                               a_va1 = a_va1 + 200;
					a_fun2(); 
				}																			 	} 
									
							
				extern：表示定义的函数和全局变量可以被其它模块引用，如果不写extern，默认就是extern，为了不麻烦，一般
					都不会明确的写extern。
					
				static：表示定义的函数和全局变量，只能被本模块有效。

				
				.symtab中所以记录的符号，严格说起来就两种：
			
			（1）全局符号：某模块定义以后，除了自己外，其它所有模块也可以引用
						我们以a.o模块为例来讲。
			
					1）由a.o模块定义，可由其它模块引用的全局符号
							a_fun1：a.o定义，但是其它模块(b.o)可以引用
							a_va1：a.o定义，但是其它模块(b.o)可以引用
							
					2）由a.o模块引用，但是由其它模块定义的全局符号
							b_fun1：a.o引用，但是由b.o定义
							b_va1：a.o引用，但是由b.o定义
			
			
			（2）本地符号：模块自己定义，而且只能由自己引用的符号			
						a.o的a_fun2和a_va2，由于加了static修饰，表示符号只在模块内有效，所以a_fun2和a_va2属于典型的由本模块
					定义、而且只能由本模块引用的本地符号。

					
					旁注：有关static
						在写c代码时，对于那些只在本模块定义和引用的函数与全局变量来说，我们要养成使用static的好习惯，这样子
					符号就是只在本模块有效的本地符号。
						
						如果不写static的话，会带来命名冲突、错误调用等等一些列可能的不良后果，特别是对于大型c工程文件来说，
					出现这类不良后果的概率非常高。
					
			
				
		5.3.2 .symtab是如何记录符号信息的				
				.symtab符号表包含很多条目，每个条目记录的就是一个符号的基本信息。
			
			
		（1）每个条目所包含的符号基本信息有哪些呢？
				int name; 
				int value;
				int size;
				char type;
				char bind;
				char section;
				
				信息含义：
				1）name
						name中记录的并不是名字的字符串，我们前面说过所有的字符串都是放在了.strtab中，
						图：
						
						name里面只记录字符串在.strtab中的偏移，通过这个偏移就能在.strtab中索引到符号的名字。
						
						比如
							name = 5 //偏移5
						
							假如.strtab中的内容为main\0fun2\0a_va\0......
							
							使用偏移5到.strtab中进行搜索，当遇到\0时就截止，那么取出来的就是符号fun2。
							
							
				2）value
					放的是地址：指向符号所代表的空间。
					
					比如：
					（a）如果符号是初始化了的全局变量
								int a = 100;//全局变量
								
								int main(void)
								{
								}
								
								初始化了的全局变量，它的空间在.data节中，那么value中放的就是这个空间的起始地址。
								图：
								
								通过value中的地址值，就可以找到符号对应的空间，这对于后续的“链接”操作来说很重要。

								
					（b）如果符号是函数的话
								比如：
								int fun()
								{
									
								}
								
								fun函数指令存放在了.text节中，value中放的就是fun函数在.text节中的起始地址，其实就是函数第一条
							指令的地址。
							图：
							
							
							
					（c）需要强调的地方
				
							不过对于.o（可重定位目标文件）和可执行目标文件来说，value的值有所不同。
				
						· 可重定位目标文件
							value总中放的只是相对于节起始地址的偏移。
							图：
							
							
							
						· 可执行目标文件
							value中放的是绝对地址。
							
							“可重定位目标文件”被连接在一起后，value中放的就是链接时重定位后的绝对地址。
					

				3）size
						size代表的是value所指向空间的大小，毕竟value只是起始地址，不能说明空间的大小。
								
						比如：
					（a）如果符号是初始化了的全局变量的话
							size代表的全局变量在.data中所占字节数。
						
					（b）如果符号是函数的话
							size代表的是函数指令在.text中所占空间的大小
							
				4）type
						符号类型，有如下几种类型。
					
					（a）FUNC：符号代表的是函数
					（b）OBJECT：符号代表的是全局变量
					（c）FILE：符号是源文件的名字
					
					
				5）bind
					就两种情况，LCOAL、GLOBAL
					
					（a）bind=LOCAL
							表示符号是本地的：符号在模块中定义后，只能由本模块引用，static修饰的全局变量和函数就是这种情况。
							比如：
							
							a.o：

							static int a = 100;
							
							static int fun(int arg)
							{
								...
							}
							
							有关static、extern等关键字，后面章节会还会详细讲，不过如果你能在这里就先理解他，后面章节再讲到时，
						你会有一种完全不一样的感觉。
							
							
					（b）bind=CLOBAL(全局符号)
							表示符号在本模块定义，但是可以被其它模块引用（使用），extern修饰的全局变量和函数就是这种情况。
							比如：
							
							a.o：

							int a = 100; 
							
							int fun(int arg)
							{
								...
							}
					
							定义a和fun时没有显式的写出extern，那么默认就是extern的，为了不麻烦，一般不会显式写出。
							
		
				6）section					
						section的值有四种情况，节索引号、ABS、UNDEF、COM
						
					（a）section=节索引号
							图：
						
						
							说明符号所对应的空间在哪个节里面。
							比如，
						
						· 如果section == 1
							符号代表的空间在.text节，说明符号代表的是函数，因为只有函数指令才会保存在.text中。
						
						· 如果section == 3
							符号代表的空间在.data中，说明符号是初始化了的全局变量，因为只有初始化了的全局变量才会在.data节。
							
								
					（b）section=ABS
							表示该符号不需要被“链接程序”处理。
							
							比如，如果符号名是***.c，这个符号不是全局变量、不是函数，只是一个源文件名而已，链接器
						（ld/collect2）在链接“可重定位目标文件”时，这个符号不需要被处理。
							
								
					（c）section=UNDEF
								表示这个符号，只是在本模块中被引用了，这个符号并不是由本模块定义的，在本某块找不到定义，所以这个
							符号的section就被标注为了UNDEF，表示这个符号被定义在了其它模块中，链接时要到其它模块中去找搜寻它的
							定义。
							
								其它模块：
								· 其它自己写的.c所对应的.o
								· 静态库
								· 动态库
								
								
								如果是链接时，在其它目标文件中还找不到该符号的定义的话，链接程序就会报错，提示找不到这个符号。
								出错的原因有两种：
								
								· 你忘了链接所需的目标文件
									比如gcc a.o b.o，结果写成gcc a.o，少了一个，肯定会找不到。
								
								· 符号名压根就写错了，不可能找得到
									
					（d）section=COM
							表示是还未被分配空间（位置）的未初始化的数据目标，比如未初始化的全局变量。
							int a;
							int main(void)
							{
								...
							}
							
							未被初始化的全局变量都放在.bss中的，但是前面就说过，由于没有数据，所以.bss没有实际空间，只有当程
						序运行时才有实际.bss节的空间。
							
								
								

					
					
出品：佳嵌工作室
----------------------------------------------------------------------------------------------------------------------------
	“佳嵌工作室”致力于物联网、嵌入式产品以及‘物联网、嵌入式技术课程’的研发，希望所推出的技术课程，能够帮助到正在努力
学习物联网、嵌入式的同学，欢迎大家和我们一起共同学习，共同进步。
----------------------------------------------------------------------------------------------------------------------------																							
		
		5.3.2 查看目标文件的.symtab符号表信息			
				目标文件三种：
				可重定位目标文件
				可执行目标文件
				共享目标文件
				
				这几类目标文件的.symtab符号表都可以被查看，目前我们这里只查看.o可重定位目标文件的符号表，查看程序（命令）
			依然是readelf。
				readelf -h：查看ELF头中的信息
				readelf -s：查看.symtab符号表
	
			
				比如：helloworld.c  ——————> helloworld.o，查看helloworld.o的.symtab
					
				helloworld.c
				
				unsigned long a = 100;
				static int b = 100;
				int c;

				int main(void)
				{
					time(&a);

					printf("hello world\n");

					return 0;
				}

				演示：readelf -s helloworld.o

																													          （section）
				 Num:      Value          	Size 		Type    	Bind   	Vis     	Ndx 		Name
					 0: 	0000000000000000     0 			NOTYPE  	LOCAL  	DEFAULT   UND 
					 1: 	0000000000000000     0 			FILE    	LOCAL  	DEFAULT  	ABS 		helloworld.c
					 2: 	0000000000000000     0 			SECTION 	LOCAL  	DEFAULT    1 
					 3: 	0000000000000000     0 			SECTION 	LOCAL  	DEFAULT    3 
					 4: 	0000000000000000     0 			SECTION 	LOCAL  	DEFAULT    4 
					 5: 	0000000000000008     4 			OBJECT  	LOCAL  	DEFAULT    3 			b
					 6: 	0000000000000000     0 			SECTION 	LOCAL  	DEFAULT    5 
					 7: 	0000000000000000     0 			SECTION 	LOCAL  	DEFAULT    7 
					 8: 	0000000000000000     0 			SECTION 	LOCAL  	DEFAULT    8 
					 9: 	0000000000000000     0 			SECTION 	LOCAL  	DEFAULT    6 
					10: 	0000000000000000     8 			OBJECT  	GLOBAL 	DEFAULT    3 			a
					11: 	0000000000000004     4 			OBJECT  	GLOBAL 	DEFAULT  	COM 		c
					12: 	0000000000000000    31 			FUNC    	GLOBAL 	DEFAULT    1 			main
					13: 	0000000000000000     0 			NOTYPE  	GLOBAL 	DEFAULT  	UND 		time
					14: 	0000000000000000     0 			NOTYPE  	GLOBAL 	DEFAULT  	UND 		puts
						
					回顾.symtab中每个条目（符号）的基本信息		
					int name; 
					int value;
					int size;
					char type;
					char bind;
					char section;
						
			（1）举例分析
					1）符号main                                                 （section）
						Num:   	    Value       	Size 		Type    	Bind   Vis      	Ndx 		Name
						12: 	0000000000000000    31 			FUNC    	GLOBAL 	DEFAULT    1 			main

						（a）符号名：main
						（b）类型：函数
						（c）本地符号/全局符号：全局
								被extern修饰的全局变量和函数，都会被标记为GLOBAL
						
						（d）符号对应空间所在位置
								· 所在节：函数指令存在了编号为1的.text节
								· 节中位置：偏移为0，表示main指令从.text第一个字节处开始存放
								· 大小：从.text的第一个字节往后，占31字节
								
								符号对应的空间有明确的定义位置（.text），表明符号是在本模块定义的。
								
					2）符号time                                                 （section）
						Num:    	Value          	Size 		Type    	Bind   	Vis      	Ndx 		Name
						13: 	0000000000000000     0 			NOTYPE  	GLOBAL 	DEFAULT  	UND 		time
						
						（a）符号名：time
						（b）类型：因为在本模块中找不到time的定义，所以不清楚符号的类型
						（c）本地符号/全局符号：全局
									UDN表示符号只是在本模块引用，但是不在本模块定义（在其它模块定义），属于全局符号。
									
						（d）符号对应空间所在位置
									UDN表示符号没有在本模块中定义，因此value/size都没有意义，所以都是0。
									

					3）符号b                                                   （section）
						Num:   	 Value          	Size 		Type    	Bind   	Vis      	Ndx 	Name
						 5: 	0000000000000008     4 			OBJECT  	LOCAL  	DEFAULT    3 			b
			
						（a）符号名：b
						（b）类型：全局变量（静态变量）
						（c）本地符号/全局符号：本地的
								被static修饰的全局变量和函数，都会被标记为LOCAL本地符号
						
						（d）符号对应空间所在位置
								· 所在节：第3节.data，放在了.data中，说明是初始化了的
								· 节中位置：.data节的第8个字节处（偏移）
								· 大小：4个字节（int类型，肯定是4个字节）
							
							符号对应空间有明确的定义位置，表明符号是在本模块中定义的。
							
							
					4）符号c                                                       （section）
							Num:    	Value          	Size 		Type    	Bind  	Vis      	Ndx 	Name
							11: 	0000000000000004     4 			OBJECT  	GLOBAL 	DEFAULT  	COM 		c
						
						（a）符号名：c
						（b）类型：（静态变量（全局变量））
								COM表示未初始化，未被初始化在.bss节中，不过.bss也是空的。
								
						（c）本地符号/全局符号：全局的
						（d）符号对应空间所在位置
								· 所在节：未分配空间的都在.bss节，也就是第4节，这不过第4节在编译阶段其实并不存在
								· 节中位置：.bss的第4字节处，这只是理论上的，因为在.o中还没有.bss的实际空间
								· 大小：4个字节
								符号对应空间有明确的定义位置，表明符号是在本模块定义的
				
					5）符号helloworld.c                                            （section）
							Num: 	    Value          	Size 		Type    	Bind   	Vis     	Ndx 		Name
								1: 	0000000000000000     0 			FILE    	LOCAL  	DEFAULT  	ABS 		helloworld.c
						
								ABS表示这个符号并不需要链接处理。
								FILE表示这个符号是源文件名。
								LOCAL表示这个符号时本地符号
								对于源文件名来说，并没有对应的空间，所以value/size没有意义，所以值为0。
						
						
					5）其它哪些没有符号名的是什么情况
							专门给链接器链接时使用的本地符号。
						
						
						
						
						
			
					
出品：佳嵌工作室
----------------------------------------------------------------------------------------------------------------------------
	“佳嵌工作室”致力于物联网、嵌入式产品以及‘物联网、嵌入式技术课程’的研发，希望所推出的技术课程，能够帮助到正在努力
学习物联网、嵌入式的同学，欢迎大家和我们一起共同学习，共同进步。
----------------------------------------------------------------------------------------------------------------------------																							
						
5. 可执行目标文件
	
	5.1 如何得到可执行目标文件		
			链接程序collect2/ld，将所有的可重定位目标文件静态链接在一起，就得到了可执行目标文件。
			图：
			
			
			静态链接动态库时，只是留下函数的接口，当程序运行时再动态加载动态库。
			
			
			简单理解的话，链接的过程，其实就是将所有的.o文件合并为一个可执行文件的过程。
		
			
			链接时，链接程序（静态链接器）做了什么事情 
				链接器主要做两件事情，
				第一：符号解析
				第二：地址重定位。
				
				有关这两件事情，我们在前面大概的介绍过，接下来我们将会较为详细的介绍下这两件事。

				
	5.2 符号解析
		5.2.1 符号解析的目的
		
				确定模块中引用的每个符号都有明确的定义，并将每个符号的引用与定义关联起来。
				
				如果你引用了一个符号，结果这符号没有被定义，程序是无法运行的。
				
				比如：				
			（1）如果引用的全局变量没有定义的话
						符号没有定义，这个变量就没有对应的空间，没有变量空间，就没办法进行读写了。
					
					
			（2）如果引用的函数没有定义的话
						函数体（函数指令）就不存在，函数没办法调用。
			
			
			
		5.2.3 如何解析符号
				检查模块（.o）的.symtab符号表，看符号的定义情况。
				
				
			（1）情况1：符号就是在本模块定义的（本地符号）
						像这种情况的话，链接器不需要做什么太多的解析工作，因为符号就是在本模块中定义的，每个符号对应的空间
					就被定义在了本模块的某个节中(比如.text、.data等节)，引用该符号时肯定没有问题。
						
						
			（2）情况2：符号由本模块引用，但是在其它模块定义的（全局符号）
						被标记为UND的符号就是这种情况，UND表示此符号只是在本模块引用，但是在其它模块定义的。
						其实链接器进行符号解析时，重点解析的是标记为UND的符号，解析时会检查UND符号是否在其它模块中有定义。
					
						怎么解析UND符号的？
						解析时，对于本模块中UND的符号，链接器会查看其它模块的.symtab符号表，看该符号是否在其它模块中有定义，
					如果找到定义，就将符号的引用和定义关联起来，如果找不到，链接器就会报undefined reference to ‘符号名’的
					错误。
						
					比如：
						a.c
						
						int fun();

						int main(void)
						{
							fun();

							return 0;
						}
						
						gcc编译链接
						zxf@ubuntu:~/Desktop$ gcc a.c  b.c -o a
						/tmp/ccTyxboK.o: In function `main':
						a.c:(.text+0xa): undefined reference to `fun'
						collect2: error: ld returned 1 exit status

						undefined reference to `fun'这个错误是由链接器报的。
						
						
			（3）说说有关编译链接时的报错	
						其实编译链接时，四个阶段都有可能会报错误。
					
					1）预处理					
							a.c ---> a.i（cpp、cc1）
							
							报预处理的错误，凡是宏、头文件包含、预编译等错误都是在预处理阶段，由“预处理器”报的。
						
						
					2）编译阶段
							a.i ----> a.s （cc1）
							
							这个阶段报的都是c语法错误，因为这个阶段的主要目的就是按照c语法格式去解释c源码文件，然后翻译得到汇编，
							
							所以编译阶段报的主要是c语法的错误，只要你不按照c语法格式的要求写，就会报C语法错误。
							
							比如：
							（a）各种c关键字用错、写错
									· 写错：return 10  写成了 retrun 10
									· 用错：
										switch(a)
										{
														case 12.6: a = 10;//c语法要求，switch的case不能跟浮点数
										}
										
							（b）各种重复定义
										编译时，是以单个源码文件为单位来操作的，单个源码文件（模块）中的一些关键内容，是不能重复
									定义的。
							
									· 变量重复定义的错误
										a.c
										int a = 100;
										int a = 101;
										
										int main(void)
										{
										}
										
										疑问：int a; 
													int a = 100;
													算不算重复定义。
												
										答：这种不算，为什么不算，后面解释。

										
										同一模块的重复定义，编译器编译时就会检查出来，不同模块之间的重复定义，只能留给链接器检查。
										a.o                   b.o
										int a = 10;           int a = 100;
										
										
										
									· 类型重复定义的错误
										比如：
										a.c 
										struct student
										{
											int num;
										};
										
										struct student
										{
											int num;
										};
										
										int main(void)
										{
										}
							
										旁注：像int、float、char、struct student等类型，是c语法格式才有的东西，是专门给cc1编译器用的，
										这些类型决定了数据空间的存储结构和大小，比如：
											int a; 		//整形存储结构，4字节
											float b;	//浮点存储结构，4字节
											
											一旦编译器cc1将其编译为汇编后，这些类型就消失了。
											其实所有属于C语法格式的东西（比如，c的类型、关键字等），在cc1编译之后，都将不复存在。
											
											
									· 模块中函数重定义的错误
										
											a.c
											int fun()
											{
												...
											}
											
											int fun()
											{
												...
											}
											
										
							
							（c）汇编
										a.i -—————> a.s
										a.s ——————> a.o (as)
							
										事实上，汇编阶段并不会报什么错误，不报错的原因，并不是因为汇编器as没有检错的能力，而是只要
									c源码被编译为a.s时通过了，也就是说只要c源码没有错误，那么编译得到的a.s就没问题，从a.s汇编
									为a.o时，其实没有什么需要报的错误。
										
										
							（d）链接
									
							
									报各种链接时产生的链接错误，比如
									
									· 某模块引用的符号，找遍其它所有模块，都找不到它的定义时，就会报
											undefined reference to ‘符号名’的错误
									
									
									· 不同模块有强符号重复定义时，报重复定义的错误
									
										- 初始化了全局变量的重复定义
										
												a.o                    b.o
												int a;                 int a = 100;
												
												链接时会报a重复定义了。
												
												如果不想报错怎么？
												+ 给其中一个加static，或者两个都加static
													加了static后，符号就是本地的，对其它模块无影响。
									
												+ 将其中一个的初始化去掉
													没有初始化的符号是弱符号，强弱符号不会冲突，有关强弱符号的问题，后面还会介绍。
													
									
										
										- 同名函数的重复定义
												a.o            	b.o
												float fun(int a)  int fun(void)
												{              	{
													
												}              	}

				
										旁注：有关c++/java中同名函数的问题。
										
										· c的情况
											对于c来说，不管函数参数一不一样，只要函数名相同，就被认为是重名。
											
										· c++/java等
												这类语言的函数允许重载，重载的意思就是说，函数名相同不一定重名，只要参数不同，就是两个
											不同的函数，
												
												int fun(int a)
												{
													
												}
												
												int fun(int b, int c)
												{
													
												}
												
												因为在进行函数重名的判断时，函数名和函数参数会合在一起判断，只有当函数名和
											参数完全相同，才能算是重名。
												
											
			
			
			
			
			
			
			
					
出品：佳嵌工作室
----------------------------------------------------------------------------------------------------------------------------
	“佳嵌工作室”致力于物联网、嵌入式产品以及‘物联网、嵌入式技术课程’的研发，希望所推出的技术课程，能够帮助到正在努力
学习物联网、嵌入式的同学，欢迎大家和我们一起共同学习，共同进步。
----------------------------------------------------------------------------------------------------------------------------																							
	
			5.2.3 链接器在符号解析时，是如何解决全局符号的重名问题的	
					前面说过，对于模块内部符号重名的情况，在编译时cc1编译器会检查出来，对于不同模块之间的全局符号重名情况，
				只能由链接器解析时来检查。
				
				
				（1）模块之间全局符号重名的情况是无法避免的
					
					为了方便工程的组织管理，程序肯定是某块化组织管理的，此时模块之间必然会涉及全局变量和函数的声明，
					比如：
					
					a.c                         							 b.c
					
					int fun();
					int a;                     								 int a = 100;
					
					int main(void)                             int fun()
					{																					 {
						a = a + 100;
						fun();                                     ...
					}			                                     }
					
					
						a.c中为了使用b.c中定义的a和fun，需要在a.c中进行声明，声明的符号与定义的符号是同名的，链接器将这两
					个文件链接为一个可执行文件，同名的符号就必须统一(合并)为一个，所以链接器进行符号解析时，重名符号的统一
					是必不可少的。

					
				（2）链接器解析符号时，是如何解决全局符号重名的情况
						
						链接器根据符号的强弱共存规则来解析。
						
						1）全局符号的强弱之分
							1）全局变量
								（a）强符号：初始化了的全局变量
								（b）弱符号：未初始化的全局变量
								
							2）函数
								（a）强符号：函数定义
								（b）弱符号：函数声明
					
								每个全局符号是强符号还是弱符号，在.symtab表中会有相应的记录。
					
						2）重名符号的强弱共存规则
							1）不允许多个同名的强符号同时存在，存在的话就报错
							2）强符号只有一个，其它同名的都是弱符号的话，统一时，选强符号，舍弃弱符号
							3）同名符号如果全都是弱符号的话，留其中某个，其它舍弃，留谁由链接器来决定
							
							
						3）举例
							（a）例子1
									a.c                       b.c
									int a = 100;				int a = 200;
									
									int fun()                 (extern) int fun()
									{                         {
										a += 10;                    a = a - 100;
									}								          }
									
									int main(void)            
									{
										static int a = 10;
										fun();
									}
									
									由于文件中定义的全局变量a和函数fun都是全局的强符号（extern修饰的），在各自的.symtab符号表中，
								a和fun都会被标记为全局强符号。
									
									链接器进行符号解析时，会去检测这两个模块的.symtab表中的符号，发现这各自的a、fun都是全局强符号，
								根据强弱符号的共存规则，一山不容二虎，存在多个同名全局强符号时会报错。
									
									
								如何解决：
								· 将其中的某个强符号变为弱符号
									int a = 100;  ————> int a;
									int fun(){...} ————> int fun();
									
									留强去弱。
								
								· 使用static来解决
										只要将其中的某个或者两个使用static修饰，将其变为本地符号，就不会存在冲突的情况。
									int a = 100;  ————> static int a = 200;
									int fun(){...} ————> static int fun();
									
										
									旁注：全局变量和函数加static，目的是将全局符号变为本地符号。
												局部变量加static，是将局部变量的从自动局部变量（栈）变为静态局部变量（.data/.bss）。
									
									
									
							（b）例子2
									a.c                       b.c
									int a;										int a;
									
									int main(void)            
									{
										fun();
									}
									
									两个模块的a都是弱符号，统一符号时，留下其中一个即可。
									
									
									
				（3）cc1编译器处理模块内符号重名的情况								
						链接器处理模块间的全局符号的重名时，是按照强弱符号的规则来处理的。
						
						对于模块内部的符号重名问题，编译器cc1在编译时，其实也是按照强弱符号的规则来处理的。
						
						1）例子1：
							a.c 
							int a = 100;
							int a = 300;
							
							int fun()
							{
							
							}
							int fun()
							{
							
							}
							
							int main(void)
							{
								
							}
							
							编译时会报重复定义的错误（强符号只能有一个）。
									
						2）例子2：
							a.c 	
							int a;
							int a;
							
							
							int main(void)
							{
								
							}
							int a = 10;
							
							没有错误，因为不存在强符号的冲突问题，编译时会统一为一个，.symtab只会记录一个a。
							
							在经典的c讲解中，这种情况将int a解释成“int a = 100;这个定义”的声明，实际上本质关系是强弱符号关系。
							
							只不过在单个模块中，弱符号（声明）可以将强符号（定义）的作用域提前。
							
								
						3）例子3
							a.c 	
							static int a = 20;
							int a = 10;
							
							int main(void)
							{
							}
							
							大家觉得会报错吗？
							答：会报错，虽然一个是全局的，一个是本地的，但是由于都在一个模块中，因此编译时肯定报错。
							
								但是如果它们两个是在不同的模块中的的话，链接器链接时就不会报错，这个前面讲过。
								a.c 	                  b.c
																				 
								int a = 10;             static int a = 20;
								
								int main(void)
								{

								}
						
						
					
					（4）再说说声明和定义
								事实上，对于编译器、链接器来说，并不知道什么是声明、什么是定义，声明和定义只是学习C语言时
							会了表述的方便，我们自己的给的，编译器/链接器只知道强符号和弱符号，解析时是按照强弱符号的规则
							来处理的。
								
								我们以全局变量为例，你会发现其实不太好明确的区分定义和声明。
							
							1）能够区分的例子
								（a）例子1
										a.c 
										
										int a;
										
										int a = 100;
										
										...
										
										针对这种情况来说，我么认为后面有初始化的a是定义，前面那个没初始化的a是后面a的声明。
								
							（b）例子2								
									工程中有两个.c
									a.c               b.c
									
									int a;						int a = 0;
									
									...               ...
									
									前面说过，没有明写出extern，默认就是extern修饰的。
									有初始化的是定义，没有初始化的是声明。
									
								
									在以上两个例子中，都能明确的区分出定义和声明。
								
								
							2）不能区分的例子
								a.c 
								
								int a;
								int a;
								int a;
								
								....
								
								在这种情况下，到底那个是定义，那个是声明呢，不好讲了，你或许会说都是定义，都是声明，这就没有什
							么明确区分了。
								
								又比如：
								a.c
								
								int a;

								只有一个int a时，到底应该说成是定义，还是说成声明呢？
								
								
								又比如工程中有两个.c
								
								a.c               b.c
								
								int a;						int a;
															
								你告诉我那个是声明，那个是定义，也是同样的情况。
								
								所以说对于编译器/链接器来说，它不关心什么是定义、什么是声明，也没办法以定义和声明来区分，人家
							只关心强弱符号。
							
								不过以后为了表述的方便，我们还是会继续使用“定义”和“声明”这两个概念，只不过在理解了强弱符号之后，
							大家心里应该清楚本质到底是什么。
							
								以后不会再严格区分定义和声明，像int a;这种未初始化的情况，我们可能即会说成是定义，也
							可能会说成是声明，只要大家理解了强弱符号，说成什么其实都无所谓，只要方便表达和理解即可。
								
								
								
								
								
								
								
								
								
							
							
						
						
				
			
					
出品：佳嵌工作室
------------------------------------------------------------------------------------------------------------------
	“佳嵌工作室”致力于物联网、嵌入式产品以及‘物联网、嵌入式技术课程’的研发，希望所推出的技术课程，能够帮助到正在努力
学习物联网、嵌入式的同学，欢迎大家和我们一起共同学习，共同进步。
------------------------------------------------------------------------------------------------------------------
																									
			
	5.3 重定位			
			链接器在完成了符号解析之后，就可以进行重定位了。
			
			不过由于重定位的内容比较复杂，当然如果你是做编译器或者逆向的话，重定位的原理是必须要求掌握的，但是作为
		应用开发者来说这不需要，因为了解详细原理的意义不大，因此有关重定位，我们这里只介绍基本内容。
		
		
		5.3.1 重定位的种类
			重定位的种类其实有两种，
			
			（1）第一种：动态重定位
						所谓动态重定位就是，重定位的动作是在程序运行的过程中动态完成的，因此被称为动态重定位。
					有关动态重定位，在讲Uboot和内核移植时会介绍。
					
					
			（2）第二种：静态重定位
					所谓静态重定位就是，由链接阶段完成的重定位，因为是在程序运行之前做的重定位，因此被称为静态重定位。
					
					所以我们现在要讲的由链接器完成的静态重定位。
					
					
					
		5.3.2 静态重定位做什么事情
				做两件很重要的事情，
				
				· 将同名节整合为新的同名聚合节
				· 将可执行目标文件中各聚合节的地址，重定位为实际运行的地址
				
				
			（1）将同名节整合为新的同名聚合节
					其中重点是将.text和.data节聚合为新的同名聚合节，为了能够将.text和.data节聚合为新的聚合节，需要依赖一
				些信息，这些信息存储在了.rel.text和.rel.data中。
				
					.rel.text中的信息：实现.text的聚合
					.rel.data中的信息：实现.data的聚合
					
					
			（2）将可执行目标文件中各聚合节的地址，重定位为实际运行的地址
						其实就是将程序在内存中实际运行时的内存地址赋给聚合节，程序在内存中运行时，就是按照重定位的地址来
					运行的，至于重定位的地址具体是多少，要分裸机和OS两种情况来看。
					
					
					
					
					1）如果程序是直接裸机运行的话（没有OS）
							程序是直接运行在物理内存上的，所以重定位的运行地址就是物理地址，所以CPU取指时所取得的指令地址
						就是物理地址。

						
					2）如果程序是基于OS运行的话
					
							大部分的OS都有提供虚拟内存机制，所以程序是运行在OS虚拟内存上的，虚拟内存所提供的地址就是虚拟地址，
						，所以CPU取指时，所取得的指令地址就是虚拟地址。
							
							虚拟内存是基于真实的物理存储器构建出来的，所以程序最终其实还是运行在物理内存上的，因此虚拟地
						址最终还是会被转为物理地址，然后到物理内存上该物理地址所指定的位置读取指令。
						
						
						疑问：反正程序最终都是运行在物理内存上的，为什么要在真实物理存储器上弄出一个虚拟内存呢？
							有关这个原因，请大家看《计算机体系结构———操作系统》的课程，里面介绍虚拟内存时有详细介绍。		
							我们都知道现在的OS基本都支持多进程并发运行，其实多进程并发运行与虚拟内存机制有着莫大关系。
							
									
						疑问：什么是进程，与程序什么关系？
							· 进程：动态运行的程序，进程有生有死，是一个动态运行的过程
							· 程序：存放在硬盘上，没有运行的静态的可执行目标文件。
								
								
						疑问：什么是进程的并发运行？
							多个进程同时运行，这就并发运行，比如酷狗/浏览器/wps同时运行着，这几个程序就是并发运行的。

							我们这里简单认为，单个程序对应单个的进程，实际上一程序可以是多进程的，有关这一点，请大家看
						《Linux系统编程、网络编程》这门课，有详细介绍。
							
							
						为什么能够并发运行？
							实际上与虚拟内存有很大关系。因为有虚拟内存这个东西，所以每个程序运行时，虚拟内存机制会给每一个进程
						都弄一个虚拟内存，也就是说每一个进程都是运行在自己独立的虚拟内存上的。
							图：
										
										
									
							由于进程是运行在虚拟内存上的，因此“虚拟内存空间”也被称为了“进程空间”。

							进程运行在自己的虚拟内存上时，每个进程运行了一个短暂的时间片（ms）后，快速切换到其它进程上
						运行，此时cpu就会取指运行不同进程的指令。
							图：
							
							
							
							如此在宏观上，我们会感觉所有的进程都是同时运行的，这就是进程的并发运行，从介绍可以看出，进程间的
						并发运行与虚拟内存机制有着密切的关系。
									
							与并发运行相对应的还是一个概念，那就是“并行运行”，有关这两个概念的异同请看
						《Linux系统编程、网络编程》的课程。
						

							我们这里所面对的OS是Linux，Linux有虚拟内存机制，所以gcc编译得到的程序基于Linux运行时，就是运行在
						虚拟内存上的。
								
						
						
			（3）如何指定重定位运行地址
			
					实际上是通过“链接脚本文件”来指定的，“链接脚本文件”里面会说明实际的运行地址是多少，重定位时会把把实际
				的运行地址赋值给新的聚合节，如此一来，函数和全局变量就有了真正可以运行的运行地址。
					
					实际运行时，将程序拷贝到运行地址所指定的内存位置，cpu的pc存放第一条指令地址(指向第一条指令_start)，
				然后整个程序就运行起来了。
					
					
					至于重定位时，给聚合节具体指定的运行地址应该是多少，这里要分裸机和OS两种情况来定。
					
					1）裸机运行
							运行地址（物理地址）是多少，可以由程序员自己来定，比如我们一般可以指定为0，表示程序需要拷贝到物
						理内存的0地址处，从0地址处开始存放。
						
							我们将0地址写到链接脚本文件中，gcc编译时给他指定链接脚本，重定位后运行地址就从0开始。
						
							我们后面讲到arm裸机时，会介绍如何修改这个链接脚本。
						
							裸机运行时，整个计算机上就一个程序，由于没有OS虚拟内存的参与，所以裸机只能运行一个程序（单进程）。
							
							
					2）基于OS运行
							运行地址（虚拟地址）为一个固定值，不同OS这个固定值不一样，比如在Linux这边
							32位OS：从0x08048000开始
							64位OS：从0x0000000000400000开始
							
							程序运行时，程序会被拷贝到虚拟内存的0x08048000或者0x0000000000400000位置处，然后pc指向_start，程序
						就运行起来了。
						
							这个地址也是指定在链接脚本中的，gcc编译基于Linux运行的程序时，这个链接脚本不需要我们自己给，是自动
						给的，这个脚本中会指定0x08048000或者0x0000000000400000的地址。
						
							而且gcc编译每一个程序，链接重定位所指定的地址都是0x08048000或者0x0000000000400000。
							
						疑问：重定位时，如果每个程序都是相同的0x08048000或者0x0000000000400000的话，运行时不会冲突吗？
						不会冲突，因为每个进程的虚拟内存是独立的，虽然都是相同的地址，但是底层实际对应的都是不同的物理空间，
						图：
						
						
						将虚拟地址转换为物理地址后，得到的物理地址是不同的，所以不同的物理地址所指向的物理空间不同，自然不
					同物理内存空间中存放的是不同程序的指令。
			
			



			
					
出品：佳嵌工作室
----------------------------------------------------------------------------------------------------------------------------
	“佳嵌工作室”致力于物联网、嵌入式产品以及‘物联网、嵌入式技术课程’的研发，希望所推出的技术课程，能够帮助到正在努力
学习物联网、嵌入式的同学，欢迎大家和我们一起共同学习，共同进步。
----------------------------------------------------------------------------------------------------------------------------																													
			
		5.3.3 可执行目标文件的ELF格式
				图：
			
			
			
			
		（1）相比.o的ELF格式，有哪些变化？
			
				（1）.rel.text和.rel.data消失了
						为什么这两个节会消失？
							
							链接器将各.o中同名的.text和.data节整合到一起时，会对整合后的.text和.data进行重定位。
						
						其实重定位时主要针对就是.text和.data节，不过这.text和.data节重定位时需要依赖.rel.text和.rel.data中的
						信息，一旦重定位结束后，这两个节的使命就完成了，自然也就会消失。
							
							
						
				（2）多出了两个节
						
						1）init节
							（a）作用
									这个节会提供_init等函数，专门用于实现程序的一些初始化。
									
									程序入口为_start，从_start开始执行后，在正式调用main函数之前，会先调用_init等函数进行程序的
								初始化（比如建立函数栈等等）。
									
									
							（b）init节怎么来的
									回顾gcc链接的过程，
									collect2    //链接程序
																	
									-dynamic-linker  /lib64/ld-linux-x86-64.so.2 //动态链接器

									crt1.o  crti.o  crtbegin.o //启动代码

									ccyIcm4A.o  			//自己程序的.o
																	
									-lc 						//libc，常用c函数库——c标准库的子库
																	
									crtend.o  crtn.o 		//扫尾代码

									init节就是由gcc提供的crt1.o、crti.o、crtbegin.o等.o构建而来的。


						2）“段头部表”节
								重定位时，链接器根据“链接脚本文件”所给的运行地址，给.text/.data中指令和变量重定位运行地址时，
							这些“运行地址”只是链接时理论上安排的。
							
								当加载程序到内存中运行时，就需要将硬盘上所存放的程序，搬到“运行地址”所指定的内存位置，段头部表中
							的内容，就是用来辅助加载程序的。
									
						
						
				
		（2）再说说“可执行目标文件”的ELF格式
					
					“可执行目标文件”的各个节，可以进行进一步的归类。
					
					图：
					
					
					
					总结：
					1）程序最终运行时，需要搬到内存上的节有：ELF/.init/.text/.rodata/.data/.bss。
							搬到内存上什么位置呢？
							搬到重定位的“运行地址”所指定的位置。
					
					2）ELF/.init/.text/.rodata：只读的存储段（代码段）
					
					3）.data/.bss：可读可写存储段（静态数据段）
							之所以称为静态数据段，是因为.data/.bss的空间规划，是在编译时就进行了理论安排，并不是程序运行起来
						才安排的，所以被称为静态数据段。
					

				
				
				
				
				
				
出品：佳嵌工作室
-------------------------------------------------------------------------------------------------------------------
	“佳嵌工作室”致力于物联网、嵌入式产品以及‘物联网、嵌入式技术课程’的研发，希望所推出的技术课程，能够帮助到正在努力
学习物联网、嵌入式的同学，欢迎大家和我们一起共同学习，共同进步。
-------------------------------------------------------------------------------------------------------------------
																							

		5.3.4 程序的加载、运行
		
				编译得到可执行目标文件后，就可以将“可执行目标文件”加载“运行地址”所指的内存位置，然后运行了。
			不过这里还是要分两种情况来看，第一种是裸机运行的情况，第二种是基于OS虚拟内存运行的情况。
			
			
			（1）裸机的情况
						使用专门针对裸机的编译器来编译程序，最后得到的就是可以在裸机上运行的可执行程序。
						
						加载裸机程序时，由专门的加载程序（加载软件）来实现的。
						如果你无法想象裸机程序是如何加载的话，你就想一想单片机程序的加载，因为单片机其实就是裸机的情况。
						
					
					
					1）加载
								其实加载的过程就是将“代码段”和“数据段”复制到内存上
								
								裸机时，链接器重定位后的“运行地址”是真实的物理地址，加载时直接将“代码段”和“数据段”复制到物理
							内存中“运行地址”所指定的位置。
							
								裸机运行地址是多少，可以由我们程序员自己来定。
									
								图：
								
								
								
								注意：裸机时就不是ELF格式头了，而是bin格式头。
									
						
						
						
					2）运行         
						（a）CPU的PC（程序计数器）存放第一条指令_start的地址，也就是将PC指向第一条指令_start。
								pc是cpu的寄存器之一。
								
						（b）从_start开始执行启动代码。
								
						（c）启动代码调用_init等函数进行初始化。
									初始化有一件非常重要的事情就是，从内存划出一片空间出来用作堆和栈，因为空间是以堆和栈的方式来
								管理的，因此就称为堆 和 栈。
								
								
						（d）启动代码调用main函数，main函数再调用各个子函数，我们自己写的代码就开始运行了。
								
						（e）main函数调用return关键字，返回到启动代码。
								对于裸机的来说，返回到启动代码就结束了。
										
								至于return的返回值，有没有返回值，对于裸机来说都没有什么影响。
								就算有返回值，将返回值返回给启动代码后，这个返回值对启动代码来说也没有什么意义。
								
								所以说，对于裸机来说，其实main函数的返回值没有什么意义，所以大家在学习单片机时候，以前的main
							函数的返回值都是void的。
								void main(void)
								{
									return;
								}
							
								不过现在都规范化了，单片机等裸机里面，也要求main函数的返回值类型为int型。
								int main(void)
								{
									return 0;
								}
								
								尽管在这里要求返回int型的返回值，但是我们自己应该清楚，在裸机下，main函数的返回值并没有
							什么大的意义。

									
									
					3）栈、堆
						前面说过，程序运行起来后，初始化代码会从内存中划出一片空间，用来作为程序运行所需要的栈和堆。
							
								图：
								
								
								
								
						（a）栈（stack）
									栈的意思是，表示内存空间以栈这种数据结构来进行管理，所谓管理就是管理空间的开辟和释放。
								学过栈这种数据结构的同学都知道，栈的特点是，只能在栈顶进行操作，不能够在栈的中间和栈底操作。
										
								· 栈是向下生长的
										所谓向下生长就是，栈底在最高地址处，当栈中没有任何空间被使用时，栈顶指针就指向栈底，
									每当栈顶被占用一个字节的空间，栈顶指针就向低地址方向移动一个字节。
										图：
										
										
										从高地址向低地址方向移动，就是向下生长，栈顶指针所指的那个字节是没被用的。
										栈顶和栈底之间的栈空间，就是被占用的空间。
	
	
										反过来，栈顶指针向高地址后退一个字节，就表示释放一个字节的空间。
										释放的意思就是将空间交出去，让别人可以使用。
										图：
										
										
										
										
										怎么理解栈顶指针？
										就是某个寄存器或则指针变量，专门用于存放栈顶字节的地址。
										
									
									
								· 栈的作用
								
										函数自动局部变量、形参等就开辟于栈。
										int fun(int a)
										{
											int b;
											...
										}
										
											不过这里有一点需要强调下，对于ARM来说，由于arm cpu内部寄存器比较多，所以如果形参在4个以内的，
										实际上形参是在寄存器中，而并不在栈中。
											如果超过4个的话，第4个往后的形参才会存在栈中。
											
											不过在intel的CPU上又不一样，因为Intel cpu的寄存器比较紧俏，所以形参基本都是存在栈中的。
										
											我们这里为了讲课的方便，我们一律认为形参都是在栈中的。
	
										从栈中开辟和释放自动局部变量、形参空间的过程，由函数被调用时，在运行的过程中自动完成的，
									无需程序员关心，开辟空间和释放空间的本质，其实就是栈顶指针移动的过程。

										
										
						（b）堆（heap）
									堆空间和栈空间的管理方式是有区别的。
									
								· 栈的话只能在栈顶才能进行操作，但是堆不是，堆的话可以在中间任何位置操作。
								· 堆的空间是向上生长的，也就是说在堆中开辟空间时与栈相反，是从低地址往高地址方向延伸的。
									图：
									
									
								· 栈的空间是自动开辟和释放的，但是堆的空间不是的，堆只能手动开辟和释放。
									
									- 从堆里面开辟空间
											程序需要调用malloc函数来手动开辟。
											
											所谓手动开辟，就是程序员需要在程序中亲自调用某个函数来实现，至于说在堆中什么位置开辟空间，
										这个由malloc函数的算法来决定。
													
									- 释放在堆中开辟的空间：在程序中调用free函数，手动释放
										释放的意思，也是将空间让出来，让别人可以使用。
								
		
		
			
			
出品：佳嵌工作室
-------------------------------------------------------------------------------------------------------------------
	“佳嵌工作室”致力于物联网、嵌入式产品以及‘物联网、嵌入式技术课程’的研发，希望所推出的技术课程，能够帮助到正在努力
学习物联网、嵌入式的同学，欢迎大家和我们一起共同学习，共同进步。
-------------------------------------------------------------------------------------------------------------------																																				
			
		（2）基于OS虚拟内存的情况
					
					基于OS运行程序时，常见有两种方式，
					· 在图形界面，双击快捷图标实现
					· 在命令行，执行./a.out命令实现
						
						我们前面说过，说每一个进程都是运行在自己的独立虚拟内存中的，命令行和图形界面本身也是一个
					程序（进程），所以也是运行在自己独立的虚拟内存上的。
					
				
				1）程序的加载
						当我们双击程序，或者执行./a.out命令时，就开始了程序的加载操作，具体步骤如下：
					
					
					（a）首先从父进程复制出一个子进程
					
								图形界面、命令行程序就是父进程，执行程序时会从父进程复制出子进程，复制的目的其实就是从父进程的
							“虚拟内存”复制出一个子进程的“虚拟内存”，准确讲应该是复制出“虚拟内存”的相关数据结构，用于建立子进
							程的虚拟内存。
								
								有了子进程的虚拟内存，就可以将新的程序加载到虚拟内存中了。
								
								图：
								
								
								
								
								虚拟内存空间被分为了两部分，一部分是内核空间，另一个部分是应用空间，应用程序的应该加载到应
							用空间。
							
	
								在Linux下复制子进程时需要调用Linux OS所提供的fork函数，该函数在《Linux系统编程、网络编程》
							中有详细介绍。fork是由父进程调用的。
							
								至于虚拟内存与真实物理内存之间的对应关系，这个事情就留给“虚拟内存机制”来操心。
							
							
					（b）调用加载器，将自己程序（新程序）的“代码段”和“数据段”加载到子进程虚拟内存的应用空间中
							
								基于Linux运行的话，gcc链接时重定位的运行地址是从0x08048000或者0x0000000000400000开始的，所以程序会
							被加载到虚拟内存中0x08048000或者0x0000000000400000地址往后的空间中。
								
								至于虚拟内存0~0x08048000或者0~0x0000000000400000之间的虚拟空间，则未被使用。
							
								图：
								
								
								
									
								基于Linux OS运行时，加载器是由Linux OS提供的，任何一个程序都可以通过execve这个系统API来调用
							加载器，为了方便称呼，我们就直接将“execve函数”称为加载器。
								
								
								有关调用fork函数创建子进程，然后调用execve函数加载新程序到子进程的过程，在
							《Linux系统编程、网络编程》第8章—进程控制有详细的介绍，大家把这章学完之后，你就知道在有OS时，
							新程序是如何基于OS运行起来的。

	
				
				2）运行
					（a）cpu的pc指向_start（将第一条指令——start所在位置的虚拟地址存放到pc）
					
					（b）从_start开始执行启动代码。
					
					（c）启动代码调用_init等函数进行初始化。
							其中很重要的就是弄出堆和栈这两个东西，这一点与前面裸机的情况时类似的，这里不再赘述。
							
							不过与裸机不同的是，在栈和堆之间，还有一个“共享映射区”。
							图：
							
							
					（d）启动代码调用main函数，main函数再调用子函数，我们自己写的代码就开始运行了。
						
					（e）main函数调用return关键字，返回到启动代码。
					
								有OS时，main函数将返回值return给启动代码后，启动代码会调用exit函数，接着将返回值返回给OS。
								在裸机情况下，启动代码不存在调用exit函数这一说，只有基于OS时才存在这种情况。
								
								
								疑问：将返回值返回给OS有什么用？
									在《Linux系统编程、网络编程》第7章—进程控制有详细介绍，我们这里只是C语言相关的课程，所以这个知
								识点不属于本门课的课程范围，请看《Linux系统编程、网络编程》。

									我们这里虽然讲的只是c的情况，实际上c++等其它语言的程序也是类似的。

							

							
			
			3）加载执行新程序后——子进程从父进程复制而来的堆/栈去哪里了
			
			（a）谁代表了堆和栈的存在
					堆栈指针代表了“堆和栈”的存在，堆栈指针存储在了寄存器或者静态区。
					
					堆栈指针在，堆栈就在，堆栈指针没有了，堆栈就没有了。
						
				
			（b）向子进程中加载新程序后会怎么样
						
						加载新程序之前，子进程中的所有内容（包括堆和栈），都是从父进程复制（继承）而来，子进程的.text、
					.data、...、堆栈与父进程的一模一样。
						
						加载新程序后，子进程原来的.text、.rodata等都被覆盖了，那么子进程原来的堆栈指针也就无效了，无效的意
					思就是原来的堆栈被释放了，释放的意思就是让出来，别人可以去操作了，只是以前的堆栈被使用时，里面的数值
					还遗留在了空间中。
						图：
						
						
					
						当exec加载新程序后，新程序的.text、.rodata、.data等会覆盖子进程原有的.text、.rodata、.data、.bss，
					然后开始执行新程序。
						
						执行新程序时一定是从.text中的“启动代码”开始执行的，当执行启动代码中设置堆栈的代码时，会重新设置新
					程序自己的堆栈指针，此时所代表的就是新程序自己的堆栈，只不过堆栈空间还是以前那个堆栈空间。
						
						这就好比上家公司搬走了，重新使用办公地点时，会从新布置办公空间的道理是一样的，只是重新布置，但是空间
					还是原来那个空间。
						
						
						
			（c）重新设置堆栈时，堆栈空间会被清零吗？
			
						子进程以前的堆栈被释放时，空间是没有清零的，设置新堆栈时清不清零，这个要看设置堆栈的代码是怎
					么做的，它可以清零，也可以不清零，实际上都是没有清零。
					
						不清零也没关系，只要我们开辟变量空间时，记得初始化一个新的值，将以前的值给它覆盖掉就行。
						就好搬进上家公司的地方时先不腾空空间，等用到哪些空间时，再搬新东西进去覆盖它即可。
						
						
						正是由于新程序重新设置堆栈时不会清零，所以当新程序最开始运行时，
						· 如果函数的“自动局部变量”没有赋初始值的话，就会是一个随机值，这个随机值就是子进程以前的栈所遗留的。
						· malloc从堆中开辟变量空间时，如果没有初始化值的话，也是子进程以前的堆所遗留的值。
							
							
						疑问：为什么以前遗留的值会被称为随机值？
						答：因为对于我们来说，并不知道里面到底遗留的是什么值，所以它可能是任何值，因此就是随机的，自然就被
						称为了随机值。
							就跟买彩票一样，号摇出来后肯定一个确定的数，但是对于不知道号是多少的我们来说，它可能是任何数，
						所以对于不知道号是多少的我们来说，它是一个随机值。
							
						
						新程序自己在释放“堆栈”中的变量空间时，实际上也不会清零，
						
						· 比如某函数运行结束，自动局部变量释放了，但是数据还遗留在了里面。
						· 比如free释放了malloc所开辟的空间，同样的，以前所使用数据也遗留在了里面。
						
							所以当新程序运行一段时间后，堆栈中的随机值已经不再是以前堆栈所遗留的数据了，而是自己所遗留的数据。
						
						
						因此，我们从堆栈中开辟变量空间时，如果不初始化的话，里面就是一个随机值，总结起来，随机来自于两个地方。
					· 新程序重新设置堆栈时没有清零，遗留了子进程的以前堆栈的数据
					· 新程序在运行的过程中，在释放堆栈中的变量空间时，也不会清零，也会导致随机值
						
						正是由于以上原因，在堆栈中开辟变量空间时，我们总是建议大家一定要初始化，否者这些随机值可能会带来
					一些麻烦，比如程序进行计算时不小心使用了随机值，从而导致程序计算结果不对，如果程序非常重要的话，这种错
					误的结果往往会带来很严重的大麻烦，不过好在于，一般性的程序都还无所谓。
					
						疑问：初始化时，我不知道初始化为什么值，怎么办呢？
						答：不知道初始化为多少，那就初始化为0（自己清零），比如。
						
						栈：
						int fun(void)
						{
							int a = 0;
							...
						}
						
						堆：
						int *p = malloc(4);
						bzero(p); //调用bzero将空间清零，或则使用memset也行，memset(p, 0, 4);
						
						
						memset与bzero的不同之处在于，bzero只能将内容设置为0，但是memset还可以设置为其它值，比如
						memset(p, 1, 4);，将4个字节全部设置1，bzero其实就是memset的特例。
						
						
			（d）请区分“释放 与 清零”，这是两回事
			
						很多同学总以为释放就是清零，清零就是释放，其实释放是释放，清零是清零，并不不是一回事，千万不要混淆，
					这就好比上厕所，上完厕所把厕所让出来是释放，走时把大便冲干净就是清零，对于不讲究的人来说，完全可以只
					释放厕所但是不清零，估计大家都挺讨厌这种人的。
					
						子进程以前的堆栈空间被释放时，其实只是把空间让出来，好让新程序重新设置自己的堆栈，但是空间并没
					有清零，以前的数据还遗留在了里面，而启动代码重新设置自己的堆栈时，往往也也不会清，所以还一直遗留着。
					不过，只要程序员在开辟变量空间时，记得初始化新值覆盖它，其实也没什么大不了的，总不至于会像不冲大便那样，
					让人讨厌。
						
					
						
						
						
					
					
				
						

									
出品：佳嵌工作室
----------------------------------------------------------------------------------------------------------------------------
	“佳嵌工作室”致力于物联网、嵌入式产品以及‘物联网、嵌入式技术课程’的研发，希望所推出的技术课程，能够帮助到正在努力
学习物联网、嵌入式的同学，欢迎大家和我们一起共同学习，共同进步。
----------------------------------------------------------------------------------------------------------------------------																																						
	
		（3）对比裸机运行和基于os虚拟内存运行时，程序的内存结构（内存布局）
					
				1）什么是程序的内存布局？
						就是程序存储在内存中运行时，程序所占用的存储空间的结构，也可以被称为“存储映像”。
						
						通过对比发现，其实裸机和基于OS虚拟内存运行时的程序布局几乎差不多，二者的共同之处就是，
					最基本的组成都是 = 代码段 + 静态数据段 + 堆 + 栈。
						
						图：
						
						但是从图中可以看出，它们还是有区别的。
						
						
				2）二者的区别
				
					（a）运行地址不同，一个是物理地址，另一个是虚拟地址
				
					（b）相比裸机的情况，基于OS虚拟内存运行时，进程的虚拟内存空间分为了“应用空间”和“内核空间”
					
							· 应用空间：运行应用程序的代码
									虚拟内存中的“应用空间”，底层对应的是“应用程序代码”真实所在的物理存储器空间，这种对应关系被
								称为“映射”。
								
								图：
								
									
									
							· 内核空间：运行内核代码
						
								虚拟内存中的“内核空间”，底层对应的是“OS代码”真实所在的物理存储器空间。										
								
								图：
									
								
									不管应用程序有多少个，运行的OS只有一个，所以所有进程虚拟内存中的“内核空间”，映射（对应）的
								是同一个OS。
								
								
								程序基于虚拟内存运行时，cpu取指所得到的指令地址都是虚拟地址，
								
								- 如果运行的指令是“应用程序”的指令的话
									虚拟地址被转为物理地址，通过物理地址找到“应用程序指令”真实所在的物理空间，取出指令给cpu执行。
									图：
									
									
								- 如果调用了OS的API，就会进入内核空间，cpu取指时所得到的指令地址为“内核空间”的虚拟地址
									内核空间的虚拟地址被转成物理地址后，找到的是OS所在的真实物理空间，取出的指令自然就是OS的指令。
				
									图：
											
												
									如此一来，应用层序就能调用OS的系统函数了。

										
					
				3）基于OS虚拟内存运行时，在栈与堆之间还有一个共享映射区
				
						有关共享操作这个东西，只能在有OS虚拟内存支持的情况下才存在，裸机的话不可能实现的。
				
				
				
					· 映射同一个共享库（动态库），多进程共享使用同一个共享库
						图：
								
								
								
					· 映射相同的物理内存，通过共享内存，实现进程间通信
						图：
								
								
								
						《Linux系统编程、网络编程》的第8章——本机进程间通信中，有详细讲这个东西
								
								
					· 映射相同的文件
						共享操作同一个文件。
						
						图：
								
								
						有关映射共享文件，我们在《Linux系统编程、网络编程》课程的第9章———高级IO有详细介绍。

								
								
				

				
									
						
	


									
出品：佳嵌工作室
----------------------------------------------------------------------------------------------------------------------------
	“佳嵌工作室”致力于物联网、嵌入式产品以及‘物联网、嵌入式技术课程’的研发，希望所推出的技术课程，能够帮助到正在努力
学习物联网、嵌入式的同学，欢迎大家和我们一起共同学习，共同进步。
----------------------------------------------------------------------------------------------------------------------------																																						

				
6. 再说说程序的内存结构
		程序的内存结构，也叫内存布局，也叫存储映像。
		
	6.1 什么是内存结构？
			前面已经介绍过，其实就是程序运行时在内存中存储结构。
				
			不管是裸机还是基于OS虚拟内存运行的情况，内存布局基本都差不多，所以我们这里只介绍程序基于OS虚拟内存运行时的
		内存布局，这个内存布局很重要，希望大家理解并记住它，至于说为什么重要，后面的课程会体现出来。
			
			图：

			
		
		
	6.2 指令 与 数据的存放
			程序在内存中存储时，就存储两个东西，一是指令，二是数据。
			
				
		6.2.1 指令
			指令存储在代码段中的.init和.text节中。
			
			.init节：放启动代码相关的指令
			.text节：主要放我们自己所写程序的指令
			
					
		6.2.2 数据
			（1）数据的存储形态
						有两种存储形态，
					
					1）第一种：量空数据存储在常间中
							数据存储在常量空间中时，由于常量空间只能读不能写，因此常量保存的数据将一直不变。
						
					2）第二种：数据存储在变量空间中
							由于变量空间的读写权限为可读/可写，所以数据存在变量中时，是可以被新的数据改写的。
				
			（2）常量
					常量空间要求是只读的，在程序的内存布局中，只有代码段是只读的，因此常量空间肯定只能在代码段中。
					在代码段中有两个地方可以用于开辟常量空间，一个是在.text中，另一个是在.rodata中。

					1）在.text中的情况
							此时，直接作为指令的一部分，放在了.text中。
							
							比如：a = a + 100;
							编译后100直接作为指令的一部分存储在了.text中，由于.text只能读不能写，因此数据100就保存在了常量中。
							
							
					2）在.rodata中的情况
						比如：
							int a = 100;
							printf("a = %d", a);
						
							char *p = "hello world";
							
							字符串"a = %d"/"hello world"被保存在了.rodata中，由于.rodata是只读的，因此"a = %d"/"hello world的存储
						空间是一个常量，在一般情况下为了好称呼，我们直接将"a = %d"/"hello world”称为常量。

						 有关char *p = "hello world"这种情况，我们后面讲字符串时，还会详细的介绍到。
						
						
						疑问：为什么不将这些字符串和指令一起直接保存在.text中
							太长了，无法作为指令的一部分存储在.text中。
							
						
			（2）变量
						变量空间只能开辟于在数据段，因为只有数据段是可读可写的。
						
						变量分为两种，一种是静态变量，另一种是动态变量。
						
						· 静态变量：空间开辟于静态数据段（.data/.bss）
							图：
							
						
						· 动态变量：空间开辟于动态数据段（堆/栈）
							图：
						

					
					1） 静态变量
							分两种情况，一个是在.data中，另一个是在.bss
							· .data：初始化了的静态变量
							· .bss：未初始化的静态变量
							
						（a）.data
									其实.data中的内容在编译时就决定好了，加载程序时，只需要将“可执行目标文件”的.data的内容，拷贝到
								内存即可。
									
									初始化了的静态变量分两种：初始化了的全局变量 和 初始化了的静态局部变量，它们都在.data中。
									
									
								+ 初始化了的全局变量
									int a = 100;
									int main(void)
									{
										...
									}
									
								+ 初始化了的静态局部变量
									int main(void)
									{
										static int a = 100;//main函数的初始化了的静态局部变量
										...
									}
							
							
						（b） .bss
								同样两种情况：
								
								+ 未初始化的全局变量
									int a;
									int main(void)
									{
										...
									}
									
								+ 未初始化的静态局部变量
									int main(void)
									{
										static int a;
										...
									}
							
								在“可执行目标文件”中，.bss并不存在，程序加载后才会开辟.bss的空间，然后再在.bss里面开辟未初始化
							静态变量的空间，并自动初始化为0。
							
								这就是以前常说的，未初始化的全局变量和静态局部变量，会被自动初始化为0。
							
							
							
							
							
						
					2） 动态变量
						之所称为动态的，是因为变量空间并不是在编译时决定的，而是在程序运行时才有的。
						
						动态变量分两种，一种是自动局部变量，另一种是手动开辟的变量。
						
						· 自动局部变量：空间开辟在栈中
						· 手动开辟的变量：空间开辟在堆中
						
						（a）自动局部变量（开辟于栈中）
								没有加static修饰的函数局部变量都是自动局部变量，我们这里将形参也归到自动局部变量里面。
						
								为什么称为自动局部变量？
								变量空间是函数运行时自动开辟，运行结束时自动释放的，所以把它称为“自动”的。
								正是由于是自动开辟和释放的，因此栈也被称为自动存储区。
							
								int fun(int a)//a形参
								{
									int b = 100;//没有加static修饰的局部变量
									int c;
									
									return a+b+c;
								}
								
								a、b、c都是开辟于栈中。
								
							
								疑问：编译得到可执行目标文件后，函数中的自动局部变量是一个什么样存在？
									
									fun函数被编译后，自动局部变量的定义会变为操作栈的指令（压栈指令push、弹栈指令pop），
									演示：
									
									
								· 压栈
										函数运行时会调用压栈指令，会将“栈顶指针”向低地址方向移动需要的字节数，挪出来的这个空间就是
									自动局部变量的空间。
										
										图：
										
										- 如果有初始化的话，就将初始化值写到空间中。
										- 如果没有初始化的话，空间中的内容就是别人之前使用后遗留的内容。
											这就是我们以前常说的，如果函数的自动局部变量不初始化的话，就是一个随机值。
											
											
											旁注：有关局部变量随机值问题。
												随机值其实是一个隐患，因为如果程序在运算时使用了不确定的随机值的话，会给程序的功能带来不
											确定的影响。
											
												比如程序控制的是机械设备的话，这种随机值是非常要不得的，如果程序进行控制运算时使用了
											随机值，设备的机械运动可能会出现无法预测的结果，这是非常危险的。
											
												因此我们要求必须给自动局部变量赋一个明确的值，特别是指针变量更是如此，如果你不知道赋什
											么值，那最起码要赋一个NULL空指针，以防止出现因随机值所导致的野指针。
												
												
											
								· 弹栈
										调用函数中的弹栈指令时，栈顶指针会向高地址方向回退相应的字节数，这样就把变量的空间给释放
									出来了，释放时并不会对空间清0，因此这一次使用的值，就变成了下一次别人使用这个空间时的随机值。
										
										图：

										
										
										
						（b）手动开辟的变量（开辟于堆中）
									栈中空间是自动开辟和释放的，但是堆空间不是的，对于堆来说，需要程序员自己在程序手动的调
								malloc函数，按需从堆中分配空间，当不再需要该空间时，就调用free函数来释放。
		
									因为堆空间是手动开辟和释放的，因此在堆也被称为手动存储区。
								
								· malloc、free的使用举例
																		
									int main(void)
									{
										int *p = NULL;
										
										p = malloc(4); //在堆中开辟4字节的空间，然后将首字节地址给p，以便访问空间
										if(p == NULL) 
										{
											printf("malloc fail\n");
											
											exit(-1);//开辟空间失败就结束进程
										}
										bzero(p, 4); //将开辟的空间清零
										
										*p = 100; //使用开辟的空间
										
										free(p);//删除p所指向的4字节空间
									}
									
									
										堆空间也存在和栈一样的随机值问题，所以我们从堆中开辟出空间后，必须主动清零，否者会影响写入
									的数据。
										
										比如程序中调用bzero(p, 4)的目的，就是将p所指向的4个字节空间清0。
								

								
								· 疑问：如果没有调用free来释放开辟的堆空间的话，程序运行结束后，堆空间会释放吗？
										当然，程序结束后，不仅堆空间，所占用所有的空间都会释放。
										
		
								· 疑问：既然程序终止时会释放所有堆空间，那为什么还需要调用free函数来释放呢？
										
										因为真实的程序，很多一旦运行起来后会长时间运行，甚至有些可能会永久运行，如果程序在运行的
									过程中每次malloc后都不free的话，程序的堆空间会越用越少，严重的话堆和栈的空间会顶到一起，相互
									篡改数据，最后导致程序死机，对于很多重要程序来说是绝不能死机的，因为死机所带来的经济损失可能
									是非常巨大的。
									
										其实正常情况下，栈和堆之间的空间距离非常大，如果正常操作（开辟后及时释放）的话，它们之间
									是不可能会碰到一起的，但是如果堆空降只开辟不释放的话，这种情况就有可能发生。
									
										为了保证堆空间不会越用越少，及时调用free是必不可少的。
										
										
								· 如何理解空间被占用
								
										空间被占用从而导致可用空间不足的情况，与现实生活中仓库很像。
										
										就好比你们家仓库是挺大的，但是就是每次放完东西后从来不清理，垃圾越来越多，最后导致仓库的空
									间全被垃圾占用，此时虽然仓库还是那个仓库，但是可用空间确是越来越少，严重时根本没有空间可用。
										

																		
							
				6.2.2 有关堆变量和栈变量，再提两句
					（1）栈变量
							从栈中开辟变量时，为了避免随机值带来的问题，一定要初始化
							
							1）基于OS虚拟内存运行时，随机值来源有两个
								（a）最开始时来自于子进程以前栈的遗留
								（b）新程序运行一段段时间后，随机值来自于自己使用后的的遗留
							
							2）裸机运行时
									没有OS虚拟内存，不存在父进程一说，上电运行时内存默认就是清零的，所以随机值来自于自己
								使用后的遗留。
						
					（2）堆变量
							1）基于OS虚拟内存运行时，随机值来源有两个
								（a）最开始时来自于子进程以前堆的遗留
								（b）来自于自己使用后的遗留
							
							2）裸机运行时
								没有OS虚拟内存时，不存在父进程一说，所以随机值也是来自于自己使用后的遗留
								
							
							3）malloc和free函数对堆内存的管理
							
								（a）malloc从堆中开辟的变量空间往往大于实际想要的空间
								
											malloc为了能够更好的管理堆内存，开辟空间时，并不是你想开辟多少，就刚好开辟多少，而是会做
										圆整处理，比如我想申请212字节，最终malloc实际开辟时会“圆整”为256。
											
											这就好比你去开房，为了好管理房间，人家肯定是一间一间来管理的，你去跟前台说我开半间房，前台
										肯定会给“圆整”为整间房，凡是大块的内存管理都是这样的，都是按“块”来管理的，目的是为了提高管
										理效率。
											
											疑问：圆整规则是怎样的?
											这是malloc内部的算法机理，这个我们无需关心。

								
								（b）如果忘了free，实际上导致的堆内存泄漏，要大于明面上所开辟的空间
										这个道理很简单，我想开辟212字节，但是malloc实际上开辟了256字节，所以如果忘了free，实际泄露
									的堆内存空间为256，大于明面上的212字节。
										
										
										有关malloc、free是如何管理堆内存的，这个属于malloc和free这两个函数的内部算法，我们作为
									应用程序开发者，其实无需关心，既然讲到这里了，我们就多说两句，作为了解即可。
								
			
				
				
				
				
				
		
		
		
			
	



		4）C可执行文件运行起来后，C内存结构布局
			（a）裸机与有OS时内存结构体的异同
			（b）c内存结构详解					
					代码段
					静态数据段
					常量数据段
					堆
					栈
					
					数据和代码是如何存放在这些段的。
					到底什么是常量，什么是变量。	
			
			
				
											
								

（2）预处理到底做了些什么
		预处理就做一下几件事
			处理宏定义，处理条件编译，文件包含，处理“特殊预处理关键字”，所以会详细介绍
		
		1）宏定义
				重点：使用宏定义构建复杂表达式
			
				很多同学在看复杂C语言程序时，其中有一个难关宏定义复杂表达式，在高级c语言程序中，大量存在各种
			宏定义实现的复杂表达式，我们举例讲解一些Linux内核中的复杂宏定义，让大家熟悉宏的复杂用法。
			
		2）条件编译
				条件编译也是各位同学无法阅读高级C程序的难点之一，复杂的C程序为了应对不同的软件和硬件平台，
			.c、.h文件中往往会写针对各种不同平台的代码，这些代码通过条件编译进行选择，如果你看不懂这些
			条件编译，这对阅读和实现复杂C代码来说是一个很大的难关。
				
				所以我们会详细介绍：
			
			条件编译的作用是什么？
			条件编译都有哪些
			每种中条件编译都是怎么用
			为了更好的理解条件编译，我们会为大家展示Linux内核源码的条件编译，加深理解。
			
		3）文件包含
			1）只能包含头文件吗？能包含C文件吗，为什么平时很少直接包含C文件？
			2）头文件中如下条件编译时是怎么回事
				#ifndef? MAX_H_??
				#define? MAX_H_??
				⋯⋯..
				#endif?
				
			3）我们.c文件中常用的哪些头文件都从哪里来的
			4）使用“”包含头文件时，只能包含当前路径的.h文件吗
				
				
		4）其它的一些预处理关键字
		
		
（4）存储类、作用域、生命周期、连接属性
		
		比如以连接为例，我们介绍连接时，会详细介绍连接到底做了什么事，连接时，
		extern这种关键字声明函数和变量时到底作用是什么


（5）指针、函数
		指针本身很简单，很多同学一直觉得指针很难，其实难得不是指针本身的概念，而是当数组、函数、字符串等
		等使用指针时，涉及到的形态很复杂，因此很多同学不理解，所以大家指针没学好，其实不是指针本身概念的
		理解有问题，其实是大话对数组、函数、字符串等着这些与知真相相关的一些东西还没有学号，所以你才会觉
		得难。
		
		
		变量名与地址
		一级指针与多级指针
		野指针与段错误
		const关键字与指针	
		指针的强制类型转换
		
		函数地址的意义
		指针与函数传参
		函数指针（函数指针数组）、指针函数
		函数调用时，是如何使用栈的（IDE）参数保存，arm4个参数以内寄存器保存，看arm汇编
		递归、内联函数
				
				
		变量定义和强制转换意义。
		
		
		
（6）C库
		
		
		库怎么来的，库可以是源码的吗
		库为什么需要头文件
		
		如何实现自己的动态库和静态库
		
		库的加载方式（以前的库是没有头文件）
		函数原型检测。
		
		
		动态链接库的二种加载方式，显示加载和隐式加载具体是怎么回事儿及优缺点
		
		
		C库、posix、BSD、关系
		
		
		
（7）数组与字符串
		多级指针构建多维数组
		


（8）结构体、联合体、枚举	
	
		变量定义和强制转换意义。
		
		结构体的对齐
		
		
		结构体强制转换，空间丢失和溢出，举struct sockaddr_例子

		
（9）c语言中值得被关注的细节问题
		1）数据溢出问题
		
		2）大小端序
		
		3）逗号表达式
		
		4）void
				变量定义和强制转换意义。
				
		
		NULL、\0 null，0
		
		5）如何理解C语言转移字符
		
		6）typedef的作用
			
			
			typedef构建的复杂表达式
			
		
		7）mian函数是谁调用的，main函数的参数到底有什么用
		
		8）++


						
（2）C语言的位操作
		& | ~ ^等等
		
		其实在C的应用层开发中，位操虽然也有用，但是用的并不频繁，但是位操作在驱动（裸机驱动、OS驱动）中会被
	大量使用，驱动开发的核心是就是进行寄存器的设置，而进行寄存器设置的核心就是进行微操作，必须掌握位操作。
		
		
		
（6）c面向应用时，其他相关知识

	图形界面与命令行之间的关系、多线程、网络、数据库

	
（7）数据结构

				
		内核链表
	
	
		
	




















	
（1）C语言的编译过程与内存结构
		1）对比使用IDE开发方式 与 直接源文件开发方式	
		2）C语言编译过程介绍
		3）c可执行文件格式	
		4）C可执行文件运行起来后，C内存结构布局
				C内存布局，其实可以简答认为就是进程空间的布局，虽然裸机不存在进程这一说，但是我们可以认为裸机
			是单进程的。
		
			（a）裸机与有OS时内存结构体的异同
			
			
			（b）c内存结构详解
					1、朱老师视频里讲解，内存中的程序分为三段.text段、.data段、.bss段，那么.rodata段是用
						来存放常量的，它属于.text段、.data段、.bss段中哪一个段？还是是独立的一个段？
					
					2、Printf(“%d”,3);  3是放在哪个段的？
					
					3、Printf(“%s”,“Linux”);  Linux是放在哪个段的？
			
					代码与数据都放在什么内存的什么位置。
					
					代码段
					静态数据段
					常量数据段
					堆
					栈
					
					
（2）C语言的位操作
		& | ~ ⋯⋯等
		
		
（3）预处理到底做了些什么时
		1）宏定义
			重点：使用宏定义构建复杂表达式
			
		2）条件编译
			复杂的.c文件以及.h文件包含会包含各式各样的条件编译，很多同学阅读复杂c程序，有一个最大的难点
			就是看不懂这些条件编译，所以我们会重点介绍这些条件编译，比如
			那么
			条件编译的作用是什么？
			条件编译都有哪些，各自都有什么具体用处
			
		3）文件包含
			1）只能包含头文件吗？能包含C文件吗，为什么平时很少直接包含C文件？
			2）头文件中如下条件编译时是怎么回事
				#ifndef? MAX_H_??
				#define? MAX_H_??
				⋯⋯..
				#endif?
				
			3）所包含的头文件都放在了哪里
			4）使用“”包含头文件时，只能包含当前路径的.h文件吗
				
				
		4）其它的一些预处理关键字
		
		
（4）存储类、作用域、生命周期、连接属性
			函数声明，做原型检查。

		连接时是怎么找到其它文件中的函数的
		
		
		结构体强制转换，空间丢失和溢出，举struct sockaddr_例子

		
（5）指针

		变量定义和强制转换意义。
		
		
		
（6）函数与库
		
		函数地址的意义
		函数调用时，是如何使用栈的（IDE）参数保存，arm4个参数以内寄存器保存，看arm汇编
		
		递归、内联函数、与宏之间的关系
		
		毁掉函数
		
		
		库怎么来的，库可以是源码的吗
		库为什么需要头文件
		
		如何实现自己的动态库和静态库
		
		库的加载方式（以前的库是没有头文件）
		函数原型检测。
		
		
		动态链接库的二种加载方式，显示加载和隐式加载具体是怎么回事儿及优缺点
		
		
		C库、posix、BSD、关系
		
		
		
（7）数组与字符串
		多级指针构建多维数组
		


（8）结构体、联合体、枚举	
	
		变量定义和强制转换意义。
		
		
		
		
（9）c语言中值得被关注的细节问题
		1）数据溢出问题
		
		2）大小端序
		
		3）逗号表达式
		
		4）void
				变量定义和强制转换意义。
				
		
		NULL、\0 null，0
		
		5）如何理解C语言转移字符
		
		6）typedef的作用
			
			
			typedef构建的复杂表达式
			
		
		7）main函数是谁调用的，main函数的参数到底有什么用
		
		8）字、半字等概念

		9）程序的优化
		
		10）程序的调试
		
（6）c面向应用时，其它相关知识

	图形界面与命令行之间的关系、多线程、网络、数据库

	
（7）数据结构

				
		内核链表
	
	
		
	
	
		
	