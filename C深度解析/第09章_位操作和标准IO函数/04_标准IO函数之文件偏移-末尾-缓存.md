# 文件偏移-末尾-缓存

## 2.9 调整“文件读写指针”的函数

调整“文件读写指针”，也可以称为调整“文件读写位置”。

涉及的函数：fseek、ftell、rewind。

这里的说法不够准确，实际上只有fseek、rewind会调整文件读写指针，至于ftell的作用，后面再介绍。

### 2.9.1 文件读写指针

#### （1）注意，这里说的是“文件读写指针”，不是“文件指针（FILE *）”，大家千万不要搞混淆了。

#### （2）简单来说，“文件读写指针”就是读写的“笔尖”，指向了文件中当前访问的位置（字节）。

#### （3）准确的说说“文件读写指针”到底是个啥

我们这里说的文件是“普通文件”，“普通文件”都存放在了硬盘上，普通文件的大小就是文件在硬盘上所占据存储空间的大小（这句话并不完全准确，目前先这么理解）。

硬盘也是一个存储器，也是以字节为单位来组成的，每个字节都有自己的地址。

```shell
整个文件的大小 =  文件最后一个字节的地址 - 文件首字节地址
```

“文件读写指针”会记录当前读写的位置在文件中哪一个字节上，那如何记录：

```shell
文件读写指针 = 当前访问字节的地址 - 文件第一个字节地址
```

“文件读写指针”记录的是当前读写字节与第一个字节的偏移（地址差）。

当访问文件中某个字节时，只要得到该字节的地址即可访问，该字节的绝对地址 = 文件读写指针（偏移） + 文件首字节地址。

大家要区分“文件读写指针”与我们常说的指针，“文件读写指针”只是一个地址差，通过它可以换算出文件中某字节的绝对地址。

我们常说的“指针”是一个绝对地址，而且是内存空间的地址

#### （4）刚开始打开文件时，“文件读写指针”是多少

+ 1）以r/r+/w/w+方式打开文件时  
  “文件读写指针”==0，也就说指向了文件的最开始位置，也就是指向了文件的第一个字节。从文件的第一个字节开始进行读写操作。

+ 2）以a/a+追加方式打开时
  “文件读写指针”也==0
  在没有任何写操作之前去读的话，就是从第一个字节开始读数据的。
  但是当进行了写操作之后，由于是以追加方式写的，所以“文件读写指针”会被设置为“文件大小”，指向了文件的最末尾，数据会被写到文件的末尾，每写一个字节，“文件读写指针”随之向后移动，文件大小也随之增加，但是“文件读写指针”一直指向了文件的最末尾。

  此时再去读时，读的就是文件的末尾，从文件末尾读什么也读不到，如果想读到数据，就需要将“文件读写指针”向前调整，移到我们要读的位置。

### 2.9.2 fseek

#### （1）函数原型

```c
#include <stdio.h>
int fseek(FILE *stream, long offset, int whence);
```

#### （2）功能

用来调整“文件读写指针”到我们期望的位置。

#### （3）参数

+ 1）stream：文件指，代表的是普通文件
+ 2）whence：粗调，指定值有三个宏，这三个宏被定义在了stdio.h中
  + （a）SEEK_SET（宏值1）：调整到文件中首字节
  + （b）SEEK_CUR（宏值2）：就停留在当前位置
  + （c）SEEK_END（宏值3）：调整到文件最后一个字节
+ 3）offset：精调
  + （a）负数：从粗调位置向前移动相应字节。
  + （b）正数：从粗调位置向后移动相应字节。

不过需要注意的是：当读写位置已经在文件首字节时，指定负数向前调整是不允许的，
```c
fseek(fp, -10, SEEK_SET);
```
之所以不允许，是因为这会访问到其它的空间里面，如果你非要这么设置参数，最后函数会返回-1报错。

如果“文件读写指针”已经指向了文件的最后一个字节，此时再向后调整有意义吗？

```c
fseek(fp, 100, SEEK_END);
```

答：有意义，此时会形成空洞文件，有关空洞文件，我们在“Linux系统编程、网络编程”的第1章文件IO中有介绍，这里就不啰嗦了。

#### （4）返回值

+ 1）成功，返回0
+ 2）函数错误，返回-1，并设置errno

#### （5）例子

+ 1）例子1
  刚开始打开文件时，"文件读写指针"指向了文件首字节，我们尝试向前移动，看看会怎样。
  
  ```c
  #include <stdio.h>

  #define print_error(str) \
  do{\
      fprintf(stderr, "File %s, Line %d, Function %s error\n", __FILE__, __LINE__, str);\
      perror("error Reason");\
      exit(-1);\
  }while(0);

  void main()
  {
      FILE *fp = NULL;
      //fp = fopen("/home/zxf/Desktop/file.txt", "w+"); 						//Linux
      fp = fopen("C:\\Users\\Administrator\\Desktop\\file.txt", "w+"); //whindows
      if(NULL == fp) print_error("fopen")
      int ret = 0;
      ret = fseek(fp, -10, SEEK_SET); //*************************
      if(-1 == ret) print_error("fseek")

      fclose(fp);
      return 0;
  }
  ```
  
  报错：
  
  ```shell
  File C:\Users\Administrator\Desktop\EGEProj\qq\a.c, Line 34, Function fseek error
  error Reason: Invalid argument
  ```
  
  提示无效参数，说明指向首字节时，不能将offset指定负数，在向前调整。


+ 2）例子2
  将以前例子中的rewind换成fseek

  + `rewind(fp)`：将文件读写指针调整到文件首字节
  + `fseek(fp, 0, SEEK_SET)`：一样能将文件读写指针调整到文件首字节
  + `rewind(fp)`其实是fseek(fp, 0, SEEK_SET)简化版。

### 2.9.3 rewind

```c
#include <stdio.h>
void rewind(FILE *stream);
```

等价于
```c
fseek(stream, 0, SEEK_SET);
```

其实就是
```c
fseek(stream, 0, SEEK_SET)
```
的更方便的简写形式。

### 2.9.3 ftell

#### （1）函数原型

```c
#include <stdio.h>
long ftell(FILE *stream);
```

#### （2）功能

返回“文件读写指针”，其实就是返回文件读写写位置距离文件第一个字节的偏移量，也就是返回当前的文件读写位置。

成功：返回文件读写指针（偏移量）。

失败：如果函数出错了就返回-1，errno被设置。

#### （3）例子

比如可以使用这个函数得到文件的大小。

```c
fseek(fp, 0, SEEK_END); //将文件指针调整到末尾（最后一个字节）
int fileSize = ftell(fp);  //返回的就是文件大小
```

### 2.9.4 注意：只有普通文件才能调整“文件读写指针”

因为只有普通文件在硬盘上有实际的存储空间，调动文件指针才有意义，如果读写的是键盘和显示器的话，调整文件杜尔斜指针是没有意义的，比如：
```c
fseek(stdout, 10, SEEK_END);
rewind(stdin);
ftell(stderr);
```
都是没有意义的。

因为键盘和显示器只是一个输入、输出设备，stdin和stdout、stderr只是以文件方式来“读写”设备输入输出数据而已，并不是一个真正的存储设备（设备），不存在真正的存储空间，调整“文件读写指针”没有意义。如果你非要这么做，fseek会报无效参数的错误。

## 2.10 检测是否读到了文件的末尾

### 2.10.1 方法1：通过EOF来检测

当fscanf、scanf、fgetc等函数读到文件末尾时会返回EOF（-1），我们通过EOF可以检测是否读到了文件的末尾。

但是这种方式有缺点，缺点就是当这些函数出错时，也会返回EOF（-1），所以就不太好判断到底是什么情况导致的返回EOF，当然如果非要使用EOF判断的话也是可以的，不过需要加入额外的判断信息，用起来有点繁琐。

### 2.10.2 方法2：通过feof函数来检测。

#### 1）原型

```c
#include <stdio.h>
int feof(FILE *stream);
```

#### 2）功能

> 判断是否读到了文件末尾

#### 3）stream

> 指向目标（普通文件）

#### 4）返回值

+ 读到了文件末尾：返回“非零值”，具体是什么非零值，手册并没有说。
+ 没有读到文件的末尾：返回0

只要检测到返回“非零值”，就说明读到了文件的末尾。

这个函数不存在调用失败的情况，一定会调用成功。

#### 5）例子

功能：file.txt文件中字符很多，一次读不完，所以需要循环读取里面的内容，当检测到读到文件末尾时就不再读取。

file.txt内容：

```txt
dsfsffdfdsfsfsdfsfsfsdfsdhfdkljhfgdffkgjkdfsgkdflgjfdkjkdfdklgfdjjjklfjks粉丝哦的放大法
```

循环读取内容的代码：

```c
#include <stdio.h>

#define print_error(str) \
do{ \
    fprintf(stderr, "File %s, Line %d, Function %s error\n", __FILE__, __LINE__, str);\
    perror("error Reason"); \
    exit(-1); \
}while(0);

void main()
{
    int ret = 0;
    FILE *fp = NULL;
    //fp = fopen("/home/zxf/Desktop/file.txt", "r"); //Linux
    fp = fopen("C:\\Users\\Administrator\\Desktop\\file.txt", "r"); //whindows
    if(NULL == fp) print_error("fopen")
    char buf[25] = {0};
    while(1)
    {
        if(feof(fp) != 0)
        {
            printf("文件末尾");
            break;
        }
        fgets(buf, sizeof(buf), fp);
        printf("%s\n", buf);
        memset(buf, 0, sizeof(buf));
    }
    fclose(fp);
    return 0;
}
```

打印结果：

```txt
dsfsffdfdsfsfsdfsfsfsdfs
dhfdkljhfgdffkgjkdfsgkdf
lgjfdkjkdfdklgfdjjjklfjk
s粉丝哦的放大法
文件末尾
```

显示打印中文时如果出现乱码的话，可能是因为编码格式问题导致的。

打印信息是在“命令行”显示的，windows命令行默认支持的中文编码格式为936（GBK：国标）编码，我们可以在windows命令窗口输入chcp命令查看：显示结果为936。

但是如果Codeblocks设置的编码格式不是936的话，那么程序中的中文肯定也不是936编码的，此时我们只需要将Codeblocks的编码指定为WINDOWS-936即可，Codeblocks设置方法：`Setting ——> Editor ——> Encoding setting ——> Use encoding when open files ——> WINDOWS-936`

重新编译运行：
重新编译时，一定要记得改动下代码再编译（比如加两个空格），如果编译器检测到文件没有任何改动的话，编译结果就会还和以前一样，看不到任何效果。

```txt
dsfsffdfdsfsfsdfsfsfsdfs
dhfdkljhfgdffkgjkdfsgkdf
lgjfdkjkdfdklgfdjjjklfjk
s粉丝哦的放大法
文件末尾
```

中文字符的编码都是使用2个以上的字节来存放的，所以读取中文字符时，如果不能完整的读出每个汉字的编码的话，比如只读取出了某个“汉字”编码的第一个字节，在打印时肯定也会造成乱码，所以读取中文编码时，必须要保证读到是每个汉字的完整编码，不能错位，否者打印结果肯定也会乱码。

## 2.11 缓存问题

### 2.11.1 什么是缓存

很多同学总是搞不清楚什么是缓存，缓存其实就是程序在内存中开辟的用来存放数据的变量空间，比如：

```c
int a;
struct Student stu;
int *p = malloc(sizeof(int) * 12);  
float buf[10];
```

等等

这些变量空间统统都是缓存，自所以称为“缓存”，是因为这个变量空间都是用来暂时存放数据使用的，“暂存”就是“缓存”吗。

### 2.11.2 应用缓存、库缓存、内核缓存

+ （1）应用缓存
  应用代码在内存中开辟的缓存空间。

+ （2）库缓存
  库代码在内存中开辟的缓存空间。

+ （3）内核缓存
  内核代码在内存中开辟的缓存空间。
  不过内核不能使用malloc，因为malloc是一个应用层调用函数，内核里面无法使用这个函数，内核有与之相似的函数。

  很多同学总感觉库缓存和内核缓存很神秘，很难想象长的是什么样子的，实际上库代码、内核代码与应用代码并没有什么本质区别，就好比中国人和美国人一样，都是人，没有本质区别，应用代码采用了哪些手段来开辟“缓存空间”，库代码、内核代码同样也是采用这些手段来开辟“缓存空间”的。

  一般来说，如果所需的缓存空间很大的话，一般都是使用malloc来开辟的。

### 2.11.3 使用标准io读写数据时，数据在缓存中的流向

应用程序调用标准io函数向底层文件读写数据时，数据并不会直接就写到了文件中，又或者直接就从文件中读到了数据，而是需要在各个缓存之间进行“捣腾”。

我们这里假设“标准IO”基于OS运行：

```shell
应用代码（应用缓存）
   |        |
   |        |
标准IO库（标准IO的库缓存）
   |        |
   |        |
   OS   （内核缓存）
   |        |
   |        |
 文件  （硬盘、键盘、显示器）
```

+ （1）读数据时
  + 1）内核函数通过“设备驱动代码”，将数据从文件中读到“内核缓存”空间
  + 2）标准io库调用“读文件IO函数（读API）”，将数据从内核缓存读到“标准IO的库缓存”空间
  + 3）自己写的“应用代码”，调用标准io的读函数，将数据从“标准IO的库缓存”读到“应用缓存”空间，数据存放到“应用缓存”空间后，我们的“应用代码”就可以使用读到的数据了。

+ （2）写数据时
   > 刚好是读过程的相反过程。

  + 1）“应用代码”调用标准IO库的“写函数”，将数据从“应用缓存”写到“标准IO的库缓存”
  + 2）标准io库调用“写文件IO函数（写API）”，将数据从“标准IO的库缓存”写到“内核缓存”
  + 3）内核函数通过“设备驱动代码”，将数据从“内核缓存”将数据交给设备
    + 显示器设备：显示数据
    + 硬盘：将数据存入硬盘上的普通文件。

### 2.11.4 库缓存的三种缓冲方式

这里说的“缓冲”就是“积压”的意思，也就是数据会暂时积压在“库缓存”中。
顺便一提，标准io库的库缓存一般为4096大小。

#### （1）为什么要积压

比如以输出为例，如果库缓存中只要有一个字符的数据，就立即调用“文件IO函数（比如write）”将数据输出的话，会频繁的调用write函数，这样会降低效率，所以数据会在缓存中先积压，直到满足相关刷新条件时，才一次的全部输出。

`疑问`：什么是刷新？  
`答`：就将数据从库缓存中取走。

#### （2）三种缓冲方式

无缓冲、行缓冲、全缓冲。

+ 1）无缓冲
  无缓冲就是，只要库缓存中有了数据就立即刷新，哪怕只有一个字符，也会立即刷新，数据是不会积压的。
  无缓冲非常适合用于输出错误信息，因为出错信息很紧急，不能被积压，所以有了错误信息后就应该被立即无条件刷新输出。
  stderr（标准出错输出）就是专门用来输出错误信息的，所以就是“无缓冲”的情况。

  不过“无缓冲”的特点是，只要库缓存中有数据了就会立即刷新输出，效率相对会低一些，但是可以将数据及时的输出。这就跟送快递的一样，只要有了一个快递就立马送出，如此的话效率肯定会低一些，但是可以保证每一个快递都能被及时的送出，一般来说快递都会积压，当挤压到了一定量后再送出，这样的话效率会高很多。

+ 2）行缓冲
  数据会积压，直到“满一行”时才会刷新，然后将数据输入/输出。  
  \n就是一行的判断条件，只要数据中有\n，就代表数据满一行了。  
  也就是说，对于标准IO库的库缓存来说，\n不仅仅只是换行，还是数据满一行的标志。  
  
  行缓冲非常适合用于正常的键盘输入和打印显示（正常的人机交互），人与计算机的交互就跟人与人的说话一样，一句一句的来是最方便的，这样既不会因  话太急而累到，也不会出现等很久都得不到信息的情况。
  
  人机交互时一行其实就是一句，stdin、stdout（标准输入、标准输出）就是专门用来进行正常人机交互用的，所以都是行缓冲的，满足一行的条件时就会  刷输入、输出数据。

  有关“行缓冲”的需要注意的地方：

  按照c标准的规定，stderr为无缓冲，stdin、stdout为行缓冲，但是针对不同平台的“标准io库”在实现时，不一定都会严格的准守c标准，比如：
  + 在Linux下：stderr为“无缓冲”、stdin、stdout为“行缓冲”，准守了c标准的规定
  + 在Windows下：stderr、stdin、stdout都是无缓冲，只要库缓存有数据就会立即刷新。

+ 3）全缓冲
  特点是必须等到“库缓存”的空间，全部被数据积压满后，才会输出  
  就好比说以一盆水满了以后才会溢出，道理有点类似。

  读写硬盘上普通文件时就是“全缓冲”，比如以写为例，写普通文件时由于不涉及人机交互时的“及时性”问题，所以并不需要立即写到文件中，完全可以先将大量数据积压到缓存中，等填满整个缓存之后再一次性刷新输出。  

  读写fopen所打开的普通文件时，就是“全缓冲”的。

#### （3）三种缓冲的基本刷新方式

我们以输出为例来介绍，输出时的缓冲是我们经常需要关注的。
	
+ 1）stderr：无缓存
  只要“库缓存”中有数据就无条件立即刷新输出。
  ```c
  #include <stdio.h>
  
  void main()
  {
      fprintf(stderr, "hello wolrd"); 
      while(1);
      return 0;
  }
	```
  hello wolrd被立即输出。
	
+ 2）stdout：行缓存
	#include <stdio.h>
	
	void main()
	{
			fprintf(stdout, "hello wolrd");
			fprintf(stdout, "@@@@@@@@@@@");
			printf("22222222222");
			fprintf(stdout, "！！！！！！！！");
			
			while(1); //死循环
			return 0;
	}
	打印结果：无
	
	由于没有\n，所以数据全部被积压在库缓存中，所以看不到打印结果。
	当然如果你的数据够多，躲到能够将整个库缓存填满的话，也会刷新，但是通过stdout输出时，一般输出的
数据量都很小，不可能将4096大小的缓存空间全部填满。
	
	加\n刷新：
	在最后一个fprintf加\n，会一次性的将所有积压的数据全部被刷新输出，结果为：
	hello wolrd@@@@@@@@@@@22222222222！！！！！！！！
	
	如果给每一个都加上\n的话，每一个都会被立即刷新输出。
	
	
	例子中使用fprintf和printf输出时，全部都是字符串常量，此时的“应用缓存”是什么？
	答：字符串常量放在了.rodata中，所以“应用缓存”空间，就是字符串常量在.rodata中存放时所占用的
		内存空间。
	
	
3）全缓冲
	#include <stdio.h>
	
	void main()
	{
			FILE *fp = NULL;
			//fp = fopen("/home/zxf/Desktop/file.txt", "w+"); 						//Linux
			fp = fopen("C:\\Users\\Administrator\\Desktop\\file.txt", "w+"); //whindows
			fprintf(fp, "hello world\n");
			while(1);
			fclose(fp);
			return 0;
	}
	
		fp指向了普通文件，此时就是全缓存的，尽管"hello world\n"中有个一\n，但是全缓冲不受\n影响，由于
	数据太少，还不足以填满整个库缓存，所以无法被刷新，此时打开file.txt文件时，里面不会有数据。
		
		但是实际上我们向文件里面写数据时，大部分时候写的数据都不多，很难一次性将库缓存全部写满，但是
	我们又必须要刷新数据，然后输出到文件中，此时我们就应该使用其它刷新方式。
		
		
#### （4）缓冲的其它刷新方式
			无缓冲是无条件立即刷新的，所以不需要什么额外刷新方式，但是行缓冲和全缓冲并不一定会立即刷新，
		当不满足刷新条件时，我们可以使用其它“刷新方式”来刷新？
			
		1）调用fflush刷新函数，手动的刷新库缓存
			 #include <stdio.h>
       int fflush(FILE *stream);
				
			1）例子1 
				void main(void)
				{
					fprintf(stdout, "hello wolrd");
					fprintf(stdout, "@@@@@@@@@@@");
					printf("22222222222");
					fprintf(stdout, "！！！！！！！！");
					fflush(stdout); //手动刷新
					
					while(1); //死循环

					return 0;
				}
				
				Linux下：stderr无缓冲。
				windows：stdout无缓冲。
				
				
			2）例子2
				void main()
				{
						FILE *fp = NULL;

						//fp = fopen("/home/zxf/Desktop/file.txt", "w+"); 								//Linux
						fp = fopen("C:\\Users\\Administrator\\Desktop\\file.txt", "w+"); 	//whindows

						fprintf(fp, "hello world\n");

						fflush(fp);
						
						while(1);

						fclose(fp);

						return 0;
				}
			  
				数据被刷新输出到了file.txt中。
			
		2）fclose关闭文件：也会手动刷新
			因为fclose关闭文件时，也会自动的调用fflush函数来手动刷新。
			
			前面我们介绍过，如果没有明写出fclose的话，程序正常终止时，也会自动的调用fclose函数。
			
			比如：
			例子1：
				void main(void)
				{
					fprintf(stdout, "hello wolrd");
					fprintf(stdout, "@@@@@@@@@@@");
					printf("22222222222");
					fprintf(stdout, "！！！！！！！！");
					
					return 0;
				}
				
				程序正常终止时，会默认调用fclose将stdout关闭。
			
			例子2：
			#include <stdio.h>
			
			void main()
			{
					FILE *fp = NULL;

					//fp = fopen("/home/zxf/Desktop/file.txt", "w+"); 						//Linux
					fp = fopen("C:\\Users\\Administrator\\Desktop\\file.txt", "w+"); //whindows

					fprintf(fp, "hello world\n");
					
					
					return 0;
			}
			
			程序结束后，默认会调用flcose关闭fp指向的文件，然后手动刷新输出到文件中。

## 2.12 使用scanf等读取函数，从键盘读取数据时存在的问题
		从键盘输入数据时，不管输入什么数据，只有当敲了回车（\n）后才会输入，从键盘输入数据时，输入的最后
	输入的字符一定是'\n'。
		
		但是scanf等读取函数从“库缓存”里面读取数据时，往往会将\n留在“库缓存”里面，如果后续紧跟着
	scanf/fscanf/getc/getchar等函数来读取数时，读取到的将是“库缓存”中遗留的'\n'，或者其它无用字符。
	
		比如：
				#include <stdio.h>

				int main()
				{
						char a;
						int b;
						char buf[10];

						char c;

						/* 一下三种不管是那种情况，都会留一个\n在缓存中，影响
						 * 最后一次的‘字符输出’
						*/
						//scanf("%c", &a);
						a = getchar();
						//scanf("%d", &b);
						//scanf("%s", buf);
					
						/* 读到的是来及字符 */
						gets(buf);
						puts(buf);

					 //scanf("%c", &c); //使用getc/getchar也是一样的
					 //printf("%d\n", c);  //会将'\n'的ascii值10输出

						return 0;
				}

		
		注意：以%d、%f格式输入时，输入的必须是0~9的数字，如果是a、b、c、d的英文字母的话，会直接将这些字符
		遗留在库缓存中，影响后续的读取。
		
		
		如何解决：
			很简单，只要将“库缓存”中所有的字符全部取走，将“库缓存”全部清空后，就不会受到这些遗留字符的干扰，
			不管使用getchar、getc、scanf("%c", &ch)中那个函数，都能将遗留的字符全部取走，我们这里使用最简洁
			getchar来实现。
			
			但是由于“库缓存”里面可能一次会遗留很多的字符，所以我们最好是通过一个while循环去读取，由于\n是键盘
		输入的最后一个字符，所以我们以'\n'作为循环结束的条件，当然'\n'也会被取走。
			
				while(getchar() != '\n');  
			 
		表示会将所有的碍眼字符的都取走，当遇到'\n'时结束读取，当然'\n'也会被取走。
		以上代码改进后就变为了如下形式：
				scanf("%c", &a);
				//scanf("%d", &b);
				//scanf("%s", buf);

				while(getchar() != '\n');
				scanf("%c", &c); //使用getc/getchar也是一样的
				printf("%c\n", c);
				
				
		使用scanf、fscanf、getchar、getc、fgetc这些函数时，往往会遗留垃圾字符在库缓存里面，此时我们需要
		使用while(getchar() != '\n')来清库缓存。
				
		不过fgets、gets取数据时不存在遗留垃圾字符的问题，所以到底加不加while(getchar() != '\n')，其实不是好
	判断，最简单的处理方法就是，当你遇到了受到垃圾字符影响的情况时，就加while(getchar() != '\n')来解决，
	没有遇到时就不加清缓存的这句话。
		
		在实际开发产品时，真正使用scanf等来输入的情况非常少，所以基本不会遇到遗留垃圾字符的情况，但是在学
	习c时，scanf等输入函数用的确很频繁，有时可能会遇到，遇到后就按照以上方法来处理。