# 1. 位操作（位运算）

常用位操作符有：

+ `&`: 位与
+ `|`: 位或
+ `^`: 位异或
+ `~`: 位取反
+ `<<`: 左移
+ `>>`: 右移

## 1.1 什么是位操作，有什么意义

数据在计算机中都是二进制形式的，位操作就是，可以通过`&`、`|`、`^`等位操作符号，修改二进制数据中的每一位。

**有什么意义？**

c语言会经常用在底层硬件的开发上，而控制硬件则是通过“位操作”去读写寄存器来实现的，显然我们有必要认真的讲一讲位操作。

## 1.2 能不能对浮点数进行“位操作”

> 不能，只能对整形数（有符号、无符号）进行位操作。

## 1.3 `&`、`|`、`^`与 `&&` `||` `!`的区别

### 1.3.1 `&&` `||` `!`

`&&`、`||`、`!`用于逻辑运算，进行逻辑运算时是以“整个数”来判断真假的，整个数的真假为非0为真、0为假。

比如：

```c
if(3 && 0)  //为假，条件不成立
if(6 || 0)  //为真，条件成立
if(!4)      //非真即为假
```

### 1.3.2 `&`、`|`、`^`

`&`、`|`、`^`则是用来对二进制数中的每个位进行操作的

数中位为1的话为真，为0则为假，后面具体介绍`&`、`|`、`^`、...时就能切身体会了

## 1.4 `&`位与

### 1.4.1 &的运算规则

+ （1）两个位都为1时，结果为1
+ （2）只要有一个为0，结果就为0

### 1.4.2 例子

```c
char a = 3;
char b = 6;
char c = a & b;
```

运算过程如下：

```c
  00000011  （3）
& 00000110  （6）
= 00000010  （c=2）
```

如果是int型的话，则为32位

十进制、二进制、十六进制、8进制之间的换算是一件不讨人喜欢的事，但是windows的计算机提供了换算功能。

## 1.5 `|` 位或

### 1.5.1 规则

+ （1）两个位都为0时，结果为0
+ （2）只要有一个为1，结果就为1

### 1.5.2 例子

```c
char a = 3;
char b = 6;
char c = a | b;
```

```c
  00000011  （3）
| 00000110  （6）
= 00000111  （c=7）
```

## 1.6 `~` 位取反

### 1.6.1 规则

+ 0取反变1，1取反变0

### 1.6.2 例子

```c
char a=6;
char b=~a;
```

```c
~ 00000110  （6）
= 11111001  （b=249）
```

## 1.7 `^` 异或

### 1.7.1 规则

+ （1）两个位相同则为0
+ （2）两个位不同则为1

### 1.7.2

```c
char a = 3;
char b = 6;
char c = a ^ b;
```

```c
  00000011  （3）
^ 00000110  （6）
= 00000101  （c=5）
```

## 1.8 `<<` 左移

### 1.8.1 规则

+ 将操作数的各个位左移若干位，溢出去的二进制位则丢弃，右边空出的位则补0。

### 1.8.2 例子

```c
char a = 195;
char b = a<<5;
```

char：8bit，a值为11000011，char只能容纳8位，移出去的丢弃。

```c
b = 00000011 << 5
b = 01100000（96）
```

二进制的每个位从右到左编号，从0开始编号，左移5位，最右边的哪一位，刚好就移到了编号为5的位上。

```c
7 6 5 4 3 2 1 0  
1 1 0 0 0 0 1 1
   <——*
0 1 1 0 0 0 0 0
```

当你也可以将第一位从1开始编号，不过我们一般都习惯从0开始编号，这样能够更加方便我们操作。

### 1.8.3 左移时的*2规律

> 在没有“有效位(为1的位)”被溢出丢弃之前，**每左移一位就是对数据*2** 比如：

```c
char a = 4;
char b = 4<<3;
```

```c
    00100000
b = 00000100 << 3  （4*2*2*2）  
b = 00100000       （32）
```

## 1.9 `>>` 右移

### 1.9.1 规则

将操作数的各个位右移若干位，右边溢出二进制位会被丢弃，左边的空出位则补0或1：

+ （1）无符号数 和 有符号正整数：补0
+ （2）有符号负整数：补1

### 1.9.2 例子

```c
char a = 75;   //有符号正整数，右移补0
char b = a>>5;
```

```c
b = 01001011 >> 5
b = 00000010  （2）
```

### 1.9.3 右移/2的规律

在没有丢弃有效数据之前，**每右移1位，就是对数据做一次/2操作**，比如：

```c
char a=112;
char b=a>>3;
```

```c
       01110
b = 01110000 >> 3;  //112/2/2/2
b = 00001110        //14
```

## 1.10 位操作实践

大家不要小瞧这些例子，认为很简单没有什么作用，实际上底层读写寄存器的每个位时，就是通过这些方式来操作的。
	
### 1.10.1 `int a=96，将第3bit置1，其它位保持不变`

分析：与1<<3进行位或即可实现

```c
a = a | (1<<3);
```

二进制的运算过程：

```c
    00000000000000000000000001100000   （96）   //int有32位
|   00000000000000000000000000000100   （1<<3） //直接使用数字时，1为int
=   00000000000000000000000001100100   （100）  //最终a中放的就是100
```

### 1.10.2 `int a=96，将3~7bit（5位）置1，其它位保持不变`

与前面的例子的实现方式是一样的。

```c
a = a | (0x1f<<3)
```

```c
                           11111000
   00000000000000000000000001100000   （96）
|  00000000000000000000000011111000   （0x1f<<3）
=  00000000000000000000000011111000   （248）
```

### 1.10.3 `int a=146，将4~6bit（3位）清0，其它位保持不变`

做&运算即可清零。

```c
a = a & (~(0x7<<4))
```

```c
    0x7<<4: 00000000000000000000000001110000
 ~(0x7<<4): 11111111111111111111111110001111
```

```c
  00000000000000000000000010010010   （146）
& 11111111111111111111111110001111   （~(0x7<<4)）
= 00000000000000000000000010000010   （130）
```

### 1.10.4 `int a=858，取出数据中3~6bit（4bit），并打印出数值`

+ （1）与3~6为1，其它位全为0的数做&，得到只保留了3~6bit的数
+ （2）将数值右移3位，并printf打印出来

```c
int b = (a & (0xf<<3)) >> 3;
printf("%d\n", b);
```

```c
  a & (0xf<<3):
  00000000000000000000001101011010   （858）
& 00000000000000000000000001111000   （0xf<<3）  
  00000000000000000000000001011000   （130）
```

```c
>> 3：
00000000000000000000000001011000   （>>3）
00000000000000000000000000001011   （b=11(0xB)）
```

### 1.10.5 如下计算结果应该是多少？

```c
char a = 96; // 01100000
int b = ~a;
```
		
#### （1）错误理解	

```c
~ 01100000
  10011111
```

b为int，将char的~a强制转为int，结果如下：

```c
b = 00000000000000000000000010011111
```

这里面忽略自动类型转换的问题，在自动类型转换的规则下，char short参与运算时，首先会自动转为int型，然后再进行运算。

#### （2）正确情况

```c
int b = ~a;
```

a -> int，转为int是，高位全部补0，结果为00000000000000000000000001100000。

```c
int b = ~00000000000000000000000001100000
    b =  11111111111111111111111110011111
```

最终b中所放的内容为，int为有符号数，最高位为1，为一个负数（-97）。

####（3）纠正前面的例子

```c
char a=6;
char b=~a;
```

这个例子的正确情况是：
a——>int，然后再位取反，赋值给char的b时，只截取其中的低8bit。

```c
b = ~ 000000000000000000000000000110  （6）
b =   111111111111111111111111111001
b =   11111001
```

### 1.10.6 某个数原来为1034，现在变为了1450，找出其中发生变化的位，并把这些位数打印出来。

```c
                            9876543210
1034：00000000000000000000010000001010
1450：00000000000000000000010110101010
	                       ** *
```

通过对比可知，5、7、8三个bit发生了变化，但是我们现在要通过“位操作”的代码来找出5、7、8这三位。

####（1）实现原理

+ 1）第1步
    将原来的值和新的值进行异或，对发生变化的位进行“异或”后，结果为1，其它没变的就为0

    ```c
                            9876543210
      00000000000000000000010000001010  （1034）
    ^ 00000000000000000000010110101010  （1450）
    = 00000000000000000000000110100000
                             ** *
    ```

+ 2）第2步
  
	分别与如下数据相&，找出是哪一位发生了变化。

	```c
    1<<0:  00000000000000000000000000000001
	1<<1:  00000000000000000000000000000010
	1<<2:  00000000000000000000000000000100
	1<<3:  00000000000000000000000000001000
	1<<4:  00000000000000000000000000001000
	1<<5:  00000000000000000000000000100000
	...
	1<<30: 01000000000000000000000000000000
	1<<31: 10000000000000000000000000000000
    ```

	比如：
	```c
	    00000000000000000000000110100000
	&	00000000000000000000000000100000  （1<<5）
		00000000000000000000000000100000
    ```

	说明第5位发生了变化。

#### （2）代码

```c
#include "stdio.h"

int main(void)
{
    int i = 0;
    int old_va = 1034;
    int new_va = 1450;

    int temp = old_va ^ new_va;

    for(i=0; i<32; i++)
    {
        if(temp & (1<<i)) //如果为很，就说明temp中那一位为1，表示发生改变了
            printf("%d ", i); //打印是哪一位
    }
    printf("\n");

    return 0;
}
```

输出结果：

```shell
5 7 8
```

与我们自之前预判的结果是一致的。

## 1.11 宏与位运算

不管是在我们自己的代码中，还是在c库、os内核源码中，为了方便使用，往往会将位操作定义为“带参宏”的形式。

### 1.11.1 置位宏（置1宏）

#### （1）功能

将数的某个bit置位，置位也被称为置1。

#### （2）例子

```c
#define SET_BIT(x, n)  ((x) | (1<<(n)))  //宏名不一定非要叫SET_BIT这个名字
SET_BIT(100, 4);
```

宏展开后：

```c
((100) | (1<<(4)))
```

疑问：为什么加这么多括号？
答：我们在第2章讲宏时介绍的非常清楚，这里不再啰嗦。

### 1.11.2 复位宏（清0宏）

#### （1）功能

将某个数的某个bit复位，复位也被称为清0。

#### （2）例子

```c
#define RESET_BIT(x, n)		((x) & ~(1<<(n)))  //RESET是复位的意思，也可以把名字起为CLR_BIT

RESET_BIT(100, 4);
```

宏展开后：

```shell
((100) & ~(1<<(4)))
```

### 1.11.3 构建某些连续位为1，其它位为0的数

```c
#define MAKE_SERI1_NUM(n, m)  (~((~0U)<<(m-n+1)) << (n))
```

构建出4~8位(5bit)为1，其它位为0的数:

```c
int a = MAKE_SERI1_NUM(4, 8);
```

宏展开：
```shell
(~((~0U)<<(8-4+1)) << (4))
```

```c
				       ~0U：11111111111111111111111111111111 //U代表0是无符号数，之所以指定无符号，是不想受到符号位的干扰
	      ((~0U)<<(8-4+1))：11111111111111111111111111100000
		 ~((~0U)<<(8-4+1))：00000000000000000000000000011111
(~((~0U)<<(8-4+1)) << (4))：00000000000000000000000111110000 //如此就得到了4~8连续位1的数，十进制为496
```

### 1.11.4 获取数中“某连续几位”

要实现这样的操作很很简单。

+ 得到某几位连续为1，其它全部为0的数，我们使用前面MAKE_SERI1_NUM宏来实现
+ 与这个数做&运算，取出关心位那连续几位
+ 右移到最右边，如此就得到

#### （1）宏

```c
#define MAKE_SERI1_NUM(n, m)  (~((~0U)<<(m-n+1)) << (n))
#define GET_BITS(x, n, m)     (((x) & MAKE_SERI_NUM(n, m)) >> (n))
```

#### （2）例子

```c
#include "stdio.h"
#define MAKE_SERI1_NUM(n, m)   (~((~0U)<<(m-n+1)) << (n))
#define GET_BITS(x, n, m)      (((x) & MAKE_SERI1_NUM(n, m)) >> (n))

int main(void)
{
    int a = GET_BITS(3454, 5, 8);  //取出3454中5~8位
    printf("%d\n", a);
    return 0;
}
```

输出结果：`11`

宏原理分析：

+ 1）`MAKE_SERI1_NUM(5, 8)：00000000000000000000000111100000`

+ 2）`((3454) & MAKE_SERI_NUM(5, 8))`：
    ```c
      00000000000000000000110101111110 （3454）
    & 00000000000000000000000111100000
    = 00000000000000000000000101100000
    ```

+ 3）`((3454) & MAKE_SERI_NUM(5, 8)) >> (5)`：
	```c
      00000000000000000000000101100000 >> 5
	= 00000000000000000000000000001011  （11）
    ```

随后取出的结果为11，以后看到这种复杂的“位运算宏定义”时，我们就带入实际值，然后分清楚()的分成关系，层层替换看左后运算结果，最后你就能弄清楚这个宏的作用，这是这种复杂宏的分析方法，我们在第二章的时候就反复强调过这个方法。