# 1. 存储空间、符号、地址

## 1.1 存储空间

### 1.1.1 什么是存储空间
就是程序代码和数据的存放空间，笼统可以分为如下两种情况。

+ 没有运行时：  
  存储在硬盘（外存）上，所以此时的存储空间为硬盘。  

+ 运行时：  
  代码和数据存放在内存上，供cpu访问。  
  当然程序在运行时，还需要用到寄存器和cache，寄存器和cache同样也是存储器，它是用于缓存内存中的代码和数据.  
  
  所有这些存储器（硬盘、内存、寄存器、cache）都是由单个字节堆叠而成，存储空间中的每个字节都有自己的地址，如果没有地址的话，是无法访问它们的，每个字节的地址就好比是每个字节的门牌号。   
  
  一般来说，当我们说存储器时，主要指的是内存。   
			
		
### 1.1.2 程序运行时，cpu是如何访问内存中的代码和数据的

存储器中的每个字节都有地址，这个地址就是每个字节的门牌号，通过地址就能找到每一个字节并访问它，    
访问权限有两种：  

+ 可读可写  
  程序的“.data、.bss、堆、栈空间”就是可读可写的。 
  
  变量空间要求是可读可写的，所以变量空间就开辟于这些中。  

+ 只读  
  .rodata、.text为只读的。    
  
  代码和常量只能被读，所以代码和常量就放在这两个中。  


`疑问`：怎么没有“不可读不可写”和“只写”的权限呢？  
`答`：两种权限没有意义  
+ 不可读不可写：这个存储空间没有任何作用  
+ 只写：写入数据的目的是为了读出，只写入不读出，这种权限的存储空间也没有任何意义

			
### 1.1.3 地址 与 指针
#### （1）地址是个啥
地址就是一个数，这个数可以唯一标记每个字节的存在，就好比人的身份证一样，也是一个数，可以唯一的标记每个人的存在。  
举个例子，如果内存大小为4G，那么内存的地址范围就是:  
0x00000000 ~ 0xFFFFFFFF：十六进制表示时的范围  
    0      ~    4G-1	 ：十进制表示时的范围


0x00000000 ~ 0xFFFFFFFF这个地址，就是一些用来__唯一标记字节空间__的数。

			
#### （2）指针就是地址的另一个名字
为什么地址也称为“指针”呢？  

通过某地址能够唯一的访问某个字节，所以地址唯一的指向了某字节，这就像“指针”一样具有指向作用，因此才被形象的称为了“指针”。  

这就好比我知道你们家的地址，然后就能找到你们家，此时就说“你们家的地址”是指向你们家的指针。  

所以记住了，`指针就是地址，地址就是指针`  
		
		
#### （3）指针与指针变量

+ `指针`：地址。

+ `指针变量`：存放地址（指针）的变量

```c
int a;
int *p = &a; 
```

`&a`：a的指针,a有四个字节，每个字节都有地址，但是只有第一个字节的地址才是a的指针，为什么是这样的，后面在解释。  

`p`：放地址（指针）的指针变量  
  这里要注意一点, `指针变量里面放了指针后, 我们就说p指向a, 但是我们自己应该清楚, 具有指向作用的是p里面的指针(地址), 而不是指针变量, 指针变量只是放指针的篮子`  

  指针变量里面的指针发生变化后, 这个指向就发生变化了, 所以说对于指针变量来说, 具有指向作用的是里面放的指针, 不是指针变量本身.

  不过以后为了称呼的方便，我们往往会将“指针变量”也简称为指针，所有平时称呼“指针”的时候，有可能指的地址，也可能指的是指针变量，就看说话的语境，不过在本章里面，为了表达更清晰，我会按照准确的名字来称呼。  


### 1.1.4 符号与地址

#### （1）程序运行时，`访问存储空间`是核心动作

##### 1）CPU执行的代码从哪里来  
要访问.text所对应存储空间。  

##### 2）CPU按照代码要求去加、减、乘、除、与、或、非运算数据时，数据从哪来  
 + （a）变量数据：需要访问.data、.bss、堆、栈空间。
 + （b）常量数据：需要访问.text、.rodata的空间。

##### 3）计算后的结果  
  得到这结果后，这个结果数据不管是拿去给USB输出，还是给LCD显示，还是给扬声器播放，还是控制机械手臂，都要先在.data、.bss、堆、栈中开辟变量空间，暂存这个结果数据，然后再将结果数据输出外设的寄存器、显存、声卡等，就可以控制USB、LCD、扬声器、机械手臂等外设工作了。  
  
   其实寄存器、显存、声卡等同样也是存储器，也是通过地址去操作的，只不过这些事情往往都是由驱动程序去做的。  
   
   对于应用程序俩说，主要访问的存储器是内存，而不是寄存器、显存、声卡这些玩意，这些是由驱动程序来访问的。  
			
			
#### （2）符号与地址
  前面说过，都是通过地址来访问存储空间的，直接通过地址来访问的话很不人性化的，所以在高级语言里面，地址都被替换为了符号。  
  
  比如我使用某个变空间，在高级语言里面，就通过变量名来访问，变量名就是一个符号，通过这个符号就可以操作这个变量，不必直接使用地址。  	
  
  所以在高级语言的程序里面，程序员基本只见符号，不见地址，正是由于这样的做法，使得高级语言的语法相对汇编来说，非常的人性化，因为直接操作地址的话，你需要了解硬件结构，特别是存储器的结构，否则你就不知道应该操作那个地址，这就很痛苦，但是变成符号后，程序员不用关心这些，只关心符号即可。  
  
  编译后，符号虽然会被转化为地址，但是在高级语言的语法里面，符号并不直接等于地址，你不能直接当做地址来使用，在高级语言里面，符号会受到作用域的限制，缺少一定的灵活性。  
  
  所以为了能够更加自由的操作存储空间，像c/c++这种高级语言，除了能够使用符号来操作外，它还允许直接使用地址来操作，使用地址来操作时，可以不受符号作用域的限制。  
	
##### 	1）作用域受限的例子。
```c
a.c
int fun1(void)
{
   int a = 200;
}
int fun2(void)
{
    int a;
    fun1(a);
}
```
		
fun1和fun2中a的作用域，只在自己函数中有效，所以通过修改fun1的a，对fun2中a不受影响。

```c
// a.c                  // b.c
                        static int flag = 0;
int fun(void)           static int fun1()
{                       {
 flag = 100;             ...
 fun1();                }
}
```


flag和fun1的作用域只在b.c中，因此a.c中的fun函数无法引用。


`疑问`：作用域限制是好还是坏？  
`答`：有好有坏。  
+ 好处：防止相互干扰，比如防止命名冲突，防止相互篡改数据等  
+ 缺点：作用域限制太严，会使得编程过于死板，不够灵活  

所以像c/c++为了更加的灵活，就加入直接的地址操作，这样就可以取一个折中，既可以受到作用域的限制，又可以保持灵活性，比如看下面的例子。  

			
##### 2）修改上面的例子

```c
// a.c
int fun1(int *a)
{
    *a = 200;
}

int fun2(void)
{
    int a;
    fun1(&a);
}
```
		
直接改fun1和fun2的a，相互不受影响，这个是作用域在发挥作用。  

但是由于fun2将a的地址（指针）传给fun1的a，所以在fun1中通过`*a`就可以读写fun2中a，又可以修改fun2中的a，如此就有了相当的灵活性。
	
##### 3）再举一个例子
```c
// a.c                                  // b.c
                                        static int flag = 0;
int fun(int *flag, void (*fun1p)())     static int fun1()
{                                       {
    *flag = 100;  //引用flag                 ...
    fun1p(); //调用fun1                 }
}                                      
                                        static int fun2()
                                        {
                                            fun(&flag, fun1);
                                        }
```

		
flag和fun1是a.c本地的，在a.c中时无法直接调用的，但是通过fun(&flag, funp)将flag和fun1的地址传递给a.c中的fun后，fun通过地址依然能够引用flag和fun1。

`疑问`：为什么不将static直接改为extern？

`答`：这样当然也能解决问题，而且一般情况也都是使用这种方式来解决的，但是当工程代码写的复杂后，必须对于函数全局全局变量的作用域进行限制，这样可以有更好封闭性，特别当代码需要进行逻辑上的分层时，那么不同层必须需要有相当的封闭性，在封闭之后层与层之间的对接，就需要靠这种方式来实现。  

  当然对接函数必须是extern的，比如，如果例子中连fun函数都是static的，那就完全隔离了。  

`疑问`：封闭性的好处？
+ 防止命名冲突
+ 防止胡乱引用
+ 防止数据篡改
	
  这就好比为了防止两个区域相互干扰，那就需要建立围栏加以限制，但是不能完全封死，为了让区域间还能沟通，所以还得留下一道门。  
  
  在上面的例子中，`void (*fun1p)()中fun1p`是函数指针变量，有关函数指针变量，本章后面再详介绍。  

		
##### 4）java、c#等语言中有指针吗？
在java和c#等高级语言中，并不允许在代码中直接操作地址，只能使用符号来操作，虽然没了指针后，灵活性降低了，但是也同时规避了指针所带来的风险，因为指针不受作用域限制，直接通过地址操作空间，因此存在潜在的危害，没有了指针，这种风险自然也就没有了，不过代价就是灵活性降低了。  

		
### 1.1.5 数据的类型

#### （1）空间第一个字节的地址
代码、变量、常量空间，往往都是连续的一片字节空间，到底哪一个字节的地址才代表整个空间的地址（指针）呢？  

我们前面说过，`第一个字节的地址是整个空间的指针`

#### （2）如何访问一片连续字节空间
只要知道如下几件事即可。  

+ 1）知道第一个字节的地址  
+ 2）知道访问到第几个字节结束  
+ 3）知道如何解析里面存放的数据  

如此就能正确访问连续字节中的数据，不管是访问函数、变量、常量，都是这样来访问的。  

**例子1 : 访问int变量的空间**  
int是四个字节组成的一片连续空间，如何访问呢？  

+ 1）知道第一个字节的地址   
+ 2）int的大小为4个字节，显然就知道了访问到那个字节结束  
+ 3）数据类型为整型，数据的存储结构就是整形的存储结构，访问空间时，需要按照“整形存储结构”去解析空间  

**例子2 : 访问float变量的空间**  
float也是四个字节组成的一片连续空间，如何访问呢？  

+ 1）知道第一个字节的地址   
+ 2）知道大小为四个字节   
+ 3）知道是float类型，那么数据就是以浮点形式存储的，读写空间时就必须按照浮点存储方式来解析空间   

`疑问`：浮点数是如何存储的？   
是以科学计数法来存储的，比如 12.3转为科学计数法就是:    

`12.3`  —————————>  `123 * 10的-1次方`

`疑问`: float为例，float空间总共32位：   
 `31 30 29 28 27 26 252 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 0`   
+ 最高位（31）：符号位，0表示正数，1表示负数  
+ 23~30：指数（1） 
+ 0~22：整数（123）  
比如向float的空间写数据时，按照这个结构来存储12.3的。
					
#### （3）回顾C语言的数据类型
对于绝大多数高级语言来说，都是有数据类型的，以c为例，就有大量的数据类型。  

凡是有数据类型的语言，我们都称为强类型语言。  

##### 1）基础数据类型
+ （a）整形：char short int long，这些还可以与unsigned进行组合，unsigned char,...   
+ （b）浮点：float double，注意浮点都是有符号的，浮点不能和unsigned进行组合，不存在无符号浮点数一说


##### 2）组合数据类型
由基础型演变而来。

+ （a）结构体、联合体类型  
	```c
	/* 结构体类型 */
	struct Student
	{
		int 	num;  //基础类型
		char 	name; //基础类型
		...
	};

	/* 联合体类型 */
	union Student
	{
		int 	num;  //基础类型
		char 	name; //基础类型
		...
	};

	```
+ （b）指针类型  
	`int *`、`float *`、`struct Student *`、 `union Student *`、`int **`、`float **`、...  
		
	`疑问`：有联合体指针吗？  
	答：有，不过用的很少，后面课程讲联合体时，还会提到的。
		
		
#### （4）数据类型的意义
##### 1）给程序员看到
比如你一看到变量类型，就知道应该放什么类型的数据到变量里面。

##### 2）数据类型决定了空间大小和存储结构
	比如：
+ （a）例子1
```c
int a;
a = 100;
```
`空间大小`：4字节
`存储结构`：整形存储结构    


编译器在编译时，就知道给a预安排多大的空间，存储结构是怎样的。   
```c
float a;
a = 100.7;
```
`空间大小`：四个字节   
`存储方式`：浮点存储方式    

+ （b）例子2:
```c
struct Student 
{
    int num;
    char name;
    float score;
    ...
};
struct Student stu;
```

`空间大小`：基本>=各成员之和，我们后面学习了结构体的对齐后，其实是能算出具体大小的。  
`存储结构`：属于结构体存储结构 

结构体存储时，是按照“构体成员的顺序”来进行存储的，每个成员的存储方式则又由成员的类型来决定。    

在很多同学的想象中，总认为成员之间是紧挨着的，其实不是的，中间其实可能有间隔，这个涉及到`结构体的对齐(当前成员变量和上一个成员变量大小对齐)`，这个我们以后再讲。    

不同结构体类型的成员类型、成员数量不同，所以不同结构体类型的存储结构是不一样的，就算是同一个结构体类型，将成员顺序改变后，也不一样  


##### 3）让编译器帮忙检查类型错误
如果编译器检查到类型有问题，就会帮我们报错或者报警告，提醒我们数据的使用可能有问题。

报错、报警告是好事，因为通过这些信息可以快速的帮我们排查问题，解决问题。  

如果没有类型检查的话，编译器就不会进行类型检查，那么与数据类型相关的错误，就只能由程序员自己来预防，当时显然这种方式很不靠谱。  
		
#### （5）=两边的类型问题  
等号的左边叫左值，右边叫右值，不管=是用于初始化，还是用于赋值，要求`右值必须与左值类型一致`。 

`左值`：必须是一个“可写”的变量空间   
`右值`：不定，可以是一个数，一个变量，一个常量  

```c
int a = 0;  //初始化：定义时就给值的就是初始化。   
a = 100;    //赋值：定义之后给值的，就是赋值 
```

类型一致有两种情况，第一种是天然一致，第二种是强行一致(强制转换)。

##### 1）天然一致
```c 
int a = 100;
```  
变量a的类型：int  
数据100的类型：100  

天然一致，其实就是什么类型的数据，就应该放到对应类型的空间中。  

##### 2）强制转换，强行一致
+ （a）显式强制转换
```c
int a = (int)12.45;
```
float被强制转为int后再，再将值给a  

```c
float a = 100.0;
int b = (int)a;
```  
float的100被强制转为int后再，然后再给b    

```c
int a = 103435455;
int b = (int)&a;	
```
`int *`的`&a`被强制转换int，然后再给b  

当然，并不是所有类型之间都可以强制转换的，比如：  
```c
float a= 134.454
int *p = (int *)a; 
```

将浮点强转为指针，这是毫无意义的，所以c不允许这种强制转换  

+ （b）隐式强制转换  
编译器在编译时，会默认将右值类型强制转换左值的类型，这就是隐式强制转换    

```c
int a = 12.56;
```
float 12.56被隐式转为int后，再给a  

```c
int a = 12.56;
char b = a;
```
int a被隐式转为char后，再赋给b  

```c
int a = 10;
char *p = a;
```
int被隐式转为`char *`

```c
int a = 10;
char *p = &a;
```
`int *`被隐式强制转为`char *`


像int a = 12.56这种基本类型的隐式强制转换，编译器在编译时是不会报警告的，但是像指针这种很重要的类型，编译时一定会报警告提醒你，两边类型不一致，让你警惕，因为编译器很担心这是你的误写。  

实际上我们并不提倡使用隐式强制转换，如果你确实需要进行“强制转换”，我们应该使用()进行显式强制转换，显式强制转换的目的：  

  + 让代码意思更明确，具有更强的可读性  
	否则其他程序员在看到你的代码时，可能认为因为误写才导致类型不一致的，而()可以明确表明，我这里就是要进行强制转换，程序有这个需求    

  + 不要让编译器误解  
	对于指针等重要的类型来说，虽然它会帮助你进行隐式强制转换，但是它一定会提警告，提醒你这里类型不一致，你需要注意  
	
	我们说编译器提警告是好事，因为这有利于程序员排查错误，为了不要让编译器报一堆的警告，干扰我们排查其它错误，我们也应该使用()，明确的告诉编译器，这里就是要进行强制准换，此时编译器就不要再报警告。  

	总之在编程时，如果能够让类型“天然一致”的话最好，否则就应该进行显式强制转换  
					
							
#### （6）函数传参和返回值的类型问题

##### 1）传参
传参时也有一个“=”的存在，编译器在翻译传参时，与翻译=是一样的，所以`传参等效于有一个=`  即 `形参 = 实参`

形参为左值，实参为右值  

如果传参时类型不一致的话，最好使用显式强制转换，不要使用隐式的  

一般时，都要求实参和形参类型一致  

##### 2）返回值：  
返回值与返回类型要一致，否者要强转，我们最好使用显式强制转换，不要使用隐式的  

```c
int fun(void)
{
    return (int)123.56;
}
```

		
#### （7）强制转换时，到底干了什么事
不管是隐式还是显式强制转换，强制转换时，其实就是强行的采用某类型去解释数据，然后将解释后的数据copy给左值  

#### 1）例子1
```c 
float a = 134.57
short b = (short)a;
```
按照short类型要求的“空间大小、存储结构”去解释a中的数据，然后copy给b    

short只有2个字节，float为4个字节，按照short类型解释时，只会强行解释a中头两个字节的空间，所以会丢失两个字节空间的内容  

而且存储类型也会从float转变为short（短整形）  


`疑问`：a的内容会发生改变吗？  
`答`：不会，只是读取a的内容时，会进行类型的强制解释，但是a中原有的内容不会改变，改变的只是复制的副本  


##### 2）例子2:
```c
char a = 'a';
int b = (int)a;
```
强行按照int去解释a中数据，然后copy给b   

a只有一个字节，b有四个字节，按照int型强行解释a空间时，a的一个字节是不够的，所以会把后面紧挨着的其它的三个字节也会解释进来  

这一个强制转换不会丢失数据，但是数据也可能会发生改变，因为会`多解释了其它空间的内容`  


##### 3）例子3:
```c
float a = 100.12;
int b = (int)a;
```

强行按照int去解释a中数据，然后copy给b。

a和b都是四个字节，空间大小都是一致的，但是存储结构不一致，此时数据也会发生变化，最终b中数据放的是100。


##### 4）例子4
```c
struct Student 
{
    int num;
    char name;
    float score;
};
struct Student stu = {100, "zhangsan", "98.0"};

struct Teacher
{
    char name;
    int num;
};
struct Teacher tea;

tea = (struct Teacher)stu;
```
强行按照struct Teacher类型去解释stu空间的内容，然后copy给tea  

struct Teacher的空间大小<struct Student，而且存储结构体也不一样的，所以强行按照struct Teacher去解释stu时，不仅数据会丢失，数据的存储结构也改变      

在struct Student类型中，头四个字节解释为一个成员，但是按照struct Teacher解释时，第一个字节为一个成员，其实每个字节的内容并没有改变，只是各自的解释方式不同了  


##### 5）总结强制类型转换
通过前面的例子可以发现，进行强制转换时，并没有改变空间每个字节中的01011001这些内容，只是各自按照不同的类型去解释而已      

强制解释时，会出现如下问题：  
+ （a）可能丢失部分空间中数据  
+ （b）可能会多包含其它空间的数据  
+ （c）存储结构会发生变化   

所以进行强制转换时，一定要小心，只有当以上可能结果都被我们接受时，而且确实需要强制转换时，我们才会进行强制转换   

在正常情况下，我们更多是还是要，尽量的让类型天然的一致  

