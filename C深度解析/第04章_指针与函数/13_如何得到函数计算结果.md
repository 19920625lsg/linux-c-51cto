13. 如何得到函数的计算结果
	当然并不是所有的函数都需要返回计算结果，但是如果需要得到计算结果的话，应该怎么办呢？
	

13.1 通过返回值的得到结果
	int fun(int a)
	{
		...
		return ***;
	}
	
		如果return的返回值不能确定，可以返回void *：
	
	void *fun(type)
	{
		if(type == 0)
		{
			int a;
			...
			return (void *)a;
		}
		else if(type == 1)
		{
			static struct student stu;
			...
			return (void *)&stu;
		}
	}	
	
	int main(void)
	{
		
		int a = (int)fun(0);
		
		struct student *stup = (struct student *)fun(1);
		
		return 0;
	}
	
	疑问：例子中的a和stu为什么需要加static修饰？
	答：如果不加static修饰的话，就是自动局部变量，函数运行结束后，自动局部变量就会被释放，此时就会返回
	一个被释放空间的指针，操作被释放的空间是很危险的，因为释放后的空间可能会被其它变量使用。
		加了static修饰后就是静态局部变量了，只要程序还活着，静态局部变量就会一直存在，不需要担心。
		

13.2 通过传参返回计算结果
	通过传参返回的意思就是，可以通过指针来修改实参，从而返回计算的结果。
	
	void fun(int a, int b, int *p1, int *p2)
	{
		*p1 = a * a;
		*p2 = b * b;
	}
	
	int main(void)
	{	
		int ret1 = 0;
		int ret2 = 0;
		
		fun(10, 20, &ret1, &ret2);
		
		return 0;
	}
	
	通过指针传参来返回计算结果时，可以返回多个值，如果要返回的值非常多的话，也可以封装为结构体返回。
	
	封装为结构体返回时，可以使用return返回，也可以还是用传参来返回。
	
	
	在库函数、OS API里面，retrun和参数返回是怎么用的：
	
	return的返回值：往往用于说明函数是否调用成功，一般返回0表示调用成功，返回-1表示调用是失败
	返回计算结果：使用传参方式返回
	
	int fun(int a, int *p)
	{
		if(NULL != p)
		{
			*p = a * a;
			
			return 0;
		}
		else 
		{
			return -1;
		}
	}
	
	int main(void)
	{
		int ret = 0;
		int va = 0;
		
		ret = fun(10, &va);
		if(-1 == ret )
		{
			printf("fun fail\n");
		}
		else 
		{
			printf("va = %d\n", va);
		}
	
		return 0;
	}