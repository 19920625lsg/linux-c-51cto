
=====================================-=============================================================================
============================物联网、嵌入式技术课程 之 《C深度解析》================================================
===================================================================================================================
					
出品：佳嵌工作室
--------------------------------------------------------------------------------------------------------------------
	“佳嵌工作室”致力于物联网、嵌入式产品以及‘物联网、嵌入式技术课程’的研发，希望所推出的技术课程，能够帮助到正在努力
学习物联网、嵌入式的同学，欢迎大家和我们一起共同学习，共同进步。
--------------------------------------------------------------------------------------------------------------------

第四章 指针与函数
	
	指针与函数的重要性，即便我不强调，我想大家也是非常的清楚。
	
1. 本章知识结构
	1. 存储空间、符号、地址
	2. 指针
	3. 指针类型
	4. 一级指针与多级指针	
	5. 野指针与段错误
	6. void *指针类型
	7. const与指针
	8. 函数指针 
	9. 函数调用
	10. 函数指针的应用举例————回调函数和函数指针数组
	12. 指针与函数传参
	13. 递归函数
	14. 内联函数
		
		
	就指针本身的概念来说，其实很简单，很多同学一直觉得指针很难，其实难的并不是指针概念本身，而是当数组、函数、
字符串等与相关联时，所涉及到的指针形态很复杂，因此很多同学被弄的晕头转向的，所以如果大家对数组、函数、字符串等
这些问题搞清楚了，指针自然就都搞明白了。
	
	当然，本章重点集中在“指针概念与函数”，至于数组、字符串就留到后面章节再介绍。


课程内容：

1. 存储空间、符号、地址

1.1 存储空间

1.1.1 什么是存储空间
		就是程序代码和数据的存放空间，笼统可以分为如下两种情况。
		
		没有运行时：
			存储在硬盘（外存）上，所以此时的存储空间为硬盘。
		
		运行时：
			代码和数据存放在内存上，供cpu访问。
			
			当然程序在运行时，还需要用到寄存器和cache，寄存器和cache同样也是存储器，它是用于缓存内存中的代码和数据，
			
		所有这些存储器（硬盘、内存、寄存器、cache）都是由单个字节堆叠而成，存储空间中的每个字节都有自己的地址
	，如果没有地址的话，是无法访问它们的，每个字节的地址就好比是每个字节的门牌号。
	
		一般来说，当我们说存储器时，主要指的是内存。
			
		
1.1.2 程序运行时，cpu是如何访问内存中的代码和数据的

		存储器中的每个字节都有地址，这个地址就是每个字节的门牌号，通过地址就能找到每一个字节并访问它，
	访问权限有两种：
	
	· 可读可写
			程序的“.data、.bss、堆、栈空间”就是可读可写的。
			
			变量空间要求是可读可写的，所以变量空间就开辟于这些中。
			
	· 只读
			.rodata、.text为只读的。
			代码和常量只能被读，所以代码和常量就放在这两个中。

			
		疑问：怎么没有“不可读不可写”和“只写”的权限呢？
		答：两种权限没有意义
		· 不可读不可写：这个存储空间没有任何作用
		· 只写：写入数据的目的是为了读出，只写入不读出，这种权限的存储空间也没有任何意义

			
1.1.3 地址 与 指针
（1）地址是个啥
			地址就是一个数，这个数可以唯一标记每个字节的存在，就好比人的身份证一样，也是一个数，可以唯一的标记每个
		人的存在。
		
			举个例子，如果内存大小为4G，那么内存的地址范围就是
		
			0x00000000 ~ 0xFFFFFFFF：十六进制表示时的范围
					0      ~    4G-1	 ：十进制表示时的范围
			
			
			0x00000000 ~ 0xFFFFFFFF这个地址，就是一些用来唯一标记字节空间的数。

			
（2）指针就是地址的另一个名字
		为什么地址也称为“指针”呢？
		
		通过某地址能够唯一的访问某个字节，所以地址唯一的指向了某字节，这就像“指针”一样具有指向作用，因此才被形象的
	称为了“指针”。
		
		这就好比我知道你们家的地址，然后就能找到你们家，此时就说“你们家的地址”是指向你们家的指针。
		
		所以记住了，指针就是地址，地址就是指针。
		
		
（3）指针与指针变量

		指针：地址。
		
		指针变量：存放地址（指针）的变量
			
			int a;
			int *p = &a; 
			
			&a：a的指针
					a有四个字节，每个字节都有地址，但是只有第一个字节的地址才是a的指针，为什么是这样的，后面在解释。
				
			p：放地址（指针）的指针变量
				
				这里要注意一点，指针变量里面放了指针后，我们就说p指向a，但是我们自己应该清楚，具有指向作用的是p里面的
			指针（地址），而不是指针变量，指针变量只是放指针的篮子。
				
				指针变量里面的指针发生变化后，这个指向就发生变化了，所以说对于指针变量来说，具有指向作用的是里面放的指针，
			不是指针变量本身。
			
				不过以后为了称呼的方便，我们往往会将“指针变量”也简称为指针，所有平时称呼“指针”的时候，有可能指的地址，也可
			能指的是指针变量，就看说话的语境，不过在本章里面，为了表达更清晰，我会按照准确的名字来称呼。


1.1.4 符号与地址

（1）程序运行时，访问存储空间是核心动作

		1）CPU执行的代码从哪里来
				要访问.text所对应存储空间。
		
		2）CPU按照代码要求去加、减、乘、除、与、或、非运算数据时，数据从哪来
			（a）变量数据：需要访问.data、.bss、堆、栈空间。
			（b）常量数据：需要访问.text、.rodata的空间。
			
		3）计算后的结果
				得到这结果后，这个结果数据不管是拿去给USB输出，还是给LCD显示，还是给扬声器播放，还是控制机械手臂，
			都要先在.data、.bss、堆、栈中开辟变量空间，暂存这个结果数据，然后再将结果数据输出外设的寄存器、显存、声卡等，
			就可以控制USB、LCD、扬声器、机械手臂等外设工作了。
			
				其实寄存器、显存、声卡等同样也是存储器，也是通过地址去操作的，只不过这些事情往往都是由驱动程序去做的。
			
				对于应用程序俩说，主要访问的存储器是内存，而不是寄存器、显存、声卡这些玩意，这些是由驱动程序来访问的。
			
			
（2）符号 与 地址
		前面说过，都是通过地址来访问存储空间的，直接通过地址来访问的话很不人性化的，所以在高级语言里面，地址都被替
	换为了符号。
		
		比如我使用某个变空间，在高级语言里面，就通过变量名来访问，变量名就是一个符号，通过这个符号就可以操作这个变量，
	不必直接使用地址。
		
		所以在高级语言的程序里面，程序员基本只见符号，不见地址，正是由于这样的做法，使得高级语言的语法相对汇编来说，
	非常的人性化，因为直接操作地址的话，你需要了解硬件结构，特别是存储器的结构，否则你就不知道应该操作那个地址，
	这就很痛苦，但是变成符号后，程序员不用关心这些，只关心符号即可。
	
		编译后，符号虽然会被转化为地址，但是在高级语言的语法里面，符号并不直接等于地址，你不能直接当做地址来使用，
	在高级语言里面，符号会受到作用域的限制，缺少一定的灵活性。
	
		所以为了能够更加自由的操作存储空间，像c/c++这种高级语言，除了能够使用符号来操作外，它还允许直接使用地址来操作，
	使用地址来操作时，可以不受符号作用域的限制。
	
	1）作用域受限的例子。
		a.c
		int fun1(void)
		{
			int a = 200;
		}
		
		int fun2(void)
		{
			int a;
			
			fun1(a);
		}
		
		fun1和fun2中a的作用域，只在自己函数中有效，所以通过修改fun1的a，对fun2中a不受影响。
		
		a.c                     b.c
														static int flag = 0;
		int fun(void)           static int fun1()
		{                       {
			flag = 100;           	...
			fun1();               }
		}												
		
		
		flag和fun1的作用域只在b.c中，因此a.c中的fun函数无法引用。
		
		
		疑问：作用域限制是好还是坏？
		答：有好有坏。
			好处：防止相互干扰，比如防止命名冲突，防止相互篡改数据等
			缺点：作用域限制太严，会使得编程过于死板，不够灵活
				所以像c/c++为了更加的灵活，就加入直接的地址操作，这样就可以取一个折中，既可以受到作用域的限制，又可以保
			持灵活性，比如看下面的例子。

			
	2）修改上面的例子
		
		a.c
		int fun1(int *a)
		{
			*a = 200;
		}
		
		int fun2(void)
		{
			int a;
			
			fun1(&a);
		}
		
		直接改fun1和fun2的a，相互不受影响，这个是作用域在发挥作用。
		但是由于fun2将a的地址（指针）传给fun1的a，所以在fun1中通过*a就可以读写fun2中a，又可以修改fun2中的a，如此就有
	了相当的灵活性。
	
	3）再举一个例子
		a.c                     								b.c
																						static int flag = 0;
		int fun(int *flag, void (*fun1p)())     static int fun1()
		{                       								{
			*flag = 100;  //引用flag        	 			...
			fun1p(); //调用fun1               									
		}																				}
																					
																						static int fun2()
																						{
																							fun(&flag, fun1);
																						}
		
		
			flag和fun1是a.c本地的，在a.c中时无法直接调用的，但是通过fun(&flag, funp)将flag和fun1的地址传递给a.c中
		的fun后，fun通过地址依然能够引用flag和fun1。
		
		疑问：为什么不将static直接改为extern？
		答：这样当然也能解决问题，而且一般情况也都是使用这种方式来解决的，但是当工程代码写的复杂后，必须对于函数全局
		全局变量的作用域进行限制，这样可以有更好封闭性，特别当代码需要进行逻辑上的分层时，那么不同层必须需要有相当
		的封闭性，在封闭之后层与层之间的对接，就需要靠这种方式来实现。
			当然对接函数必须是extern的，比如，如果例子中连fun函数都是static的，那就完全隔离了。
	
			疑问：封闭性的好处？
			· 防止命名冲突
			· 防止胡乱引用
			· 防止数据篡改
	
			这就好比为了防止两个区域相互干扰，那就需要建立围栏加以限制，但是不能完全封死，为了让区域间还能沟通，所
		以还得留下一道门。
		
			在上面的例子中，void (*fun1p)()中fun1p是函数指针变量，有关函数指针变量，本章后面再详介绍。
		
		
	4）java/c#等语言中有指针吗？
			在java和c#等高级语言中，并不允许在代码中直接操作地址，只能使用符号来操作，虽然没了指针后，灵活性
		降低了，但是也同时规避了指针所带来的风险，因为指针不受作用域限制，直接通过地址操作空间，因此存在潜在的危害，
		没有了指针，这种风险自然也就没有了，不过代价就是灵活性降低了。
			

						
出品：佳嵌工作室
--------------------------------------------------------------------------------------------------------
	“佳嵌工作室”致力于物联网、嵌入式产品以及‘物联网、嵌入式技术课程’的研发，希望所推出的技术课程，能够帮助
到正在努力学习物联网、嵌入式的同学，欢迎大家和我们一起共同学习，共同进步。
--------------------------------------------------------------------------------------------------------
		
1.1.5 数据的类型

（1）空间第一个字节的地址
			代码、变量、常量空间，往往都是连续的一片字节空间，到底哪一个字节的地址才代表整个空间的地
		址（指针）呢，我们前面说过，第一个字节的地址是整个空间的指针。


（2）如何访问一片连续字节空间
		只要知道如下几件事即可。
		
		1）知道第一个字节的地址
		2）知道访问到第几个字节结束
		3）知道如何解析里面存放的数据
		
		如此就能正确访问连续字节中的数据，不管是访问函数、变量、常量，都是这样来访问的。
		
		例子1：
			访问int变量的空间，int是四个字节组成的一片连续空间，如何访问呢？
		
			1）知道第一个字节的地址
			2）int的大小为4个字节，显然就知道了访问到那个字节结束
			3）数据类型为整型，数据的存储结构就是整形的存储结构，访问空间时，需要按照“整形存储结构”去解析空间。
			
		
		例子2：
			访问float变量的空间，float也是四个字节组成的一片连续空间，如何访问呢？
			
			1）知道第一个字节的地址
			2）知道大小为四个字节
			3）知道是float类型，那么数据就是以浮点形式存储的，读写空间时就必须按照浮点存储方式来解析空间。
				
			疑问：浮点数是如何存储的？
				是以科学计数法来存储的，比如
							  
								转为科学计数法就是           指数
				12.3  ——————————————————————>  123 * 10的-1次方
				
				疑问float为例，float空间总共32位：
				 31 30 29 28 27 26 252 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 0
				 
				· 最高位（31）：符号位，0表示正数，1表示负数
				· 23~30：指数（1）
				· 0~22：整数（123）
					
					比如向float的空间写数据时，按照这个结构来存储12.3的。
		
				
（2）回顾C语言的数据类型
		对于绝大多数高级语言来说，都是有数据类型的，以c为例，就有大量的数据类型。
		凡是有数据类型的语言，我们都成为强类型语言。

		1）基础数据类型
			（a）整形：char short int long，这些还可以与unsigned进行组合，unsigned char,... 
			（b）浮点：float double，注意浮点都是有符号的，浮点不能和unsigned进行组合，不存在无符号浮点数一说，
					
					
		2）组合数据类型
			由基础型演变而来。

			（a）结构体、联合体类型
					/* 结构体类型 */
					struct Student
					{
						int 	num;  //基础类型
						char 	name; //基础类型
						...
					};
					
					/* 联合体类型 */
					union Student
					{
						int 	num;  //基础类型
						char 	name; //基础类型
						...
					};
				
			（b）指针类型
					int *，float *，struct Student *, union Student *。
					int **，float **，...。
					
					疑问：有联合体指针吗？
					答：有，不过用的很少，后面课程讲联合体时，还会提到的。
		
		
（2）数据类型的意义
		1）给程序员看到
			比如你一看到变量类型，就知道应该放什么类型的数据到变量里面。
		
		2）数据类型决定了空间大小和存储结构
				比如：
				
			（a）例子1
					int a;
					a = 100;
					
					空间大小：4字节
					存储结构：整形存储结构
					
					编译器在编译时，就知道给a预安排多大的空间，存储结构是怎样的。
					
					float a;
					a = 100.7;
					
					空间大小：四个字节
					存储方式：浮点存储方式
					
					
			（b）例子2:
					struct Student 
					{
						int num;
						char name;
						float score;
						...
					};
					struct Student stu;
					
					空间大小：基本>=各成员之和，我们后面学习了结构体的对齐后，其实是能算出具体大小的。
					存储结构：属于结构体存储结构
						结构体存储时，是按照“构体成员的顺序”来进行存储的，每个成员的存储方式则又由成员的类型来决定。
						在很多同学的想象中，总认为成员之间是紧挨着的，其实不是的，中间其实可能有间隔，这个涉及到结
					构体的对齐，这个我们以后再讲。
						
						不同结构体类型的成员类型、成员数量不同，所以不同结构体类型的存储结构是不一样的，就算是同一
					个结构体类型，将成员顺序改变后，也不一样。
							
							
		3）让编译器帮忙检查类型错误
				如果编译器检查到类型有问题，就会帮我们报错或者报警告，提醒我们数据的使用可能有问题。
				报错、报警告是好事，因为通过这些信息可以快速的帮我们排查问题，解决问题。
				
				如果没有类型检查的话，编译器就不会进行类型检查，那么与数据类型相关的错误，就只能由程序员自己
			来预防，当时显然这种方式很不靠谱。
		
		
（3）=两边的类型问题  
			等号的左边叫左值，右边叫右值，不管=是用于初始化，还是用于赋值，要求右值必须与左值类型一致。
			
			左值：必须是一个“可写”的变量空间
			右值：不定，可以是一个数，一个变量，一个常量
			
			int a = 0;  //初始化：定义时就给值的就是初始化。 
			a = 100;  	//赋值：定义之后给值的，就是赋值
				
				
			类型一致有两种情况，第一种是天然一致，第二种是强行一致。
			
			
		1）天然一致
			int a = 100;
			
			变量a的类型：int
			数据100的类型：100
			
			天然一致，其实就是什么类型的数据，就应该放到对应类型的空间中。
			
		2）强制转换，强行一致
			（a）显式强制转换
					int a = (int)12.45;
					float被强制转为int后再，在将值给a。
					
					float a = 100.0;
					int b = (int)a;
					float的100被强制转为int后再，然后再给b。

					int a = 103435455;
					int b = (int)&a;	
					int *的&a被强制转换int，然后在给b。
					
					
					当然，并不是所有类型之间都可以强制转换的，比如：
						float a= 134.454
						int *p = (int *)a; 
					
						将浮点强转为指针，这是毫无意义的，所以c不允许这种强制转换。
					
			（a）隐式强制转换
					编译器在编译时，会默认将右值类型强制转换左值的类型，这就是隐式强制转换。
					
					int a = 12.56;
					float 12.56被隐式转为int后，再给a。
					
					
					int a = 12.56;
					char b = a;
					int a被隐式转为char后，在都给b。
					
					int a = 10;
					char *p = a;
					int被隐式转为char *。
					
					
					int a = 10;
					char *p = &a;
					int *被隐式强制转为char *。
						
				
					像int a = 12.56这种基本类型的隐式强制转换，编译器在编译时是不会报警告的，但是像指针这种很重要的
				类型，编译时一定会报警告提醒你，两边类型不一致，让你警惕，因为编译器很担心这是你的误写。
					
					实际上我们并不提倡使用隐式强制转换，如果你确实需要进行“强制转换”，我们应该使用()进行显式强制
				转换，显式强制转换的目的：
				
				· 让代码意思更明确，具有更强的可读性
						否则其他程序员在看到你的代码时，可能认为因为误写才导致类型不一致的，而()可以明确表明，我
					这里就是要进行强制转换，程序有这个需求。
					
				· 不要让编译器误解
						对于指针等重要的类型来说，虽然它会帮助你进行隐式强制转换，但是它一定会提警告，提醒你这里
					类型不一致，你需要注意。
					
						我们说编译器提警告是好事，因为这有利于程序员排查错误，为了不要让编译器报一堆的警告，干扰我
					们排查其它错误，我们也应该使用()，明确的告诉编译器，这里就是要进行强制准换，此时编译器就不要再
					报警告。
					
						总之在编程时，如果能够让类型“天然一致”的话最好，否则就应该进行显式强制转换。
					
					
					
（3）函数传参和返回值的类型问题

	1）传参
			传参时也有一个“=”的存在，编译器在翻译传参时，与翻译=是一样的，所以传参等效于有一个=。
			
			形参 = 实参
			
			形参为左值，实参为右值。
			
			如果传参时类型不一致的话，最好使用显式强制转换，不要使用隐式的。
			
			一般时，都要求实参和形参类型一致。
			
	2）返回值：
		返回值与返回类型要一致，否者要强转，我们最好使用显式强制转换，不要使用隐式的。
		
		int fun(void)
		{
			return (int)123.56;
		}
		
		
（4）强制转换时，到底干了什么事
		不管是隐式还是显式强制转换，强制转换时，其实就是强行的采用某类型去解释数据，然后将解释后的数
	据copy给左值。
		
		1）例子1
			float a = 134.57
			
			short b = (short)a;
			按照short类型要求的“空间大小、存储结构”去解释a中的数据，然后copy给b。
			
			short只有2个字节，float为4个字节，按照short类型解释时，只会强行解释a中头两个字节的空间，所以会丢
		失两个字节空间的内容。
			
			而且存储类型也会从float转变为short（短整形）。

			
			疑问：a的内容会发生改变吗？
			答：不会，只是读取a的内容时，会进行类型的强制解释，但是a中原有的内容不会改变，改变的只是复制的副本。

			
		2）例子2:
			char a = 'a';
			
			int b = (int)a;
			
				强行按照int去解释a中数据，然后copy给b。
				
				a只有一个字节，b有四个字节，按照int型强行解释a空间时，a的一个字节是不够的，所以会把后面紧挨着的
			其它的三个字节也会解释进来。
				这一个强制转换不会丢失数据，但是数据也可能会发生改变，因为会多解释了其它空间的内容。
					
					
		3）例子3:
				float a = 100.12;
				int b = (int)a;
				
				强行按照int去解释a中数据，然后copy给b。
			
				a和b都是四个字节，空间大小都是一致的，但是存储结构不一致，此时数据也会发生变化，最终b中数据放
			的是100。

			
		4）例子4
			struct Student 
			{
				int num;
				char name;
				float score;
			};
			struct Student stu = {100, "zhangsan", "98.0"};
			
			struct Teacher
			{
				char name;
				int num;
			};
			struct Teacher tea;
			
			tea = (struct Teacher)stu;
			强行按照struct Teacher类型去解释stu空间的内容，然后copy给tea。
			
			struct Teacher的空间大小<struct Student，而且存储结构体也不一样的，所以强行按照struct Teacher去
			解释stu时，不仅数据会丢失，数据的存储结构也改变。
			
				在struct Student类型中，头四个字节解释为一个成员，但是按照struct Teacher解释时，第一个字节为一
			个成员，其实每个字节的内容并没有改变，只是各自的解释方式不同了。
			
			
		4）总结强制类型转换
				通过前面的例子可以发现，进行强制转换时，并没有改变空间每个字节中的01011001这些内容，只是各自按
			照不同的类型去解释而已。
				
				强制解释时，会出现如下问题：
			（a）可能丢失部分空间中数据
			（b）可能会多包含其它空间的数据
			（c）存储结构会发生变化 
				
				所以进行强制转换时，一定要小心，只有当以上可能结果都被我们接受时，而且确实需要强制转换时，
			我们才会进行强制转换。
				
				在正常情况下，我们更多是还是要，尽量的让类型天然的一致。

				
				
				
				
出品：佳嵌工作室
--------------------------------------------------------------------------------------------------------
	“佳嵌工作室”致力于物联网、嵌入式产品以及‘物联网、嵌入式技术课程’的研发，希望所推出的技术课程，能够帮助
到正在努力学习物联网、嵌入式的同学，欢迎大家和我们一起共同学习，共同进步。
--------------------------------------------------------------------------------------------------------
						
2. 指针
2.1 指针与指针变量

2.1.1 指针
	前面说过，指针就是地址，指针和地址是同义词。
		
2.1.2 指针变量
	存放指针的变量就是“指针变量”。
	
	
2.2 *与&

2.2.1 & 
（1）&作为双目运算符使用时，为“位与”运算符
		int a = 0x10;
		int b = 0x04;
		
		int c = a & b;

		
（2）&作为单目运算符使用时，为取地址运算符
		1）取变量的地址
			int a = 100;
			
			&a代表的是a变量第一个字节的地址，也即是a的指针。
			
		2）取函数的地址
			int fun()
			{
				
			}
			
			&fun即函数的指针，也即函数代码所在空间第一个字节的地址，只不过为了方便使用，往往将&省略，也就是
		说函数名可以直接代表函数的指针。
			也就是说fun与&fun等价。
		
		
		3）取数组的地址
			int buf[7] = {0};
			
			&buf为整个数组的地址，注意是整个数组的地址，不是数组第一个元素buf[0]的第一个字节的地址（指针），
		&buf[0]和buf才是，与数组指针相关的内容，我们留到讲数组时再介绍。
			

			
2.2.2 *
	*作为双目运算符时是乘号，作为单目运算符时则与指针有关。

（1）用于组建指针类型
		*与int/float/struct Student等类型相结合，构成指针类型。
		
		int a = 100;
		int *p = &a;
		
		图示：
		
		
		此时p和a是两个不同的变量，各自拥有自己独立的变量空间。
		a：是整形变量，用于存放整形数100
		p：是指针变量，用于存放整形变量a的指针。

		由于p中存放了a的指针，所以我们说p也指向了a，但是我们前面说过，本质是p里面放的指针指向a。
		
		什么叫“指向”？
		答：指向的意思就是，可以通过这个地址找到对应的空间，并访问它。
		
		
（2）解引用时
		int a = 100;
		int *p = &a; 
		
		*p = 200;  //*p：解引用
		
		
		此时整个*p代表就是p中指针所指向的空间，也就是a的空间，所以*p=200与a=200的效果是一样的。
		此时*的作用就是解引用，解引用时*p是一个整体。
		
		这里还要注意的是，使用*解引用时，其实解引用的是p中的指针，而不是p本身，p只是装指针的容器。
		
		
		
		
		总结解引用的目的：找到指针所指向空间，找到后我们就可以访问（读写）它了
		读：从空间读数据
			int a = 100;
			int *p = &a; 
			
			int c = *p; //从*p所代表的空间中读数据
			
		写：修改空间数据
			int a = 100;
			int *p = &a; 
			
			*p = 200; //往*p所代表的空间中写数据
		
		
		
2.2.3 在c程序中，获取存储空间地址（指针）方式有哪些		
（1）直接获取数字形式的地址

		int *p = (int *)0x4234f5e4;
		*p = 200; //向0x4234f5e4所指向的空间，写入200

		
		像这种方式有个前提，那就是程序员需要事先知道这个地址所对应的空间是可用的，可用的意思是？
		1）地址对应的空间存在
		2）这个空间没有被别人（变量、常量、代码）使用
		3）空间的访问权限，能够满足我们的访问要求

		
		在纯应用的c程序中，我们是不知道具体哪个地址是可用的，我们只能采用&a等方式来使用，编译器在编译时，
	会将它变为具体的地址值，程序员不需要具体的地址值。
		
		疑问：什么时候会直接使用数字形式的地址呢？
		
		答：这个一般在单片机、驱动等偏硬件的c程序中才会用到，因为开发偏底层的程序时，往往会直接通过数字形式
		的地址来访问存储空间，为什么会这样呢？
			其实只要你学习过单片机和驱动，你很容易就能理解我所说的，否则就算我解释了你不太明白，所以目前大家
		只需要知道存在这种情况即可。
			
			我们目前讲的各种c例子程序，都是属于应用的c程序，与底层硬件无直接关系，所以我们不会用到纯粹数
		字形式的地址。
		
		疑问：进行单片机、驱动开发时，我怎么知道具体那个数字地址可用？
		答：我们需要产看硬件的说明手册。
			
（2）使用&
			int a;
			int *p = &a;
			*p = 200; 
			
				作为程序员的我们，其实并不知道a的指针具体是多少，所以无法直接使用数字形式的地址，所以只能使
			用&a方式来代表，编译器会把它变为具体的地址。

				这里一定要注意，a不是指针，a只是一个的符号，&a才是a的指针。
			
			
（3）malloc返回地址
		int *p = malloc(4);
		
		malloc从堆中开辟空间后，程序员也不需要知道这个空间的指针（第一个字节的地址）是多少，也没法知道，因为
	malloc在运行的过程时才会到堆中开辟空间，到那个时候才知道。
			
		所有只能是在运行的过程中，让malloc将地址（指针）返回并放在p中，然后通过p去间接的使用指针。
	
	
（4）某些符号本身就是地址（指针）
		1）例子1
			char *p = "hello wolrd，it is butefull"的情况
			
				"hello wolrd，it is butefull"是一个字符串常量，它放在了.rodata中，而p中放的是
			"hello wolrd，it is butefull"所在常量空间的指针。
			 
			 图：
					
					
			 千万不要以为字符串存放在了p中，p只有4或8个字节，这个字符串存放时需要十几个字节，不可能将字符串放到
			p中的，所以p中只能放字符串的指针，然后通过这个指针去访问常量空间中的字符换。
			 
			 对于程序员来说，我们并知道字符串所在常量空间的指针是多少，所以在c语法中，此时整个字符串
		 "hello wolrd，it is butefull"就直接代表那个指针。
			
			疑问：char buf[] = {"hello wolrd"}，这种情况也是的吗？
			答：这种情况不是的，此时字符串字节放在了数组中，所以这里的"hello wolrd"不代表指针。
			
			
		2）例子2
			int fun()
			{
				
			}
			fun这个符号就是函数的指针，即函数代码所在空间的第一个字节的地址。


							
2.2.4 解引用时，指针的使用方式有哪些		
	两种，一种是直接使用，另一种是间接使用。
	
（1）直接使用
		直接对指针进行解引用，这就是直接使用。
		
		1）例子1
			*((int *)0x43355435) = 100;
		
		2）例子2
			int a;
			*(&a) = 200;
		
			
			
（2）间接使用  				
		先放到指针变量中，然后通过指针变量去使用。
		
		int a = 10; 
		int *p = &a;
		
		*p = 200;  
		
		这种间接的使用方式，才是我们最常见的方式。
		
		这里一定要注意，指针变量只是一个放指针的“篮子”而已，真正起作用的是里面所放的指针。
		
	
2.2.3 *和&互为逆向运算符
		int a = 100;
		int *p = &a;
		
		*p = 200; 
		
		由于p中放的是&a，而解引用的是p里面的指针，所以*p = 200实际上就等价于*&a = 200;
		
		*&a的意思就是，找到&a这个指针所对应的空间，其实就是a的空间，因此*&a = 200等价于a=200。
		
		其实相当于*和&相互抵消了，因为这两个能相互抵消，所以*和&互为逆向运算符，就好比+-、*/互为逆向运算一样。	
	
	
	
	
	
	
	
	
			
出品：佳嵌工作室
--------------------------------------------------------------------------------------------------------
	“佳嵌工作室”致力于物联网、嵌入式产品以及‘物联网、嵌入式技术课程’的研发，希望所推出的技术课程，能够帮助
到正在努力学习物联网、嵌入式的同学，欢迎大家和我们一起共同学习，共同进步。
--------------------------------------------------------------------------------------------------------
		
	
2.3 所有指针变量的大小（宽度）都是固定的

2.3.1 为什么指针变量的大小都是一样的？

	因为存储空间所有字节的指针都是相同“宽度”的，
		
		
	比如，如果地址宽度是32位的话，那么每个字节的地址都是32位的。
	比如，如果地址宽度是64位的话，那么每个字节的地址都是64位的。
	
		图：
		
		
		
	既然所有字节的指针宽度都是一样的，因此所有指针类型的宽度也都是一样的，
		int *
		float *
		struct Student *
		double *
		
		以上所有指针类型所规定的“宽度”是相同的，使用这些类型所定义的指针变量，其宽度也都是一样的。
	
		指针变量是用来存放指针的，既然所有指针的宽度都是一样，那么存放指针的指针变量的宽度必然也是一样。
		
	
	
（5）测试自己Linux和Windows下地址的宽度。
		#include <stdio.h>

		int main(void)
		{
			int *p = NULL;
			
			printf("%d\n", sizeof(p)); //或者sizeof(int *))

			return 0;
		}
		
		我这边的情况：
		1）windows
			地址宽度为32位（4字节）。
			
		2）Linux
			地址宽度为64位（8字节）。
			

			
			

3 指针类型
3.1 指针的类型长什么样子
	指针类型由基本类型 + *组成。
	int *
	float *
	...
	
3.2 定义指针变量
	定义时，在指针类型*的后面加上变量名即可。
	int *p;

	int **p;
		
		
3.3 指针类型中基本类型的作用
		在前面就说过，int */struct student *等指针类型的宽度都是固定的，既然“宽度”固定的，那么指针
	类型中区分int、struct Student等基本类型有什么意义呢？
		
		其实意义就在于，正是由于有int、struct Student等基本类型，所以对指针进行解引用时，才能正确的解
	释指针所指向的空间，比如:
	
		int a = 100;
		int *p = &a;
		
		*p = 10000;
		
		a的空间有4个字节，访问a的空间，只需要知道如下三件事：
		（1）知道a第一个字节的地址，即a指针
		（2）知道访问哪一个字节时结束
		（3）知道空间的存储结构
		
		*p解引用时，很显然是能够知道以上三件事的
		（1）p中放的就是a指针
		（2）int *中的基本类型为int，所以访问指针所指向的空间时，需要访问的空间大小为四个字节
		（3）int *中的int也指明了，在访问指针所指向的空间时，按照整形的存储结构来解析的
			
		总之对指针进行解引用时，指针类型中基本类型的作用，就是用于决定对所指向空间的解释方式。
			
		指针类型都是固定宽度的，指针类型中的基本类型，与指针本身宽度无关，只与指针所指向空间的宽度有关。
		
		
3.4 对指针进行强制转换
	前面说过=两边的类型必须一致，自然也包括指针类型。
	
（1）天然的一致
		int a = 100;
		int *p = &a;
		
		&a：a的指针，指针的数据类型为int *
		p：指针变量，类型也为int *
	
	
（2）通过“强制转换”来保证类型一致
		double a = 100.6;
		
		float *p = &a;            //隐式强制转换
		float *p = (float *)&a;   //显式强制转换
		
		
（3）强制转换时做了什么
			强制转换时，&a本身的值不改变，变的只是对指针所指向空间的“解释方式”。

			double a = 100.6;
			float *p = (float *)&a;
			
			*p = 12.6;
			
			&a：指针类型为double *
			p：float *
			
			两边的类型不一致，因此需要做强制转换。
			
			直接使用&a访问所指向的空间时，
				*(&a) = 200.02;
			
			是按照double类型来解释的，但是将指针强制转换为float *后，再使用该指针去访问时，就会以float的类型
		去访问。
			图：
			
			
			struct Student
			{
				int 	num;  
				char 	name; 
				float score;
			};

			struct Teacher
			{
				char 	name; 
				int 	num; 
			};
			
			struct Student stu = {123, "zhangsan", 87.6};
			
			struct Teacher *stup = (struct Teacher *)&stu; //&stu为结构体指针，即第一个字节的地址 
			
			指针类型被强转为struct Teacher *后，通过stup解引用访问stu的空间时，则会以struct Teacher类型来解析。
			
			
			
			指针（地址）就是一个数，至于这个数应该如何解释，就看这个数的类型，比如：
			
			int a = 0;
			
			· &a：为int *的指针，解引用时按照整形来解释&a所指向的空间。
			
			· (int)&a：此时这个数就只是一个普通的整形数，此时不再是一个指针，不能进行解引用
			
			· (void *)&a：为void *指针，这是一个空类型指针
					空类型指针仅仅就是一个指针，不能被直接解引用，如果要解引用的话，必须将指针强制转换为
				int *、float *等具体指针类型，然后才能进行解引用，后面还会再次介绍void *。
			
			· (struct student *)&a：结构体指针，解引用时会按照student student结构来解释。
					a的合法空间只有4个字节，但是由于struct student类型大小>4个字节，所以按照struct student进行解
				引用访问时，所访问的空间会超过4个字节，这样会访问到其它的非法空间。
					图：
					
					所以在实际编程中进行强制转换时，我们必须慎重使用强制转换。
				
				
				
				
				
出品：佳嵌工作室
--------------------------------------------------------------------------------------------------------
	“佳嵌工作室”致力于物联网、嵌入式产品以及‘物联网、嵌入式技术课程’的研发，希望所推出的技术课程，能够帮助
到正在努力学习物联网、嵌入式的同学，欢迎大家和我们一起共同学习，共同进步。
--------------------------------------------------------------------------------------------------------
										
4. 一级指针 与 多级指针				
4.1 一级指针
4.1.1 什么是一级指针
	所有普通变量的地址都是一级指针，存放“一级指针”的变量就是一级指针变量。
	
	什么是普通变量？
	凡是定义时，类型中没有*的就是普通变量。
	char a、int b，类型中没有*，都是普通变量。
	
	
4.1.2 一级指针类型

（1）类型结构	
		普通变量的类型 + *。

		char a = 'a';		
		char *p = &a;  //char * = char + *
	
		&a的类型为char *，放&a的变量p自然也是char *，=两边天然的一致，不一致的话就需要强制转换。
		
	
（2）如何理解char *
		char：指针指向空间的解释方式
		*：它是一个指针
		
		

（3）a/&a/p/*p/&p各自的含义
		char a = 'a';		
		char *p = &a;
		
		图：
		
		
		
		a：char普通变量
		&a：a的指针，类型为char *
		p：char *指针变量
		*p：p中指针所指向的空间
			p为char *，*p解引用时抵消一个*，char就是p指向空间的解释方式。

		&p：变量p的指针，类型为char **（char * + *）
	
	
4.2 多级指针

4.2.1 什么是多级指针	
	指针变量也是变量，所以指针变量的每个字节也是有地址的，那么“指针变量”第一个字节的地址就是多级指针。
	
	一句话，指针变量的指针就是多级指针。
	
	在多级指针的类型中，*的个数代表了指针的级数，n个*就是n级。
		
		
4.2.2 多级指针 之 二级指针
	一级指针变量的指针就是二级指针，存放二级指针的变量就是二级指针变量。

	
（1）类型结构
		二级指针的类型结构为，一级指针类型 + *，比如：
		
		int a = 100;
		int *p1 = &a; 
		int **p2 = &p1; //int ** = int * + * 
	
		&p1的类型为int **，放&p1的变量p2自然也是int **。
	
	
（2）如何理解 int **	
		int *：指针指向空间的解释方式
		*：最后一个星表示它是指针
		

（3）a/p1/*p1/&p1/p2/*p2/**p2/&p2各自的含义
		int a = 100;
		int *p1 = &a; 
		int **p2 = &p1;
		
		图：
	
		· a：int变量
		
		· p1：int *指针变量，用于存放int *的指针
		
		· *p1：p1中指针所指向的空间
				
				指向空间的解释方式？
				p1为int *，*p1解引用时，抵消一个*，解释方式为int。
				
				
		· &p1：一级指针变量p1的指针，为int **的二级指针
		
		· p2：int **指针变量，用于存放int **的二级指针
				
				
		· *p2：一级解引用，代表的是p2中指针所指向的空间
					
						指向空间的解释方式？
						p2为int **，解引用时，抵消一个*，解释方式为int *。
					
		· **p2：二级解引用，代表p2所指向的p1所指向的空间，这里就是a的空间
					
					做一个等价替换的话：**p2——————>*(*p2)——————>*p1 ————————>a
					所以**p2就是a的空间。
					**p2 = 100;
					int d = **p2;
					
					
					指向空间的解释方式？
					p2为int **，解引用时，抵消两个个*，解释方式为int，也就是说**2，会以int的方式去解释a的空间。

					
		· &p2：二级指针变量p2的指针，类型为int ***
		
	
		提问：如下情况怎么理解？
			int a = 100;
			int *p1 = &a; 
			float **p2 = (float **)&p1;
		
		*p2：按照float *解释p1
				*p2 ——————> (float *)p1
				
		**p2：按照float解释a
			
			**p2  ————>  *(*p2)  -----> *((float *)p1)  ——————> (float)a




			
4.2.3 多级指针 之 三级指针		
	二级指针变量的地址就是三级指针，放三级指针的变量就是三级指针变量。

		int a = 100;
		int *p1 = &a; 
		int **p2 = &p1;
		int ***p3 = &p2;

		a、&a、p1、...、*p3、**p3、***p3、&p3的含义请大家自行分析，分析方式与二级指针完全一样。
		
		
4.2.4 n级指针
		规则以此类推。
	
		不过就一般情况来说，顶多到三级就够用了，连三级都用的很少，更多的是一级和二级，因为三级以上
	的多级指针只是在绕圈圈，当然我这里只是说的一般情况。
	

4.2.5 一级与多级指针的异同

（1）相同之处
		不管是几级指针，都是一个地址，所有地址宽度都是一样的。
		
		既然指针的宽度都是一样的，那么放指针的“指针变量”的宽度的也全都是一样的，不管它是多少级的指针变量。
		
		
（2）不同之处
		不同之处在于解引用的深度。
		
		一级指针：解引用深度为1级
		二级指针：解引用深度为2级
		三级指针：解引用深度为3级
		....

（3）不同级别之间强制转换
		不同级别之间的强制转换，改变的是解引用的深度。
		
	1）例子1
		int a = 10;
		int *p = &a;        //&a为int *
		
		解引用深度：*p为一级，抵消一个*后，按照int去解释所指向的a空间。
		图：
					
		
		
		int a = 10;
		int **p = (int **)&a;    //&a为int *
		
		解引用深度变为了2级：
		*p：抵消一个*，按照int *去解释所指向的a空间
		
		**p：抵消两个**，按照int去解释a的10所指向的空间
				
				**p --> *(*p) ---> *(a) ———> *10   非法操作。
				
				
				图：
				
				
			事实上10根本不是一个有效的地址，10并没有对应有效存储空间，就算有对应空间，也是一个不明情况
		的非法空间，所以不能以指针的方式去解引用10，强行解引用的话，就会导致指针错误。
				
				
				
				
	2）例子2
		int a = 10;
		int *p = &a;
		int *p1 = (int *)&p;    //&p为int **
		
		图：
		
		
		
		解引用深度变为1级：
		*p1：抵消一个*后，以int方式解引用p1所指向p空间，将p中的指针&a强行解释为一个整形数。
			
			*p1 ——————>(int)p ————————>(int)&a
			
			图：
		
		
		**p1：无法编译通过
			**p1 --->  *(*p1) ——————>*((int)p) ————————> *((int)&a) ——————> *(整形)
			
			从以上等价后的结果可以看出，*(整形)在尝试对一个整形数进行解引用，这是无法编译通过的。
			我们前面说过，同一个数但是类型不同，会有很大区别，当编译器检测到你对一个整形数进行解引用时，
		会直接报类型错误，提示你，你在尝试解引用一个整形数。
		
			对于强类型语言来说，不同类型的数据有自己的使用规则，不能乱用，整形的数据就不能当做站指针来用，
		如果强行使用，编译器就会报错。
	
			如果你非要当做整形的数来用，必须做强制转换。
			
			**((int **)p1)  ----> *(&a) ——————*(int *指针)
			
	
	3）总结	
			不同级别之间的强制转换，会改变解引用的深度，因此可能会导致某些解引用为非法操作，所以对不同级别
		指针进行强制转换时，一定要慎重，只有当确实有强制转换的需求时，我们才会进行不同级别的强制转换。
			
	
		为什么某些解引用为非法操作呢？
		因为不同级别之间的强制转换，会导某些指针为非法指针，非法的意思就是。
		· 要么指针指向的空间不存在，比如前面例子中10，将10当做指针使用是不行的，因为不知向任何有效空间
		· 要么指针类型不匹配，不允许进行解引用
	

	
	
4.3 对指针进行解引用时，一定要确保指针为合法指针

4.3.1 什么叫合法指针
	不合法情况有如下几种：
	
（1）类型不正确，解引用的根本就不是指针
		*(整数)
		
		像这种情况，直接会导致编译不通过。

		
（2）指针所指向的空间压根就没有
			指针的类型对的，但是指针没有对应任何空间。
			所以对这种指针进行解引用时，会导致指针错误，压根找不到空间。
		
			这就好比按照地址去找亲戚，结果亲戚搬家了，肯定是找不到的。
		
			像这种情况，编译没问题，但是运行时会有指针错误。
		
		
（3）指针类型没问题，也有对应实际的存储空间，但是没有访问权限
		1）这不是你应该访问的空间
		2）人家只允许读，你偏要写

		像这种情况，编译也没问题，但是运行会有指针错误。


		
4.3.2 非法指针举例
（1）一级指针
		a.c
		
		int *p1;
		
		int fun(void)
		{	
			int *p2;
			
			*p1 = 100;
			*p2 = 200;
		}	
		
		
		*p1 = 100和*p2 = 200都存在问题：
		· p1：
			为全局变量，p1会被自动初始化为0，也就是说P1中的地址默认为0，但是0地址是没有对应实际存储空间的。
		
		· p2
			为fun函数的自动局部变量，自动局部变量站在未初始化时为随机值，这个随机值会带来很大的问题。
			- 问题1：
				如果这个随机值没有对应任何空间的话，*p解引用访问时的会导致指针错误，然后程序会被终止。
			
			- 问题2：
				如果恰好有对应某个空间，如果这个空间不允许写访问的话还好，因为这会直接导致指针错误，程序被终止，
			程序员就回去排查错误。
				
				允许写的话更糟糕，因为这个空间很可能是其它变量的空间，这会导致数据的篡改。
				
				
			所以对指针进行解引用时，指针必须是合法的，只有这样才能访问正确的空间。
			改进以上代码，比如：
				int a = 0;
				int *p1 = &a;
				
				int *p2;
				p2 = malloc(4);
						
						
（2）多级指针
		1）例子1
			int *p1;
			int **p2 = &p1;
			
			int fun(void)
			{	
				**p2 = 100;
			}	
			
			*p2 ———————> p1
			一级解引用是正确的。
			
			
			**p2 ——————> *(*p2) ————————> *p1 ——————> *((int *)0) ————> X
			
			二级解引用是指针错误。
			
			改进：
				int a = 0;
				int *p1 = &a;
				int **p2 = &p2;
		
		
		2）例子2
			不同级别指针之间的强制转换，也会导致非法指针，有关这一点我们在前面就讲过，这里不再多说。
			
		
		
		
出品：佳嵌工作室
--------------------------------------------------------------------------------------------------------
	“佳嵌工作室”致力于物联网、嵌入式产品以及‘物联网、嵌入式技术课程’的研发，希望所推出的技术课程，能够帮助
到正在努力学习物联网、嵌入式的同学，欢迎大家和我们一起共同学习，共同进步。
--------------------------------------------------------------------------------------------------------
			
		
5. 野指针与段错误
		有关野指针和段错误，其实在前面已经断断续续的提到过，只是没有明确的称呼为“野指针”和“段错误”而已，
	这里需要再完整的讲述下。
	
5.1 野指针
5.1.1 什么是野指针
	所谓野指针就是，指针（地址）是一个随机值，这个随机值会指向任何可能的空间，这就是野指针。
	
5.1.2 野指针的危害
	野指针可能会导致两种情况，这两种情况其实在前面描述过。
	
（1）指针没有对应任何真实的存储空间

（2）指向其它空间
		1）其它空间不允许操作
		2）允许操作
			这种最麻烦，可能会导致数据的篡改，而且还很难排查出错误。
				int fun()
				{
					int *p;
					
					*p = 200;
				}
				
				例子忘了给P初始化，也忘了赋值，如果p中的随机值恰好指向某个可以操作的空间，*p = 200这句话是
			没问题的，但是很有可能把别的变量的空间给修改了。
		
			其实像这种野指针的问题，在开发时总会遇到个那么几次，如果在开发中不能将野指针排查出来的话，就会
		一直遗留到产品中，在用户使用的过程中，问题随时都可能爆发出来。
		
	
5.1.3 怎么解决野指针的问题

（1）在使用指针变量之前，记得赋值一个合法指针		
	int fun()
	{
		int *p;
		p = malloc(siezof(int));  //p中有了合法指针后，就不会出现野指针的情况
		*p = 200;
	}
		仅靠赋值这种方式不是很靠谱，因为非常容易搞忘了。

		
（2）最好的方法：定义指针变量时初始化
		容易忘记赋值，但是初始化确不容易忘记，所以我们在定义指针变量时，一定要记得初始化。
		
		1）初始化为你需要的指针
			int a = 10;
			int *p = &a;
		
		2）如果不知道初始化为何值的话，那就初始化为NULL（空指针）。
			int *P = NULL;
			
				有些时候确实不知道初始化为什么，因为需要在使用时才指定具体的指针，像着这种情况的话，就初
			始化为NULL指针。
			
		疑问：初始化NULL的好处？
		答：万一忘了赋值合法指针的话，解引用NULL会导指针错误，在编程调试时，指针会导致程序被终止，程序员
		就回去排查错误，方便了程序员对指针错误的排查。
			
			如果不初始化为NULL的话，随机值可能指向了其它变量的空间，如果这个空间还可以操作的话，程序表面上
		会正常运行，但是可能篡改其它变量的数据，程序得不到正确的计算结果，这样的错误更难搞定。
			
			所以野指针就好像是野狗一样，会到处乱咬其它的空间，给它初始化为NULL，就好比带了狗套子，这样就能防
		止它乱咬。
	
（3）更严谨的使用指针
		如果更严谨一点的话，我们在使用应该加上if(NULL != p)的判断。 
	
		int *p = NULL; 
		
		if(NULL != P)
		{	
			*p = 200;
		}
		
		但是如果所有的指针，都按照这个套路来使用的话，写代码就太累了，所以一般都不会这么麻烦，不过对于非常
	重要的指针来说，我们可以加这样的判断。
	
					
5.1.4 NULL指针
（1）NULL宏被定义在什么地方
		NULL这个宏被定义在了c标准库的stddef.h中，定义形式如下，
	
		#if defined(__cplusplus)  
			#define NULL 0  
		#else                      
			#define NULL ((void *)0) 
		#endif
			
			我们知道C++是兼容c的，所以stddef.h既可以被c使用，也可以被c++使用，在c++中使用时，NULL为0，在c中使
		用时NULL为((void *)0)。
		
			这两种情况的值一样，唯一所不同的只是类型，0的类型时int，((void *)0)的类型时void *，至于为什么会
		有这样的区别，我们暂且不关心，现在只需要记住，在C中NULL为(void *)0即可。
			
			
（2）0地址
		NULL这个空指针就是0地址，0地址要么不对应实际空间，要么就是不能访问，所以对NULL指针进行解引用时，
	会导致指针错误。
				
		如果指针变量是全局变量的话，其实可以不用初始化NULL，因为全局变量不初始化时，默认就是0。
		
		
	
5.2 段错误		

5.2.1 什么是段错误
	这个实际上Linux下指针错误的叫法，英文叫Segmentation fault，翻译为中文就是“段错误”。
		
	疑问：那么为什么将指针错误说成是段错误呢？
	答：应该与程序的内存结构有关，因为程序的内存结构是由.text、.rodata、.data、.bss、堆、栈等组成个，
	我们可以将.text等称为Segment（段），如果指针有问题的话，就可能会导致放问错误的Segment，因为此就称
	为了段错误。
	
	比如：
		
		int main(void)
		{
			int *p = NULL;
			*p = 200;

			return 0;
		}
		在Linux运行时，会提时Segmentation fault（段错误），其实就是指针错误。
		
	
	
5.2.1 大段错误和小段错误

（1）大段错误
		指针所指向的空间不存在，这种就是大段错误。

		
（2）小段错误
		指针所指向的空间是存在的，但是由于访问权限有限制，比如想写数据，但是空间只允许读数据，像这种权
	限所导致的指针错误，就是小段错误。

	

		
出品：佳嵌工作室
--------------------------------------------------------------------------------------------------------
	“佳嵌工作室”致力于物联网、嵌入式产品以及‘物联网、嵌入式技术课程’的研发，希望所推出的技术课程，能够帮助
到正在努力学习物联网、嵌入式的同学，欢迎大家和我们一起共同学习，共同进步。
--------------------------------------------------------------------------------------------------------
			
6. void *指针类型
	void *为空指针类型，void表示具体类型不确定，所以void *指针就是一个纯粹的指针，无法被解引用，如果想
需要解引用的话，必须强制转换为int */float *等具体类型的指针之后，才能解引用。
	
	int a = 100;
	void *p = (void *)&a;
	
	*p = 200;  
	
	编译时会提示*p = 200为无效操作。

		

6.1 void *的意义
	我们这里直接通过例子来看一看void *的意义。
		
	#include <stdio.h>
	#include <string.h>

	struct student
	{
		int num;
		char name[20];
	};

	void init_fun(int type, void *addr)
	{
		if(type == 1)
		{
			*((int *)addr) = 100;
		}
		else if(type == 2)
		{
			*((double *)addr) = 2324.56;
		}
		else if(type == 3)
		{
			((struct student *)addr)->num = 9527;
			strcpy(((struct student *)addr)->name, "zhangsan");
		}
	}

	int main(void)
	{
		int a = 0;
		double b = 0.0;
		struct student c = {0};

		init_fun(1, (void *)&a);
		printf("a = %d\n", a);

		init_fun(2, (void *)&b);
		printf("b = %lf\n", b);

		init_fun(3, (void *)&c);
		printf("num = %d\n", c.num);
		printf("name = %s\n", c.name);

		return 0;
	}
	
	传递指针时，将指针强制转换为void *，通过这种方式就可以兼容的传递各种不同类型的指针。
	
	从这个例子可以看出，传参时使用void *可以让传参变的很灵活，后面还会再次提到这一点。
		
		
（5）malloc返回指针的就是void *
			malloc只负责开辟空间，并返回空间第一个字节的地址，也就是空间的指针，至于如何解释这个空间，这个应
		该由程序员自己决定，所以malloc返回void *的指针，程序员需要根据需求将其强制转换为具体类型的指针。
		
		1）malloc的函数原型
			#include <stdlib.h>
			void *malloc(size_t size);
		
		
			
		2）使用举例
			int *p = (int *)malloc(4);		
			
			
	
	
	
	
出品：佳嵌工作室
--------------------------------------------------------------------------------------------------------
	“佳嵌工作室”致力于物联网、嵌入式产品以及‘物联网、嵌入式技术课程’的研发，希望所推出的技术课程，能够帮助
到正在努力学习物联网、嵌入式的同学，欢迎大家和我们一起共同学习，共同进步。
--------------------------------------------------------------------------------------------------------
	
7. const与指针
7.1 const
	const是constant的缩写，为常量的意思，所以当变量被const修饰后就变为了常量。
	不过这个“常量”并不是真正的常量，而是一个伪常量，后面会解释为什么是一个“伪常量”。
	
	
7.2 const的用法

7.2.1 const修饰普通变量

（1）例子
		int const a = 0; //等价于const int a = 0
		a = 100;    		 //编译报错
		
			编译时会报错，提示a是只读的，是不能被修改的，所以a = 100这句赋值语句是错误的，对a赋值的所有语
		句一概无法编译通过，如此a变相的就变成了一个内容不能被修改的“常量”。

	
（2）只能通过初始化给值
		由于const修改后不能赋值，那么就只能通过初始化来给值了。

		说到初始化，总觉的int a = 100这种才是初始化，实际上函数传参也是在初始化。
		int fun(const int a)
		{
			printf("a = %d\n", a); //打印初始化的值10
			
			a = 200;  		//这句话无法编译通过，因为const修饰的就不能被赋值
		}
		
		int main(void)
		{
			fun(10);
			
			return 0;
		}
	
		传参时，其实初始化的过程等价于。
		const int a = 10;
	
	
7.2.2 const修饰指针变量
	我们直接通过例子来讲解。

（1）int const *p
		等价于const int *p，不管是哪一种写法，它们的共同点是const都是在*前面。
		
		这种情况表示，p所指向空间不能被修改，但是指针变量p本身可以修改。
		
		int a = 10;
		int b = 20;
		
		int const *p = &a;
		*p = 200; 			//*p所指向空间不能被修改，所以编译时这句话会报错
		p = &b; 				//p本身可以被修改，所以这句话没问题
		
		图：
		
		这种情况就是，允许改变指针的指向，但是不能改变指针所指向的空间。
		对于指针指向的空间，只能读不能写，如此一来，指向的空间就变成了一个“常量”。
		
（2）int * const p 
		刚好与前面相反，p本身不能被修改，但是p所指向的空间可以被修改。
		
		int a = 10;
		int b = 20;
		
		int * const p = &a;
		*p = 200; //p指向的空间可以被修改
		p = &b; 	//p不可以被修改
		
		图：
		
		指向的空间可以被该，但是指向不能发生改变，此时指针变量就是一个“常量”。
		
		
（3）int const * const p
		
		等价于 const int * const p。
	
		为前面两种情况的综合情况，p本身不能修改，p所指向的空间也不可以。
		
		int a = 10;
		int b = 20;
		
		int const * const p = &a;
		*p = 200; //不能修改
		p = &b; 	//不能修改
		
		图：
		
		此时指向的空间是一个“常量”，指针变量本身也是一个“常量”。
		

		
7.2.3 const的实现原理		
	const实际上是编译器帮忙实现的常量，并不是真正的常量。
	
	
（1）什么是编译器帮忙实现的
			因为一旦变量被const修饰后，当编译器检查到变量被赋值时，编译器就会报错并终止编译，程序员必须将赋
		值语句删除，否则无法编译通过，如此就保证了const所修饰变量不会被修改，变相的让变量变成了常量。
			
			事实上const修饰的变量本身是可读可写的，并不是真正的常量，因为真正常量是只读的，不能被改写。
		
		疑问：为什么const修饰的变量不是真正的只读的常量？
		答：因为变量空间开辟于.data、.bss、堆或者栈中，我们知道.data/.bss/栈/堆都是可读可写的，所以变量也
		是可读可写，只是被const修饰后，编译器通过检查并阻止赋值语句的存在，这使得表面上看起来就像是一个
		常量了，但实际上并不是真正的只读的常量，所以const修饰所实现的常量其实是“伪常量”。
		
（2）真正的常量
		空间为只读的才是真正的常量，前面的课程介绍过，真正的常量都在.text和.rodata中，因为.text和.rodata是只
	读的，那么从只读的.text和.rodata中所开辟的常量空间，必然也是只读的。
	
		我们可以通过一个例子来验证const实现的常量是一个“伪常量”，本质上它还是一个变量。
		#include <stdio.h>

		int main(void)
		{
				int const a = 10;

				int *p = &a;

				*p = 200;
				
				printf("%d\n", a);

				return 0;
		}
		
			例子中a虽然是const的，但是通过a的地址去访问a的空间时，确是能修改的，这就证明了a空间其实是可以被
		写的，所以a并不是真正的常量，其实它还是一个变量。
		
		疑问：a被const修饰后，为什么通过指针去修改，在编译时编译器不报错？
		答：按照语法规则，编译器只负责检查a不被修改，但是例子并没有直接修改a，所以编译器就没有报错，
		说白了编译器被欺骗了。
		
		
7.2.4 const有意义吗
		当然意义，针对那些不希望被修改的变量，我们就可以使用const修饰，对变量加以限制，以防止被误改。
	在函数传递指针的时候，const用到更是很频繁，有关这一点后面会介绍。

	
7.3 单片机中的code关键字
		这一个并不是c语法的通用关键字，所以一般的c编译器并不能理解这个关键字，这个开发单片机的C语言才支持
	的关键字，所以只有针对单片机开发的编译器才支持这个关键字。
		
		code也是用来定义常量的，与const的区别是，const只是编译器检查变相实现的，但是本质上还是变量，
	const这个关键字属于通用语法，在开发单片机的c语言中也能使用，因为单片机的c也必须准守通用语法规则。
		
	
		不过使用code定义的却真的是一个只能读不能写的常量，因为使用code修饰以后，数据会和代码放到一起，代码
	所处的空间只能读不能写，因此属于真正的常量。
		
		int code a = 100; //同样的，只能通过初始化给值，不能赋值
		
		a就是和代码放在一起的，a是一个真正的只读的常量空间。
		
		当然这里对code的描述并不算100%准确，因为与单片机的存储器结构有关系，但是大家对单片机并不熟悉，
	所以这里只能进行简单的描述。
		
		
		
		
		
		
出品：佳嵌工作室
--------------------------------------------------------------------------------------------------------
	“佳嵌工作室”致力于物联网、嵌入式产品以及‘物联网、嵌入式技术课程’的研发，希望所推出的技术课程，能够帮助
到正在努力学习物联网、嵌入式的同学，欢迎大家和我们一起共同学习，共同进步。
--------------------------------------------------------------------------------------------------------
			
8. 函数指针 
8.1 什么是函数指针
	函数指针其实就是函数地址，准确的说应该是函数代码所在空间的第一个字节的地址，即整个函数的入口。
	在c语言中，函数名直接就代表函数指针，这一点在前面就介绍过。
	
	
8.2 指针函数、函数指针
	这两个名称很容易混淆，但是本小节介绍完后，保证大家一定能够分清这两个概念。
	
	
8.2.1 指针函数
		如何理解“指针函数”这个词。
		前面的“指针”两个字为形容词，后面的“函数”两个字为名词，所以这句话的全称为“返回值为指针类型的函数”，
	所以“指针函数”的本质是函数。
	
	int *fun(void)
	{	
		int *p = NULL;
		
		p = malloc(sizeof(4));
		
		return p;
	}	
	
8.2.2 函数指针
		同样的，前面“函数”为形容词，后面的“指针”为名词，这句话的全称应该叫“函数的指针”，也就是函数的地址，
	，所以函数指针的本质是“指针”，自然存放“函数指针”的变量就是“函数指针变量”。
		
		总结：
		对于“指针函数”和“函数指针”这两个词，大家只要知道后面两个字是名词，就很容易区分。
		· 指针函数：本质是函数
		· 函数指针：本质是指针
		
	
（1）函数指针的类型
		对于一般的指针类型来说，形式很简单，就是基本类型加*，几级指针就几个*，比如
		int *     int ** 
		float *   float **
		char *    char **
		struct student *   struct student **
		等
		
		函数指针的类型就比较怪异了，跟一般的指针形式不一样，由于是函数指针类型与函数有关，所以长的与函数
	的样子很像。
		
		比如：
		int fun(void)
		{
			...
		}
		fun为函数指针，函数指针的类型为int (*)(void)。

		int *fun(int a, int b)
		{
			...
		}
		fun为函数指针，指针的类型为int *(*)(int, int)。
		第一个*是返回值类型int *的组成部分。
		
		
（2）定义函数指针变量
		1）定义普通的函数指针变量
			定义时只需要在*后面加上变量名即可。
			int *p; 
			float *p;
			char *p;
			...
			
		2）定义函数指针变量
			也是类似的，在*后面加上变量名即可，比如：
		
			int *fun(int a, int b)
			{
				...
			}
			
			定义一级函数指针变量：int *(*funp)(int, int) = &fun; //&fun的类型为int *(*)(int, int)
				在前面就说过，&可以省略，&fun等价于fun。
			
			定义二级函数指针变量：int *(**funp)(int, int) = &funp; //&funp的类型为int *(**)(int, int)
			...
			
			
			定义一级函数指针数组：int *(*funp[4])(int, int);
			定义二级函数指针数组：int *(**funp[4])(int, int);
			...
			
	
			不过使用函数指针时，一般一级、二级就已经很够用了。
	
			为了表述的方便，以后我们会将“函数指针”和“函数指针变量”都统称为函数指针，具体指哪一个，就看说话
		的语境。
			
			
		3）函数指针类型中的()一定不能省略，否则就变成了函数的定义形式，比如：
				
				int (*funp)(void);
				
				将()省略后：
				
				int *funp(void);
				
				对于int *funp(void)来说，()的优先级高于*的优先级，funp会先和(void)结合，所以编译器在编译时
			就会把funp理解是函数，但是又没有函数体{...}，所以编译器最终会报错。
				
				但是加了括号后就变为了int (*funp)(void)，*就会优先和funp结合，那么编译器就会把funp理解为指针
			变量，所以括号一定不能省略，省略后含义完全不一样。
	
				
（3）进行强制转换时，应该怎么写

		1）使用普通指针类型进行强制转换时
			float a = 123.42;
			int *p = (int *)&a;

			
		2）使用函数指针类型进行强制转换时
			int (*funp)(void) = (int (*)(void))addr;
			int (**funp)(void) = (int (**)(void))addr;
			...
			
		
		

出品：佳嵌工作室
--------------------------------------------------------------------------------------------------------
	“佳嵌工作室”致力于物联网、嵌入式产品以及‘物联网、嵌入式技术课程’的研发，希望所推出的技术课程，能够帮助
到正在努力学习物联网、嵌入式的同学，欢迎大家和我们一起共同学习，共同进步。
--------------------------------------------------------------------------------------------------------
		
9. 函数调用
9.1 直接使用函数名调用
		int *fun(int a, int b)
		{
			...
		}
		
		int fun1()
		{
			fun(100, 200); //直接使用函数名调用
		}	
		
		这种也是最常见的方式。
			
9.2 使用函数指针来调用
		int *fun(int a, int b)
		{
			...
		}
		
		int *(*funp)(int, int) = &fun; //等价于fun 
		
		int fun1(void)
		{
			*funp(100, 200); //等价于(*funp)(100, 200)
		}
	
		
		为了使用更加方便，所以c语法允许将&和*省略，因此以上写法就简写为如下形式：
		int *(*funp)(int, int) = fun;  
		funp(100, 200); 			


9.3 函数调用时，栈的使用过程
9.3.1 本小节内容概要
		我们都知道，函数在运行时是需要栈的，为什么需要栈呢，因为函数的形参、自动局部变量、返回地址等都放
	在栈中，没有栈的话函数是没办法运行的。
		
		我们在第一章讲c程序的“内存结构”时，我们有详细介绍栈是个啥，所以在本小节就不再介绍栈是个啥，本小节
	的重点是讲解函数调用时，栈的使用过程。
	
9.3.2 直接通过例子理解
	#include <stdio.h>
	
	int fun1(int *ap, int *bp)
	{
		*ap *= 2;         //等价于 *ap = *ap * 2
		*ap *= 2;
	}
	
	int fun(int a, int b)
	{
			int sum;
			
			fun1(&a, &b);
			
			int c = 10;
			
			sum = a + b + c;
	
			return sum;
	}
	
	int main(void)
	{
		int a = 10;
		int b = 20;
		int ret = 0;
		
		ret = fun(a, b);
		
		printf("ret = %d\n", ret);
		
		return 0;
	}	

（1）先做一个简单的铺垫
	· 为了简单化，我们这不考虑“启动代码”对于栈的使用。
	
	· 为了方便讲解，我们一律认为形参都是开辟于栈中，不考虑形参在寄存器中的情况
	
	· 最开始，栈针指向栈底，栈顶和栈底是重合的
	
	· 从栈中每开辟1个字节，栈指针就移动一个字节，栈顶开始移动
		栈顶和栈底之间的空间，就是开辟出的需要被使用的空间，形参等就在里面。
		
		栈指针是个啥？
		栈指针全称叫“栈指针变量”，用于存放栈顶字节的地址，所以栈指针标记了栈顶的位置。
		
		
	· 释放时也是一样的，栈顶指针向栈底移动一个字节，就释放一个字节
		只不过空间释放了，但是里面的数据还遗留在里面，遗留数据就变成了我们所说的随机值。
	
	
	· 调用函数时，会在栈中保存被中断处下一条指令的地址，当函数运行结束后，就是利用保存的地址来返回
		并继续执行的
		
		
（2）函数调用时，栈的使用过程
		图：
			

		
9.3.3 为什么工程代码越复杂，越消耗内存
	因为当工程代码写复杂之后，无法避免的会封装大量的函数，函数调用时是非常耗费栈的，所以所工程越
复杂，越消耗栈内存，栈是内存的一部分，栈消耗的很厉害，其实就是内存消耗的很厉害。	

	
	
	
9.4 有关函数传参的一些需要被强调的地方

9.4.1 实参类型与形参类型可以不一致，返回值与返回类型也可以不一致
		这个问题我们在前面介绍过，此时如果不一致的话，就会进行隐式强制转换，但是我们建议使用显式强
	制转换。
		
				
9.4.2 实参的数量与形参数量不一定要想等

（1）直接使用函数名调用时
		要求实参与形参的数量必须相等，否则就会报错，编译无法通过。
		
		int fun(int a, float b)
		{
			...
		}
		
		fun(100); //报参数太少的错误
		fun(200，12.3, 324); //报参数太多的错误
		
		疑问：为什么直接使用函数名调用时，参数不能多不能少，必须与形参一致？
		答：因为函数定义时，明确的指明了参数的个数，必须遵守。
		
		
（2）使用“函数指针变量”来调用时，可以不相等
			
			疑问：为什么使用“函数指针变量”来调用时，可以不相等？
			答：因为在定义“函数指针变量时”，可以从新指定形参。
			
			
		1）例子1：定义函数指针变量时，省略部分形参
			#include <stdio.h>
			int fun(float a, int b)
			{
				printf("a = %f\n", a);
				printf("b = %d\n", b);
				
				return 0;
			}
			
			int main(void)
			{
				int (*funp)(float, int) = fun;
				
				funp(12.3, 100); //此时传递两个
				
				int (*funp1)(float) = (int (*)(float))fun; //fun的类型为int (*)(float, int) 
				
				funp1(12); //此时只传一个
				
				return 0;
			}
			
			int (*funp)(int, float) = fun;
			定义函数指针变量时，要求传递两个参数，所以调用时需要按照int和float来传参。
			
			int (*funp1)(int) = (int (*)(int))fun; 
			调用时传递只一个参数，没有传递实参的形参就是随机值。
			
			为什么时随机值？
			形参开辟与栈中，你不通过实参来初始化的话，它就是一个随机值。
	
			不过由于funp1的类型为int (*)(int)，而fun的类型为int (*)(int, float)，指针类型不一致，所以复
		制时需要将fun强制转为int (*)(int)类型。
			
			
		2）例子2：定义函数指针变量时，也可以将形参全部省略
				int fun(int a, float b)
				{
					printf("a = %d\n", a);
					printf("b = %d\n", b);
				}
				
				int main(void)
				{
					int (*funp)() = fun; //定义时将参数省略
					
					fun(10);             //可以
					fun(10, 12.4);       //可以
					fun(21, 34.5, 3453); //可以
				}
				
				从例子不难看出，定义函数指针变量时，如果不指定形参的话，调用时实参可以根据需求随意指定。
				
				疑问1：在int (*funp)() = fun中，为什么没有对fun进行“强制转换”。
				答：不指定形参的这种情况，可以省略强制转换。
					int (*funp)() = (int (*)())fun;
					可省略为
					int (*funp)() = fun;

						
						
				疑问2：将参数全部省略，有意义吗?
				答：有，这么一来就可以让“函数指针变量”指向任何一个函数。
						int fun1(int a)
						{
							...
						}
						
						int fun2(int a, int b)
						{
							...
						}
						
						int fun3(int a, int b, float c)
						{
							...
						}
						
						int main(void)
						{
							int (*funp)() = NULL;   //赋NULL的时候不需要进行类型的强制转换

							funp = fun1;
							funp(10);
							
							funp = fun2;
							funp(23, 45);
							
							funp = fun3;
							funp(23, 45, 34.65);
						}
						
						如果定义为int (*funp)(int, int)，funp就只能指向fun2函数。
						
						但是将形参全部省略后，就不用担心因参数的不同所带来的矛盾了。
			


			
出品：佳嵌工作室
--------------------------------------------------------------------------------------------------------
	“佳嵌工作室”致力于物联网、嵌入式产品以及‘物联网、嵌入式技术课程’的研发，希望所推出的技术课程，能够帮助
到正在努力学习物联网、嵌入式的同学，欢迎大家和我们一起共同学习，共同进步。
--------------------------------------------------------------------------------------------------------				
						
10. 函数指针的应用举例————回调函数和函数指针数组

10.1 回调函数	

10.1.1 什么是回到函数
	我们直接通过例子来理解什么是回调函数。
	
	a.c                     								b.c
	                                        #include <stdio.h>
	int (*g_funp)() = NULL;									extern int fun(int (*funp)());
	
	int fun(int (*funp)())      						int fun1(int a)
	{                       								{
		funp(100);
																						printf("%d\n", a);
		
		g_funp = funp;                          
	}																				}
																				
																					int main()
																					{
																						fun(fun1);
																						
																						return 0;
																					}

		这两个例子在前面介绍过，只不过这里做了点小改动，由于b.c中的fun1是static的，所以在a.c中无法直接
	调用fun1，所以需要将fun1的函数指针传递给a.c的fun，然后再回调fun1函数，fun1函数其实就是回调函数。
		
		为了让a.c中的其它函数也能回调fun1，我们可以将函数指针保存到全局变量中。
		
		
10.1.2 普通调用与回调的对比
（1）普通的直接调用方式			
		        调用
		 fun ————————>  fun1
			
			这种方式，都是直接通过函数名来调用，使用这种方式时，不过要求fun在fun1的作用域范围内，否则是没办
		法调用的。
			
			
（2）回调

			      fun1函数指针
			     <—————————— 调用fun
			fun              
			     ——————————> fun1
						  回调
			
			通过对比一看就知道什么是回调函数了。
			其实我们还可以使用结构体来对函数指针进行封装，然后将结构体传递给对方，对方从结构体中取出函
		数指针后，再来回调。
		
			后面章节介绍使用结构体来模拟面向对象思想时，会讲到这种发方式。
		
		
		
11.2 函数指针数组		
	我们还是通过例子来介绍。
	
11.1.1 例子
	#include <stdio.h>

	int add(int a, int b)
	{
			return a + b;
	}

	int sub(int a, int b)
	{
			return a - b;
	}

	int mul(int a, int b)
	{
			return a * b;
	}

	int div(int a, int b)
	{
			return a / b;
	}
	
	int squ(int a)
	{
		return a*a;
	}
	
	int main(void)
	{
			int  i = 0, ret = 0;
			int da1= 0, da2 = 0;
			//函数参数不一致，所以不要指定任何形参
			int (*funp[5])() = {add, sub, mul, div, squ};

			while(1)
			{
					printf("0. add\n");
					printf("1. sub\n");
					printf("2. mul\n");
					printf("3. div\n");
					printf("4. square\n"); //平方
					printf("select\n");
					
					scanf("%d", &i);

					if(i == 4) 
					{
						printf("input data1\n");
						scanf("%d", &da1);
						
						ret = funp[i](da1);  //通过函数指针，调用对应函数
					}
					else 
					{
						printf("input data1, data2\n");
						scanf("%d %d", &da1, &da2);
						
						ret = funp[i](da1, da2); 
					}
					
					printf("ret = %d\n", ret);
			}
	
			return 0;
	}
	
	其实可以将例子中ret = funp[i](da1, da2)、ret = funp[i](da1)这句话，改为如下方式。

	switch(i)
	{
			case 0:
					ret = add(da1, da2);
					break;
			case 1:
					ret = sub(da1, da2);
					break;
			case 2:
					ret = mul(da1, da2);
					break;
			case 3:
					ret = div(da1, da2);
					break;
			case 4: 
					ret = squ(da1);
					break;
	}

		通过对比可以发现，使用“函数指针数组”比switch更简洁，所以如果能够用好“函数指针数组”的话，可以让我
	们代码变的更加优美和高效。
		
		
		
		
		
		
			
出品：佳嵌工作室
--------------------------------------------------------------------------------------------------------
	“佳嵌工作室”致力于物联网、嵌入式产品以及‘物联网、嵌入式技术课程’的研发，希望所推出的技术课程，能够帮助
到正在努力学习物联网、嵌入式的同学，欢迎大家和我们一起共同学习，共同进步。
--------------------------------------------------------------------------------------------------------				
	
		
12. 指针与函数传参
12.1 普通传参
		普通传参时，其实就是开辟一个形参空间，然后将实参数据复制过去，此时形参是独立的变量空间，修改形参时，
	实参不会有任何改变。
	
	int fun(int a)
	{
		...
	}
	
	int main()
	{
		int a = 20;
		
		fun(a);
		
		return 0;
	}
	
	图：
	
	
12.2 传递指针
	int fun(int *p1, int **p2)
	{
		...
	}
	
	int main(void)
	{
		int a = 20;
		int *p = &a;
		
		fun(p, &p);
		
		return 0;
	}
	

12.2.1 与普通传参的相似之处
		传递指针与传递普通参数没有本质区别，指针形参也是独立的空间，然后将实参复制给形参。
	唯一不同的时，传递指针，复制的数值是指针。
	图：
	
	
	
12.2.2 与普通传参的不同之处	
		修改形参本身，并不会改变实参的值，但是不同之处就在于，由于传递的是指针，所以可以通过*解引用，实现对
	实参的访问。
	
	图：
	
		所以指针传参，与普通传参没有本质区别，都是将数据传递给独立的形参空间，唯一不同的是，如果是普通传参
	的话，不能访问实参，如果传递的是指针的话，可以通过解引用来访问实参。
		
		
		
12.3 什么时候传递指针
12.3.1 使用指针的通病
		学会指针之后，很多同学惯于事事皆指针，当然传递指针肯定都没问题，但事实上有些时候只需“普通传参”
	即可搞定的。
	
	
12.3.2 传递指针的原则（什么时候传递指针呢？）
		只要符合以下两个原则中某个或者两个时，就需要传递指针。

（1）原则1：修改原则
		如果被调函数需要修改实参的值时，就必须传递实参变量的指针，否则是修改不了的。
		
		void fun(int **p)
		{
			*p = malloc(sizeof(int));  //修改p，让p指向malloc的空间
		}
		
		int main(void)
		{
			int *p = NULL;
			
			fun(&p);
		}
		
（2）原则2：效率原则
		传参时，凡是大片的空间，都需要传递指针，这样效率更高。
		
		1）结构体
			其实是可以对结构体进行普通传参的，
			struct student
			{
				int num;
				char name[40];
				float scaore;
				...
			}; 
			
			int fun(struct student stu)
			{
				...
			}
			
			int main(void)
			{
				struct student stu = {9527, "zhangsan", 99.0, ...};
				
				fun(stu);
			}
			
			在例子中，fun的形参stu是一个结构体变量，实参stu中所有的内容会全部复制到形参stu中，显然直接传递
			结构体变量，是很浪费存储空间，特别是在实际应用中，一个大的结构体往往会有十几个，甚至几十个成员，
			如果是这样的话，真的非常浪费栈空间。
			
			但是如果传递指针的话，就不存在这个问题，因为传递指针时，形参只需要4或者8个字节，通过这个指针，
			我们一样可以从实参空间中读取数据。
			int fun(struct student *stup)
			{
				...
			}
			fun(&stu);
			
			
		2）传递数组
				数组往往都是很大的一片连续空间，我们传递数组时，如果传递的是整个数组的话，形参也必须是一个
			数组空间，然后将值复制进去，显然很浪费栈空间，因此在c语法中，传递数组时都是传递指针。
			
			int fun(int *buf, 10)
			{
				...
			}
			
			int main(void)
			{
				int buf[10] = {0,1,2,3,4,5,6,7,8,9};
				
				fun(buf, 10);
			}
				
				图：
				
				在传参时，buf代表的是数组的第一个元素的指针，也即第一个元素的第一个字节的地址，与&buf[0]等价。
			所以fun(buf)等价于fun(&buf[0])。
				
				由于数组是一片连续的内存空间，所以只要拿到了第一个元素的指针，后面的元素就可以被依次的访问到。
			有关于数组指针的问题，我们留到后面讲组章节时再详细介绍。
				
		3）传递函数指针
				其实传递函数指针也可以归属到效率这一原则中，因为函数代码的存储空间也是一大片空间，所以你不可能
			把整个代码全部复制给对方，一个没有传递函数代码的这种操作，另一个是站在效率的角度来说，这也是不
			允许的，所以只能传递函数指针。
				
				
			不管是满足以上两个原则中的哪一种，还是两个都满足，此时我们就需要传递指针了，除此以外的就使用
		普通传参。

	
	
	
	
12.2.3 再说说传参
（1）形参空间
			我们之前讲到过，总体上，形参开辟于“栈”中，但是也有特殊情况，其实在前面的章节提到过，
		这里再提一下。
		
		· windows 
				当c程序在windows下运行时，由于windows系统基本都是运行intel的处理器上的，而intel处理器的寄存
			器相对偏少，所以形参都在栈中。其实只要是寄存器偏少的情况，形参都是在栈中。
			
		· 嵌入式Linux
				嵌入式Linux系统，大多是运行在ARM处理器上，ARM处理器的寄存器相对偏多，因此如果形参个数<=4，
			那么形参就开辟于寄存器中，之所以放在寄存器中，主要是因为寄存器的访问速度比内存快，只有当形参
			数量超过4个时，多余的形参才开辟在栈中。其实只要是寄存器比较多的，都是这样的情况。
				
			对于现在所介绍的这些，其实你了不了解的都无所谓，并不影响我们的实际编程。
			不过有一点可以肯定的是，不管是寄存器还是栈，都是宝贵的存储空间，所以形参越多，所越消耗存储空间
		就越多，如果我们能够有效的减少形参数量的话，可以有效的降低栈的消耗，提高函数的运行效率。
		
		
（2）如何减少形参数量
			不要没事就传参，只有当有必要时才传参，要有意识的控制形参数量。
			
			如果实在没办法，必须要传递很多参数时，我们可以使用结构体将形参都封装起来，然后传递结构体指针，
		如此一来原本需要开辟很多形参的情况，现在只需要开辟一个“指针形参”来存放“结构体指针”即可。
			
			当然，当参数很少时，就不必使用结构体封装了。
			
			比如：
			
			struct student 
			{
				...
			};
			
			int fun(int a, int b, float c, int *p1, char *buf, struct student *stup)
			{
				...
			}
			
			int main(void)
			{
				int va = 100;
				
				int a = 10;
				int b = 20;
				int c = 30.5;
				int *pva = &va;
				char buf[] = "zhangsan";				
				struct student stu = {0};
				
				fun(a, b, c, pva, buf, &stu);
				
				return 0;
			}
			
			fun的形参非常多，此时使用结构体封装封装后，就变成了如下形式：
			
			struct student 
			{
				...
			};
		
			struct formal_parameter
			{
				int a;
				int b;
				int c;
				int *pva;
				char buf[];
				struct student stu;
			};
			
			int fun(struct formal_parameter *stup)
			{
				...
			}
			
			int main(void)
			{
				int va = 100;
				
				struct formal_parameter form_para = {10, 20, 30.5, &va, "zhangsan", &stu};
				
				int fun(&form_para);
				
				
				return 0;
			}
			
			从例子可以看出，原本形参需要几十个字节的空间，现在节省为了4或8字节的指针变量空间。
			
			总结，我们在什么时候需要传递一个结构体：
			1）必须传递一个结构体时，比如例子中的struct student结构体
				绝大部分传递结构体的情况都是这种，属于正常需求。
				
			2）使用结构体对传参进行封装
				这种情况不常见，只有当函数参数特别多时才会这么办。
			
			
			疑问：我以后是不是只要遇到形参非常多的时候，就是用结构体封装？
			答：站在效率的角度来说应该这么办，但是也不见得完全是这样，如果你的程序非常的简单，对内存消耗本
			来就不是很高，此时封不封装都无所谓，但是如果：
				· 程序很复杂，程序复杂后本来就很消耗内存，那么此时就需要有意识节约存储空间
				· 是单片机程序，单片机资源本来就有限，那么此时也需要有意识的节约存储空间	

			
			
			
（2）如果参数不能确定是怎么办	
		
		有同学可能会疑问，还有无法确定参数的情况吗，其实是有的，参数的不确定有两方面：
		
		· 不确定参数数量
		· 不确定参数类型
	
		当我们遇到这种情况时，就使用void *指针，此时可以传递任何你想传递的参数。
		
		例子1：c线程的
		struct student 
		{
			int num;
			char buf[40];
			float score;
		};
		
		void fun(int type, void *p)
		{
			if(type == 0)
			{
				printf("%d\n", (int)p);
			}
			else if(type == 1)
			{
				*((float *)p) = 200.456;
			}
			else if(type == 2)
			{
				struct student *tmp = (struct student *)p;
				printf("%d\n", tmp->num);
				printf("%s\n", tmp->name);
				printf("%f\n", tmp->score);
			}
		}
			
		void fun1(void)
		{
			fun(0, (void *)100);
		}
		
		void fun2(void)
		{
			struct student stu = {9527, "zhangsan", 99.0};
			fun(2, (void *)&stu);
		}
		
		int main(void)
		{
				fun1();
				fun2();
			
				return 0;
		}

			fun函数代码是if else结构，只有一个条件成立，所以只处理一种情况，调用fun函数时只是处理
		某一种情况，那就应该根据情况，值传递某一种参数过去，也就是说fun的参数不确定，要根据实际情况来定，
		此时就是使用void *来统一。
			你想传递什么都可以，只要在fun中将类型强制转换为你要的类型即可。
			从例子可以看出，就算你想通过void *来直接传递整形也是可以的，因为int的大小是4个字节，而void *的
		大小要么是4或8个字节，所以存放整形的内容完全没问题，只要再强制转换为int型即可。
		
		
		例子2：c线程库中的pthread_create函数
		
			int pthread_create(pthread_t *thread, pthread_attr_t const *attr, 
													void *(*start_routine) (void *), void *arg);
		
			有关c线程的这个函数，我们在《Linux系统编程/网络编程》第9章有详细讲解，具体情况请看这部分课程。
		
			第四个参数之所以为void *，就是因为传参不确定，你可以传递任何你你要参数，如果传递的参数很多，
		那就封装为结构体，然后传递结构体指针，使用参数的一方，只要对应的将其强制转换回来即可。
	
	

12.4 传递指针的风险

12.4.2 什么是指针风险
		为了提高传参效率，所以必须传递指针，但是并不想修改实参的内容，但是由于传递的是指针，所以存在潜在
	误改实参的风险。

	
12.4.3 如何规避指针风险

（1）使用普通传参
			如果能够使用普通传参时就使用普通传参，因为普通传参不存在这种情况。

			
（2）如果必须传递指针，但是又不想被误改时，我们可以使用const来防止
		有关const的用法，在前面就详细的介绍过，const修饰指针时有三种情况
		
		int const *p：p可以改，但是p中指针所指向空间不能改
		int * const p：p不可改，但是p中指针所指向的空间可以修改
		int * const * const p：p和指向的空间都不可以修改
		
		
		传参时，为了保护实参不被误改，最常用的是第二种情况。
	
			int fun(struct student const *stup) 
			{
				...
			}
			
			int main(void)
			{
				struct student stu = {9527, "zhangsan", 99.0, ...};
				
				fun(&stu);
			}
			

				stup一旦被&stu初始化后，通过stup操作实参时，只能读实参开空间，不能写。
			如果你想stup一直指向stu，不希望被修改为指向别的空间，那就需要将stup也变成不可修改的，此时定义
			形式就改为
				struct student const * const stup
			
				不过一般来说没有这种需求，只要不误改实参空间就可以了。
				
				使用const修改指针形参的情况非常多，特别是当调用的是库函数和OS API时，更是比比皆是，在讲
			《Linux系统/网络编程》课程，我们讲Linux的OS API时，指针形参就有大量的使用const，我们自己
			传递指针时，为了让指针的使用更安全，我们也要学会使用const。
				
	
	
	
13. 如何得到函数的计算结果
	当然并不是所有的函数都需要返回计算结果，但是如果需要得到计算结果的话，应该怎么办呢？
	

13.1 通过返回值的得到结果
	int fun(int a)
	{
		...
		return ***;
	}
	
		如果return的返回值不能确定，可以返回void *：
	
	void *fun(type)
	{
		if(type == 0)
		{
			int a;
			...
			return (void *)a;
		}
		else if(type == 1)
		{
			static struct student stu;
			...
			return (void *)&stu;
		}
	}	
	
	int main(void)
	{
		
		int a = (int)fun(0);
		
		struct student *stup = (struct student *)fun(1);
		
		return 0;
	}
	
	疑问：例子中的a和stu为什么需要加static修饰？
	答：如果不加static修饰的话，就是自动局部变量，函数运行结束后，自动局部变量就会被释放，此时就会返回
	一个被释放空间的指针，操作被释放的空间是很危险的，因为释放后的空间可能会被其它变量使用。
		加了static修饰后就是静态局部变量了，只要程序还活着，静态局部变量就会一直存在，不需要担心。
		

13.2 通过传参返回计算结果
	通过传参返回的意思就是，可以通过指针来修改实参，从而返回计算的结果。
	
	void fun(int a, int b, int *p1, int *p2)
	{
		*p1 = a * a;
		*p2 = b * b;
	}
	
	int main(void)
	{	
		int ret1 = 0;
		int ret2 = 0;
		
		fun(10, 20, &ret1, &ret2);
		
		return 0;
	}
	
	通过指针传参来返回计算结果时，可以返回多个值，如果要返回的值非常多的话，也可以封装为结构体返回。
	
	封装为结构体返回时，可以使用return返回，也可以还是用传参来返回。
	
	
	在库函数、OS API里面，retrun和参数返回是怎么用的：
	
	return的返回值：往往用于说明函数是否调用成功，一般返回0表示调用成功，返回-1表示调用是失败
	返回计算结果：使用传参方式返回
	
	int fun(int a, int *p)
	{
		if(NULL != p)
		{
			*p = a * a;
			
			return 0;
		}
		else 
		{
			return -1;
		}
	}
	
	int main(void)
	{
		int ret = 0;
		int va = 0;
		
		ret = fun(10, &va);
		if(-1 == ret )
		{
			printf("fun fail\n");
		}
		else 
		{
			printf("va = %d\n", va);
		}
	
		return 0;
	}
	

	
	
14. 递归函数
14.1 什么是递归函数
	大家都应该听过递归函数。
	所谓递归函数，就函数自己调用自己，至于为什么自己调用自己就被称为递归呢？
	这个问题我们后面再回答。
	
	
14.2 递归函数举例
14.2.1 例子
		#include <stdio.h>
		
		long sum(int n) 
		{
			if(1==n) 
			{
				return 1;
			}
			else 
			{
				return (n+sum(n-1));//sum函数自己调用自己，所以sum函数就是一个递归函数。
			}
		}
		
		int main(void) 
		{
			int a = 0;
			
			a = sum(3);
			
			printf("a = %d\n", a);
			
			return 0;	
		}
		
		疑问：这个递归函数的作用是什么？
		
		答：对0~3的做累加运算，既然能计算0到3之间的累加和，自然也能计算0~n的累加，比如做100的累加时，
		只要把代码中sum(3)改为sum(100)，即可计算0~100的累加。
		
		当然累加计算时，也可以通过循环来实现，我们这里之所以使用递归来实现，主要是想通过这个例子来介绍递归。
		int i = 0;
		for(i=0; i<=100; i++)
		{
			sum = sum + i;
		}
		
		
		
14.1.2分析这个递归函数
		图：
		

		1）递归次数：2次，也就是说，sum函数自己调用自己的次数只有两次，main函数调用sum的那一次不算。
		2）递与归：“递”是一级一级调用的过程，“归”是一级一级返回的过程。
		3）当n=1时，整个递归就开始一级一级返回，所以n==1就是递归返回条件
		4）递归在一级一级调用时，只是在做计算的准备，只有当一级一级返回时，才开始在真正的计算，回到最
			开始调用sum的位置时，整个计算结果就出来了。
			
			递：就是在撒网
			归：就是在收网
			
			
			
				
		总结递归算法特点
		1）递归就是函数自己调用自己
		2）递归次数就是自己调用自己的次数
		3）递归中的“递”就是一级一级调用的过程，“归”就是一级一级返回的过程
		4）递归必须要有终止条件，不能没完没了的调用下去

		
14.3 直接递归和间接递归
（1）直接递归：函数自己直接调用自己，上面的例子就是直接递归。

（2）间接递归：间接递归就是自己先调别的函数，别的函数再调自己。
			间接递归要比直接递归难一些。

	
14.4 如何分析别人给的递归函数	
	阅读源码时或者面试时，可能需要分析别人的递归函数，那么我们应该如何分析别人的递归函数，搞清递归的目的呢。
	
	分析方法很简单，以我们自己的递归例子为例，我们只要降低递归次数，将次数少的递归过程分析明白了，自然就能
清楚这个递归是干嘛的。
	
	不过分析递归时，千万不要只拿眼睛看，一定要像我之前一样，耐心画出递归的过程图，只要能够把递归过
程图画出来，很容易就能搞清楚这个递归作用，当然了，不用画的像我那么精细，画个草图就行。

	对于直接递归来说，分析起来较为容易，但是间接递归的分析稍微难一些，不过分析方法也是一样的，一般只要将
5~7次的递归过程分析清楚了，基本就能搞清楚递归的作用。




14.5 递归的优点和缺点	
14.5.1 优点
	使用递归解决问题时，程序代码会比较干脆、简洁。

14.5.2 缺点：不容易被人理解和阅读，而且非常消耗栈内存空间	
（1）图：递归时，函数栈空间的消耗。
		
		
		
		从图中可以看出，递归算法很消耗栈空间。
		
		
（2）栈内存消耗的很严重时，递归甚至可能会导致“栈边界”溢出
		所谓溢出就是，由于递归的某些问题，在递归调用时导致了栈的过分消耗，严重时甚至越过了栈边界跑到堆空间，
	将堆空间内容给修改了，最后直接会导致整个程序的崩溃。
		图：
	
		
		有些黑客有时就会利用递归的“栈边界溢出”特性来进行攻击，从而瘫痪被攻击的程序。
		
		递归的"返回判断条件"其实也被称为“边界保护条件”，为什么称为边界保护条件呢？
		因为它防止递归无限制运行下去，从而防止栈边界溢出，所以才被称为“边界保护条件”。

	
	导致栈溢出的情况有哪些呢？
	1）忘了给“递归返回条件”，使得递归无限进行下去
	
	2）递归算法有问题，使得递归次数太多，导致递归调用太深，深到大量消耗栈内存
			#include <stdio.h>
			
			int fun(int n)
			{
				int ret = 0;

				if(n == 1) return 1;
				else    
				{
					ret = n + fun(n-1);     
					ret = ret + n + fun(n-1);
				}

				return  ret;
			}

			int main(void)
			{
				int ret = 0;

				ret = fun(50);

				printf("%d\n", ret);

				return 0;
			}

			为什么上面这个递归有问题？
			由于递归时有两次调动函数，你去跟踪这个递归时，你会发现随着fun(n)中数字的增加，递归次数会急剧增加，
			当n达到30时，这个递归很久都不会结束，如果将n改为100的话，情况会更严重，几乎等不到结束。
			
			所以从这个例子可以看出，对于递归来说仅有返回条件还是不够的，如果递归算法本身有问题的话，同样不行，
			对于这个例子来说，要么优化这个递归，要么干脆不要使用递归，换一种非递归的方式来代替实现。

			
	
（3）我们应该如何看待递归的使用

		递归算法的缺点是明显的，因此但凡能不用递归时就不使用递归，正是基于这一原则，不少公司为了让自己的
	软件能够更加的稳定，往往会对“递归”的使用加以限制，只有当非递归不可时才使用，但凡有更好算法时就不会
	使用递归。
	
		比如之前的递归求和，其实就可以不使用递归，我们可以使用两种方法来替代递归，所以真实的累加求和运算，
	我们是不会使用递归来做的。

	1）替代方法1：使用while循环代替
			使用while循环来实现，这个在前面已经介绍过，对于大部分的递归来说，其实都可以使用while循环来代替，
		如果使用循环来代替，循环比递归更好。
			
			当然，如果有比循环更好的方法，自然是最好的，比如累加求和，其实就有比循环更好的方法，
		那就是“方法2：高斯算法”。
		
		
		
	2）替代方法2：高斯算法					
			高斯算法的公式：sum = n/2 * (1 + n)
			
			那么0~100的求和：sum = 100/2 * (1 + 100)
			最终：sum = 5050
			
			
			从这个例子可以看出，为什么对于哪些真正做算法的人来说，对数学有很高的要求了，因为如果你数学够牛，
		你就能通过数学算法来优化程序的算法，提高程序的效率。
			
			当然，大家千万不要因为听我说数学很重要，你就去研究数学，然后想去做算法，事实上对于我们应用工
		程来说，算法不是重点，我们的重点是开发产品，如果真要用到什么算法，我们只要能够调用别人的算法库即可。

			这道理就好比造汽车，对于造汽车的人来说，只需关心怎么将所有的部件组合起来，做成产品，这才是重点，
		结果人家说了一句发动机的材料很重要，然后你就去研究材料了，这其实就南辕北辙了，你的长处是造汽车，
		不是研究材料，等你把材料研究透时，黄花菜都凉了，所以研究材料这件事就应该交给哪些专门研究材料的人。
		
			
			
			
			
			
出品：佳嵌工作室
--------------------------------------------------------------------------------------------------------
	“佳嵌工作室”致力于物联网、嵌入式产品以及‘物联网、嵌入式技术课程’的研发，希望所推出的技术课程，能够帮助
到正在努力学习物联网、嵌入式的同学，欢迎大家和我们一起共同学习，共同进步。
--------------------------------------------------------------------------------------------------------				
						
15. 内联函数
		在前面介绍过，当代码写复杂后，一定会封装出大量的函数，这会导致两个问题：
		
	（1）函数越多，栈的消耗也越厉害
			疑问：为什么代码复杂了、函数变多了，栈消耗的就很厉害？
			答：因为这会导致函数的调用深度可能会很深，比如：
			fun1 --> fun2 --> fun3 --> fun4 --> fun5 ---> ...
			
			
			在这些函数都没有返回之前，所有函数所消耗的栈空间，将一直不会被释放。
			如果复杂程序还有大量使用线程的话，线程函数还会占用栈空间。
			
			
	（2）函数的调用过程，会多花费更多额外的时间
			调用函数时，除了函数代码本身执行的时间外，还需要花费额外的时间，比如：
			
			1）从调用位置跳转到函数代码处
			2）从栈中开辟空间，将形参、自动局部变量、返回地址压栈
			3）利用返回地址返回，以及返回时的弹栈
			
			这些都是需要额外时间的，特别是如果这个函数的调用非常频繁的话，累积花费的就更多。
		
	
		所以，对于那些被频繁调用，而且“代码很简短”的函数来说，我们往往就使用“带参宏”和“内联函数”代替，
	以减少这类函数的数量，如此一来:
	（1）函数减少了，在一定程度上节约了栈内存
	（2）消除了函数调用所需的额外时间，效率更高
		
		c++中也有内联函数，用法是类似的。
		
		疑问：为什么只替代“调用频繁并且代码量很简短”的函数？
		答：后面再解释。
		
	
15.1 使用宏来代替
		事实上我们在第二章讲宏时就介绍过，可以通过宏的来代替简短的函数，以减少程序中的函数的数量。
	
	
15.1.1 例子
		a.c
			#include <stdio.h>
		
			int my_max(int a, int b)
			{
				a *= 2; // a = a * 2 
				b /= 3;
				return (a>b) ? a : b;  //找出最大值
			}
			
			int main(void)
			{
				int ret = 0;
				
				ret = my_max(25, 30);
				
				printf("ret = %d\n", ret);
				
				return 0;
			}
			
			如果my_max调用非常频繁的话，做成函数形式，其实是非常不划算的，所以完全可以使用带参宏来代替。
			
			
			
		a.c
			#include <stdio.h>
			#define MY_MAX(a, b, ret)  \
				ret = ((a*2)>(b/3)) ? (a*2) :(b/3)
		
			
			int main(void)
			{
				int ret = 0;
				
				MY_MAX(25, 30, ret);
				printf("ret = %d\n", ret);
				
				return 0;
			}
			
			进行宏替换后，main函数就变为了
			int main(void)
			{
				int ret = 0;
				
				ret = ((25*2)>(30/3)) ? (25*2) :(30/3);  //找出最大值
				printf("ret = %d\n", ret);
				
				return 0;
			}
		
			大家自己去通过预编译查看宏替换后的结果。
			预编译命令：gcc -E a.c -o a.i
		
			
			使用宏来代替后，“宏体”就变成了“引用者”的一部分，如此一来不仅节约了栈空间，也免去了函数调用
		时的额外开销。
			
				
15.1.2 使用带参宏代替函数时的要求	

（1）只用于对3~5行代码的简短函数进行替换，为什么只替换3~5行代码的简短函数呢？
			
			使用宏来代替函数，缺点也是很明显的，因为宏替换后，使用宏的函数的代码会增加，如果很多函数都有使用这
		个宏的话，程序的代码量就会急剧增加，大家要明白，代码也是需要存储空间的。
		
			为了节省点栈空间、以及降低“函数调用”所消耗的额外时间，结果导致整个程序代码的剧增，这就得不偿失了。
		
		
		
		
（2）而且只替换被频繁调用的函数
		替换这类函数才有明显的效果，否则占那么点小便宜也没有什么意思。
		
		
		
15.1.3 带参宏的缺点
		我们在第2章介绍带参宏时就说过，带参宏的参数只用于替换，不涉及参数类型的检查，所以如果我们把参数
	写错了，在预编译进行宏替换时，是不会提示错误或者警告的，这不利于代码排错。
	
		
			#define MY_MAX(a, b, ret)  \
				ret = ((a*2)>(b/3)) ? (a*2) :(b/3); 
			
			int main(void)
			{
				int ret = 0;
				
				MY_MAX(dsf344, 30, ret);
				printf("ret = %d\n", ret);
				
				return 0;
			}
			
			参数指定为dsf344肯定是错的，但是宏在替换时，只进行替换，不会进行参数检查，但是这个你要是搁在
		函数里面，函数会进行严格的参数检查，如果不对就会报错。
			为了改进带参宏不会进行参数检查的缺点，后来从c99标准开始就有了"内联函数"。
			

	
	
	
	
15.2 内联函数 

15.2.1 内联函数是个啥	
	内联函数既不是函数也不是宏，它一个兼具宏和函数共同特点的这么个特殊的玩意。
	
（1）具有宏的特点，会像宏一样进行替换
			不过宏是在“预处理阶段”进行替换的，而内联函数则是在“编译、链接”阶段进行替换的。
		替换的过程也被称为“内联”的过程，所以才被称为“内联函数”。
		
（2）也具有函数的特点，会像函数一样进行参数类型检查		
		
	
	一句话来概括的话，内联函数就是会像函数一样进行“参数类型检查”的带参宏。
	

	
15.2.2 内联函数举例	
（1）inline关键字
			这个是内联函数所使用的关键字，标记了这个关键字的函数就是内联函数，不过只有标记“函数定义”时才
		是有效的，至于声明，标不标记inline都无所谓。
		
			由于内联函数和“宏”有点类似，而宏经常放在.h中，所以我们一般习惯于将“内联函数”的定义放在.h中，
		不过我们前面的课程就说过，如果将函数放在.h中，而且函数如果是extern的话，会报重复定义的错误，所以我
		们往往需要将其修饰为static。
		
（2）例子	
		inline.h
		
		#ifndef H_A_H
		#define H_A_H
		
		static inline int my_max(int a, int b) //inline只有修饰函数定义时才有效
		{
			a *= 2;
			b /= 3;
			return (a>b) ? a : b;  //找出最大值
		}
		
		#endif
		
		a.c
		#include <stdio.h>
		#include "inline.h"
		
		int main(void)
		{
			int ret = 0;
			
			ret = my_max(25 ,30);
			
			printf("ret = %d\n", ret);
			
			return 0;
		}
		
		凡是要使用这个内联函数的.c，只需要包含这个.h即可。
		
		不过大家要小心，如果.c恰好有定义与“内联函数”同名的函数的话，不管这个函数普通函数还是“内联函数”，
	编译会报错的，所以编程时不要编写与内联函数同名的函数。
		
		
		
（2）检查预编译后的.i文件
		gcc -E a.c -o a.i
		
		
		a.i
		
		...
		
		
		inline int my_max(int a, int b)  //预编译后，这个玩意任然还在
		{
			a *= 2;
			b /= 3;

			return (a > b) ? a : b;
		}

		int main(void)
		{
			int ret = 0;
			
			int (*funp) = my_max;
			
			ret = funp(25, 30);
			
			return 0;
		}
		
		预编译后内联函数仍然还在，所以内联函数这玩意并不在“预编译阶段”被处理。
		

	
15.2.3 内联函数只是建议进行替换

		指定了内联函数后，只是建议进行替换，到底会不会进行替换，这个需要看编译器，如果编译器判断存在
	如下情况的话，就算指定了inline关键字，但是编译器也只当做是普通函数。
		
	1）函数代码量很大，不够简短，代码超过5句以上时，就不简短了
	2）不是通过函数名调用的，而是通过“函数指针”来调用的
			int (*funp) = my_max;
			ret = funp(25, 30);
	
	3）函数是递归
	4）switch、while、for、do while等
		
		
		
15.2.4 编译时无法识别inline关键字，怎么办
	
	在解释原因之前，先说说c标准。
	
（1）c标准
		为了标准化c语法，所以制定了C标准，目前的c标准有4个版本
		c89：1989年制定
		c90：1990年制定
		c99：1999年制定
		c11：2011年制定
			
			其实中间还有c94/c95标准，不过这两个可以忽略。
			c89和c90其实是一个标准，为什么一个标准有两个名字，这个是由于历史原因导致的。
			
			一般来说，制定新标准时，一些旧的语法可能会被修改或者抛弃，然后再添加一些新的语法特性，
		至于inline则是从c99才开始支持的语法特性，所以目前只有c99/c11才支持inline。
			
		
（2）为什么有些编译器在编译内联函数时，会有问题呢

			说明你的编译器版本比较老，老版本默认是按照c89/90去编译的，自然不认识inline，所以我们需要给
		gcc指定-std=c99或者-std=c11选项，明确的告诉编译器，请使用c99、c11标准去编译c程序，这是就没问题了。
	
			比如：
			gcc a.c -std=c99  //或者c11
			
			如果你想查看.s的话，
			gcc -S a.c -o a.s -std=c99  //或者c11
			
			在IDE下如何设置-std=**选项？
			演示：
			
			
			疑问：我这边在gcc编译时，为什么内联函数没问题？
			答：我这边gcc版本比较新，默认就是以c99或者c11来编译的，所以自然就是没问题了。
			
				gcc -v查看版本号为gcc version 5.4.0 20160609，版本推出日期为20160609，
			而现在的时间是201809010，确实是很新的版本，不过目前最新的版本，好像已经到了6.1.0。

	
	
	
	
	
