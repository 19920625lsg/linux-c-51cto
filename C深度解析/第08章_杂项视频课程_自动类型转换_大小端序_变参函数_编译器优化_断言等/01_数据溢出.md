# 0. 数据溢出（数值范围和补码）

本小节不仅仅只是介绍数据溢出，还会借此介绍整形的数值范围、补码、有符号与无符号等问题。

# 0.1. 面试题：指出如下代码的问题

```c
#define MAX 255

int main(void)
{
    unsigned char A[MAX],i;  //i被定义为unsigned char
    for (i=0; i<=MAX; i++){
        A[i]=i;
    }
}
```

## 0.2 unsigned char的数值范围和数据溢出

### 0.2.1 数值范围

i的类型为unsigned char，**最高位不再用来表示符号**，而是直接参与数值的表示，所unsigned char所允许的数值范围为：

```shell
76543210  位编号
11111111   255     2的8次方-1，即100000000-1
11111110   254  
...
00000001   1  
00000000   0
```

所以，unsigned char类型的数值范围为：`0~2^8-1`(或者`0~255`)  
不要去记数值范围，记是记不住的，关键是理解，只要理解了，随时可以推算出来。

### 0.2.2 unsigned char的数据溢出

#### （1）向上溢出

```c
 11111111 + 1  进位变为
100000000      由于char只有8位，最高位被舍弃，所以溢出变成  
 00000000      所以结果为00000000, 向上溢出变为了最小数0 
```
 

#### （2）向下溢出

```c
 00000000 - 1  借位溢出  
011111111      借位向下溢出后，结果为11111111, 向下溢出变为了最大数255
```

#### （3）题目存在的问题	

```c
for (i=0; i<=MAX; i++){
    A[i]=i;
}
```

题目中for循环的`i<=MAX`是不成立的，因为i是unsigned char，它的数值范围为`0~2^8-1`，即0~255  
当i++到255后就会向上溢出为0，而MAX为255，所以i永远不存在大于255的情况，所以是一个`死循环`    

## 0.3 char的数值范围和数据溢出

一般情况下，char默认就是signed char，但是也有极少数编译器比较特殊，char会被默认理解为unsigned char，
有符号char必须明确的写为signed char，signed不能省略，不过这种情况很少，一般char都是默认为signed char。

### 0.3.1 数值范围 

char为有符号，**最高位用于表示符号**(1表示负数、0表示正数)，不参与数值的表示，所以真正表示数据的只有7位

```c
符
号
位
76543210
01111111  127    2的7次方-1  即 10000000-1 
01111110  126
...
00000011  3
00000010  2
00000001  1

00000000  0     -------------------------

11111111  -1     
11111110  -2
11111101  -3
...				
10000010  -126
10000001  -127
10000000  -128  -2的7次方
```

char的数值范围：-2的7次方 ~ 2的7次方-1（-128 ~ 127）。

有关char的数值范围，同样不要去记忆，关键是理解，只要理解了就能推导出来。

疑问：为什么在计算机有符号数（char）中，11111111就代表-1、11111110就代表-2？
答：这个涉及到了计算机存储数据时的补码问题，有关补码后面再介绍。

### 0.3.2 char型数据溢出

```c
01111111  127    2的7次方-1  即 10000000-1
01111110  126
...
00000000  0
...
10000010  -126
10000001  -127
10000000  -128  -2的7次方
```

#### 1）向上溢出

```c
01111111+1
10000000     -128，在计算机有符号char中，10000000就代表-128
```

所以同样的，最大数向上溢出，就变为了最小数。

#### 2）向下溢出

```c
10000000-1
01111111     为127，在计算机有符号char中，01111111就代表127
```

与unsigned char一样，最大数向上溢出就变为了最小的数，最小的数向下溢出就变为了最大的数。

## 0.4 unsigned int、int的数值范围 与 数据溢出

### 0.4.1 回顾unsigned char和char

char位数：8bit

#### unsigned char的数值范围

0 ~ 2的8次方-1

#### char范围

-2的7次方  ~  2的7次方-1 

#### 溢出

最小变最大，最大边最小。

### 0.4.2 unsigned int与int

int位数：32bit

#### unsigned int的范围

0 ~ 2^32-1

```c
11111111 1111111 1111111 1111111   2^32-1
 ..
00000000 0000000 0000000 0000000    0
```

#### int的范围

-2^31 ~ 2^31-1

```c
01111111 1111111 1111111 1111111    2^31-1
...
00000000 0000000 0000000 0000000    0   -----------
11111111 1111111 1111111 1111111    -1
...
10000000 0000000 0000000 0000000    -2^31
```

#### 溢出

最小变最大，最大边最小。

### 0.4.3 short、long

同样的道理，short、long也是一样的，只是位数不一样而已。

通过以上介绍可知，只要大家理解了char、unsigned char的数值范围和数据溢出，int、unsigned int、short、unsigned short、...等的数值范围和数据溢出，也可以非常容易的被类推出来。

### 0.4.4 数据类型的范围规律

> 数据类型的位数 = 字节数 * 8，比如int类型为4个字节，那么就是32个位

+ 正常范围：`2^(数据类型位数-1)` ~ `2^(数据类型位数-1) - 1`
+ unsigned范围：`0` ~ `2^数据类型位数 - 1`
+ 溢出后的值：`最小变最大，最大边最小`

## 0.5 计算机数据存储————补码

### 0.5.1 回顾char的数值范围

```c
01111111  127    2的7次方-1  即 10000000-1 
...
00000011  3
00000010  2
00000001  1

00000000  0     -------------------------

11111111  -1
11111110  -2
11111101  -3
...
10000000  -128  -2的7次方
```

为什么在计算机的有符号数中11111111代表-1，11111110代表-2？  
答：因为计算机是使用补码来表示负数的，对于有符号char来说，在计算机看来11111111就是-1，11111110就是-2，10000000就是-128。

### 0.5.1 补码

计算机存储数据时，是以补码形式存储的：

+ `正数的补码`：就是自己，也就是说**计算机存储正数补码时，存储的就是正数本身** 

+ `负数的补码`：**绝对值取反+1**，计算机存储负数时，存储的就是“绝对值取反+1”这个补码，在计算机中这个补码就代表这个负数。取反是逐位取反，1变0，0变1

#### （1）-1在计算机中存储时，存储的补码是多少

我们假设为char型

```c
        -1
         ↓
absolute ↓  |-1|
         ↓
     00000001 
         ↓
 toggle  ↓   ~
         ↓
     11111110
         +  
         1
         ↓
     11111111
```

存储的-1补码为11111111=255。

#### （2）-2在计算机中存储时，存储的补码是多少

我们假设为char型。

00000010  |-2| ~
11111101  +
   1   		 
11111110   
```c
        -2
         ↓
absolute ↓  |-2|
         ↓
     00000010 
         ↓
 toggle  ↓   ~
         ↓
     11111101
         +  
         1
         ↓
     11111110
```
存储的-2补码为1111111=254

规律：
+ 正数补码 = 自己
+ 负数补码 = 2^数据类型位数 + 负数
#### （3）得到了某个补码后，如何知道这个补码表示的是-?

比如补码为11101100，假设还是为char类型，那么它所代表的是-？

```c
        取绝对值            取反  +1
-？————————————————> ？ ——————————————>  11101100
```

反推:
```c
            -1      取反             加上-
11101100 ———————> ? —————————> ? ————————————> ?

	  -1           取反                           加上-
11101100 ————>11101011——————>00010100(2^4+2^2 = 20)———————————> -20
```

所以在计算机有符号数(char)中, 补码11101100代表的就是-20，11101100是计算机理解的-20，-20这个是人以理解的样子.

计算机在显示器上显示-20这个图形给我们人识别时，就是这样先反推出“绝对值”，然后给绝对值加上-，然后再以人类所能识别的图形-20显示出来。

#### （4） 计算机存储补码有什么好处

提问：同一个有符号数的正数补码+负数补码 = ？
为了描述的方便，我们还是以char型来讲解。
1）5的补码：就是本身00000101，计算机存储5时，存储的就是这个数。
2）-5的补码：11111011，计算机存储-5时，存储的就是这个数
3）5+(-5)

计算机其实就是将5和-5的补码相加。
	
```c
5   00000101 
-5  11111011
   100000000 
    00000000  // char型只允许8bit有效，将溢出位去掉，结果为0。
```
			
这不就是实现了同一个数的正负数相加等于0吗，这就存储补码的好处，`正数补码+负数补码 = 0`  
			
对于人来说，5+(-5)=0属于数学规则，人们只要一看到这个表达式就知道结果为0，但是对于计算机来说不可能通过感觉来计算，它必须要有具体的实现规则，这个规则就是**正数、负数补码相加=0**
		
### 0.5.3 对于二进制数11011011来说，如果是char类型的话，它所代表的十进制数是多少？如果是unsigned char的话，它所代表的十进制数又是多少？

对于同一个二进制数，因为有符号和无符号的区分，导致所代表的十进制数可能会截然不同。

#### （1）如果该二进制数的类型为char(signed char)

最高位为符号位，1表示负数，0表示正数。

11011011的最高位为1，表示它是负数的补码，所以表示的十进制数是一个负数，至于是-？，我们需要反推之后才知道。
```c
              -1  取反                          加上- 
11011011——————————————————> 00100101（?37?）————————————>  -37
```

所以，如果11011011的类型为char的话，代表的十进制数是-37  

#### （2）如果该二进制数的类型为unsigned char

最高位不再是符号位，最高位也用于表示数值，整个数就是一个正数的补码，我们前面说过，**正数的补码就是正数本身**，因此这个二进制数直对应的十进制，就是它所代表的十进制数。

```c
11011011 ——————————————> 219
```

因此，当二进制数11011011的类型为unsigned char，代表的是十进制数219。

#### （3）例子：`int a= -20，unsgined int b = a;`，请问a和b各自代表的十进制数是多少？
		
请一定要理解这个例子，我们后面讲自动类型转换时，会牵涉到这个例子。
			
			
+ 1）a所代表的十进制数是多少？

	计算机存放-20时，存放的是-20的补码

	```c
	         取反 + 1               补码：实际存储的内容
	|-20|  ——————————————>11111111 11111111 11111111 11101100
	```

	由于a的类型为int(有符号)，数据的最高位为符号位，最高位为1，表示它是负数的补码，  
	因此11111111 11111111 11111111 11101100所表示的十进制数是一个负数，通过反推可知，为-20  

+ 2）`unsgined int b = a`
  
	通过初始化，a中的11111111 11111111 11111111 11101100被复制到了b中，还是那个二进制数，但是由于b的类型为unsgined int，最高位不再是符号位，是最高数值位了，因此会以 unsgined int去解释这个数  。

	此时最高位不再是符号位，整个二进制数就是正数的补码，因此这个二进制数代表的是一个非常大的正数4294967276  

	再次总结，对于同一个二进制数来说，由于有符号与无符号的区分，它所代表的十进制数可能会截然不同。
