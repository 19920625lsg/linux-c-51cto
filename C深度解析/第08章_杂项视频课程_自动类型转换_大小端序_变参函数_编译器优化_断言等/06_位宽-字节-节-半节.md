# 5. 位宽、字节、字、半字

很多同学对于位宽、字节、字、半字不是很理解，这里有必要介绍一下  
	
其实有关这些概念就算你不知道，也并不会十分影响我们的编程开发，但是如果你知道的话肯定是最好的，这能够帮助我们理解和解决其它与之相关的问题  

## 5.0 位宽

“位宽”其实是一个非常底层的概念，只与硬件有关，与编程并没有太大关系。

但是如果你能理解这个概念的话，有助于你阅读文档资料，因为有些文档资料里面会有位宽的概念，所以有必要了解下。

## 5.1 什么是位宽 

位宽就是cpu访问寄存器、缓存、内存、显存等时，一次能传输的数据位数（bit数）（最小传输单位）。

我们这个说法不够严谨，实际上cpu是不能直接访问显存的，是由GPU来直接访问显存的，我们会和CPU对接。
	
## 5.2 “位宽”就是“数据线的根数”

一般情况下，“位宽”就是“数据线的根数”，但是也有些少数情况是，“位宽”不等于“数据线根数”，不过这种情况不考虑，因为常见的情况就是“位宽”等于“数据线的根数”。

## 5.3 位宽与内存对齐

我们上一章介绍的“结构体成员对齐”，其实就是各种“内存对齐”情况当中的一种。
	
“位宽”决定了访问寄存器、缓存、内存、显存等时，一次传输数据的bit数，进行内存对齐以后，可以按照“位宽”的大小，一次就将数据传输完毕，但是如果不对齐的话，本来一次就能传输完毕数据，可能要传输好几次，如此显然会降低了访问效率。
	
这就是我们在上一章说的，“内存对齐”有利于提高访问效率  

`疑问`：我是不是应该深入的研究下内存对齐呢？  
答：没必要  
对于内存对齐这个东西，大家不要纠结，也没有必要纠结，因为编译器在编译时会帮我自动的进行“内存对齐”，包括结构体成员的“内存对齐”也是有编译器自动完成的，我们顶多会手动指定一下“对齐系数”  

在上一章里面，我们为什么会重点的介绍一下“结构体成员”的内存对齐呢，主要是在Linux嵌入式开发中，有时候会涉及到，所以我们才介绍，否者我们是不会介绍的  
	
	
## 5.4 字节、字和半字

字节、字和半字也是与硬件密切相关的概念。
	
### （1）字节

字节是固定的，8个bit为一个字节，不管是在什么硬件（cpu）平台上，都是一样的。
		
### （2）字

一般来说，字就是“位宽”的大小，或者说就是“数据线的根数”。

数据线为32根时，“位宽”为32bit(4字节)，字也就为32bit(4字节)  
数据线为64根时，“位宽”为64bit(8字节)，字也就为64bit(8字节)  
		
### （3）半字

字的一半就是半字，这个非常好理解。
	
字节与硬件平台无关，都是固定的8bit，但是“字”、“半字”与硬件平台有关，不同硬件平台下，“字”、“半字”不一定相同。

## 5.5 编程时无需关心“字”、“半字”

编程时，我们顶多只关心“字节”这个概念，因为字节是衡量变量空间大小的基本单位，但是对于半字和字来说，我们编程时关心的意义不大。

对于编程的程序员来说，只需关心“字节”、char/short/int/float等这些类型。

各种类型的大小，我们就是用“字节”来衡量，比如char1个字节，short2个字节等等。
	
	
## 5.6 char/short/int等类型的大小是否是固定？
	
在“c标准”的规定里面，只有char的是固定的，为一个字节，但是除了char外的其它类型，“c标准”只是给了一个范围，比如“c标准”规定，int的大小为2~8字节之间。

c标准只给一个范围的这种规定，这个给c语言在不同硬件平台上的使用，提供了一种灵活性，具体int是4个字节还是8字节，这个由硬件平台来决定，比如在有些硬件平台下，int为2字节，而有些则是8字节，不过常见的int都是4字节。
		
我们想得到针对不同硬件平台的“二进制程序”，就必须使用专门针对该硬件平台的编译器，编译器在编译c代码时，它会按照该平台的类型要求，去翻译char/short/int/double等类型，比如：
	
该平台规定int为2字节：翻译int a;时，a的空间大小就是2字节。
该平台规定int为8字节：翻译int a;时，a的空间大小就是8字节。
		
疑问：不同平台下，char/short/int等类型的大小是不一样的，我怎样才能知道他们具体是多大呢？  
答：很简单，pritnf("%d\n", sizeof(类型名))就可以了  
		
