# 6. 编译器优化

## 6.1 什么是编译器优化

我们在编写程序时，代码写的可能并不精炼，代码不精练有两个表现：

+ 代码冗余
+ 代码不合理

### （1）代码冗余

代码冗余会带来如下两个问题：

+ 1）冗余代码会增加程序的代码量，所以冗余代码会浪费存储空间
+ 2）冗余代码也会被cpu执行，因此会降低代码的执行效率，浪费执行时间

编译器就可以通过优化，帮我们优化掉这些冗余代码，提高代码质量。

### （2）代码不合理

我们举一个例子：

```c
int square(int *ptr)
{
    return *ptr * *ptr;
}
```

以上是求平方的函数，在单线程中这个函数并没有问题，但是在多线程中这个代码中确存在问题。

`疑问`：为什么在多线程中存在问题？
答：因为存在如下可能性。
当“当前线程”执行第一个`*ptr`时，假设`ptr`所指向空间的值为3，因此第一个`*ptr`为3，假如碰巧在执行第二个`*ptr`之前就切换到了其它线程上，刚好该线程将ptr所指向空间的内容改为了8，然后再切换会回来执行第
二个`*ptr`时，此时第二个`*ptr`确为8，此时计算的结果为`3*8`。并不是我们需要的平方运算。

编译器在编译时，会帮我们优化以上代码，将以上代码优化为如下形式的等价代码：

```c
int square(int *ptr)
{
    int a = *ptr;

    return a * a; 
}
```

该代码求的一定是平方运算。

## 6.2 优化级别

在第1章我们就提到过优化级别，不过当时介绍的很简略，那么现在我们来较为详细的介绍一下优化级别，介绍的目的就是让大家了解一下什么优化级别，以及应该如何对待这些不同的优化级别。

首先我们要知道，不同编译器的优化级别是不一样的，比如以gcc为例，我们在Linux下，通过man命令查看gcc的命令手册，可以查看到gcc的优化级别：

```shell
-O0  -O1（-O）  -O2  -O3  -Os -Ofast -Og。
```

-O0  -O1（-O）  -O2  -O3这几个，数字越大优化级别就越高，-Os -Ofast -Og与O3算是同级别，但是会略有不同。

我们在编译时，如何指定优化级别：

### （1）在命令行下

```shell
gcc a.c -O2
```

### （2）在IDE下

如果是通过IDE的话，就需要在IDE选项中指定优化级别，比如Codeblocks为例：演示：

Codeblocks调用gcc时，就会给gcc指定这些选项。

这里需要注意一点，优化级别越高，优化的就越深，编译器编译时越耗费时间，因为编译器对代码进行优化时，是需要执行相应的优化算法的，执行这些优化算法，必然会额外消耗时间，优化的越深，算法所学的时间就越多。

### 6.2.1优化级别的介绍

在gcc的man手册描述中，对每一个优化级别都有详细介绍，我们这里简单的介绍一下。

+ `-O0`：表示不优化。
   gcc -g生成调试版（Debug）版程序时，默认就是-O0，在调试版中不会进行优化

+ `-O1`：
    -O和-O1是一样的，这个优化级别会在不剧烈影响编译速度的前提下，尽量采用一些优化算法降低代码大小和提高代码的运行速度。
    O1为缺省值，gcc时如果不指定优化级别的话，默认就是O1优化级别。

    在不指定-g时，编译得到的是发行版（Release）版程序时，如果没有明确指定优化级别的话，会默认按照-O1来优化（默认值）。

    为什么发行版默认会进行最低级别的优化呢?
    答：因为发行版是给用户使用的，所以必须要提高代码质量，提高代码有两个方面，
        + （1）降低代码量，减少对用户计算机存储空间占用
        + （2）提高代码的执行效率，降低代码运行时间

+ `-O2`：
    除了包括O1的优化选项外，还会进行进一步的优化，以提高目标代码的运行速度。

+ `-O3`：
    该选项除了保留-O2所有的优化选项之外，还会采用很多“向量优化算法”，更好的利用现代CPU中的流水线，Cache等来更好的提高代码的运行速度。

    O3的优化级别很高，但是这个级别的优化也是很危险，因为

    + 1）优化的太深，编译速度会非常的慢，如果编译的海量代码的话，会非常痛苦，而且在优化效果上，O3其实并不比O2强太多。

    + 2）O3采用了深度优化算法，可能会导致“代码逻辑”出现大的变化，最终导致程序的运行结果并不是我们要的结果，而且编译失败的可能性也很大。

    鉴于以上问题，O3这个优化级别，大部分时候算是一种传说中的存在。

+ `-Os`：
    Os与O3基本处于同一优化级别，只不过O3的侧重点是提高代码运行效率，而Os的侧重点是尽可能降低“代码量”。

`-Ofast`：
    与O3属于同一级别，但是优化时可能会借鉴其它语言的一些相关特性来优化c代码。

-Og：只进行与-g选项不冲突的优化，-g是调试选项，Og就是选择与调试不冲突的优化选项。


如果你对优化级别感兴趣，请看gcc的手册，里面有详细描述，而且是非常权威的描述，比大家上网查到的很多信息要靠谱得多，但是不建议去详细阅读，意义不大，以后确实有需求再去看。

## 6.3 我们应该怎么对待优化

### 6.3.1 不要过分神话优化，优化也有缺点

虽然优化能够提高代码质量，但是优化不一定都是好的，特别是当优化级别很深时，优化有可能会完全违背你原有的意思，最后导致程序不能运行得到期望的结果。

### 6.3.2 如何选择优化级别

+ （1）Debug版程序
    gcc通过加上-g选项，在编译时就得到了调试版程序，此时如果没有明确指定优化级别的话，编译得到调试版程序时，默认是不会优化的。 

+ （2）Release版程序
    如果不加-g的话，就编译得到了Release版程序，如果没有明确指定优化级别的话，编译得到Release版程序时，一般默认为-O1优化级别，如果你想得到更高的优化级别，就需要明确的指定更高级的优化。

    在编译得到Release版程序时，建议使用默认优化级别即可，因为这是一个很合适的优化级别，既能帮我们进行一定程度的优化，同时又不会过分改动，让代码变的很厉害。

    如果非要提高优化级别的话，O2级别也是可以的，不过O3这个级别就要慎用了。

    `疑问`：O3级别似乎完全没有存在的意义呢?
    答：当然也不是的，如果说你的设备对于代码速度或者代码大小非常敏感，那么我们就需要通过O3这种高级别优化来极大的提升运行速度、减少占用的存储空间。

    比如早期单片机设备，存储空间很少很精贵，为了让代码尽可能的占用更少的代码空间，就需要选择高优化级别，以最大限度的减少代码量。使用高优化级别来优化时，如果不想让代码因优化而被严重扭曲，那么你的代码就要写的更加的严谨，越严谨的代码，被优化改动的可能性就越小

    不过，现在就连单片机这类嵌入式计算机的cpu性能和存储空间都已经很高了，所以在单片机程序中也不会使用这种高级别的优化了。

## 6.4 volatile关键字

### 6.4.1 volatile的作用

一般情况下，我们在编译得到“发行版（Realse版）”程序时，会了让代码质量更高，编译器一般会默认进行最低级别（-O1）的优化，而且我们也希望进行这种级别的优化，因为可以在一定程度上提高代码质量，同时程序代码又不会改动的很厉害。

但是有些时候，我们虽然希望对整个程序进行优化，但是程序中的某些代码确不希望被优化，此时我们就可以使用volatile来阻止这些代码被优化，所以volatile的作用就是阻止编译器对某些代码进行优化。

volatile最常见的作用就是修饰变量，修饰变量后，volatile就会**阻止优化所有操作该变量的代码**，如果没有volatile的修饰的话，编译器会对操作变量的代码，进行如下两种常见的优化：

  + 1）**删掉它认为无用的代码**
  + 2）**抄近路，不使用变量在内存中的数据，而是直接赋值或者使用缓存中的数据**

    如果这两种优化对程序来说无影响，那无所谓，但是如果这两种优化对程序有很大影响，我们就应该是使用volatile来修饰变量，阻止编译器对操作变量的代码进行优化  

#### （1）删掉它认为无用的代码

比如：
    ```c
    int i = 0;
    i = 1;
    i = 2;
    i = 3;
    ```

编译器在编译这三句赋值语句，它会认为前两次的赋值毫无意义，因为它觉得其两次赋值会被第三次覆盖，
优化时编译器会将前两句赋值删除，最终变为了如下样子：
    ```c
    int i = 0;
    i = 3;
    ```

假如连续三次赋值有意义的话，就不能优化删除代码，那么我么就必须使用volatile来阻止编译器的优化。
    ```c
    volatile int i = 0;
    i = 1;
    i = 2;  
    i = 3;
    ```

此时编译器不会对操作i的代码进行任何优化，完全保持源码，那么前两句赋值语句就不会被删除。

当然，如果前两句确实毫无意义，那么我们也没有必要使用volatile来阻止优化，应该让编译器把这两句赋值语句优化掉，否则就会造成冗余代码，降低代码质量。

#### （2）抄近路，不使用变量在内存中的数据，而是直接赋值或者使用缓存中的数据

```c
int j = 10;
int m, n, k;

m = j;
n = j;
k = j;
```

编译器在编译时，由于它发现在执行三句赋值语句期间，并没有任何修改j的代码，它认为j的值固定为10，此时编译器就会优化搞点小动作，得到它所认为的高质量代码，此时编译器可能会按照如下两种形式来优化  

+ 1）第一种优化方式
    编译认为，既然j的值固定为10，那干脆直接将10赋值给m、n、k就可以了，从而会把这三句话优化为如下形式的三句话。
    ```c
    int j = 10;
    int m, n, k;

    m = 10;
    n = 10;
    k = 10;
    ```

    优化后代码就不会读内存中j变量的值，而是直接将m/n/k赋值为了10，它认为这种捷径更合理，这样就不需要费劲的去读取j变量的内存空间了。

+ 2）第二种优化方式
    ```c
    m = j;
    ```
    将j内存空间中的10读到寄存器中，然后再从寄存器中将10赋给m。
    ```c
    n = j;
    k = j;
    ```
    编译以上两句话时，编译器优化后的代码就会走捷径了，此时不会去读取变量j在内存中的10，而是直接读取寄存器中缓存的10，从寄存器中将10赋给n和k  

+ 3）以上两种优化方式存在的问题

    不管是以上哪一种优化方式，编译器都认为在执行三句赋值语句时，j的内容都固定为10，因此没有必要每次都去读j的内存空间，编译器就会优化代码，优化后的代码都会走捷径，不会每次都老老实实去内存中读取j中的10。

    如果在执行三句赋值语句期间，j的内容确实不会改变的话，那么编译器的以上优化确实提高了代码质量，因为优化后的代码，避免了费劲的去读取内存。

    但是如果在执行三赋值语句期间，j的值有可能会改变的话，那么编译器的优化就会带来问题。 

    那么j的值可能会因为哪些情况而改变呢？一般为如下三种：
    + 1）**j被计算机硬件本身改变**
    + 2）**被中断函数改变**
    + 3）**在多线程中，被其它线程改变**

    如果在我们的程序中，j的值确实存在被以上三种情况改变的可能的话，优化的代码确实存在严重的问题。

    `疑问`：什么问题呢？  
    假设在执行m=j自后，j空间中的内容被改变为了20，那么n和k里面放的就应该是20，但是优化后的代码确使得m、k固定为10，优化后的代码根本无法响应j值的变化，此时我们就需要使用volatile来阻止优化。
    ```c
    volatile int j = 10;
    int m, n, k;

    m = j;
    n = j;
    k = j;
    ```

    加了volatile之后，编译器就不会优化与j有关的操作代码，以上三句话都与j有关，自然也不会被优化。

    没有被优化的代码在执行每一次的赋值时，都会老老实实的将j内存空间中的值读出，并赋值给m、n、k，如果j的值在三次赋值中有改变的话，那么代码将能够很好的响应这个改变。

    同样的，最终加不加volatile需要由我们程序员自己来判断，如果你发现优化后的代码存在问题的话，就加上以阻止优化，否则就不要加，让编译器优化以提高代码质量。

#### （3）总结volatile的作用

用来阻止编译器的优化，最常见的是修饰变量，阻止编译器优化操作变量的代码

+ 1）**阻止优化时删减代码**
+ 2）**阻止优化代码走捷径，保证每次都从变量的内存空间读取原始数值**

volatile在多线程中使用尤其多

#### （4）对于变量的误区

说到变量时，很多同学一直以为int a、float b、sturct Student c的a、b、c才算是变量，但事实上只要是可以被修改的空间都是变量。

如果地址0x32343454所指向的空间可以被修改，对0x32343454进行解引用后，`*((unsigned int *)0x32343454)`同样也是一个变量。

### 6.4.2 volatile的真实案例

#### （1）例子1：volatile修饰寄存器变量的例子

假设某个状态寄存器的地址为0x65464543，大小为4字节。

状态寄存器的特点是，寄存器中的数值随时可能会被计算机硬件本身所修改。

读“状态寄存器”的代码：
```c
#define  REG (*((unsigned int *)0x65464543))  //状态寄存器变量

int i = REG; //读取状态寄存器变量的值，赋值给i
int n = REG; //读取状态寄存器变量的值，赋值给n
int k = i + n;
```

+ 1）编译器会如何优化
    编译器编译时，会认为第二次对n的赋值没有意义，编译器优化时会将第二个赋值语句删除，优化后的等价
    代码如下：
    ```c
    int i = REG;
    int k = 2*i;
    ```

+ 2）实际情况
    实际情况是，状态寄存器变量中的值可能随时会被计算机硬件本身所修改，所以两次赋值时，所读到的寄存器中的值可能并不一样，因此第二次的赋值不能省略，那么此时就需要使用volatile来阻止优化了。
    ```c
    #define  REG (*((volatile unsigned int *)0x65464543))  //状态寄存器变量强制转换为volatile类型

    int i = REG;
    int n = REG;
    int k = i + n;
    ```

    使用voatile修饰后，操作寄存器的代码将不会被优化
    大家在做单片机等与硬件密切相关的开发时，会经常见到使用volatile来修饰寄存器变量的情况，其实就是我们这里所讲的情况。

    `疑问`：为什么要强制转换为`unsigned int *`？  
    答：如果不转为指针类型的话，0x65464543就是一个整形数，是不能够对整形数进行解引用的，而且寄存器的大小为四个字节，所以我们使用int来访问，因为int的大小恰好也是4个字节，如果使用char、short的话，就只能访问寄存器的1个~2个字节。
    
    而且对于寄存器操作来说，负数是没有意义的，为了防止负数最高位符号位的干扰，所以我们使用了unsigned，以无符号类型去解释寄存器空间时，将不会受到符号位的干扰。
			
#### （2）例子2：中断函数的例子

```c
int i = 0;

int main(void)
{
    ...
    while(1)
    {
            if(i) dosomething();
    }
    return 0;
}

/* 中断处理函数 */
void ISR_2(void)
{
    i=1;
}
```

+ 1）编译会如何优化？

    编译器在编译main函数中的if(i)时，它发现i的值一直为0，因此它认为if(0)永远是假的，所以它觉得  
    ```c
    if(i) dosomething();	
    ```
    完全是多余的，因为代码根本不会被执行，编译器在优化时就会将以上代码删除


+ 2）实际情况
    实际情况是，i的值并不会一直为0，因为当某个中断产生后，比如按键按下产生了一个中断信号后，正在执行的main主线就会被打断，中断处理函数会被硬件自动调用，此时cpu进而会去执行“中断处理函数”的代码，在中断函数中将i的值修改为1，当“中断处理函数”执行完毕后，再回到被打断的主线继续执行，此时if(i)必然就是成立的，因此
    ```c
    if(i) dosomething();
    ```
    是有意义的，不能被优化删掉，此时我们就需要使用volatile来阻止编译器优化操作i的代码。
    ```c
    volatile int i = 0;
    ...
    ```

#### （3）例子3：多线程并发运行的例子

主线程：
```c
extern int i = 10;

int main(void)
{
    int m, n, k;
    m = i;
    n = i;
    k = i;
    ...
    ...
    return 0;
}
```

次线程:
```c
extern int i;

void *pth_fun(void *ptharg)
{
    i = 20;
    ...
    ...
}
```

没有次线程时，整个程序就是单线程的，此时单线程就是主线程，main函数一定是由主线程来执行的。

+ 1）编译器会如何优化
    这个例子我们在前面就大概的讲过，主线程中的m = i; n = i; k = i;，可能会被优化为如下等价形式：

    ```c
    m = 10;
    n = 10;
    k = 10;
    ```

    编译器之所以会这么优化，是因为它认为i的值是固定死的，这样优化的能够提高代码质量。

+ 2）实际情况
    实际情况是，当主线程在执行中某个赋值语句时，比如刚要执行m = i;时，可能就会从主线程切换到次线程上，执行次线程的代码，此时次线程会通过i=20将i赋值为20，当再次切换到主线程执行m=i; n=i; n=k;时，m、n、k就应该被赋值为20，但是被优化后，m、n、k确固定为10，代码无法响应次线程的修改，此时需要阻止优化。

    为了阻止编译器优化，我们必须使用volatile修饰i，阻止编译器对操作i的代码进行优化，如此一来，当执行主线程的m = i; n = i; k = i;语句时，每次都会老老实实的从i的内存空间中读出实际数值，如果i的值发生变化了，那么赋值的就是发生变化后的值。

#### （4）其它例子

比如**操作共享内存时，我们也会使用volatile**，使用volatile的例子不少，不过我们这里不再一一举例。

## 6.5 volatile不要乱用

有需求时才使用volatile，否则不要胡乱使用，因为胡乱使用往往会带来不良效果。

### 6.5.1 回顾前面的例子

```c
int square(int *ptr)
{
    return *ptr * *ptr;
}
```

在多线程中，这个函数存在缺陷，但是编译时编译器会帮我们优化为如下等价的代码：

```c
int square(int *ptr)
{
    int a = *ptr;
    return a * a;
}
```

优化后的代码就不存在缺陷了。

### 6.5.2 给形参加了volatile的话，会怎样呢？

比如：

```c
int square(volatile int *ptr)
{
    int a = *ptr;
    return a * a;
}
```

volatile会阻止编译器的优化，代码的缺陷会被一直保留，显然volatile起到了反效果 

当你需要优化的时候，不能加volatile，不需要优化时才需要加volatile，总之不能胡乱加

### 6.5.3 这个例子告诉了我们什么道理

#### （1）volatile不能随便乱用，要看准了用

当你确定时再使用，否者就会起到反效果，以上volatile起反效果的例子，是volatile的经典面试题，请大家一定要理解。

#### （2）写出高质量代码才是王道

例子的根本原因是我们写的代码不够严谨，存在缺陷，需要通过编译器优化来提升代码质量，volatile阻止了优化后反倒起了反效果，如果我们一开始就将代码写为如下严谨形式的话，其实并不会受到volatile的影响。

```c
int square(int *ptr)
{
    int a = &ptr;
    return a * a;
}

```

所以说，我们在写代码时要尽可能写出高质量的代码。同时尽可能的不要乱用volatile，因为有些时候防不胜防。

## 6.7 一个指针可以是volatile的吗？

当然可以，比如：

```c
int a = 100;
int *p = &a;

int m, n, k;

m = *p;
n = *p;
k = *p;
```

编译器可能认为p所指向的a的值一直为100，不会变化，所以同样会进行优化，比如优化为如下形式：

```c
m = 100;
n = 100;
k = 100;
```

但是如果a的内容有可能发生变化的话，比如：

+ 1）被硬件修改
+ 2）被中断函数修改
+ 3）被其它线程修改

此时我们就应该使用volatile来阻止优化，

```c
volatile int *p = &a;
```

然后每次赋值时，代码都会老老实实的将`p所指向的a内存空间中内容`读出，然后赋值给m、n、k，而不会走捷径、抄近道。

## 6.8 volatile与const同时修饰变量有意义吗

当然有意义，const与volatile并不冲突，比如修饰寄存器变量：

```c
#define  REG (  *((volatile const unsigned int *)0x65464543)  )
```

### 6.8.1 有些同学会觉得没有意义的原因

通过前面的讲解可知，volatile所修饰的变量，大多都有一个特点，那就是变量可能会随时会被修改，比如：

+ 1）被硬件修改
+ 2）被中断函数修改
+ 3）被其它线程修改

变量的值不是固定不变的。

const修饰变量的目的，是想让它变为“常量”，顾名思义常量是不变的，这不就矛盾了吗？  

const：希望变量不要变

volatile：告诉编译器，这个值随时都可以能改变

同时使用volatile与const真的有意义吗？  

### 6.8.2 使用volatile和const同时修饰变量，并不矛盾 

#### （1）const的作用

**const修饰变量所得的是“伪常量”**，“伪常量”并不是真正的不能修改的只读常量，“伪常量”只是不让代码去赋值修改而已，当程序中有代码尝试去赋值修改“伪常量”时，会导致无法编译通过，逼着程序员去掉赋值代码。

**const不让代码去修改变量，但是并不意味着不让计算机硬件本身去修改变量(比如硬件和中断等)**

#### （2）volatile的作用

告诉编译器不要优化，因为变量的值不是一成不变的，有可能会发生变化，虽然被const限制了代码这种修改途径，但是变量有可能随时会被计算机硬件本身修改，一旦优化后，程序将无法响应修改。

#### （3）总结const与volatile同时修饰“寄存器变量”的目的

+ 1）const的目的：阻止代码去赋值修改寄存器变量

+ 2）volatile的目的：  
   告诉编译器，不要优化操作寄存器的代码，寄存器的值可能会随时改变。
   虽然因为cosnt的限制，变量不会被代码所改变，但是有可能会被`计算机硬件本身`所改变。

const与volatile同时使用的情况，基本都是`修饰寄存器`的情况。

## 6.9 typedef与volatile

```c
typedef volatile int vint32_t;
vint32_t a = 100; // 等价于volatile int a = 100;
```

更规范的写法是：

```c
#define __IO volatile   // 当然__IO这个名字并不是固定的
typedef __IO int vint32_t;
```

我们在好些c库源码中，往往会看到以上这种写法

## 6.10 疑问：前面有关volatile的内容都听懂了，但是好像我还是不知道该在什么时候加volatile？

如果你有这个问题的话，说明大家的功底还不够，功底这个东西是需要经验来支持的，目前最关键的是听懂我们对于volatile的介绍，至少知道当出现以上我们介绍的情况时，你知道应该要加volatile，慢慢的当你有了相当的开发经验后，自然就能了然于胸了。

不过目前一定要先理解volatile的基本情况，因为c面试中，会经常出现volatile的经典面试题。特别是嵌入式相关的开发中，volatile使用的很频繁，因此面试单片机、linux嵌入式相关的工作时，volatile是常考的题目，所以一定要掌握。

不过大家可以放心的是，在本小节，我们基本上已经把c经典面试题会出现的volatile的内容都讲到了，我们后面讲“c经典面试题”时，里面就有volatile的经典面试题，只要你把本部分内容听懂了，里面的volatile题目，都没有问题，但是如果你没听懂的话，大部分学生可能都会做错，因为volatile确实有点不好理解。

当然在java等语言中同样有volatile关键字，而且作用都是相似的，因此理解好了c的volatile，也有助于大家理解java的volatile。

## 6.11 `volatile` 与 `__volatile__`

怎么理解__volatile__呢？

完全可以将__volatile__理解为一个预定义宏，它是GCC给volatile取的另一个名字，似乎GCC也支持`__volatile`写法，也就是也就说`volatile`、`__volatile__`、`__volatile`是等价的。

```c
volatile        int i  =0;
__volatile__    int i  =0;
__volatile      int i  =0;
```

以上三个写法的作用是一样的。

只不过volatile是c标准的关键字，而后面两个是GCC给volatile起的另外两个名字，当然其它c编译器也可能会给volatile搞出类似的名字，只不过名字不一定叫`__volatile__`、或者`__volatile`。

不过`__voltile__`和`__vilatile`是GCC编译器提供的，如果使用`__voltile__`、`__vilatile`的话，其它C编译器可能无法识别，由于volatile是c标准关键字，所有的c编译器都会支持，因此建议在c代码中最好使用volatile。

不过在Linux内核代码中，用的几乎都是`__volatile__`，因为Linux内核的“御用”编译器为GCC，因此全部使用`__volatile__`也并无不妥。
