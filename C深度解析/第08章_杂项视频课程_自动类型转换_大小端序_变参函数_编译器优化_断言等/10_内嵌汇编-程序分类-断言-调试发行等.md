# 9. c内嵌汇编（内联汇编）

## 9.1 什么是c内嵌汇编

所谓c内嵌汇编，就是在c代码中嵌入汇编代码，不过此时需要使用asm关键字。
asm为GCC编译器的扩展关键字，而__asm__、__asm则为asm的另两个名字。
	
## 9.2 内嵌格式

__asm__ (汇编代码);

为了防止优化，一般还会加上volatile或者__volatile__

准确格式：
```c
__asm__ __volatile__(汇编语句模板 : 输出部分 : 输入部分 : 破坏描述部分);
```

如果是运行在ARM cpu上，内嵌的就是ARM的汇编，如果是运行在Intel cpu上，内嵌的就是Intel的汇编  

```c
void test(void)
{
    int input = 10,result;


    __asm__ __volatile__ 
    (
        "movl %1,%0" :

        "=r" (result) : "r" (input)
    );

    return;
}
```
		
## 9.3 我们为什么要介绍内嵌汇编

我们介绍内嵌汇编的目的，并不是想让大家去学习和掌握内嵌汇编，事实上对于我们c应用开发来说，内嵌汇编没有意义，我们不会用到，如果你花大把时间到这个里面去会得不偿失。
	
`疑问`：什么时候使用内嵌汇编呢？  
答：使用内联汇编的场合非常少，只有在极少数的情况下才会用到，在我们c应用代码中几乎用不到，只有在Linux内核源码种可能才会见到，而且使用的也不多。
我们这里之所以介绍内嵌函数，只是想告诉你有这么个东西存在，以后你要看见了，知道这是什么，对待方式就是忽略它。
		
		
## 10. 控制台程序 和 app应用程序	
我们以codeblockes IDE为例，使用IDE创建工程时，其中有两个选择：
+ Console application：控制台程序
+ GUI application：GUI程序	图:

## 10.1 Console application：控制台程序

程序运行时如果交互界面为“控制台（命令行）”的话，这个程序就是控制程序(命令行程序)。图：

如果创建工程时，你选择的是Console的，程序就只能通过“命令行”来交互(输入输出)

一般大家在初学c语言时，以及做底层开发时，使用的都是命令行交互界面。
	
## 10.2 GUI application：GUI程序

GUI为Graphical User Interface，程序交互界面为更加人性化的“图形化界面”。
	
如果你选择GUI的话，IDE就会提供“按钮、控制、输入框、文本框”的开发界面，方便开发GUI界面。

# 11. 断言（assert）

## 11.1 程序调试

进行程序调试时，为了辅助我们调试，我们往往需要知道某些条件是否成立，某些值是否为我们需要的值，此时我们可通过if判断、以printf打印来测试。
比如：举一个简单的例子。
```c		
void fun(int a, int b)
{
    //调试检测传参是否符合要求
    if(a!=10)
    {
        printf("a:%d，非法参数\n"， a);
        exit(-1);
    }
    if(b!=20) 
    {
        printf("b:%d，非法参数\n"， b);
        exit(-1);
    }
    //...
}

int main(void)
{	
    int a=10;
    int b=20;

    fun(a, b);

    retutn 0;
}	
```

但是if、printf这种做法存在如下问题：
+ 1）代码繁琐
+ 2）这个代码只是辅助调试的代码，最终发布程序时，这些代码都是要删除的，如果程序里面写了大量的这种代码的话，删除是一个很麻烦的事情，如果这些代码不删除，会增加程序的代码量，所以凡是与调试相关的信息，都是要删除的。

此时我们可以使用assert（宏）来辅助调试。

## 11.2 assert宏

在前面的课程就介绍过，使用assert宏（断言）时，被定义在了assert.h，如果要使用assert宏的话，必须包含
assert.h。
```c
#include <assert.h>

void fun(int a, int b)
{
    assert(a==10);
    assert(b==20);

    //...
}

int main(void)
{	
    int a=10;
    int b=20;

    fun(a, b);

    return 0;
}
```

assert中的判断需要反过来写，意思就是我（程序员）断言a==10，b==20，只要assert断言的条件为真，那么assert什么都不会做，因为我们要的就是a==10、b==20。
但是如果判断为假的话，就证明参数出了问题，此时：
+ assert宏就会打印出断言出错位置：文件、函数、行号
+ 调用abort函数，然后让进程（程序）异常终止。

我们这里的例子很简单，assert用来测试传参的合法性，但不要被例子所误导，以为只能用在传参的判断上，事实上调试，assert可以用在有判断需求的任何地方。
		
## 11.3 如何让assert宏失效

gcc时通过-D指定NDEBUG宏即可让assert失效，比如：

```shell
gcc a.c -DNDEBUG 
```
				
之所以指定这个宏，这个与assert的实现原理有关，有关assert的具体实现，请大家自己查看c标准库assert.h中的内容，我们这里不再啰嗦，不过我认为没有必要去查看。
		
				
## 11.4 有些if判断是不能使用assert替换的

前面说过，当正式release版（发行版）的程序时，assert将会无效，正常代码中的if判断是不能使用assert来代替。

只有调试时钟涉及到的if判断，我们才会使用assert来代替。


比如：
+ （1）需要判断用户输入数据是否正确，如果不正确的话，就需要进行异常处理，此时就需要进行if判断，像这类的if判断是正代码，是不能使用assert来替换

+ （2）函数报错处理的if不能使用assert代替
    比如：
   ```c
    int *p = malloc(sizeof(int));
    if(NULL == p)
    {
        perror("malloc");
        exit(-1);
    }

    assert(p!=NULL); //这里是多余
   ```


    这类函数出错处理的代码必须要有的，所以不能使用assert代替。像这种已经有现成的if判断的地方，就没有必要再加上assert了，加上了也是多余，因此这个if判断也能帮我们报错。

`总结`：什么时候使用断言？  
调试时，当我们不清楚程序中某些值是否为我们期望的值时，我们就可以使用assert判断，如果我们能够将debug打印调试宏与assert宏配合使用好的话，这将是我们很好的调试利器。

# 12. 编译得到“调试版” 与 “发行版”程序

## 12.1 调试版（DEBUG版）

调试版的目的只有一个，在程序中需要包含各种调试信息，帮助我们进行程序调试。

### 12.1.1 命令行

+ （1）gcc时加上-g选项，在程序中包含“单步调试信息”
+ （2）gcc 通过-D指定DEBUG宏，使能debug打印调试宏
+ （3）gcc时不要指定NDEBUG宏，调试时assert断言宏有效
+ （4）其它：暂不关心

### 12.1.2 IDE 

+ （1）创建Debug版工程，编译时会动加上“单步调试信息”
+ （2）在IDE中设置DEBUG宏，使能debug打印调试宏
+ （3）不要指定NDEBUG宏，调试时让assert有效
+ （4）其它：暂不关心
		
## 12.2 发行版（RELEASE版）

发行RELEASE版程序时，说明bug都已经被调试找出，此时可以发行了，发行时就需要将各种调试信息全部去掉，如果你不去掉的话，这些调试信息就会非常的占用资源（内存）。
	
### 12.2.1 命令行

+ （1）gcc时指定-s，去掉“单步调试信息”
+ （2）gcc时不指定DEBUG宏，让所有的“debug打印调试宏”失效
+ （3）gcc时通过-D指定NDEBUG宏，让所assert宏也失效
+ （4）其它：比如进行一定程度的优化等，暂时不关心

	经过以上步骤后，就可以瘦身得到RELEASE版程序，编译时对DEBUG版程序瘦身之后，就能得到RELEASE版程序。
	
### 12.2.2 IDE

+ （1）将DEBUG工程改为RELEASE工程，编译时会自动删除“单步调试信息”
+ （2）在IDE中不要指定DEBUG宏，让所有的“debug打印调试宏”失效
+ （3）在IDE中指定NDEBUG宏，让所有assert宏失效
+ （4）其它：比如进行一定程度的优化等，暂时不关心
