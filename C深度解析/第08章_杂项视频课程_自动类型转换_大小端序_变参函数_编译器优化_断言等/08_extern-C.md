# 7. extern "C"

## 7.1 有什么作用
c++是兼容c的，在c++中是可以调用c代码的，比如团队中有人擅长c++，有人擅长c，擅长c++的人可以使用c++来开发负责的模块，擅长C的就可以使用c来开发负责的模块，最后在c++和c代码整到一起，合为一个程序。

由于c++的语法>c语法，所以最后只能使用C++编译器来编译整合后的代码，但是存在一个问题，那就是c++和c的语法毕竟有所差异，比如c++有函数重载，但是c没有，以c++编译器去编译c代码时，就会出问题。

为了让c++代码能够很好的兼容c代码，避免出现不兼容的问题，就有了extern "C"，凡是被这个修饰的C代码，c++编译器在编译时就按照c的语法去编译，如果没有extern "C"的话，使用c++语法编译时就可能出问题。

使用c++编译器编译c代码时，才需要extern "C"来兼容，如果你使用的c编译器来编译c代码的话，这个玩意就用不着了。
	
## 7.2 如何使用extern "C"

### （1）它可以只修饰一句话

```c
extern "C" int max(int a, int b);  
```

c++编译器编译这句话时，以c语法来编译  

### （2）修饰一段代码

XXX.h
```c

#ifndef H_XXX_H
#define H_XXX_H

...
...
...
...

//c++编译器编译这一段代码时，以c语法来编译
extern "C" 
{
	...
	...
}

...
...
...
...

#endif

```


XXX.c 
```c
...

//c++编译器编译这一段代码时，以c语法来编译
//不能{}不能写在函数里面
extern "C"
{
	void fun()
	{
		...
		...
	}
}

...
```
		
### （3）实际常见的情况

在.h中和.c中都使用extern "C"，反倒会把事情搞麻烦了，常见情况是我们会在.h中使用，然后将.h中所有的内容都包含到extern "C" { }中。

前面说过，只有在使用c++编译器编译c代码，才需要使用extern "c"来兼容，c++编译器一看到extern "c"就知道，它应该使用c语法来编译，使用c编译器来编译时是不需要extern "c"，所以我们使用条件编译来选择，当使用c++编译器编译时extern "c"自动有效，使用c编译器来编译时自动无效。

我们在.h当中经常看到的extern "C"的用法是如下这样的：

fine.h 
```c

#ifndef H_FINE_H
#define H_FINE_H


/* 当使用c++编译器来编译C代码时，会自动生成__cplusplus宏，此时条件编译成立，extern "C"有效
* 如果是c编译器的话，就不会产生__cplusplus宏，条件编译不成立，extern "C"无效
*/
#ifdef __cplusplus
extern "C" 
{
#endif

/* .h中所有的内容都在{}中 */
...

...

...

...


/* 与extern "C" { 配对 */
#ifdef __cplusplus
}
#endif


#endif
```

对于我们自己写的c应用代码来说，如果需要和c++代码进行整合时，就是需要在自己的c代码里面使用extern "C"，让c++兼容c，如果没有这种需求的话，就不需要使用extern "C"。		
