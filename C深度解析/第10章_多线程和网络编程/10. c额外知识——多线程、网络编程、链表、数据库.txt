
第10章 进行c程序开发时，所需的一些其它知识————多线程、网络编程、数据库、数据结构（链表：本章重点）

	本章是一个很好的动手敲代码的章节，所以希望大家多动手实践。

1. 多线程
2. 网络编程
3. 数据库
4. 数据结构
5. 顺序表
6. 链表
7. 单链表
8. 双链表
9. 队列 和 栈
10. Linux内核链表	


1. 多线程
1.1 什么是多线程
	正常情况下程序都是单线程的，也就是说指令都是单线运行的，单线程就是单任务。
	单任务处理“事件”时有先后关系，但是有些时候希望多个事件被同时处理，我们的程序需要用到多线程，多线程是
并发运行的，不同的线程可以各自处理不同事件，事件就能被同时处理。

1.2 c线程库
	多线程都是以线程库的方式来提供的，对于c++、java、c#等语言来说，都有自己的线程库，c语言也不例外，也有
自己的线程库，只要学会c线程函数的使用，就可以在c程序中实现多线程。
	
	我们在第5章介绍thread.h时就讲过，c标准库有提供c线程库，只不过我们在《Linux系统编程、网络编程》的第9章
c线程中，讲的是posix c线程库，但是它们的函数功能与用法都是类似的，只要学会其中一个，其它的都好说。
	
1.3 一般什么时候会使用c线程
	一般只在偏上层的c程序开发中，才会较多的涉及到多任务的问题，此时才会用到多线程。
	我们知道c语言因为能够使用指针的关系，常用在与硬件相关的偏底层的开发中，比如单片机程序开发、驱动开发。
	
	偏底层的开发用不到c线程，c线程库的运行一定要OS的支持才行，否者是用不了，所以只有在有OS支持的应用
程序中，我们才能使用多线程。

	但是在偏底层的的C程序开发中，是没有OS支持的，所以不能多线程，其实也不需要使用多线程。
	
	
1.4 c线程函数
	有关c线程函数，请看《Linux系统编程、网络编程》的第9章——c线程。

	
2. 网络编程
2.1 什么是网络编程
	所谓网络编程，就是调用“网络编程的函数接口”，来让我们的程序实现网络通信。
	
	
2.2 什么时候需要进行网络编程
	当你的程序需要进行网络通信时，我们就需要进行网络编程了。

2.3 学会使用网络编程的函数接口
	同样的，我们在《Linux系统编程、网络编程》的第十章网络编程中，我们会讲解c语言的网络编程接口，详情请看
这一章。
	
	事实上在我看来，学习网络编程的最大意义，是通过学习网络编程了解网络相关的基础知识，对于一个程序员来说，
或者说对于一个IT开发者来说，网络基础知识是必须具备的，这些基础知识我们可以通过学习网络编程来获得。
	
	在早期，网络编程常见于“偏应用层”的开发中，在单片机这类偏底层的开发中很少见，因为早期的单片机由于性能
原因，往往都是单机运行的，不涉及到网络通信，然而随着这些年集成电路的发展，现在单片机性能越来越强劲，
单片机联网也是常有的事情，因此网络通信在单片机这种偏底层的开发中，也是常有的事。

	特别是这些年随着物联网发展，物联网的终端计算机存在着大量的单片机，大量单片机联入物联网也逐步成了必然
的趋势。
	
	
3. 数据库
3.1 什么是数据库
	数据库就是一个软件，一个专门用于存放数据的数据仓库，这个软件会帮我们在计算机硬盘上保存和管理海量数据。
	数据库这玩意，采用最简单的方式来理解的话，就是一个能够存放海量数据的超大号文件。
	
	对于应用软件开发者来说，我们要做的不是去开发数据库这个软件，而是学会使用数据库这个软件，也就是学会在
程序中调用数据库提供的编程接口（SQL接口），通过这个接口就可以向数据库读写数据。
	
	不过有一点我们需要强调一下，现在程序访问的数据库，大多都是单独运行在独立的服务器上，程序需要通过网络
去访问数据库服务器。
	                                      网络
							c、java、c#程序  <————————————————————>  数据库服务器
							

3.2 对于c开发者来说，应该如何看待数据库
	如果使用c来进行的是底层开发的话，用不到数据库。
	如果是应用层有时会用到数据库。
	
	不过总体而言，对于java、c#、python等语言来说，c语言程序对数据库的使用频率相对偏低，对于c开发来说，所以
我们不需要上杆子的去学习数据库相关的内容，等到你真的需要用到时再去学习也不晚，毕竟在有需求的情况下去
学习，学习的效果会更好。
	正式基于这样的理由，我们没有出数据库的课程，如果你真的需要，请自行另寻课程来学习。
	
	
	
	
4. 数据结构
4.1 什么是“数据结构”
	程序处理数据时，必须先将数据读入内存，然后才能处理内存中的数据，数据结构就是管理内存中数据的管理思想。
	当程序要处理的数据很少时，数据在内存中的存放很简单，只需要定义一些单独的char、short、int、float、
double、结构体变量等来存储就可以了，不需要进行什么复杂的数据管理，此时不涉及“数据结构”。

	但是有时程序需要处理数据的非常多，而且比较复杂，所以这些大量数据在内存中存储时，不能只是简单的存储在
内存中，必须以某些特有的形式来存放，这些特有存储和管理形式，就是属于“数据结构”要讲的内容。
	
	
4.2 数据库 与 数据结构
	这是两个完全不相同的东西，不要不混淆。

	数据库：这个软件用于管理硬盘上存储的数据。
	数据结构：各种存储管理的思想，而且管理的是内存上数据。
			如果我们希望这种思想发挥作用的话，我们需要通过代码来实现这种思想。
			
			
	举一个，能够有效帮助我们区分“数据库”与“数据结构”的例子：
	
	假如程序需要处理从数据库中读取到的数据的话，应该先从数据库将数据读到内存中，如果读到的数据非常多的话，
读到内存中时，必须以某种“数据结构”来存储和管理数据。
	
							 数据结构
								  |
	                |   
				  c程序   |               网络            数据库软件
			    内存（数据）   <———————————————————>    硬盘（数据）    
					
         客户机                                   数据库服务器
			 
4.2 数据结构的 逻辑结构 和 存储结构
	“数据结构”包含两方面的内容，即逻辑结构 和 存储结构。
	
	只要理解了逻辑结构 和 存储结构，我们就理解了“数据结构”这个概念。
	
4.2.1 逻辑结构
	体现的是数据之间的逻辑关系，数据逻辑结构与计算机之间是没有任何关系，只是数据的自然特点。

（1）数据逻辑结构有四种：
		1）集合结构
		2）线性结构**********
		3）树型结构		
		4）网络结构
		
		本章要讲的链表是线性结构的，因此我们只介绍线性结构，其它的我们不关心。
		
		
（2）线性结构
		1）线性结构的特点
				除了第一个和最后一个数据外，每个数据的前后只有一个数据。
				这就跟排队一样，我们所排的队列就是线性的，除了第一个人和最后一个人外，每一个人的前面和后面就只有
			一个人，如果后面、后面并列的站了两个或者多个人的话，那就不是线性结构了。
	
				学生人员名单，典型的就是线性结构：
					名字   学号    成绩
					张三    1      60
					李四    2      70
					王五    3      50
					...
		
				在学生名单上，每个数据的前后紧挨着的只有一个数据。
		
		2）常见的线性结构有哪些	
			线性表、栈、队列等都是线性结构的，其中线性表是重点，会面要讲的链表就是线性表，它们之间的区别，
			我们后续再介绍。只要把线性表理解到位了，容易就能理解栈和队列。
			
			
4.2.2 存储结构
			
	数据的逻辑结构与计算机没有关系，但是存储结构就与计算机有关了。
			
（1）四种存储结构
		数据存入计算机内存时，有四种存储结构，分别是顺序存储、链式存储、散列存储、哈希存储。
		
		只有当数据很多很复杂时，才会涉及到以上这些复杂的存储结构，前面说过如果只是非常少量的数据的话，直
	接定义单个的char、int、float等变量来存储即可，不需要搞的如此的麻烦。
		
		
（2）数据的“逻辑结构”与“存储结构”之间的关系

		1）数据逻辑结构是数据的天然属性，与计算机毫无关系
		
		2）存储结构与计算机有关
		
		3）不管什么“逻辑结构”的数据，可以使用四种中的任何一种“存储结构”来存储。
				数据的“逻辑结构”与“存储结构”之间没有必然的对应关系，但是存在合适性。
				也就是说某种“逻辑结构”的数据，更适合使用某种“存储结构”来存储，比如逻辑结构为线性结构的数据，更
			适合使用顺序存储和链式存储。
			
		4）按照某种“存储结构”将数据存入内存后，必须要能够反映出数据的“逻辑结构”
				比如，数据本来是线性结构，按照某种“存储结构”存入计算机内存后，结果数据的“逻辑结构”变成了树形结构，
			这就扯淡了。
				
				采用某一种“存储结构”将数据存入计算机内存后，必须要能准确反映出数据的逻辑结构，如果不能准确的反应
			出数据的逻辑结构的话，数据所携带信息很有可能会发生变化。
				
				
				
4.3 数据结构 之 顺序表 和 链表	

	前面说过，计算机存储“线性表（线性结构的数据）”时，常用的存储结构为顺序存储和链式存储。
	顺序存储的线性表就是“顺序表”。
	链式存储的线性表就是“链表”。
	
	
4.1 顺序表
	顺序存储的线性表就是顺序表。
	
	· 顺序表的逻辑结构：线性结构
	· 顺序表的存储结构：顺序存储结构

	
4.2 链表
		链式存储的线性表就是链表。
		
	· 链表的逻辑结构：线性结构
	
	· 链表的存储结构：链式存储结构
		
		链表是本章的重点，因为链表在开发中是非常常见的数据结构，就算是在单片机开发中，不时也会使用到链表，
	比如单片机GUI界面的菜单管理，我们就需要使用链表的来存储、管理菜单数据。
		
		至于其它的“数据结构”本章不介绍，因为在开发中极少用到，我们只讲对我们有用，如果你确实想学习其它
	“数据结构”，请自行学习专门的《数据结构》书籍。
	

	
6. 链表

6.0 从顺序表的缺点说起
	顺序表就是顺序存储的线性表。
	
	顺序存储其实就是使用“数组”来存储的形式，数组的每个元素是顺序的一个挨着一个的空间，使用数组来存储
线性表，在结构上是最为契合的，但是顺序表也存在不少的缺点：
	
	仅仅站在存储的角度来说，使用顺序存储来存储线性表时非常合适的，不幸的是存在其它缺点。
	
	
（1）顺序表的缺点1：删除、添加元素时，元素的移动很麻烦。
		顺序表其实就是一个数组，我们以前使用数组时用的都很简单，不涉及到删除、添加元素的操作，实际上对数组
	进行删除、添加元素时，是一件比较麻烦的事情。
		
		当删除和添加的位置越靠前时，所需要移动的元素就越多，如果总共有200个元素的话，将第一个元素删除后，后面
	199个元素都需要向前移动一个位置，很麻烦。
		图：
			
			
			
（2）顺序表的缺点2：不利于 利用“内存碎片”。
			在内存中开辟顺序表空间时，由于内存碎片空间太小了，很难被顺序表用起来，除非顺序表很小，但是顺序表
		的空间一般都是一整块的大容量空间。
			
			
	其实有关顺序表我们是使用过的，我们在第7章讲“结构体内嵌函数指针”的例程时，当时我们存放学生和老师
信息所用的数组其实就是顺序表，只不过当时不涉及到添加和删除元素，用的比较简单。
	
	当时的老师信息和学生信息是线性表，把线性表存入数组后，数组就是为顺序表。
	

	如果数组存放的逻辑结构为树形结构（二叉树）的数据话，数组就是顺序二叉树。
	
	数组作为顺序存储来说，可以存放任何逻辑结构的数据。
	
	正是由于顺序表存在以上所描述的缺点，后来才有了链表这个东西，链表可以很好的解决顺序表的以上两个缺点。
	
6.1 什么是链表 	
		链式存储的线性表就是链表。
		
	· 链表的逻辑结构：线性结构
	· 链表的存储结构：链式存储结构
	
6.2 链式存储的特点
	元素之间不需要紧挨着，只需要使用指针指向前后元素即可。
	图：
	
（1）链式存储方式的优点：
		1）由于元素之间不需要紧挨着，所以不需要大片内存空间，能够很好的利用内存碎片
		
		2）删除、添加元素时，无需大批量的移动元素空间的内容，只需要修改指针指向即可。
			
			
（2）链表的缺点
		缺点就是每个元素必须要多开辟出存放指针的空间。
		不过这个缺点与链表本身的优点相比，可以忽略。
		
		正是由于链表的明显优点，所以相比顺序表来说，链表使用的更加广泛。
		
			
6.3 链表的元素结构
		链表的每个元素都是使用结构体来封装的，元素内部分为两部分，数据部分和指针部分。
		
（1）单链表（单向链表）
		typedef struct SignalNode  	//单链表的节点结构体，链表节点就是链表元素
		{
			void *data; 							//指向存放数据的空间，具体指向什么样的数据空间，需要根据情况来定
			struct SignalNode *next; 	//存放后继节点指针，指向下一个元素
		} SNode, *SNodep;
	
		使用typedef的目的，主要是想让名字变的更简洁。
		
		
		
（2）双链表（双向链表） 
		typedef struct DoubleNode  	//单链表结构
		{
			void *data;  							//指向存放数据的空间
			struct DoubleNode *prev; 	//存放前继节点指针，指向上一个元素
			struct DoubleNode *next; 	//存放后继节点指针，指向下一个元素（节点）
		}DNode, *DNodep;
	
	
（3）结构体内嵌自己类型时，需要注意的地方	

		我们举例说明：
		1）例子1
			typedef struct DoubleNode  
			{
				void *data; 					
				struct DoubleNode dDode;  
			
			}DNode, *DNodep;
			
			
				直接内嵌定义一个自己类型的结构体变量肯定是不行的，因为struct DoubleNode类型还没有定义完成，
			不知道结构体类型的大小，编译时肯定会报错。
			
		2）例子2
			typedef struct DoubleNode  
			{
				void *data;
				struct DoubleNode *dDode;  
			}DNode, *DNodep;
			
			内嵌自己这个类型，定义一个指针变量确是可以的，因为我们在前面的章节就讲过，指针的宽度都是固定的，
			所以指针类型的大小都是固定的，编译时可以通过。
		
		3）例子3
			typedef struct DoubleNode  
			{
				void *data;
				DNodep dDode;  
			}DNode, *DNodep;
			
			DNodep在后面，所以在里面是不能使用typedef后的DNodep和DNode *，只能使用struct DoubleNode。
			
			
			
（4）从哪里开辟链表的元素空间（节点空间）
			节点空间就是一个结构体变量空间，我们知道在.data、.bss、栈、堆都是可以开辟变量空间，
		由于链表删除、添加频繁，为了方便操作，我们选择从堆中开辟链表的每个“节点空间”，比如：
		
			SNode *p = (SNode *)malloc(sizeof(SNode));
			if(NULL == p) print_error("malloc");
			
		
		
6.4 链表的具体课程内容
		链表是本章的重点，我们打算分如下几部分来讲。

（1）单链表
（2）双链表
（3）Linux内核链表
（4）c++/java中的链表
	
	
	
7. 单链表
		由于相比双链表来说，单链表用的并不多，所以我们讲单链表时会讲的简略些，我们会将重点放到双链表上。
	
	为了让大家都熟悉一下IDE和命令行，所以我们讲单链表时使用Linux命令行来写代码，讲双链表时使用
Codeblocks IDE来编写代码。
	
		//单链表节点结构体
		typedef struct SignalNode  	
		{
			void *data; 							//指向存放数据的空间，具体指向什么样的数据空间，需要根据情况来定
			struct SignalNode *next; 	//存放后继节点指针，指向下一个元素
		}SNode;
	
	单链表分为两种：
	单向非循环链表。
	单向循环链表。
	
	
7.1 单向非循环链表的组成结构
	
	图：
	
	
	
	
	
	
（1）头指针变量（链表入口）
		头指针变量里面放的是头节点的指针，所以指向了头节点，为整个链表的入口。
		通过这个入口就能找到头节点，通过头节点的next就可以找到第一个数据节点，依次类推就能找到链表中
	每一个节点。
		
（2）头节点
			头节点中不放数据，只是一个空节点，加入头节点的目的是为了方便操作链表，实际上没有头节点也是
		可以的，但是在添加、删除节点时可能会比较麻烦，但是有了头节点后就会很方便，后面我们会感受到这一点的。
			
			
（3）数据节点
		数据存放在了每一个数据节点的“数据空间”中。
		成员data指向了数据空间，而成员next则指向了下一个数据节点。
		
		
（4）最后一个节点的next
		1）如果存放的是头节点的指针的话，它就指向了头节点
				此时为“单向循环链表”。
		
		2）如果next为NULL（指向空）
				此时就是“单向非循环链表”，对于“单向非循环链表”来说，访问后面的元素很容易，指针往后索引即可，
			但是如果想要访问前面元素的话，就必须从头开始。
				
				我们目前讲的“单向非循环链表”，有关的单向循环链表，请大家自行实现。
				

（5）分析hp、hp->next、hp->next->next
	
		hp: 头指针变量，里面存放的是头节点的指针
		
		hp->：等价于(*hp).，*hp为头节点的空间
		
		hp->next：等价于(*hp).next，为头节点的next成员，放的是第一个数据节点的指针
		
		hp->next->：等价于*((*hp).next).，为第一个数据节点空间
		
		hp->next->next：等价于*((*hp).next).next，为第一个数据节点中的next成员

		当表达式中有很多个next时，很容易把大家给搞糊涂，此时我们就采用以上方法来分析。
		
	

7.2 实现单向非循环链表
	实现方式并不是固定不变的，当你把单链表完全搞明白后，大家完全可以按照自己的方式去编写链表代码。
	不过目前大家还是先按照我们所讲的方式来实现。
	
	
7.2.1 单链表的基本操作
	· 创建节点
	· 插入节点
	· 删除节点
		
		typedef struct SignalNode  
		{
			void *data; 
			struct SignalNode *next; 
		}SNode;
		
		单链表的基本操作只与节点本身有关，与节点中的“具体数据”无关。
		
（1）创建节点
		1）代码
		
			SNode *Sig_CreateNode(void *data, int dataSize)
			{
					/* malloc开辟节点空间 */
					SNode *p = (SNode *)malloc(sizeof(SNode));
					if(NULL == p) print_error("malloc");

					//让next默认指向空
					p->next = NULL;
					
					/* 创建节点数据空间 */
					if(NULL != data)
					{
							p->data = malloc(dataSize);
							if(NULL == p) print_error("malloc");
							
							//将数据存入节点
							memcpy(p->data, data, dataSize);
					}

					return p;
			}
			
			创建节点的代码写法并不是固定，只要大家理解了单链表的核心，完全可以有自己的实现方法。	
			
		2）代码分析
			代码做了如下三件事：
		（a）开辟节点空间
		（b）将节点的->next赋NULL
		（c）开辟节点中的数据空间
				· 当形参data==NULL时
					表示没有数据需要存放到节点中，因此不需要开辟数据空间，此时开辟的是一个空间节点。
				
				· 当形参!=NULL时
						表示调用创建节点的函数时，需要存入数据，数据就放在了data所指向的空间中，data所在空间的大小为dataSize。
					此时就需要开辟dataSize大小的空间，并让节点中的void *data成员指向malloc的空间。
					然后使用memcpy函数将形data指向空间的数据，复制到节点中data所指向的空间。
					
						之所以将节点中data的类型定义为void *，是因为不希望创建节点的操作与具体的数据类型有关，让创建节点的函数
					成为与具体数据类型无关的基本操作函数。
					
（2）插入节点				
		1）通用插入代码
			（a）实现原理
					对于单链表来说，由于单向的特点，所以插入时需要找到插入位置的上一个节点，然后才能插入。

					代码的实现原理如下图所示：
					图3：
					
					
			（b）代码
					//p指向了插入位置的上一个节点
					void Sig_InsertNode(SNode *p, SNode *nodep)
					{
							nodep->next = p->next;
							p->next = nodep;
					}
					
		2）将节点插入链表头
		
			（a）实现原理
						插入到链表头，其实就是插入到“头节点”和第一个数据节点之间，所以只需要将插入位
					置的上一个节点（头节点）的指针，传递给Sig_InsertNode即可插入。
						
						
			（b）代码
					void Sig_HeadInertNode(SNode *hp, SNode *nodep)
					{
							Sig_InsertNode(hp, nodep);
					}
				
			（c）为什么要给单链表要加入“空头节点”
						插入时必须找到上一个节点，如果没有“头节点”的话，在链表头插入数据时，第一个数据节点之前
					没有其它节点，不利于统一所有节点的插入操作。
					
					
		3）将节点插入链表尾部
			（a）实现原理
					方法很简单，先遍历链表找到最后一个节点，得到最后一个节点的指针后，然后即可插入。
						
					遍历找到最后一个节点：
					定义一个游标指针变量，最开始指向第一个数据节点，然后依次向后移动指向后续节点，当检测到节点
					的next为NULL时，就表示找到了最后一个节点。
					
					· 定义一个游标指针变量、指向第一个数据节点
						SNode *p = hp->next;
						
					· 指向下一个节点
						p = p->next
							
					· 判断结束
						if(p->next == NULL) 
						if(p == NULL)
						
						以上两种方法都可以。
						
							如果使用第一种判断方式的话，最后p指向了最后一个节点。
							如果使用第二种判断方式的话，最后p会指向空（NULL）。
							
							将节点插入尾部时，我们需要得到最后一个节点的指针，所以我们这里使用第一种判断方式。
							
							
			（b）代码
					void Sig_TailInertNode(SNode *hp, SNode *node)
					{
							SNode *p = hp;
							while(1)
							{
									if(p->next == NULL)
									{
											Sig_InsertNode(p, node);
											break;
									}
									p = p->next;
							}
					}

					
（3）删除节点				
		1）实现原理
			与插入节点一样，只要找到前一个节点的指针即可删除。
			图：
			
			
			删除节点后，我们需要将被删除节点的空间释放（free）。
		
		
		2）代码
			//只要将上一个节点的指针，传递给Sig_DeleteNode函数就可以删除
			
				void Sig_DeleteNode(SNode *p)
				{
						/* 记住要被删除的节点的指针 */
						SNode *temp = p->next;

						/* 删除节点 */
						p->next = p->next->next;

						/* 释放节点空间 */
						free(temp->data);//释放节点的数据空间
						temp->data = NULL;//预防野指针

						free(temp); //释放节点空间
						temp = NULL; //预防野指针
				}
				
			
			删除节点前，一定要先记住要被删除节点的指针，以供free释放时使用。
			
			这里要一定要区分删除和释放：
			删除：是将节点从链表中脱离，但是空间并没与释放
			释放：将节点空间free，因为节点空间是malloc所得，所以需要free来释放

7.2.2 基于链表的基本操作，正式实现一个存放学生数据的“单向非循环链表”

（1）要实现的功能函数如下
		1）创建一个只有“头指针变量”和“头节点”的空链表
		
		2）从文件中读取出学生数据，然后保存到链表中，每个节点只存放一条学生数据	
		
		3）遍历所有学生数据，然后将所有学生的数据全部打印显示
		
		4）按照学号查找学生数据
				之所以按照学号查找是因为学号具有唯一性，所以我们按照学号来查找。
				我们暂时不考虑节点数据相同的情况。
				
		5）从键盘输入某个学生数据，然后插入到链表中（插入链表头部或者插入链表尾部，或者插入到中间的指定位置）
		
		6）修改某个学生的数据
		
		7）将链表中所有的学生数据全部保存到文件中
		
		8）按照学号排序
				有关排序，我们暂时不介绍，讲到双链表再来实现。
				
		9）删除某个学生节点
		
		10）清空链表（将所有数据节点删除，只剩一个空头节点）
		
		11）销毁链表（把空头节点也删除掉）
		
		实现了以上这些功能函数之后，我们就可以在main函数中，调用这些功能函数来操作学生链表了。
		
		“链表基本操作函数”与“链表功能函数”之间的不同之处。
		1）基本操作函数：只涉及创建节点、插入、删除节点的基本操作，只与节点本身有关，与节点内部的数据无关
		2）链表功能函数：基于“链表基本操作函数”来实现的，与节点内部数据有关
		
		
（2）数据结构体

			链表的功能函数与具体的数据有关，我们要实现的是学生链表，链表里面存放的自然是学生数据，所以要定一个
		学生结构体来存放学生数据，比如：
			
			/* 学生结构体 */
			typedef struct Student
			{
					char name[40];
					int  number;
					char gender;
			}Stu;
		
				
（3）实现链表的功能函数
		1）创建一个只有“头指针变量”和“头节点”的空链表
		
			1）实现原理
				（a）调用创建节点的基本操作函数，创建一个空节点作为头节点
				（b）将“头节点”的指针存放到“头指针变量”中
							让“头指针变量”指向头节点。
				
				
			2）代码
				void createList(SNode **hpp)
				{
						//创建一个空间点作为头节点，由于空节点没有数据，所以参数传NULL和0
						*hpp = Sig_CreateNode(NULL, 0);

						//保险起见，给头节点next再赋一次NULL
						(*hpp)->next = NULL;
				}
				
				hpp为“头指针变量”的地址，*hpp代表的是头指针变量。
			
			
	2）从文件中读取出学生数据，然后保存到链表中	
	
		（a）实现原理
				· 打开存放学生数据的文件
				· 循环读取文件中的每一条学生数据
			  · 每读出一条数据，就创建一个节点并存入数据
				· 将创建的节点插入链表（头插、尾插都可以）
					
					所用到的标准IO函数：fopen、fscanf、feof、fclose。

					
		（b）代码
			//hp：头节点指针    filename：文件路径名
			void ReadDataFromFileToList(SNode *hp, const char *fileName)
			{
					/* 打开存放学生数据的文件 */
					FILE *fp = fopen(fileName, "r+"); 
					if(NULL == fp) print_error("fopen");
					
					/* 循环读取文件内容，然后存入链表 */
					Stu stu = {}; 			//暂存从文件中读到的一条学生数据
					while(1)
					{
							/* 格式化读文件，每次只读出一条，name为数组，就不要再&取地址了 */
							fscanf(fp, "%s %d %c", stu.name, &stu.number, &stu.gender);

							/* feof返回非零时，就表示读到末尾了，然后退出循环 */
							if(feof(fp) != 0) break;

							/* 创建节点，将stu中的数据保存到节点中data所指向的数据空间中 */
							SNode *nodep = Sig_CreateNode((void *)&stu, sizeof(stu));

							/* 将节点插入链表，我们这里选择都在链表头部插入，当然也可以修改为尾部插入   */
							Sig_HeadInertNode(hp, nodep);
					}

					fclose(fp);
			}
			
			fscanf(fp, "%s %d %c", stu.name, &stu.number, &stu.gender);
			读格式为%s %d %c，中间隔的是空格，所以往文件中录入的学生数据时，必须为格式如下:
			zhansan 45  f
			wangwu  90 	m
			lisi    53 	m

			
	
	3）将所有学生信息打印显示出来
		（a）原理
				使用游标指针变量遍历每个节点，将节点中的学生数据打印显示。
	
		（b）代码
				void ShowList(const SNode *hp)
				{
						SNode *p = hp->next;  //游标指针变量，指向第一个数据节点
						Stu *datap = NULL;    //用于临时存放节点中“数据空间”的指针

						if(NULL == hp->next) printf("链表为空\n");
						else
						{
								/* 遍历链表，找到每个节点，打印学生信息 */
								while(1)
								{
										if(NULL == p) break;   //判断是否到了末尾
										datap = (Stu *)p->data; //将void *强制转为Stu *
										printf("%s %d %c\n", datap->name, datap->number, datap->gender);//打印节点中的学生信息

										p = p->next; //指向下一个节点
								}
						}
				}
														
	4）按照学号查找学生数据
		（a）原理	
					遍历链表，比对学生学号，找到节点后并返回节点指针，不过为了方便后续插入、删除等操作，我们返回
				被找到节点的上一个节点的指针。
				
					SNode *p = hp;   //指向头节点
					datap = (Stu *)p->next—>data;  //下一个节点的“数据空间”的指针
					if(datap->number == number)    //对比的是下一个节点中学生的学号
					
					
		（b）代码
					SNode *FindStuByNumber(const SNode *hp)
					{
							SNode *p = hp; //指向头节点
							Stu *datap = NULL;
							int number = 0;

							if(NULL == hp->next) printf("链表为空\n");
							else
							{
									printf("输入学号\n");
									scanf("%d", &number);
									/* 遍历链表，找到每个节点，通过比对学号找到某学生信息 */
									while(1)
									{
											if(NULL == p->next) break;    //判断是否到了末尾

											datap = (Stu *)p->next->data; //暂存节点中数据指针
											if(datap->number == number)
											{
													printf("%s %d %c\n", datap->name, datap->number, datap->gender);//打印节点中的学生信息
													break;
											}
											p = p->next; //指向下一个节点
									}
							}

							return p;  //返回被早到节点的上一个节点
					}
				
		5）从键盘输入一条学生数据，然后插入到链表中
			（a）原理
					从键盘输入数据，然后插入链表中，可以选择插入到“链表头部”、“链表尾部”，或者插入任意位置。

					
					
			（b）代码
					void ReadDataFromKeybordToList(SNode *hp)
					{
							int select = 0;
							Stu stu = {};
							SNode *nodep = NULL;
							SNode *temp = NULL;

							printf("请输入学生信息，输入格式为：名字 学号 性别（M/F）\n");
							scanf("%s %d %c", stu.name, &stu.number, &stu.gender);

							/* 创建节点，将数据保存到节点中data所指向的数据空间 */
							nodep = Sig_CreateNode((void *)&stu, sizeof(stu));

							printf("1. 插入链表头部\n");
							printf("2. 插入链尾部\n");
							printf("3. 插入指定位置\n");
							
							scanf("%d", &select);
							switch(select)
							{
									case 1:
											Sig_HeadInertNode(hp, nodep);
											break;
									case 2:
											Sig_TailInertNode(hp, nodep);
											break;
									case 3:
											ShowList(hp);  							//显示整个链表，方便寻找插入位置
											temp = FindStuByNumber(hp); //返回要插入位置的上一个节点的指针
											Sig_InsertNode(temp, nodep);//调用同样插入函数，将nodep插入到temp所指节点的后面
											break;
									default: printf("无此选项\n");
							}
					}
					
		6）修改学生数据
			（a）原理
					使用学号遍历链表，找到节点，然后修改节点中的学生数据。
					
			（b）代码
					void AlterNode(const SNode *hp)
					{
							SNode *tmp = NULL;
							Stu *datap = NULL;

							/* 调用FindStuByNumber函数，按照学号查找，找到后返回节点指针 */
							tmp = FindStuByNumber(hp);

							if(tmp->next == NULL) printf("没有找到\n");
							else
							{
									//暂存节点中数据空间的指针，以方便操作，不过需要将void *强制转为Stu
									datap = (Stu *)tmp->next—>data;
									printf("输入新信息，格式：名字 学号 性别\n");
									scanf("%s %d %c", datap->name, &datap->number, &datap->gender);
							}
					}

								
		7）保存学生链表中的数据到文件中
		（a）原理
				以"w"/"w+"方式打开文件，清空文件中原有的数据，然后再将修改过的链表中的数据，重新写入文件中。

		（b）代码
				void SaveListToFile(const SNode *hp, const char *fileName)
				{
						SNode *p = hp->next;
						Stu *datap = NULL;

						/* 以w方式打开（只写），并将文件内容清空，清空后
						 * 再重新将被修改后的链表中的数据写入文件中 */
						FILE *fp = fopen(fileName, "w"); 
						if(NULL == fp) print_error("fopen");

						/* 遍历链表，找到每个节点，将每个节点中数据保存到文件中 */
						while(1)
						{
								if(NULL == p) break;    //判断是否到了末尾
								datap = (Stu *)p->data; //将void *强制转为Stu *
								fprintf(fp, "%s %d %c\n", datap->name, datap->number, datap->gender);//打印节点中的学生信息

								p = p->next; //指向下一个节点
						}
						//关闭文件，并将数据从库缓存刷新到文件中
						fclose(fp);
				}
				
				
			8）删除某个学生节点
			（a）如何实现
					· 调用FindStuByNumber函数，得到要被删除的节点的上一个节点的指针。
					· 调用基本操作函数Sig_DeleteNode删除节点
				
			（b）代码	
					void DeleteStu(const SNode *hp)
					{
							//通过学号找到节点
							SNode *p = FindStuByNumber(hp);

							//删除节点
							Sig_DeleteNode(p);
					}
				
				
			（b）清空链表
					删除所有数据节点，只保留“空头节点”。
				
				（a）如何实现
							循环的将头节点后的第一个数据节点删除，直到头节点的next为NULL时，就表示所的数据节点都被删除了。
							图：
							
							
				（b）代码
						void EmptyList(const SNode *hp)
						{	
								while(1)
								{
									 if(hp->next == NULL) break;
									 Sig_DeleteNode(hp); //删除第一个节点
								}
								printf("链表已被清空\n");
						}

		9）销毁链表			
			（a）如何实现
					· 先清空链表
					· 释放“空头节点”
					
			（b）代码
					void DestroyList(const SNode *hp)
					{
							//清空链表
							EmptyList(hp);

							//释放头节点
							free(hp);
							printf("链表已被销毁");
					}
							
7.2.3 完整代码				
	· 基本操作函数：sList_base_op.h、sList_base_op.c
	· 功能函数：sList.h、sList.c
	· 主函数：main.c
	
	
（1）基本操作的函数				
		1）sList_base_op.h
			#ifndef H_SLIST_BASE_OP_H
			#define H_SLIST_BASE_OP_H
			#include <stdlib.h> //exit函数需要这个头文件
			
			#define print_error(str) \
			do{\
							fprintf(stderr, "File %s, Line %d, Function %s error\n", __FILE__, __LINE__, str);\
							perror("error Reason");\
							exit(-1);\
			}while(0); 

			typedef struct SignalNode  //单链表结构
			{
					void *data;
					struct SignalNode *next; //指向下一个元素
			}SNode;


			extern SNode *Sig_CreateNode(void *data, int dataSize);
			extern void Sig_InsertNode(SNode *p, SNode *node);
			extern void Sig_DeleteNode(SNode *prevNodep);
			extern void Sig_HeadInertNode(SNode *hp, SNode *node);
			extern void Sig_TailInertNode(SNode *hp, SNode *node);

			#endif
		
		2）sList_base_op.c
			#include <stdio.h>
			#include <string.h>
			#include "sList_base_op.h"


			/* 功能：创建节点
			 * 参数：
			 *      data：指向空间中，存放了要被写入节点的数据
			 *          如果data为NULL，就表示没有数据要存入节点，
			 *          此时只是一没有数据的空节点
			 *
			 *      dataSize：数据空间的大小
			 *
			 * 返回值：返回新节点的指针（结构变量首字节地址）
			 */
			SNode *Sig_CreateNode(void *data, int dataSize)
			{
					/* malloc开辟节点空间 */
					SNode *p = (SNode *)malloc(sizeof(SNode));
					if(NULL == p) print_error("malloc");

					//让next默认指向空
					p->next = NULL;

					/* malloc开辟节点中的数据空间，然后存入数据
					 * 有数据才开辟，没有数据就不用开辟了
					*/
					if(NULL != data)
					{
							p->data = malloc(dataSize);
							if(NULL == p) print_error("malloc");

							//前面的课程就说过，结构体变量之间是可以整体复值的
							memcpy(p->data, data, dataSize);
					}

					return p;
			}


			/* 功能：通用插入函数
			 * 参数：
			 *      prevNodep：放的是要插入位置前一个节点的指针
			 *      node：放的是要插入节点的指针
			 * 返回值：无
			*/
			void Sig_InsertNode(SNode *p, SNode *node)
			{
					node->next = p->next;
					p->next = node;
			}

			/* 功能：在链表头部不插入，也就是头节点后的位置插入
			 * hp：链表头指针
			 * node：要插入节点的指针
			 * 返回值：无
			 */
			void Sig_HeadInertNode(SNode *hp, SNode *node)
			{
					Sig_InsertNode(hp, node);
			}

			/* 功能：在链表尾部插入，也就是链表最后一个节点的后面插入
			 * hp：链表头指针
			 * node：要插入节点的指针
			 * 返回值：无
			 */
			void Sig_TailInertNode(SNode *hp, SNode *node)
			{
					SNode *p = hp;
					while(1)
					{
							if(p->next == NULL)
							{
									Sig_InsertNode(p, node);
									break;
							}
							p = p->next;
					}
			}

			/* 功能：删除节点
			 * 参数：
			 *      prevNodep：放的是要删除节点的前一个节点的指针
			 * 返回值：无
			*/
			void Sig_DeleteNode(SNode *p)
			{
					/* 记住要被删除的节点的指针 */
					SNode *temp = p->next;

					/* 删除节点 */
					p->next = p->next->next;

					/* 释放节点空间 */
					if(temp != NULL) free(temp->data);//释放节点的数据空间
					temp->data = NULL;//不要让遗留的随机值（节点指针），干扰下一次的空间使用

					free(temp); //释放节点空间
					temp = NULL;
			}

（2）链表的功能函数	
		1）sList.h
			#ifndef H_SLIST_H
			#define H_SLIST_H
			#include "sList_base_op.h"

			/* 学生结构体(存放数据的结构体) */
			typedef struct Student
			{
					char name[40];
					int  number;
					char gender;
			}Stu;

			/* 功能函数的声明 */
			extern void createList(SNode **hpp);
			extern void ReadDataFromFileToList(SNode *hp, char *fileName);
			extern void ShowList(SNode *hp);
			extern SNode *FindStuByNumber(SNode *hp);
			extern void ReadDataFromKeybordToList(SNode *hp);
			extern void AlterNode(SNode *hp);
			extern void SaveListToFile(SNode *hp, char *fileName);
			extern void DeleteStu(SNode *hp);
			extern void EmptyList(SNode *hp);
			extern void DestroyList(SNode *hp);

			#endif

		2）sList.c
		#include <stdio.h>
		#include "sList.h"

		/* 功能：创建一个空链表
		 * 参数：
		 *      hpp：头指针变量的指针（地址）
		 * 返回值：无
		 */
		void createList(SNode **hpp)
		{
				//创建一个空间点作为头节点，由于空节点没有数据，所以参数传NULL和0
				*hpp = Sig_CreateNode(NULL, 0);

				//保险起见，给头节点next再赋一次NULL
				(*hpp)->next = NULL;
		}

		/* 功能：读取文件中的学生信息，然后保存到单链表中
		 *       如果文件中没有数据，链表就是一个空链表，我们可以选择从键盘输入学生数据
		 * 参数：
		 *      hp：头指针变量
		 * 返回值：无
		 */
		void ReadDataFromFileToList(SNode *hp, char *fileName)
		{
				/* 打开存放学生信息的文件 */
				FILE *fp = fopen(fileName, "r+"); 
				if(NULL == fp) print_error("fopen");

				/* 循环读取文件内容，每读出一条，就存入创建的节点中
				 * feof函数检测读到文件末尾时，就退出循环
				*/
				Stu stu = {}; //暂存读出的数据
				while(1)
				{
						/* 格式化读文件，每次只读出一条，name是数组，就不要再&取地址了 */
						fscanf(fp, "%s %d %c", stu.name, &stu.number, &stu.gender);

						/* feof返回非零时，就表示读到末尾了，然后退出循环 */
						if(feof(fp) != 0) break;

						/* 创建节点，将数据保存到节点中data所代表的数据空间 */
						SNode *nodep = Sig_CreateNode((void *)&stu, sizeof(stu));

						/* 将节点插入链表，我们这里选择都在链表头部插入 */
						Sig_HeadInertNode(hp, nodep);
				}

				fclose(fp);
		}


		/* 功能：遍历每一个节点，并打印出每个节点的学生数据
		 * 参数：
		 *   hp：头指针
		 * 返回值：无
		 */
		void ShowList(SNode *hp)
		{
				SNode *p = hp->next;
				Stu *datap = NULL;

				if(NULL == p) printf("链表为空\n");
				else
				{
						/* 遍历链表，找到每个节点，打印学生信息 */
						while(1)
						{
								if(NULL == p) break;   //判断是否到了末尾
								datap = (Stu *)p->data; //将void *强制转为Stu *
								printf("%s %d %c\n", datap->name, datap->number, datap->gender);//打印节点中的学生信息

								p = p->next; //指向下一个节点
						}
				}
		}

		/* 功能：遍历链表，通过学号查找学生信息
		 * 参数：
		 *   hp：头指针
		 *   number：要查找的学号
		 * 返回值：返回找到节点的上一个节点的指针
		 *   之所以返回上一个节点，是因为想方便后续的删除和插入操作
		 */
		SNode *FindStuByNumber(SNode *hp)
		{
				SNode *p = hp; //指向头节点
				Stu *datap = NULL;
				int number = 0;

				if(NULL == p) printf("链表为空\n");
				else
				{
						printf("输入学号\n");
						scanf("%d", &number);
						/* 遍历链表，找到每个节点，通过比对学号找到某学生信息 */
						while(1)
						{
								if(NULL == p->next) break;    //判断是否到了末尾

								datap = (Stu *)p->next->data; //暂存节点中数据指针
								if(datap->number == number)
								{
										printf("%s %d %c\n", datap->name, datap->number, datap->gender);//打印节点中的学生信息
										break;
								}
								p = p->next; //指向下一个节点
						}
				}

				return p;  //返回被早到节点的上一个节点
		}

		/* 功能：从键盘输入一条学生信息然后插入链表的头，
		 *      当然你也可以插入链表中的任何位置，我们这里简单一点，直接插入到链表头
		 * 参数：
		 *   hp：头指针
		 * 返回值：无
		 */
		void ReadDataFromKeybordToList(SNode *hp)
		{
				int select = 0;
				Stu stu = {};
				SNode *nodep = NULL;
				SNode *temp = NULL;

				printf("%s %d %c\n", stu.name, stu.number, stu.gender);
				printf("请输入学生信息，输入格式为：名字 学号 性别（M/F）\n");
				scanf("%s %d %c", stu.name, &stu.number, &stu.gender);

				/* 创建节点，将数据保存到节点中data所代表的数据空间 */
				nodep = Sig_CreateNode((void *)&stu, sizeof(stu));

				printf("1. 插入链表头部\n");
				printf("2. 插入链尾部\n");
				printf("3. 插入指定位置\n");
				scanf("%d", &select);
				switch(select)
				{
						case 1:
								Sig_HeadInertNode(hp, nodep);
								break;
						case 2:
								Sig_TailInertNode(hp, nodep);
								break;
						case 3:
								ShowList(hp);  //显示整个链表，方便寻找插入位置
								temp = FindStuByNumber(hp); //返回要插入位置的上一个节点的指针
								Sig_InsertNode(temp, nodep);//调用同样插入函数，将nodep插入到temp所指节点的后面
								break;
						default: printf("无此选项\n");
				}
		}

		/* 功能：通过学号找到学生信息，然后修改
		 * 参数：
		 *   hp：头指针
		 *   number：要查找的学号
		 * 返回值：无
		 */
		void AlterNode(SNode *hp)
		{
				SNode *tmp = NULL;
				Stu *datap = NULL;

				/* 调用FindStuByNumber函数，
				 * 按照学号查找，找到后返回节点指针 */
				tmp = FindStuByNumber(hp);

				if(tmp->next == NULL) printf("没有找到\n");
				else
				{
						//暂存节点中数据空间的指针，以方便操作，不过需要将void *强制转为Stu
						datap = (Stu *)tmp->next->data;
						printf("输入新信息，格式：名字 学号 性别\n");
						scanf("%s %d %c", datap->name, &datap->number, &datap->gender);
				}
		}

		/* 功能：将链表中的数据保存到文件中
		 * 参数：
		 *   hp：头指针
		 * 返回值：无
		 */
		void SaveListToFile(SNode *hp, char *fileName)
		{
				SNode *p = hp->next;
				Stu *datap = NULL;

				/* 以w方式打开（只写），并将文件内容清空，清空后
				 * 再重新将被修改后的链表中的数据写入文件中 */
				FILE *fp = fopen(fileName, "w"); 
				if(NULL == fp) print_error("fopen");

				/* 遍历链表，找到每个节点，通过比对学号找到某学生信息 */
				while(1)
				{
						if(NULL == p) break;    //判断是否到了末尾
						datap = (Stu *)p->data; //将void *强制转为Stu *
						fprintf(fp, "%s %d %c\n", datap->name, datap->number, datap->gender);//打印节点中的学生信息

						p = p->next; //指向下一个节点
				}
				//关闭文件，并将数据从库缓存刷新到文件中
				fclose(fp);
		}

		/* 功能：删除某个学生信息
		 * 参数：
		 *   hp：头指针
		 * 返回值：无
		 */
		void DeleteStu(SNode *hp)
		{
				//通过学号找到节点
				SNode *p = FindStuByNumber(hp);

				//删除节点
				Sig_DeleteNode(p);
		}

		/* 功能：删除所有的数据节点，只保留头节点
		 * 参数：
		 *   hp：头指针
		 * 返回值：无
		 */
		void EmptyList(SNode *hp)
		{
				while(1)
				{
					 if(hp->next == NULL) break;
					 Sig_DeleteNode(hp);
				}
				printf("链表已被清空\n");
		}

		/* 功能：将数据节点和头节点都删除，整个链表就被销毁了
		 * 参数：
		 *   hp：头指针
		 * 返回值：无
		 */
		void DestroyList(SNode *hp)
		{
				//删除所有数据节点
				EmptyList(hp);

				//删除头节点
				free(hp);
				hp = NULL;
				printf("链表已被销毁");
		}

	（3）main.c
		#include <stdio.h>
		#include "sList.h"

		//文件路径名
		//#define FILE_PATH "C:\\Users\\Administrator\\Desktop\\StuFile.txt"  //windows
		#define FILE_PATH "/home/zxf/Desktop/sList/StuFile.txt"    						//Linux
		
		#define SHOW                1
		#define FIND                2
		#define READ_KEYBORD        3
		#define ALTER               4
		#define SAVE                5
		#define DELETE              6
		#define EMPTY               7
		#define EXIT                8

		/* 功能：交互函数
		 * 参数：无
		 * 返回值：选择
		 */
		int interactive(void)
		{
				printf("1. 打印显示所有信息\n");
				printf("2. 按照学号查找，并打印学生信息\n");
				printf("3. 从键盘输入一条学生信息，然后插入链表\n");
				printf("4. 修改学生信息\n");
				printf("5. 保存链表到文件中\n");
				printf("6. 删除某个学生的信息\n");
				printf("7. 清空链表\n");
				printf("8. 退出程序，并销毁链表\n");

				int select = 0;
				scanf("%d", &select);

				return select; //返回选择
		}

		int main(void)
		{
				SNode *hp = NULL;

				/* 创建空链表 */
				createList(&hp);

				/* 读取文件数据 */
				ReadDataFromFileToList(hp, FILE_PATH);

				/* 操作链表 */
				while(1)
				{
						//interactive为交互函数
						switch(interactive())
						{
								case SHOW:  //显示所有链表信息
										ShowList(hp);
										break;
								case FIND:  //按照学号查找
										FindStuByNumber(hp);
										break;
								case READ_KEYBORD:  //从键盘输入信息
										ReadDataFromKeybordToList(hp);
										break;
								case ALTER: //修改信息
										AlterNode(hp);
										break;
								case SAVE: //保存到文件中
										SaveListToFile(hp, FILE_PATH);
										break;
								case DELETE: //删除某个学生
										DeleteStu(hp);
										break;
								case EMPTY: //清空链表
										EmptyList(hp);
										break;
								case EXIT: //退出程序，并销毁链表
										DestroyList(hp); //销毁链表
										return 0;  //main函数退出，整个程序结束
										break;
								default: printf("无此选项\n");
						}
				}

				return 0;
		}
			
			
7.2.4 为什么要将节点中的data定义为void *
	
	//单链表的节点结构体
	typedef struct SignalNode  
	{
			Stu *data;
			struct SignalNode *next; //指向下一个元素
	}SNode;

		实际上也可以将data定义为Stu *data或者Stu data，但是这样的话“节点结构体”就会与具体的数据类型Stu相关，
	如此一来“基本操作函数”的代码就会与具体的数据类型相关联，如此我们将无法独立出与“具体数据类型”无关
	“链表基本操作函数”。
		
		当我们后需加入老师链表时，老师的数据类型（比如Tea）与学生数据类型Stu的肯定不一样，但是“基本操作函数”
	里面使用的确是Stu学生数据类型，而老师链表使用的却是Tea，那么老师链表的功能函数自然不能共用链表的
	“基本操作函数”，此时就必须重新为老师链表写一个份“老师链表的基本操作函数”，这会很麻烦。
		
		如果“链表基本操作函数”与具体的数据类型无关的话，那么老师和学生的链表功能函数，都可以共用相同的
	“链表基本操作函数”。
                         共用  
													 /-----学生链表的功能函数
                          /														
		    	链表基本操作函数-------老师链表的功能函数
		                      \
		                       \-----其它链表的功能函数 
														
		
		所以说，我们将data定义为void *后，有利于我们将“链表基本操作函数”与具体数据类型脱离，让所有的链表功能
	函数都能调用（共用）相同的“链表基本操作函数”，这么做其实说白了就是将链表代码分为了两层，一层是共用
	的“链表基本操作函数”，另一层是与具体数据有关的链表功能函数。
		
		通过这种分层，不仅能够尽可能的将共用的代码提出，以减少劳动量，同时还能将程序“模块化”，以后添加其它
	链表时，只需要添加对应的代码“模块”即可，比如添加老师链表时。
		
		我们这里的分层没有用到第7章讲的“结构体内嵌函数指针”，所以不是一遇到分层就会使用“结构体内嵌函数指针”。
		
		
（1）定义老师数据结构体
			typedef struct Teacher
			{
				...
			}Tea;
			
（2）实现老师链表的功能函数
			我们通过调用共用的“链表基本操作函数”来实现。
			
			void Tea_createList(SNode **hpp);
			void Tea_ReadDataFromFileToList(SNode *hp, char *fileName);
			void Tea_ShowList(SNode *hp);
			SNode *Tea_FindStuByNumber(SNode *hp);
			...
			
			为了和学生的功能函数区别，我们在老师功能函数的头上加Tea_前缀。
			实际上我们在实现学生链表的功能函数时，为了和老师的进行区别，我们也应该加上Stu_前缀，比如：
			void Stu_createList(SNode **hpp);
			void Stu_ReadDataFromFileToList(SNode *hp, char *fileName);
			void Stu_ShowList(SNode *hp);
			...
	
			大家自己去实现时，希望大家能够按照以上格式去命名。
			
			
（3）在main函数中调用老师链表的功能函数，操作老师链表
		1）定一个老师链表的“头指针变量”
			SNode *teaHp = NULL;

		2）调用老师链表的功能函数，创建一个老师空链表
			比如： 
			 Tea_createList(&teaHp);
			
		3）调用老师链表的功能函数，读取老师文件中的数据并保存到老师链表中
			比如：
				Tea_ReadDataFromFileToList(teaHp, TEA_FILE_PATH);
		
		4）调用老师链表的其它功能函数，实现插入、删除、修改、保存、清空等操作。
			
8. 双链表
8.1 双链表的节点结构体
	双链表和单链表的实现并没有什么太大的差别，只不过比单链表的节点多了一个prev成员，用于指向上一个节点。
		
		//双链表的节点结构体
		typedef struct DoubleNode  
		{
			void *data;  						 //指向数据空间，为了独立出“链表基本操作”，我们任然将data定义为void *
			struct DoubleNode *prev; //存放前继节点指针，指向上一个节点
			struct DoubleNode *next; //存放后继节点指针，指向下一个节点
		}DNode;
		
		由于双向链表比单链表多了一个向前的指向，所以使用起来更加方便。
		我们知道，在单链表中进行插入、删除操作时有点麻烦，必须找到前一个节点才能进行操作，但是在双链表
	中就不必如此麻烦，要操作那个节点，直接拿到这个节点的指针即可。
		
		双链表也分为了“双向非循环链表”和“双向循环链表”，我们举例时举的是“双向循环链表”。	
		
			
8.2 双向循环链表的结构
	图5：
	
	
	从图中可以看出，其实与单链表的差别并不大。
	
（1）头指针变量：存放的是头节点的指针，指向了头节点，为整个链表的入口。
（2）头节点：与单链表一样，为了方便操作，我们也加入“空头节点”。
（3）由于是循环链表，所以头节点的后面为链表头部，头节点的前面为链表尾
		
		
8.3 实现双向循环链表
8.3.1 实现链表基本操作
	· 创建节点
	· 插入节点
	· 删除节点
		
		同样的，“链表基本操作”只与节点本身有关，与具体的数据无关。
		
		由于双链表只是比单链表只多了一个指向，所以双链表与单链表的“基本操作”的几乎差不多，所以我们只需要
	在单链表代码的基础上进行修改，即可得到双链表的“基本操作函数”。
		
	
（1）创建节点
		1）代码

			DNode *Dou_CreateNode(void *data, int dataSize)
			{
					/* malloc开辟节点空间 */
					DNode *p = (DNode *)malloc(sizeof(DNode));
					if(NULL == p) print_error("malloc");

					//让prev、next默认指向空
					p->data = NULL;  
					p->prev = p->next = NULL;  			

					/* malloc开辟节点中的数据空间，然后存入数据
					 * 有数据才开辟，没有数据就不用开辟了
					*/
					if(NULL != data)
					{
							p->data = malloc(dataSize);
							if(NULL == p->data) print_error("malloc");

							//前面的课程就说过，结构体变量之间是可以整体复值的
							memcpy(p->data, data, dataSize);
					}

					return p;
			}
			
			
		2）代码分析
			除了*****标记代码不同之外，其它与单链表的都是一样的。
			
	
（2）插入节点				
			由于双链表有next和prev这两个指向，所以插入操作会比单链表更加容易。
			只要拿到了前一个节点和后一个节点的指针，就能在两个节点之间插入新节点。
			图：
			
			
			
		
		1）通用插入代码
			/* 功能：将新节点插入到前后两个节点之间
			 *   prev：前一个节点的指针
			 *   next：后一个节点的指针
			 *   nodep：新节点的指针
			*/
			void Dou_insertNode(DNode *prev, DNode *next, DNode *nodep)
			{
					//新节点与前一个节点相互指向
					prev->next = nodep;
					nodep->prev = prev;

					//新节点与后一个节点相互指向
					next->prev = nodep;
					nodep->next = next;
			}
				
				
		2）插入到p所指向节点的后面
			void Dou_InsertNodeAfter(SNode *p, SNode *nodep)
			{	
					Dou_insertNode(p, p->next, nodep);
			}

			
		3）插入到p所指向节点的前面
			void Dou_InsertNodeBefore(SNode *p, SNode *nodep)
			{
					//p->prev为前一个节点的指针，p为后一个节点的指针
					Dou_insertNode(p->prev, p, nodep);
			}
				
				
		4）插入到链表的头部（也就是插入到头节点的后面）
			//hp：头节点指针    nodep：新节点指针
			void Dou_HeadInertNode(SNode *hp, SNode *nodep)
			{
					Dou_InsertNodeAfter(hp, nodep); 
			}

					
		5）插入整个链表的尾部（也就是插入到头节点的前面）
			//hp：头节点指针    nodep：新节点指针
			void Dou_TailInertNode(SNode *hp, SNode *nodep)
			{
					Dou_InsertNodeBefore(hp, nodep); 
			}


			
（3）删除节点				
			只要拿到了前一个节点和后一个节点的指针，就可以删除掉中间的节点。
			
		1）删除操作的通用代码
			
			void Dou_Delete(SNode *prev, SNode *next)
			{
					prev->next = next;
					next->prev = prev;
			}
			
			
		2）删除某个节点（基于Dou_Delete实现）
			
			
			//p指向了要被删除的节点
			void Dou_DeleteNode(SNode *p)
			{
					/* 删除节点，p->prev：前一个节点的指针， p->next：后一个节点的指针 */
					Dou_Delete(p->prev, p->next);

					/* 释放节点数据空间 */
					if(NULL != p->data)
							free(p->data);//释放节点的数据空间
							
					p->data = NULL; 
					p->prev = p->next = NULL;
					
					//释放节点空间
					free(p); 
					p = NULL;
			}

		
8.3.2 基于链表的基本操作，正式实现一个存放学生数据的“双向循环链表”
（1）要实现的功能如下
		1）创建一个只有“头指针变量”和“头节点”的空双向循环链表
		2）从文件中读取出学生数据，然后保存到链表中	
		3）将所有学生数据打印显示出来
		4）按照学号查找学生数据
				
		5）从键盘输入学生数据，然后插入到链表中（头插或者尾插）
		6）修改学生数据
		7）保存链表数据到文件中
		8）按照学号排序
		9）删除某个学生节点
		10）清空链表（只剩一个空头节点）
		11）销毁链表（把空头节点也删除掉）
		
		
（2）功能函数的实现
		与单链表的功能函数基本差不多，所以直接在单链表代码的基础上修改即可。
		
		1）创建一个只有“头指针变量”和“头节点”的空双向循环链表
			void createList(SNode **hpp)
			{
					//创建一个空间点作为头节点，由于空节点没有数据，所以参数传NULL和0
					*hpp = Dou_CreateNode(NULL, 0);

					//让头节点的next、prev放头节点自己的地址
					(*hpp)->next = (*hpp)->prev = *hpp; 
			}
			让头节点的next、prev放头节点自己的地址，就得到了基本的双向循环链表。
			
			
		2）从文件中读取出学生信息，然后保存到链表中	
				这一个功能函数与单链表的基本没有区别。
				
				void ReadDataFromFileToList(SNode *hp, const char *fileName)
				{
						FILE *fp = fopen(fileName, "r+"); 
						if(NULL == fp) print_error("fopen");

						Stu stu = {}; //暂存从文件中所读出的数据
						while(1)
						{
								fscanf(fp, "%s %d %c", stu.name, &stu.number, &stu.gender);
								if(feof(fp) != 0) break;
								SNode *nodep = Dou_CreateNode((void *)&stu, sizeof(stu));
								//Dou_HeadInertNode(hp, nodep); //*************
								Dou_TailInertNode(hp, nodep); //*************
						}
						fclose(fp);
				}

		3）将所有学生信息打印显示出来
			与单链表的没有大区别，唯一不同的是，双链表的遍历结束判断条件变为if(hp == p)。
				void ShowList(const DNode *hp)
				{
						DNode *p = hp->next;
						Stu *datap = NULL;

						if(hp == hp->next) printf("链表为空\n");
						else
						{
								while(1)
								{
										if(hp == p) break;  //*************
										datap = (Stu *)p->data;
										printf("%s %d %c\n", datap->name, datap->number, datap->gender); //打印显示
										p = p->next; //指向下一个节点
								}
						}
				}
				
			
		4）按照学号查找学生信息
				与单链表的也几乎一样，只不过在单链表中，返回的是找到节点上一个节点的指针，但是在双链表中，
			找到节点后，会直接返回该节点的指针，因为在双链表中，你要操作那个节点，直接使用该节点的指针即可。
			
				DNode *FindStuByNumber(const DNode *hp)
				{
						DNode *p = hp->next;
						Stu *datap = NULL;
						int number = 0;

						if(hp == hp->next) printf("链表为空\n");
						else
						{
								printf("输入学号\n");
								scanf("%d", &number);
								while(1)
								{
										if(hp == p) break; //判断是否到了末尾 *****************

										datap = (Stu *)p->data; //暂存节点中数据指针
										if(datap->number == number)
										{
												printf("%s %d %c\n", datap->name, datap->number, datap->gender);//打印节点中的学生信息
												break;
										}
										p = p->next; //指向下一个节点
								}
						}

						return p;
				}
				
		5）从键盘输入某个学生数据，然后插入到链表中
			这个与单链表基本一样，只是稍微有点区别。
			void ReadDataFromKeybordToList(DNode *hp)
			{
					int select = 0;
					Stu stu = {};
					DNode *nodep = NULL;
					DNode *temp = NULL;

					printf("请输入学生信息，输入格式为：名字 学号 性别（M/F）\n");
					scanf("%s %d %c", stu.name, &stu.number, &stu.gender);

					/* 创建节点，将数据保存到节点中data所代表的数据空间 */
					nodep = Dou_CreateNode((void *)&stu, sizeof(stu));

					printf("1. 插入链表头部\n");
					printf("2. 插入链尾部\n");
					printf("3. 插入指定位置\n");
					scanf("%d", &select);
					switch(select)
					{
							case 1:
									Dou_HeadInertNode(hp, nodep);
									break;
							case 2:
									Dou_TailInertNode(hp, nodep);
									break;
							case 3:
									ShowList(hp);  //显示所有学生信息，方便查看
									temp = FindStuByNumber(hp);  //查找要插入的位置
									printf("1. 插入到前面\n"); //*************
									printf("2. 插入到后面\n"); //*************
									scanf("%d", &select);      //*************
									
									if(select == 1)      Dou_InsertNodeBefore(temp, nodep); //*********
									else if(select == 2) Dou_InsertNodeAfter(temp, nodep);  //*********
							
							default: printf("无此选项\n");
					}
			}
		
		6）修改学生数据
				与单链表基本一样，仅仅判断条件有所不同，如果FindStuByNumber最终返回的是头节点的指针，
			就说找了一圈没有找到，又回到了头节点上。
			
				void AlterNode(const DNode *hp)
				{
						DNode *tmp = NULL;
						Stu *datap = NULL;

						tmp = FindStuByNumber(hp); //按照学号查找，找到后返回该节点的指针
						
						if(tmp == hp) printf("没有找到\n");
						else
						{
								datap = (Stu *)tmp->data;
								printf("输入新信息，格式：名字 学号 性别\n");
								scanf("%s %d %c", datap->name, &datap->number, &datap->gender); //向节点中，重新输入信息
						}
				}
				
				
		7）保存链表数据到文件中
			与单链表完全一样，唯一不同的只是判断结束的条件。
				void SaveListToFile(const DNode *hp, const char *fileName)
				{
						DNode *p = hp->next;
						Stu *datap = NULL;

						FILE *fp = fopen(fileName, "w"); 
						if(NULL == fp) print_error("fopen");

						while(1)
						{
								if(hp == p) break;    //判断是否到了末尾
								datap = (Stu *)p->data; //将void *强制转为Stu *
								fprintf(fp, "%s %d %c\n", datap->name, datap->number, datap->gender);//打印节点中的学生信息
								p = p->next; //指向下一个节点
						}
						fclose(fp);	//关闭文件，并将数据从库缓存刷新到文件中
				}
					
		8）按照学号排序
				排序算法有很多种，比如插入排序、选择排序、冒泡排序、快速排序、希尔排序等等。
				我们这里的重点不是介绍排序算法，在实际的应用开发中，排序算法对我们来说并不重要，所以我们这介绍
			简单的冒泡排序。
				我们这里讲排序目的就是想向大家演示，如何对链表进行排序。
				
				实现的从小到大排序：
				
				void BubbleSort(const DNode *hp)
				{
						DNode *p     = NULL; 
						DNode *lastp = hp->prev; //指向最后一个节点
						Stu *datap = NULL;
						Stu *nextNodeDatap = NULL;
						Stu *temp = NULL;

						while(1)
						{
								p = hp->next; //指向第一个数据节点
								if(lastp->prev == hp) break;
								
								while(1)
								{
										if(p == lastp) break;
										datap = (Stu *)(p->data);
										nextNodeDatap = (Stu *)(p->next->data);
										if((datap->number) > (nextNodeDatap->number))
										{
												temp = p->next->data;
												p->next->data = p->data;
												p->data = temp;
										}
										p = p->next;
								}
								lastp = lastp->prev;
						}
						printf("冒泡排序结束\n");
				}
								
				
		9）删除某个学生节点
			与单链表一样。
			void DeleteStu(const DNode *hp)
			{
					DNode *p = FindStuByNumber(hp);
					Dou_DeleteNode(p);
			}
			
		10）清空链表（只剩一个空头节点）
			与单链表一样，只不过要删除第一个节点时，在单链表中p要指向头节点，但是在双链表中，p直接指向第一个节点。
			
			void EmptyList(const DNode *hp)
			{
					DNode *p = NULL; 				//*******
					while(1)
					{
						 p = hp->next;  			//指向第一个数据 ********
						 if(p == hp) break;  	//***********
						 Dou_DeleteNode(p);
					}
					printf("链表已被清空\n");
			}
		
		
		11）销毁链表（把空头节点也删除掉）
			与单链表完全一样
			void DestroyList(const DNode *hp)
			{
					EmptyList(hp); //清空链表
					
					free(hp);
					
					printf("链表已被销毁\n");
			}
			
		
8.3.3 双链表例程的完整代码
	· 基本操作函数：dList_base_op.h、dList_base_op.c
	· 功能函数：dList.h、dList.c
	· main函数：main.c
	
（1）基本操作函数
		1）dList_base_op.h
			#ifndef H_SLIST_BASE_OP_H
			#define H_SLIST_BASE_OP_H
			#include <stdlib.h> //exit函数需要这个头文件

			#define print_error(str) \
			do{\
							fprintf(stderr, "File %s, Line %d, Function %s error\n", __FILE__, __LINE__, str);\
							perror("error Reason");\
							exit(-1);\
			}while(0);

			typedef struct SignalNode  //单链表结构
			{
					void *data;
					struct SignalNode *prev; //指向上一个元素
					struct SignalNode *next; //指向下一个元素
			}DNode;


			extern DNode *Dou_CreateNode(void *data, int dataSize);
			extern void Dou_insertNode(DNode *prev, DNode *next, DNode *nodep);
			extern void Dou_InsertNodeAfter(DNode *p, DNode *nodep);
			extern void Dou_InsertNodeBefore(DNode *p, DNode *nodep);
			extern void Dou_Delete(DNode *prev, DNode *next);
			extern void Dou_DeleteNode(DNode *prevNodep);
			extern void Dou_HeadInertNode(DNode *hp, DNode *node);
			extern void Dou_TailInertNode(DNode *hp, DNode *node);

			#endif

		2）dList_base_op.c
			#include <stdio.h>
			#include "dList_base_op.h"


			/* 功能：创建节点
			 * 参数：
			 *      data：指向空间中，存放了要被写入节点的数据
			 *          如果data为NULL，就表示没有数据要存入节点，
			 *          此时只是一没有数据的空节点
			 *
			 *      dataSize：数据空间的大小
			 *
			 * 返回值：返回新节点的指针（结构变量首字节地址）
			 */
			DNode *Dou_CreateNode(void *data, int dataSize)
			{
					/* malloc开辟节点空间 */
					DNode *p = (DNode *)malloc(sizeof(DNode));
					if(NULL == p) print_error("malloc");

					//让prev、next默认指向空
					p->prev = p->next = NULL;

					/* malloc开辟节点中的数据空间，然后存入数据
					 * 有数据才开辟，没有数据就不用开辟了
					*/
					if(NULL != data)
					{
							p->data = malloc(dataSize);
							if(NULL == p) print_error("malloc");

							//前面的课程就说过，结构体变量之间是可以整体复值的
							memcpy(p->data, data, dataSize);
					}

					return p;
			}
			
			/* 功能：将新节点插入到前后两个节点之前
			 * 参数：
			 *   prev：前一个节点的指针
			 *   next：后一个节点的指针
			 *   nodep：新节点的指针
			 *
			 * 返回值：无
			 */
			void Dou_insertNode(DNode *prev, DNode *next, DNode *nodep)
			{
					//新节点与后一个节点相互发生指向
					nodep->next = next;
					next->prev = nodep;

					//新节点与前一个节点相互发生指向
					nodep->prev = prev;
					prev->next = nodep;
			}

			/* 功能：将新节点nodep，插入到p所指向节点的后面
			*/
			void Dou_InsertNodeAfter(DNode *p, DNode *nodep)
			{
					Dou_insertNode(p, p->next, nodep);
			}

			/* 功能：将新节点nodep，插入到p所指向节点的前面
			*/
			void Dou_InsertNodeBefore(DNode *p, DNode *nodep)
			{
					Dou_insertNode(p->prev, p, nodep);
			}

			/* 功能：插入到链表头部，也就是插到头节点的后面
			 * hp：头节点指针
			 * nodep：新节点的指针
			 * 返回值：无
			 */
			void Dou_HeadInertNode(DNode *hp, DNode *nodep)
			{
					Dou_InsertNodeAfter(hp, nodep); //插入到头节点的后面
			}

			/* 功能：插入链表尾部，也就是插到头节点的前面
			 * hp：头节点指针
			 * nodep：新节点的指针
			 * 返回值：无
			 */
			void Dou_TailInertNode(DNode *hp, DNode *nodep)
			{
					Dou_InsertNodeBefore(hp, nodep); //插入到头节点的前面
			}

			/* 功能：删除两个节点之前的节点
			 * 参数：
			 *    prev：前一个节点的指针
			 *    next：后一个节点的指针
			 * 返回值：无
			*/
			void Dou_Delete(DNode *prev, DNode *next)
			{
					prev->next = next;
					next->prev = prev;
			}

			/* 功能：删除某个节点
			 * 参数：
			 *    p：要删除节点的指针
			 * 返回值：无
			*/
			void Dou_DeleteNode(DNode *p)
			{
					/* 删除节点 */
					Dou_Delete(p->prev, p->next);

					/* 释放节点空间 */
					if(NULL != p->data)
							free(p->data);//释放节点的数据空间
					p->data = NULL; //不要让遗留的随机值（节点指针），干扰下一次的空间使用
					p->prev = p->next = NULL;

					free(p); //释放节点空间
					p = NULL;
			}
		
（2）功能函数
		1）dList.h
			#ifndef H_SLIST_H
			#define H_SLIST_H
			#include "dList_base_op.h"

			/* 学生结构体(存放数据的结构体) */
			typedef struct Student
			{
					char name[40];
					int  number;
					char gender;
			}Stu;

			/* 功能函数的声明 */
			extern void createList(DNode **hpp);
			extern void ReadDataFromFileToList(DNode *hp, const char *fileName);
			extern void ShowList(const DNode *hp);
			extern DNode *FindStuByNumber(const DNode *hp);
			extern void ReadDataFromKeybordToList(DNode *hp);
			extern void AlterNode(const DNode *hp);
			extern void SaveListToFile(const DNode *hp, const char *fileName);
			extern void DeleteStu(const DNode *hp);
			extern void EmptyList(const DNode *hp);
			extern void DestroyList(const DNode *hp);

			#endif
			
		2）dList.c
			#include <stdio.h>
			#include "dList.h"

			/* 功能：创建一个空链表
			 * 参数：
			 *      hpp：头指针变量的指针（地址）
			 * 返回值：无
			 */
			void createList(DNode **hpp)
			{
					//创建一个空间点作为头节点，由于空节点没有数据，所以参数传NULL和0
					*hpp = Dou_CreateNode(NULL, 0);

					//保险起见，给头节点next、prev放自己的地址
					//如此就做成了双向循环链表
					(*hpp)->next = (*hpp)->prev = *hpp;
			}

			/* 功能：读取文件中的学生信息，然后保存到单链表中
			 *       如果文件中没有数据，链表就是一个空链表，我们可以选择从键盘输入学生数据
			 * 参数：
			 *      hp：头指针变量
			 * 返回值：无
			 */
			void ReadDataFromFileToList(DNode *hp, const char *fileName)
			{
					/* 打开存放学生信息的文件 */
					FILE *fp = fopen(fileName, "r+"); //FILE_PATH定义在了sList.h中
					if(NULL == fp) print_error("fopen");

					/* 循环读取文件内容，每读出一条，就存入创建的节点中
					 * feof函数检测读到文件末尾时，就退出循环
					*/
					Stu stu = {}; //暂存读出的数据
					while(1)
					{
							/* 格式化读文件，每次只读出一条，name是数组，就不要再&取地址了 */
							fscanf(fp, "%s %d %c", stu.name, &stu.number, &stu.gender);

							/* feof返回非零时，就表示读到末尾了，然后退出循环 */
							if(feof(fp) != 0) break;

							/* 创建节点，将数据保存到节点中data所代表的数据空间 */
							DNode *nodep = Dou_CreateNode((void *)&stu, sizeof(stu));

							/* 将节点插入链表，我们这里选择都在链表头部插入 */
							Dou_TailInertNode(hp, nodep);
					}

					fclose(fp);
			}


			/* 功能：遍历每一个节点，并打印出每个节点的学生数据
			 * 参数：
			 *   hp：头指针
			 * 返回值：无
			 */
			void ShowList(const DNode *hp)
			{
					DNode *p = hp->next;
					Stu *datap = NULL;

					if(hp == p) printf("链表为空\n");
					else
					{
							/* 遍历链表，找到每个节点，打印学生信息 */
							while(1)
							{
									if(hp == p) break; //如果p指向了头节点，表示遍历结束了
									datap = (Stu *)p->data; //将void *强制转为Stu *
									printf("%s %d %c\n", datap->name, datap->number, datap->gender);//打印节点中的学生信息

									p = p->next; //指向下一个节点
							}
					}
			}

			/* 功能：遍历链表，通过学号查找学生信息
			 * 参数：
			 *   hp：头指针
			 *   number：要查找的学号
			 * 返回值：无
			 */
			DNode *FindStuByNumber(const DNode *hp)
			{
					DNode *p = hp->next;
					Stu *datap = NULL;
					int number = 0;

					if(hp == p) printf("链表为空\n");
					else
					{
							printf("输入学号\n");
							scanf("%d", &number);
							/* 遍历链表，找到每个节点，通过比对学号找到某学生信息 */
							while(1)
							{
									if(hp == p) break;    //判断是否到了末尾

									datap = (Stu *)p->data; //暂存节点中数据指针
									if(datap->number == number)
									{
											printf("%s %d %c\n", datap->name, datap->number, datap->gender);//打印节点中的学生信息
											break;
									}
									p = p->next; //指向下一个节点
							}
					}

					return p;
			}

			/* 功能：从键盘输入一条学生信息然后插入链表的头，
			 *      当然你也可以插入链表中的任何位置，我们这里简单一点，直接插入到链表头
			 * 参数：
			 *   hp：头指针
			 * 返回值：无
			 */
			void ReadDataFromKeybordToList(DNode *hp)
			{
					int select = 0;
					Stu stu = {};
					DNode *nodep = NULL;
					DNode *temp = NULL;

					printf("%s %d %c\n", stu.name, stu.number, stu.gender);
					printf("请输入学生信息，输入格式为：名字 学号 性别（M/F）\n");
					scanf("%s %d %c", stu.name, &stu.number, &stu.gender);

					/* 创建节点，将数据保存到节点中data所代表的数据空间 */
					nodep = Dou_CreateNode((void *)&stu, sizeof(stu));

					printf("1. 插入链表头部\n");
					printf("2. 插入链尾部\n");
					printf("3. 插入指定位置\n");
					scanf("%d", &select);
					switch(select)
					{
							case 1:
									Dou_HeadInertNode(hp, nodep);
									break;
							case 2:
									Dou_TailInertNode(hp, nodep);
									break;
							case 3:
									ShowList(hp);  //显示所有学生信息，方便查看
									temp = FindStuByNumber(hp);  //查找要插入的位置
									printf("1. 插入到前面\n");
									printf("2. 插入到后面\n");
									scanf("%d", &select);
									if(select == 1)      Dou_InsertNodeBefore(temp, nodep);
									else if(select == 2) Dou_InsertNodeAfter(temp, nodep);
							default: printf("无此选项\n");
					}
			}

			/* 功能：通过学号找到学生信息，然后修改
			 * 参数：
			 *   hp：头指针
			 *   number：要查找的学号
			 * 返回值：无
			 */
			void AlterNode(const DNode *hp)
			{
					DNode *tmp = NULL;
					Stu *datap = NULL;

					/* 调用FindStuByNumber函数，
					 * 按照学号查找，找到后返回节点指针 */
					tmp = FindStuByNumber(hp);

					if(tmp == hp) printf("没有找到\n");
					else
					{
							//暂存节点中数据空间的指针，以方便操作，不过需要将void *强制转为Stu
							datap = (Stu *)tmp->data;
							printf("输入新信息，格式：名字 学号 性别\n");
							scanf("%s %d %c", datap->name, &datap->number, &datap->gender);
					}
			}

			/* 功能：将链表中的数据保存到文件中
			 * 参数：
			 *   hp：头指针
			 * 返回值：无
			 */
			void SaveListToFile(const DNode *hp, const char *fileName)
			{
					DNode *p = hp->next;
					Stu *datap = NULL;

					/* 以w方式打开（只写），并将文件内容清空，清空后
					 * 再重新将被修改后的链表中的数据写入文件中 */
					FILE *fp = fopen(fileName, "w");
					if(NULL == fp) print_error("fopen");

					/* 遍历链表，找到每个节点，通过比对学号找到某学生信息 */
					while(1)
					{
							if(hp == p) break;    //判断是否到了末尾
							datap = (Stu *)p->data; //将void *强制转为Stu *
							fprintf(fp, "%s %d %c\n", datap->name, datap->number, datap->gender);//打印节点中的学生信息

							p = p->next; //指向下一个节点
					}
					//关闭文件，并将数据从库缓存刷新到文件中
					fclose(fp);
			}

			/* 功能：删除某个学生信息
			 * 参数：
			 *   hp：头指针
			 * 返回值：无51
			 */
			void DeleteStu(const DNode *hp)
			{
					//通过学号找到节点
					DNode *p = FindStuByNumber(hp);

					//删除节点
					Dou_DeleteNode(p);
			}

			/* 功能：删除所有的数据节点，只保留头节点
			 * 参数：
			 *   hp：头指针
			 * 返回值：无
			 */
			void EmptyList(const DNode *hp)
			{
					DNode *p = NULL;

					//先删除
					while(1)
					{
						 p = hp->next;  //指向第一个数据
						 if(p == hp) break;
						 Dou_DeleteNode(p);
					}
					printf("链表已被清空\n");
			}

			/* 功能：将数据节点和头节点都删除，整个链表就被销毁了
			 * 参数：
			 *   hp：头指针
			 * 返回值：无
			 */
			void DestroyList(const DNode *hp)
			{
					//删除所有数据节点
					EmptyList(hp);

					//删除头节点
					free(hp);
					hp = NULL;
					printf("链表已被删除\n");
			}


			/* 功能：按学号的从小到大排序
			 * 参数：hp：头指针
			 * 返回值：无
			 */
			void BubbleSort(const DNode *hp)
			{
					DNode *p     = NULL; //指向第一个节点
					DNode *lastp = hp->prev; //指向最后一个节点
					Stu *datap = NULL;
					Stu *nextNodeDatap = NULL;
					Stu *temp = NULL;

					while(1)
					{
							if(lastp->prev == hp) break;
							p = hp->next; //指向第一个节点

							while(1)
							{
									if(p == lastp) break;
									datap = (Stu *)(p->data);
									nextNodeDatap = (Stu *)(p->next->data);
									if((datap->number) >= (nextNodeDatap->number))
									{
											temp = p->next->data;
											p->next->data = p->data;
											p->data = temp;
									}
									p = p->next;
							}
							lastp = lastp->prev;
					}
					printf("冒泡排序结束\n");
			}

（3）main.c
		#include <stdio.h>
		#include "dList.h"

		//文件路径名
		#define FILE_PATH "C:\\Users\\Administrator\\Desktop\\StuFile.txt"

		#define SHOW                1
		#define FIND                2
		#define READ_KEYBORD        3
		#define ALTER               4
		#define SAVE                5
		#define DELETE              6
		#define EMPTY               7
		#define SORT                8
		#define EXIT                9

		/* 功能：交互函数
		 * 参数：无
		 * 返回值：选择
		 */
		int interactive(void)
		{
				printf("1. 打印显示所有信息\n");
				printf("2. 按照学号查找，并打印学生信息\n");
				printf("3. 从键盘输入一条学生信息，然后插入链表\n");
				printf("4. 修改学生信息\n");
				printf("5. 保存链表到文件中\n");
				printf("6. 删除某个学生的信息\n");
				printf("7. 清空链表\n");
				printf("8. 按学号进行从小到大排序\n");
				printf("9. 退出程序，退出前先销毁链表\n");

				int select = 0;
				scanf("%d", &select);

				return select; //返回选择
		}

		int main(void)
		{
				DNode *hp = NULL;

				/* 创建空链表 */
				createList(&hp);

				/* 读取文件数据 */
				ReadDataFromFileToList(hp, FILE_PATH);

				/* 操作链表 */
				while(1)
				{
						//interactive为交互函数
						switch(interactive())
						{
								case SHOW:  //显示所有链表信息
										ShowList(hp);
										break;
								case FIND:  //按照学号查找
										FindStuByNumber(hp);
										break;
								case READ_KEYBORD:  //从键盘输入信息
										ReadDataFromKeybordToList(hp);
										break;
								case ALTER: //修改信息
										AlterNode(hp);
										break;
								case SAVE: //保存到文件中
										SaveListToFile(hp, FILE_PATH);
										break;
								case DELETE: //删除某个学生
										DeleteStu(hp);
										break;
								case EMPTY: //清空链表
										EmptyList(hp);
										break;
								case SORT: //清空链表
										BubbleSort(hp);
										break;
								case EXIT: //销毁链表
										DestroyList(hp);
										printf("退出程序\n");
										return 0;
										break;
								default: printf("无此选项\n");
						}
				}

				return 0;
		}




8.3 “链表例子程序”的健壮性问题
	我们所写的链表程序，只是为了演示如何实现链表基本功能，并没有考虑程序的各种需要完善的细节，比如

（1）程序输入的健壮性问题
		输入选择时要求输入整形数，但是如果输入的是a、b、c、d等字母的话，程序就出现问题。
		
（2）学号重复的问题
		我们知道学生的学号是不能重复的，所以当你输入学生信息时，应该自动检测是否重复。
	
	像以上这些类似的问题我们都没有解决，毕竟这些不是我们的重点。
	
	
8.4 其它的链表操作
（1）链表的反序
（2）将链表拆分为两个、多个子链表
（3）将两个或多个链表合为一个链表
（4）等等
		
		事实上这些操作只不过是在玩花样而已，事实上你只要将基础的内容掌握了，实现这些都不是问题。
	
	
9. 队列 和 栈		
9.1 队列和栈的本质
	队列和栈的本质为操作受到一定限制的“特殊线性表”。
	
	对于普通的线性表来说，我们可以在链表中的任何位置插入、删除数据，但是队列和栈不行。
	
9.2 队列
	队列只能在一头插入数据，另外一头删除数据，不能在中间插入删除。

	图：
	
9.3 栈 
（1）栈这种特殊线性表的特点
		只能在一头插入和删除。
		图：
	
	
（2）程序“内存结构”中的栈
			内存结构中的“栈”空间之所以称为栈，是因为使用了栈的管理方式，开辟和释放变量空间时只能在一头（栈顶）
		插入、删除。
			
10. Linux内核链表
	本小节我们会介绍Linux内核中链表的实现方式，你会发现与我前面讲的实现方式有所不同。
	
10.1 介绍Linux内核链表的目的
（1）了解内核链表的实现原理

（2）了解之前所讲的offsetof宏和container_of宏在内核链表中的具体应用

（3）我们实现自己的链表时，我们可以直接调用“Linux内核链表”的基本操作，省去了我们自己写基本操作代码。
			帮助我们实现自己的链表，这一个才是我们介绍内核链表的最核心目的。

			
10.2 Linux内核是单链表还是双链表
	由于双链表比单链表用起来更加的方便，因此Linux内核链表为双链表。
	
	
10.3 如何独立出“链表的基本操作”
	有两个方法：
	
（1）方法1：将节点中data定义void *
		我们前面使用的就是这个方法。
		
		typedef struct DoubleNode  
		{
			void *data;    //***************
			struct DoubleNode *prev
			struct DoubleNode *next; 
		}DNode;
	
	
（2）方法2：采用内核链表的方式
		也能将基本操作独立出来。

		
10.4 内核链表的实现原理	
10.4.1 回顾普通方式
			typedef struct DoubleNode  
			{
				void *data;    //***************
				struct DoubleNode *prev
				struct DoubleNode *next; 
			}DNode;
			
			节点中的prev和next，放的是struct DoubleNode变量的指针。
			图：普通链表结构
			
			
			链表的每个节点为struct DoubleNode结构体变量。
		
		
10.4.2 内核链表方式
		直接看例子：
		struct list_head 
		{
			struct list_head *prev; 
			struct list_head *next;
		};
		
		typedef struct Student 
		{
			char name[30];
			int  number;
			char gender;
			
			struct list_head list;
		}Stu;
		
		当然，我们也完全可以将name、number、gender封装为一个单独的结构体。
		
		图：内核链表结构
		
			
		在内核链表这种实现方式中，链表中的每个节点为struct list_head结构体变量，并不是struct Student。
		
		遍历链表得到的只是成员list的指针，如果想要访问name、number、gender的话，此时就需要利用contaner_of宏，
		通过成员list的指针，计算得到外部struct Student结构体变量的指针，然后才能访问name、number、gender。
		
		
10.5 内核链表的基本操作	
		同样的，基本操作只与“节点结构体（struct list_head）”有关，与具体的数据无关。
		
		当我们理解了内核链表的原理后，我们完全可以自己来实现这些基本操作函数，不过Linux内核的list.h
	已经帮我们定义出了这些“基本操作代码“，我们没有必要自己去实现，只要在自己的程序中包含list.h，就可以
	调用这些基本操作，在list.h中，这些基本操作以内联函数和宏的形式存在的。
		
		以后我们实现c的链表时，如果你要是觉得自己写“基本操作函数”很麻烦的话，我们完全可以包含list.h，直接
	调用list.h中所给的基本操作，此时我们只需要实现功能函数即可。
		
		
10.6 如何得到list.h
（1）自己到Linux内核中把list.h复制出来
（2）使用我给的list.h
（3）网上下载网友分享list.h

10.7 分析list.h中的基本操作
	我们这里只分析其中一个部分。

	
list.h：
	#ifndef _LINUX_LIST_H
	#define _LINUX_LIST_H  //防止.h重复包含

	/* offsetof宏 和 container_of宏 */
	#define offsetof(TYPE, MEMBER) 	((size_t) &((TYPE *)0)->MEMBER)
	#define container_of(ptr, type, member) 	( { \
					const typeof( ((type *)0)->member ) *__mptr = (ptr); \
					(type *)( (char *)__mptr - offsetof(type,member) ); } )

					
	...
	
	
	/* 与NULL的作用一样 */
	#define LIST_POISON1  ((void *) 0x00100100)   
	#define LIST_POISON2  ((void *) 0x00200200)  
	
	
	//内核链表的节点结构体 ****************
	struct list_head 
	{
		struct list_head *next, *prev;
	};
	
	
	/* 创建头节点，并让头节点自己指向自己
		使用举例：
		LIST_HEAD(head);
		宏替换后的结果为：
		struct list_head head = { &(head), &(head) };  //自动定义头指节点，并让头节点的prev和next指向自己
		prev和next都被初始化为了&head，如此就构建出了双向循环链表
	*/
	#define LIST_HEAD_INIT(name) { &(name), &(name) }
	#define LIST_HEAD(name) struct list_head name = LIST_HEAD_INIT(name)
	
	

	/* 创建头节点，并让头节点自己指向自己，不过与LIST_HEAD有点区别。
		使用举例：
	  struct list_head head; 		 //需要我们自己定义“头节点”
		INIT_LIST_HEAD(&head);     
		宏替换后：
		do { (&head)->next = (&head); (&head)->prev = (&head); } while (0); //让头节点的prev和next指向自己 
	*/
	#define INIT_LIST_HEAD(ptr) do { \   \\****************
					(ptr)->next = (ptr); (ptr)->prev = (ptr); \
	} while (0)

	
	/* 将新节点插入到前后两个节点之间，与我们自己写的Dou_insertNode相同
		new：新节点指针
		prev：前一个节点的指针
		next：后一个节点的指针   
	*/
	static inline void __list_add(struct list_head *new,
																struct list_head *prev,
																struct list_head *next)
	{
					next->prev = new;
					new->next = next;
					new->prev = prev;
					prev->next = new;
	}

	
	/* 将新节点插入到head节点的后面（head代表任何一个节点），与我们自己写的Dou_InsertNodeAfter相同
	*/
	static inline void list_add(struct list_head *new, struct list_head *head)  //****************
	{
				  //new：新节点   head：前节点指针  head->next：后节点指针
					__list_add(new, head, head->next);
	}

	/* 将新节点插入到head节点的前面，与我们自己写的Dou_InsertNodeBefore相同
	*/
	static inline void list_add_tail(struct list_head *new, struct list_head *head) //***************
	{           
					//new：新节点   head->prev：前节点指针  head：后节点指针
					__list_add(new, head->prev, head);
	}

	
	/* 通用删除函数，删除前后两个节点之间的节点，与我们自己的Dou_Delete相同
			prev：被删除节点的前一个节点的指针
			next：被删除节点的后一个节点的指针
	*/
	static inline void __list_del(struct list_head * prev, struct list_head * next)
	{
					next->prev = prev;
					prev->next = next;
	}
	
	/* 删除entry所指向的节点，并将节点的prev和next赋值为NULL */
	static inline void list_del(struct list_head *entry)  //*****************
	{
					__list_del(entry->prev, entry->next);
					entry->next = LIST_POISON1;  //LIST_POISON1等价于NULL
					entry->prev = LIST_POISON2;  //LIST_POISON2等价于NULL
	}
	...
	...
	...
	
	/* 与直接使用container_of是一样的，只是换了一个名字而已 */
	#define list_entry(ptr, type, member) container_of(ptr, type, member)  //********************

	...
	...
	...
	/* 遍历链表用，与while循环的功效是一样的
		 pos = (head)->next
		 while(1)
		 {
				if(pos == (head))  break;
				pos = pos->next;
		 }
	*/
	#define __list_for_each(pos, head) \   //******************
					for (pos = (head)->next; pos != (head); pos = pos->next)

	...
	...
	...
		
		
	#endif

	
		有关list.h中的内容，我们先只理解以上这些。

10.7 使用list.h中现成的“内核链表的基本操作”，来实现一个学生双向循环链表

10.7.2 如何使用list.h
	将list.h放到自己的c工程中，然后在.c中包含list.h，即可使用里面的基本操作。
	
	
10.7.3 简单的使用案例

（1）需要用到list.h中的如下内容

		1）节点结构体
			struct list_head：
			{
				struct list_head *next, *prev;
			};

		2）基本操作
			（a）INIT_LIST_HEAD：	让头节点的next和prev指向头节点自己
			（b）list_add：				将新节点插入到某节点的后面
			（c）list_add_tail：	将新节点插入到某节点的前面
			（d）__list_for_each：遍历链表的宏
			（e）list_entry：			使用成员list的指针，计算得到包含list成员的结构体变量指针
			（f）list_del：				删除某个节点
					
					
（2）定义学生结构体
		typedef struct Student
		{
				char name[40];
				int  number;
				char gender;
				
				struct list_head list;  
		}Stu;
		

（3）完整代码
		0）工程中文件
			（a）内核链表的基本操作：list.h
					我们需要将list.h复制到工程中。
					
			（b）功能函数：dList.h、dList.c
			（c）main函数：main.c
		
		
		
		1）list.h
		
		2）dList.h
			#ifndef H_SLIST_H
			#define H_SLIST_H
			#include "list.h"

			#define print_error(str) \
			do{\
							fprintf(stderr, "File %s, Line %d, Function %s error\n", __FILE__, __LINE__, str);\
							perror("error Reason");\
							exit(-1);\
			}while(0);


			/* 学生结构体(存放数据的结构体) */
			typedef struct Student
			{
					char name[40];
					int  number;
					char gender;
					
					struct list_head list;
			}Stu;

			extern void createList(struct list_head **hpp);
			extern void ReadDataFromFileToList(struct list_head *hp, const char *fileName);
			extern void ShowList(const struct list_head *hp);
			extern struct list_head *FindStuByNumber(struct list_head *hp);
			extern void ReadDataFromKeybordToList(struct list_head *hp);
			extern void AlterNode(struct list_head *hp);
			extern void DeleteStu(struct list_head *hp);

			#endif

			
		3）dList.c
			#include <stdio.h>
			#include "dList.h"

			/* 功能：创建一个空链表
			 * 参数：
			 *     hpp：头指针变量的指针，注意类型为struct list_head **
			 */
			void createList(struct list_head **hpp)
			{
					/* 开辟一个空的头节点 */
					*hpp = (struct list_head *)malloc(sizeof(struct list_head));
					if(NULL == *hpp) print_error("malloc");

					//让头节点的prev和next指向头节点自己
					INIT_LIST_HEAD(*hpp); //***************
			}

			/* 功能：读取文件中的学生信息，然后保存到链表中
			 * 参数：
			 *      hp：头指针变量
			 *      fileName：文件路径名
			 */
			void ReadDataFromFileToList(struct list_head *hp, const char *fileName)
			{
					FILE *fp = fopen(fileName, "r+");
					if(NULL == fp) print_error("fopen");

					while(1)
					{
							/* 开辟大结构体空间 */
							Stu *stup = (Stu *)malloc(sizeof(Stu));
							if(NULL == stup) print_error("malloc");

							//向大结构空间存入学生信息
							fscanf(fp, "%s %d %c", stup->name, &stup->number, &stup->gender);

							if(feof(fp) != 0) break;

							/* 调用内核链表的插入函数，将list成员插入链表头部，也就是头节点的后面。
							 * &stup->list：成员list的指针
							 * hp：头节点的指针
							 */
							list_add(&stup->list, hp); //***************
					}

					fclose(fp);
			}


			/* 功能：遍历每一个节点，将list指针换算为外部结构体的指针，然后访问里面的数据并打印显示
			 * 参数：
			 *   hp：头指针
			 */
			void ShowList(const struct list_head *hp)
			{
					struct list_head *p = NULL;
					Stu *stup = NULL;

					if(hp->next == hp) printf("链表为空\n");
					else
					{
							/* 遍历链表，打印学生信息，将__list_for_each(p, hp->next)进行宏替换后，结果为
							 * for (p = (hp)->next; p != (hp); p = p->next)
							*/
							__list_for_each(p, hp) //******************
							{
									/* 遍历链表得到了list指针后，换算得到所在大结构体的指针 */
									stup = list_entry(p, Stu, list); //*******************

									//通过大结构指针访问数据成员，然后打印出信息
									printf("%s %d %c\n", stup->name, stup->number, stup->gender);
							}
					}
			}

			/* 功能：遍历链表，通过学号查找学生信息
			 * 参数：
			 *   hp：头指针
			 *   number：要查找的学号
			 * 返回值：返回找到节点的指针（list的指针）
			 */
			struct list_head *FindStuByNumber(struct list_head *hp)
			{
					int number = 0;
					struct list_head *p = hp->next;
					Stu *stup = NULL;

					if(hp->next == hp) printf("链表为空\n");
					else
					{
							printf("输入学号\n");
							scanf("%d", &number);

							/* 遍历链表，找到每个节点，通过比对学号找到某学生信息 */
							__list_for_each(p, hp) //***************
							{
									//获取大结构体变量的指针
									stup = list_entry(p, Stu, list); //**************
									if(stup->number == number)
									{
											printf("%s %d %c\n", stup->name, stup->number, stup->gender);//打印节点中的学生信息
											break;
									}
							}
					}

					return p;  //返回被找到节点的指针
			}

			/* 功能：从键盘输入一条学生数据然后插入到链表中
			 * 参数：
			 *      hp：头指针
			 */
			void ReadDataFromKeybordToList(struct list_head *hp)
			{
					int select = 0;
					Stu *stup = NULL;
					struct list_head *temp = NULL;

					/* 开辟大结构体空间 */
					stup = (Stu *)malloc(sizeof(Stu));
					if(NULL == stup) print_error("malloc");

					/* 输入学生信息 */
					printf("请输入学生信息，输入格式为：名字 学号 性别（M/F）\n");
					scanf("%s %d %c", stup->name, &stup->number, &stup->gender);

					printf("1. 插入链表头部\n");
					printf("2. 插入链尾部\n");
					printf("3. 插入指定位置\n");
					scanf("%d", &select);
					switch(select)
					{
							case 1:
									list_add(&stup->list, hp);      //插入到链表头部，也就是头节点的后面 ***************
									break;
							case 2:
									list_add_tail(&stup->list, hp); //插入到链表头尾部，也就是头节点的前面 ***************
									break;
							case 3:
									ShowList(hp);                   //显示整个链表，方便寻找插入位置
									temp = FindStuByNumber(hp);     //查找要插入的位置
									printf("1. 插入到前面\n");
									printf("2. 插入到后面\n");
									scanf("%d", &select);
									if(select == 1)      list_add_tail(&stup->list, temp);  //插到指定节点的前面 *************
									else if(select == 2) list_add(&stup->list, temp);       //插到指定节点的后面 *************
									break;
							default: printf("无此选项\n");
					}
			}

			/* 功能：通过学号找到学生节点，然后修改学生数据
			 * 参数：
			 *       hp：头节点指针
			 */
			void AlterNode(struct list_head *hp)
			{
					struct list_head *temp = NULL;
					Stu *stup = NULL;

					/* 调用FindStuByNumber函数，按照学号查找，找到后返回节点指针 */
					temp = FindStuByNumber(hp);

					if(temp == hp) printf("没有找到\n");
					else
					{
							/* 换算得到大结构体的指针 */
							stup = list_entry(temp, Stu, list); //******************

							printf("输入新信息，格式：名字 学号 性别\n");
							scanf("%s %d %c", stup->name, &stup->number, &stup->gender);
					}
			}

			/* 功能：删除某个学生信息
			 * 参数：
			 *    hp：头指针
			 */
			void DeleteStu(struct list_head *hp)
			{
					struct list_head *p = FindStuByNumber(hp); //通过学号找到节点

					//删除节点
					list_del(p);   //*******************
			}

	4）main.c
		#include <stdio.h>
		#include "dList.h"

		//文件路径名
		#define FILE_PATH "C:\\Users\\Administrator\\Desktop\\StuFile.txt"

		#define SHOW                1
		#define FIND                2
		#define READ_KEYBORD        3
		#define ALTER               4
		#define DELETE              5


		/* 功能：交互函数
		 * 参数：无
		 * 返回值：选择
		 */
		int interactive(void)
		{
				printf("1. 打印显示所有信息\n");
				printf("2. 按照学号查找，并打印学生信息\n");
				printf("3. 从键盘输入一条学生信息，然后插入链表\n");
				printf("4. 修改学生信息\n");
				printf("5. 删除某个学生的信息\n");

				int select = 0;
				scanf("%d", &select);

				return select; //返回选择
		}

		int main(void)
		{
				//头节点指针，也即整个链表的入口
				struct list_head *hp = NULL;

				/* 创建空链表 */
				createList(&hp);

				/* 读取文件数据，保存到链表中 */
				ReadDataFromFileToList(hp, FILE_PATH);

				/* 操作链表 */
				while(1)
				{
						//interactive为交互函数
						switch(interactive())
						{
								case SHOW:  //显示所有链表信息
										ShowList(hp);
										break;
								case FIND:  //按照学号查找
										FindStuByNumber(hp);
										break;
								case READ_KEYBORD:  //从键盘输入信息
										ReadDataFromKeybordToList(hp);
										break;
								case ALTER: //修改信息
										AlterNode(hp);
										break;
								case DELETE: //删除某个学生
										DeleteStu(hp);
										break;
								default: printf("无此选项\n");
						}
				}

				return 0;
		}

		
	