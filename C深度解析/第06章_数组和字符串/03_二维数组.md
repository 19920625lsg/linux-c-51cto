# 3. 二维数组

## 3.1 为什么需要二维数

在实际开发中需要使用二维数组的情况不少，也不需要举什么例子。
		
## 3.2 二维数组的定义形式

```c
int buf[m][n];
```

比如：int buf[3][4]

 ```c
  buf[0][0] buf[0][1] buf[0][2] buf[0][3]   // 第0个小一维数组 

  buf[1][0] buf[1][1] buf[1][2] buf[1][3]   // 第1个小一维数组

  buf[2][0] buf[2][1] buf[2][2] buf[2][3]   // 第2个小一维数组
 ```
  
二维数组由三个小一维数组来组成的，每个小一维数组4个元素  
	
## 3.2 二维数组的内存结构

比如以int buf[3][4]为例，“二维数组”的存储空间是一片连续的空间，只是这片空间被划分为了三个小的一维数组，每个一维数组又有4个元素  
		
## 3.3 向二维数组的给值

### 3.3.0 不初始化

如
```c
int a[2][2]; //没有初始化
```
在未初始化时，每个元素内容为多少，视数组所在内存位置而定。
	
### 3.3.1 初始化

#### （1）给定空间的初始化
					
+ 1）全部初始化为0
  ```c
  int a[2][2] = {};
  ```
  等价于
  ```c
  int a[2][2] = {0}; // 全部初始化为0
  ```

+ 2）完全初始化
  如
  ```c
  int a[2][2] = {0, 1, 2, 3};
  ```
  更规范的写法应该为
  ```c
  int a[2][2] = {{0, 1}, {2, 3}};
  ```

  0、1用于初始化0一个小一维数组的两个元素，2、3用于初始化第1个小一维数组的两个元素。


+ 3）部分初始化
  如
  ```c
  int a[2][2] = {0, 1, 2};
  ```
  或则
  ```c
  int a[2][2] = {{0, 1}, {2}};
  ```
  没被初始化的其它元素的值为0  

  ```c
  int a[2][2] = {,,,,,, 1,, 2,, 3,,} // 写法是不对的。
  ```

+ 4）个别初始化
   如
   ```c
   int a[2][2] = {[1][0]=10, [0][1]=9, [1][1]=3};
   ```
   未初始化的其它元素默认为0  

#### （2）不给定空间的初始化

```c
int a[][2]= {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
```

实际上我们任然是给定了空间的。行 = 元素个数/列，如果不能被整除的话，那就补增元素，直到能被整除为止，补增元素的值默认为0  

比如例子中0~10只有11个数，11不能整数2，增补为12后就可以整除2了，此时总共12个元素，行位6，列2

```c
int a[][2]= {{0, 1, 2, 3, 4, 5}, {6, 7, 8, 9, 10}};
```

+ `提问`：`int a[2][]= {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}`写法是否可以?  
  答： 编译器并不支持这种写法。:cn: 只能省略行，不能省略列 :cn:

+ 提问：`int a[][] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}`是否正确？  
  答：显然不行，因为不知道如何划定二维数组的“行、列”，编译时是无法编译通过的。

		
### 3.3.2 赋值

与一维数组一样，不能够整体赋值，只能单个元素赋值，或者使用memcpy来实现赋值。
		
#### （1）单个元素赋值

```c
#include <stdio.h>

int a[3][3];

int main(void)
{       
  int i = 0, j = 0;

  for(i=0; i<3; i++)
  {
    for(j=0; j<3; j++)
    {
      a[i][j] = xxxx;
      printf("^ %d\n", a[i][j]);
    }	
  }

  return 0;   
}
```
		
#### （2）memcpy函数

```c
int buf1[2][2] = {{0, 1}, {2, 3}};
int buf2[2][2];	

memcpy((void *)buf2, (void *)buf1, sizeof(buf1));
```
		
	
## 3.4 一维数组与二维数组的关系

以int a[3][4]为例：

二维维数其实还是一个一维数组，为什么这么说？我们可以从两个角度来看这个问题： 

+ （1）第一个角度
  二维数组就一个只有三个元素的“一维数组”，只是每个元素又是一个小的“一维数组”。图：

+ （2）第二个角度
  忽略每个小的一维数组，我们完全可以将整个二维素组看成是一个大号的有12个元素一维数组。图：
  
## 3.5 二维数组的“数组名”的相关含义
	
以int buf[3][4];为例：  
buf的含义:  

### 3.5.1 数组的名字，代表整个数组空间，sizeof(buf)，此时buf就是这个含义  
	
此时buf代表的这个二维数组就是一个大号的变量，sizeof(buf)所得到的就是这个大号变量的空间大小  

### 3.5.2 代表第0个元素的指针

由于二维数组的第0个元素是一个“一维数组”，所以**buf就是`第0个一维数组`的“数组指针”**，也就“第0个一维数组”的“第一个字节的地址”，等价于`&buf[0]`,图：
  
+ `buf`的指针类型    
  每个“小一维数组”为4个元素的int数组，所以buf的数组指针类型为`int (*)[4]`  

+ `buf+1`  
  由于buf为第0个一维数组的数组指针，而`buf+1`加的是一个“小一维数组空间”的大小，小一维数组为4个元素，`buf+1`为`buf+1*4*sizeof(int)`，得到的就是第1个一维数组的“数组指针”。 图：

+ `buf+i`    
   :cn: 通过`第0个一维数组的数组指针+i`，可以跳转到任何一个小一维数组的第一个字节处 :cn:  
   :cn: 然后再将“数组指针”转为第0个元素的指针后，就可以访问“小一维数组”中的每一个元数了 :cn:  
		
### 3.5.3 &buf

根据：&第0个元素的指针  ————————> 元素所在数组的数组指针
		
buf为二维数组第0个元素的指针，所以:cn:&buf为整个二维数组的数组指针:cn:。图：  
				
二维数组的数组指针的指针类型为`int (*)[3][4]`  
		
### 3.5.4 `*buf`

#### （1）`*buf`的含义

buf为二维数组第0个元素的指针，也就是第0个“一维数组”的数组指针，根据  
  ```c
  *数组指针 ————————> 数组第一个元素的指针  
  ```
所以`*buf`为“第0个一维数组”的第0个元素的指针 ,图：  
		
#### （2）`*buf`的指针类型

小一维数组的每个元素为int的普通变量，那么`*buf`的指针类型就为`int *`  
		
`*buf` 等价于`*(buf+0)`  
		
#### （3）`*(buf+1)`

`buf+1`为第1个一维数组的指针数组，`*(buf+1)`为第1个一维数组的第0个元素的指针，指针类型为int *。图：  
		
#### （4）`**buf`

`**buf` ———> `*(*(buf+0)+0)` ———> `*(*(第0个一维数组的数组指针)+0)`————> `*(第0个一维数组的第0个元素的指针 + 0)` ——> 第0个一维数组的第0个元素的空间  

`**buf` 其实就是`buf[0][0]`  

按照[]与"指针访问方式"之间的等价关系，也可以得出这个结论  
```c
*(*(buf+0)+0) ————>*(buf[0]+0) ————————>buf[0][0]  
```
`*(*(buf+i)+j)`：第i个数组中第j个元素的空间  

根据我们前面所讲的内容  
```c
*(*(buf+i)+j) ——> *(buf[i]+j) ——> buf[i][j]  
```
这几个写法都是成立的。`(*(buf+i))[j]`的写法也是正确的。
		
		
		
#### （5）二维数组的buf[0]、buf[1]等的含义

  在面试的时候，可能会见到询问二维数组中buf[0]、buf[1]含义的题目，很多人都想记住它们的含义，但是
实际上是记不住的，但是只要掌握了分析方法，我们可以很快搞清楚它的含义，以后分析3维等多维数组时，
也是相同的规则。

例子：
`int buf[3][2];`
  
```c
  buf[0][0]  buf[0][1]
  buf[1][0]  buf[1][1]
  buf[2][0]  buf[2][1]
```

+ 1）buf[0]、buf[1]、buf[2]的含义
  
   + （a）分析思路1
      `buf[0][0]`  `buf[0][1]`  

      为了好理解，我们将buf[0]替换为buf0  
      ```c
      buf0[0]  buf0[1]  //为两个元素的小一维数组
      ```
      buf0为一维数组的第0个元素的指针，此时buf0对应的是第0个一维数组，所以buf0（buf[0]）为第0个一维数组的第0个元素的指针  

      同理，buf[1]为第1个一维数组的第0个元素的指针，buf[2]为第2个一维数组的第0个元素的指针  

      buf[0]、buf[1]、buf[2]的指针类型为`int *`

  +  （b）分析思路2
     ```c
      buf[0][0]  buf[0][1] ————> (*(buf+0))[0]  (*(buf+0))[1]
     ```
     通过前面的课程可知，buf为二维数组第0个一维数组的数组指针，根据  
     ```c
	 *数组指针  ——————————>数组第一个元素指针
	 ```
      `*(buf+0)`自然就是第0个一维数组的第0个元素的指针，所以`buf[0]`为第0个一维数组的第0个元素的指针,图：

      ```c
      buf[1][0]  buf[1][1] ————> (*(buf+1))[0]  (*(buf+1))[1]
      ```

      依据同样的思路，也可以知道`buf[1]`为第1个一维数组的第0个元素的指针，`buf[2]`、`buf[i]`也是类似的  图：

+  2）`&buf[0]`、`&buf[1]`、`&buf[2]`

      buf[0]是二维数组第0个一维数组的第0个元素的指针，根据
      ```c
      &第0个元素的指针  ——————> 数组指针
      ```
      所以`&buf[0]`为第0个一维数组的数组指针，我们前面讲过，`&buf[0]`等价于`buf`  

      同理，`&buf[1]`为第1个一维数组的数组指针，等价于`(buf + 1)`
      同理，`&buf[2]`为第2个一维数组的数组指针，等价于`(buf + 2)`

+  3）`*buf[0]`、`*buf[1]`、`*buf[2]`

   + （a）`*buf[0]`
        buf[0]为第0个一维数组的第0个元素的指针，通过*解引用后，*buf[0]代表的就是第0个一维数组的第0个元素的空间，其实就是buf[0][0]元素的空间。
      换一种思路，也能得到同样结果：
      ```c
      *buf[0] ————> *(buf[0] + 0) ————> buf[0][0]
      ```

   + （b）`*buf[1]`
     ```c
      *buf[1] ————> *(buf[1] + 0) ————> buf[1][0]
     ```
     
   + （c）`*buf[2]`
      ```c
      *buf[2] ————> *(buf[2] + 0) ————> buf[2][0]
      ```
									
## 3.6 二维数组的访问

### 3.6.1 [][]下标方式

```c
int buf[2][3] = {{0, 1, 2}, {3, 4, 5}};

int i=0, j=0; 
for(i=0; i<2; i++)
{
    for(j=0; j<2; j++)
    {
        buf[i][j] = i*j;
    }
}
```
	
### 3.6.2 指针方式

[]访问方式的本质也是通过指针来访问，现在来看一下，如何通过指针方式来访问二维数组的每个元素的。
	
```c
int buf[2][3] = {{0, 1, 2}, {3, 4, 5}};

int i=0, j=0; 

for(i=0; i<2; i++)
{
    for(j=0; j<2; j++)
    {
        *(*(buf+i)+j)= i*j;
    }
}
```

`*(*(buf+i)+j)`是如何访问到第i个一维数组的第j个元素的。

+ 第一步：`buf+i`，得到第i个一维数组的数组指针  
+ 第二步：`*(buf+i)`，进行强制转换，得到第i个一维数组的第0个元素的指针  
+ 第三步：`*(buf+i)+j`， 得到第i个一维数组的第j个元素的指针   
+ 第四步：`*(*(buf+i)+j)`，解引用第j个元素的指针，得到第j个元素的空间  

## 3.7 二维数组的传参

## 3.7.1 例子1：常见传参方式
	
```c
#include <stdio.h>

void fun(int m, int n, int (*p)[3])  //或则int (*p)[n]
{
    int i=0, j=0; 

    for(i=0; i<2; i++)
    {
        for(j=0; j<2; j++)
        {
            printf("%d \n", *(*(p+i)+j));
        }
    }

    printf("\n");
}

int main(void)
{
    int buf[2][3] = {{0, 1, 2}, {3, 4, 5}};

    fun(2, 3, buf); //int (*)[3]

    return 0;
}	
```

`fun(2, 3, buf)`，buf为第0个一维数组的数组指针，每个一维数组有3个元素，因此类型为`int (*)[3]`，所以形参的类型也为`int (*)[3]`  

传参时，如果不知道形参怎么写，那就搞清楚实参类型，然后你就知道形参应该怎么写

3不能省略，也不能写成2/4/5等其它值，否则在访问每个小一维数组时，就不能准确找到每个小一维数组。n会被传参为3，所以`int (*)[3]`的3也可以改为n。


二维数组形参的等价写法：
```c
void fun(int m, int n, int (*p)[]) //*p ----> p[]
{
}
```
等价于  
```c
void fun(int m, int n, int p[][n])
{
}
```
`int p[][n]`也可以写成`int p[m][n]`，第一个[]中有没有数字都无所谓，但是n必须要，刚才已经解释过原因  

### 3.7.3 二维数组传参时，可不可以传递`*buf`、`buf`	
比如：
```c
int buf[2][3];
```
	
#### （1）`*buf`
`*buf`为第0个一维数组第0个元素的指针，此时可以将“整个二维数组”看成一个有6个元素的大的一维数组  
`*buf`为整个大的一维数组的第0个元素的指针，此时完全可以以一维数组的方式来访问二维数组  

```c
#include <stdio.h>

void fun(int m, int n, int *p)
{
    int i=0, j=0; 
    for(i=0; i<2*3; i++)
    {
        printf("%d \n", *(p+i));
    }
    printf("\n");
}

int main(void)
{
    int buf[2][3] = {{0, 1, 2}, {3, 4, 5}};

    fun(2, 3, *buf); //等价于fun((int *)buf)

    return 0;
}
```


#### （2）`&buf`
`&buf`为整个二维数组的数组指针，`&buf`的指针类型为`int (*)[2][3]`，2和3不能省略，后面介绍三维数组时，就知道为什么不能省略了  

```c
#include <stdio.h>

void fun(int m, int n, int (*buf)[m][n]) //m和n不能省略
{
    /* 方式1：以二维数组方式访问 */
    int (*p)[n] = *buf; //等价于int (*p)[n] = (int (*)[n])buf 

    int i=0, j=0, k=0; 
    for(i=0; i<2; i++)
    {
        for(j=0; j<2; j++)
        {
            printf("%d \n", *(*(p+i)+j));
        }
        printf("\n");
    }

    /* 方式2：以三维数组访问
     * 三维数组是由二维数组构成的，将二维数看成是一个只有一个二维数组的三维数组。
    */
    for(i=0; i<1; i++)
    {
        for(j=0; j<m; j++)
        {
            for(k=0; k<n; k++)
            {
                printf("%d \n", *(*(*(buf+i)+j)+k)); //buf[i][j][k]
            }
        }
    }
    printf("\n");
}

int main(void)
{
    int buf[2][3] = {{0, 1, 2}, {3, 4, 5}};

    fun(2, 3, &buf); //等价于fun(2, 3, (int (*)[m][n)buf)

    return 0;
}
```

		
### 3.8.2 以二维数组方式来访问一维数组
进行一维数组传参时，也可以传递“数组指针”，然后以二维数组的方式来访问  
此时我们可以将之前讲的“一维数组”看成是只包含一个小一维数组的二维数组  
图：  

```c
#include <stdio.h>

void fun(int n, int (*buf)[10])
{
    int i=0, j=0;

    /* 访问方式1 */
    int *p = (int *)buf; //等价于int *p = *buf

    for(i=0; i<n; i++)
        printf("%d", *(buf + i)); //buf[i]


    /* 方式2 */
    for(i=0; i<1; i++) //只有要一维数组，所以i只取0值
    {
        for(j=0; j<n; j++) 
        {
            printf("%d", *(*(buf+i)+j)); //buf[i][j]
        }
    }
}

int main(void)
{
    int buf[10] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
    int n = sizeof(buf)/sizeof(int);

    fun(n, &buf);

    printf("\n");

    return 0;
}
```
	
