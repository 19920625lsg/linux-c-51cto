第6章 数组与字符串

1. 为什么讲本章
	两个原因：

（1）数组、字符串确实有值得强调的地方
		可能有些同学觉得"数组、字符串"非常的简单，其实不是这样的，学完本章后，你会觉得确实有很多地方需
	要我们去关注。
	
（2）我们在第四章就讲过，很多同学总觉得指针很复杂，其实指针概念本身并不复杂，而是由于指针与函数、数组、
	字符串相关联后，往往会使得指针的形态变的很复杂，使得指针不好理解，所以大家才会觉得指针很难，只有大家
	把函数、数组、字符串等都搞通透后，你才能将彻底的将指针理解透彻。
		
	当然指针概念与函数，我们在第四章中已经讲的很清楚了，那么本章我们就来详细的讲讲数组与字符串。
		
		
2. 本章知识结构
1.数组概述
	1.1 为什么需要数组
	1.2 数组与普通变量的关系
	1.3 一维数组与多维数组	
	
2、一维数组
	2.1、使用一维数组的案例
	2.2、一维数组的内存结构
	2.3 数组的定义
	2.4 如何对一维数组给值
	2.5 访问一维数组	
	2.6 一维数组的传参
	2.7 指针数组 与 数组指针

3. 二维数组
	3.1 为什么需要二维数组
	3.2 二维数组的定义形式
	3.2 二维数组的内存结构
	3.3 二维数组的 初始化 和 赋值
	3.4 一维数组与二维数组的关系
	3.5 二维数组的buf的各种含义
	3.6 二维数组的访问形式
	3.7 二维数组的传参
	
4. 三维数组
	4.1 定义形式	
	4.2 三维数组的内存结构
	4.3 三维数组的初始化 和 赋值
	4.4 三维数组buf相关的含义		
	4.5. 多维数组总结

5. 使用malloc开辟多维数组
	5.1 开辟普通的多维数组
	5.2 通过“多级指针“来”创建另一种形式的多维数组
	5.3  *在数组中和普通变量中的使用区别

6. 字符串
	5.1 字符数组
	5.2 '\0'、0、NULL、'0'区别
	5.3 字符串数组
	5.4 操作字符串的常见函数
	5.5 字符串数组 和 字符串常量

7. 指针变量、数组、字符串与sizeof
	7.1 sizeof 与 strlen
	7.2 指针变量与sizeof
	7.3 数组与sizeof
	7.3 字符串常量与sizeof

8. main函数的argc、argv 
	8.1 字符串指针数组
	8.2 main函数参数的作用		
	8.3 main函数的返回值
		
		
		
		


课程内容：

1.数组概述
 
1.1 为什么需要数组
 因为我们有批量定义变量空间的需求，但是传统定义变量的方式比较麻烦。
 
 比如想定义100个变量，用于存放100位同学的成绩，我们使用最笨的方法类实现。
	int a1;
	int a2;
	int a3;
	int a4;
	int a5;
	...
	...
	int a100;
	
1.1.1 直接大量定义变量空间的缺点

（1）定义非常的麻烦
		如果真的一个一个的定义的话，这非得把人给累死了。
	
（2）每个变量空间是独立的，所以无法连续的访问每个变量空间
		如果无法连续访问的话，就只能单个的访问每个变量，那么使用起来就非常的不方便。
		a1 = 80.6;
		a2 = 45.6;
		...
		a100 = 60.4;
		
		
1.1.2 使用数组实现的好处
	int buf[100];
	
	等效于：
	int buf[0];
	int buf[1];
	int buf[2];
	...
	
（1）可以批量的定义出100个变量空间，非常方便
（2）由于变量空间是连续挨着的，可以通过buf[i]这种方式，连续的访问每个空间

			通过编号索引数组的每个变量空间，其实就是通过地址去访问紧挨着的每个变量空间，这就好比所有的房间都是
		紧紧挨着的话，所以通过连续编号的门牌号，连续的访问每一个房间，非常的方便。

		
1.2 数组与普通变量的关系

1.2.1 其实数组与普通变量并无本质区别
	我们可以分两个角度来看这个问题。
	
	
（1）站在整体的角度 
			整个数组可以看成是一个超大号的变量，sizeof(buf)得到的是整个数组的空间大小，所以此时就是将buf当做
		是一个大号的变量。

		
（2）咱在每个数组元素的角度，数组就是一堆普通变量的集合

		数组的每个元素就是一个普通的变量，比如buf[0]、buf[1]、buf[2]、buf[10]...，这些单个元素就是普通的
	变量，只不过：
	
		1）这些变量空间一定是紧挨着的
		
		2）变量名比较特殊，为数组名+[编号]就是每个变量的变量名
				之所以这么命名，是因为数组名都是相同的，所以每个数组元素（变量）只能通过[编号]来唯一区别每
			个变量。
			
				既然每个变量的名字是数组名+[编号](比如buf[i])，那么就可以使用buf[i]来访问每个元素
			（变量），学到后面我们知道，这种访问方式最终还是通过地址来访问的。
			
			
			
1.2.3 这里为什么要强调数组与普通变量的关系？

		很多同学初学数组时，往往因为数组形态的古怪而不能很好的理解数组，但是如果你明白了数组的每个元
	素其实就是一个普通的变量的话，其实可以很好的帮助你理解数组这个东西。
		
		
		
		
1.2.4 数组每个元素的指针以及指针类型

（1）前面说过个，每个元素就是一个变量，所以每个元素的指针，就是每个元素（变量）第一个字节的地址
		比如：
		int buf[10];
		
		&buf[0]、&buf[1]、&buf[2]、...，这些就是每一个元素的指针，即每个元素（变量）第一个字节的地址。
		
		
		
（2）每个元素的指针类型
		每个元素的指针类型，为元素（变量）的类型 + *。
		
		1）比如：int buf[10]
		
			（a）buf[1]：int
			（b）&buf[1]：int *
		
		
		2）又比如：int *buf[10];
		
			（a）buf[2]：int *
			（a）&buf[2]：int **
	
	
	
1.5 一维数组与多维数组	
		二维数组以及二维数组以上的就是多维数组，事实上一维数组与多维数组在本质上是一样的，多维数组就是由一
	维素组来构建的。通过后面的学习，大家就能理解我为什么会这么说了。
			
2、一维数组
2.1、使用一维数组的案例	
	比如前面的例子，定义100个变量，用于存放100位同学的成绩，此时就可以使用一维数组来实现。
	在编程中，一维数组使用的也是最多。
	
2.2、一维数组的内存结构
	一维数组的在内存中，为一片连续的内存空间，比如以int buf[5]为例：
	
	图：
	
	
	从图中可以看出，数组的每个元素是紧挨着的，没有任何的间隔。
	
	
2.2.1 数组每个元素（变量）的空间大小
		比如int buf[100]、struct student buf[100]，每个元素（变量）的大小为int、struct student的大小，所
	每个元素的空间大小由int、struct student等类型来决定。
		
		整个数组的字节数 = 元素个数  *  元素的大小(字节数)，比如：
		
		int buf[100];
		
		buf的字节数  =  100  *  4;
							   =  400字节
		
2.3 数组的定义
2.3.1 数组的定义形式
	类型 数组名[元素个数];
	
	int buf[100]; 
	

2.3.2 定义数组的目的
	从相关内存区域划出一片连续的内存空间，从而批量的开辟出连续的变量空间，以便我们快速、方便的访问。
	
（1）全局数组
		空间开辟于静态区.data、.bss中。
		
		1）未初始化：.bss
			未初始化时，所有元素（变量）就默认初始化为0。
		
		2）初始化：.data
		
（2）静态局部数组
		空间开辟于静态区.data、.bss中。
		
		1）未初始化：.bss
			未初始化时，所有元素（变量）就默认初始化为0。
			
		2）初始化：.data
			
（3）自动局部数组
		空间开辟于栈中，如果没有初始化的话，所有元素（变量）中放的就是随机值。
		
		
		
（4）动态数组
		空间开辟于堆中，如果没有对所有元素（变量）进行赋值的话，也是随机值。
		
		
2.3.3 数组名的各种相关含义

	比如：int buf[100]; 

	buf的各种相关含义：
（1）数组名，代表整个数组空间，sizeof(buf)时，buf代表的就是在整个数组
		我们以普通变量为例来对比介绍。
		int a = 10;
		
		a就是变量名，代表整个变量空间，sizeof(a)表示获取a这个变量的空间大小（字节数）。
		
		
		sizeof(buf)中buf为数组名，代表的就是整个数组，此时整个数组就是一个大号的变量，所以sizeof(buf)获取
	的就是整个数组的的空间大小。
		
		buf做为数组名时，代表就是整个数组。
		
		
（2）buf做为指针时，代表数组第0个元素（变量）的第一个字节的地址，等价于&buf[0]
		说白了就是数组第0个元素（变量）的指针，有关这一点，其实我们在第4章就讲过。
	
	
	1）例子1
		
		int main(void)
		{
			int buf[100];
			
			fun(buf); //&buf[0]
			
			return 0;
		}
		
		fun(buf)等价于fun(&buf[0])，进行数组的传参时，此时的buf就是这个含义。
		
		
	2）例子2
		int buf[100];
		int *p = buf; //等价于int *p = &buf[0];
		
		
		疑问：为什么第一个元素的指针有buf这种等价形式？
		答：第一个元素的指针使用非常频繁，&buf[0]写法太过繁琐，所以给出了buf这种简洁的等价形式。
		
		
		
（3）buf是常量，不能改变其值，buf++是错误的
		
		buf++的本质写法是buf = buf + 1，前面课程说过，=的左边必须是可以被写的变量空间，但是buf是只读的常量，
	所以buf++是无法编译通过的。
		
		疑问：buf是个符号，符号可以是一个常量吗？
		答：一个符号为常量并不奇怪，比如int a，&a为a的指针，&a也是一个常量，所以(&a)++也是不行的。
			所以&a整个符号也是一个常量，所以符号是常量，一点也不奇怪。
		
		
		提问：&buf[0]可不可以++？
			buf[0]为变量名，&buf[0]为变量的指针，与&a是一样的，既然&a是常量，那么&buf[0]也是常量，所以&buf[0]++
		也是不行的。
		
		
		
（4）&buf为整个数组的指针，也就是“数组指针”
		
		比如：int (*p)[100] = &buf; //int (*)[100]
		
			存放“数组指针的变量”就是数组指针变量。
		
			整个数组的指针，其实为整个数组的第一个字节的地址，其实就是第一个元素的第一个字节，虽然时同一个
		字节的地址，但是指针含义不同，buf为第一个元素的指针，&buf为整个数组的指针。
		图：
			
			第0个元素指针：用于访问第0个
			整个数组的指针：用于访问整个数组
			
			所以buf和&buf值虽然相等，但是因为数据类型不同，各自的含义作用也是不同的，在c语言中同一个数据，但是
		由于类型不同，而导致各自有不同的含义和用途，整个是非常常见。
			
			有关“数组指针”，我们后面还会详细讲解。
			
			当然&buf也是常量，所以(&buf)++也是错误的。

		
		
（5）一维数组里面的buf与&buf的异同
		int buf[10];

		1）相同点：值相等
				buf与&buf值相等，因为是同一个字节的地址。
				图：
			
				验证：printf("buf=%p, &buf=%p\n", buf, &buf)
				值是一样的。
				
				
		2）不同点：指针类型不同
			buf：第0个元素的指针，类型int *
			
			&buf：为整个数组的指针，类型为int (*)[10]
			
			
			这两者类型不同，导致各自的共用不同。
			
			验证：printf("buf+1=%p, &buf+1=%p\n", buf+1, &buf+1)
			由于各自的类型不同，所以各自加1时，所得到的地址是不一样的，
			
			
			buf+1加的是一个元素空间的大小。
			图：
				

			
			&buf+1加的是整个数组空间的大小。
			整个数组看成一个大变量，数组指针就是数组这个大变量的指针，所以数组指针+1，加的就是一个数组空间的
			大小。
			
			图：
			
			
			由于指针类型不同，编译器在识别buf+1和&buf+1时，识别的结果是不同的：
			buf+1：被识别为buf + 1*sizeof(int)
			&buf+1：被识别为&buf + 1*sizeof(buf) 
			
			
				
2.4 如何向一维数组给值
	两种方式，
	第一种：通过“初始化”给值
	第二种：通过“赋值”给值

	
2.4.1、初始化
	定义数组的同时给值的就是初始化。
	
（1）不初始化
		int buf[10];
		
		如果是全局数组的话，buf就在.bss中，那么每个元素的值就默认为0。
		如果在栈中，那就是随机值。
			
			
		不初始化时，必须指定元素个数，否则就不知道应该开辟多大的空间了。
				
	
（2）指定空间大小的初始化				
	（a）全部初始化为0	
			int buf[10] = {}; 
			
			//或者
			int buf[10] = {0}; //这个是部分初始化，但是还是实现将全部初始化为0
			
			全部元素初始化为0。
			
			不过，如果数组是全局变量的话，就算不初始化也是0，所以全局数组如果想被初始化为0的话，可以不做初始化，
			默认就是0，当然正规写法，还是明写出初始化为0好一些，这样有利于代码阅读。
	
	（b）完全初始化
	
			int a[10] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
			
			对每一个元素初始化为对应值。
			
			
	（c）部分初始化
			int buf[10] = {0, 1, 2, 3, 4, 5};
			其余元素（6~9）默认为0。
			
			打印验证：
			int i = 0;
			for(i=0; i<10; i++)
			{
				printf("%d\n", buf[i]);
			}
						
			疑问：int buf[10] = {,,,,,,1,,2,,3}，这种写法可不可以？
			答：这种写法是错误的，如果想进行个别元素的初始化的话，不应该是这种写法。
			
			
			其实前面的int buf[10] = {0}; 是部分初始化，第0个元素给了具体的初始化值0，其他默认为0，所以就全部被为0.
			int buf[10] = {1}; //第0个元素初始化为1，其他的全为0
			
			
	（d）个别初始化
			int buf[10] = {[4]=10, [7]=9, [5]=3};
			
			未被初始化的元素，会被默认初始化为0，可以打印验证。
			
			疑问：个别初始化时，[7]在[5]的前面可以吗？
			答：进行个别初始化时，元素编号的先后无影响。

		
（3）不指定空间大小的初始化
		int a[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
		
		
		表面上没有指定空间大小，但是实际上任然有指定空间大小。
		此时空间大小由初始化的元素个数来决定的。
		
		疑问：int buf[];可不可以？
		答：前面说过，不初始化的话，必须指定元素大小，否则无法编译通过。

		
2.4.1、赋值
	赋值就是，先定义，后给值。


（1）错误写法：数组不允许整体赋值，
		

		1）错误例子1
			int a[10];
			a = {0, 1, 2, 3, 4, 5, 6};	//错误的
			
			只能个别赋值：
			a[0] = 0;
			....
			
		2）错误例子2
			int a[10];
			int b[10] = {0, 1, 2, 3, 4, 5, 6};
			a = b;									//错误
			
			只能个别赋值：
			a[0] = b[0];
			....
			
			
（2）正确写法：数组只能单个元素的进行赋值，如：
		int a[10];
		
		int main(void) 
		{
			int i, j;
			
			for(i=0; i<10; i++)
			{
				scanf("%d", &a[i]);	
				//或者
				//a[i] = xxx;
			}
		}

		
（3）如何将“某个数组的值”复制给“另一个数组”
		int buf1[6] = {0, 1, 2, 3, 4, 5}; 
		int buf2[6];
			
		1）方法1：
			int i = 0;
			for(i=0; i<6; i++)
			{
				buf2[i] = buf1[i];
			}
			
		2）方法2：通过memcpy函数来实现
			
			
			void *memcpy(void *dest, const void *src, size_tn);
			dest：指向目标空间
			src：指向源空间
			size_tn：要复制空间的大小
			
			memcpy((void *)buf2, (void *)buf1, sizeof(buf1));
			
			图：
			
			等价于
			
			memcpy((void *)&buf2[0], (void *)&buf1[0], sizeof(buf1));
			
			将buf1中的sizeof(buf1)个字节的内容复制到buf2数组空间。
			
			
			
		
		
2.5 访问一维数组		

2.5.1、利用下标访问（普通访问方式）
	int a[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
	
	int main(void)
	{
		for(i=0; i<10; i++)
			printf("%d ", a[i]);
			
		printf("\n");
	}

2.5.2 通过指针访问

（1）补充知识点：指针的“加减”运算

		1）指针+/-整形数
				int a = 10;
				
				int *p = &a + 1; 
				
				&a+1：本质为&a + 1*4，加的是int的大小，同理，&a + n，其实为&a + n*4。			
				图：
				
				
				同样的“指针-1”、“指针-n”也是同样的情况。
			
				不过对于本例子来说，&a + 1、&a + n并没有什么意义，因为&a + 1、&a + n会指向非法空间，但是对于数
			组来说确很有意义。
			
		
		2）两个指针相加
			int a = 0;
			int b = 10;
		
			int *p = &a + &b;
			
				纯粹站在加法运算的角度来说，两个指针按道理是可以相加的，但是相加所得的新指针并没有实际意义，因
			为新指针所指向的是一个无法确定情况的空间，说白了这个新指针就是一个“野指针”，所以两个指针相加没有
			实际意义。
			
				由于两个指针相加没有意义，因此编译器不允许指针相加，否则会编译报错，比如下面这个例子就无法编
			译通过。
				int a;
				int b;
				int *p = &a + &b;
				
		3）两个指针相减
			与两个“指针相加”刚好相反，两个指针相减是有意义的，比如下面的例子是可以编译通过。
				int a;
				int b;
				int va = (int)(&a - &b); //左边类型为int，右边类型为int *，所以需要强制转换 
				
				
				
				通过这计算，就可以知道两个指针间有多少个int空间，4*(&a - &b)为相差的字节数。
				图：
				
				当然对于上面这个例子来说，并没有什么太大的意义，但是对于数组来说就很有意义。
				int buf[70];
				
				&buf[32] - &buf[2]：buf[32]和buf[2]之间所间隔的元素个数。				
				
				
					
（2）直接使用“指针”访问
		int buf[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
		
		int main(void)
		{
			for(i=0; i<10; i++)
				printf("%d", *(buf+i)); //等价于*(&buf[0] + i)
			
			printf("\n");
		}
		
		1）数组元素指针的指针类型
		
			每个元素（变量）的第一个字节的地址，就是每个元素的指针。
			例子中，每个元素（变量）类型为int，所以每个元素的指针类型为int *。
				
		2）buf+i
				buf为第0个元素的指针，因此buf+i就是buf+4*i，i的取值为0~10，所得的就是每一个元素的
			指针(每个元素第一个字节的地址)。
				
				既然得到了每个元素的指针，那么就可以对指针通过*解引用来访问，那么*(buf+i)所代表的就是每个
			元素的空间。
				图：
				
				
				buf[i]相比*(buf+i)来说，buf[i]的写法更加的人性化，对于初学c数组的同学来说buf[i]也更好理解，
			这也是为什么C语言要给出buf[i]这种人性化写法的原因了。
				
				由于*(buf+i)是buf[i]的本质形式，所以buf[i]被编译后，最终会变为*(buf+i)这种指针的访问形式。
				
		
		2）buf++可以吗
			在前面就说过，buf为第一个元素的指针（等价于&buf[0]），是一个常量，因此buf++是无法编译通过的，
			
			每个元素的指针也是一个常量，每个元素(&buf[i])++也是不允许的。
			
			buf+i并不会修改buf这个常量本身，所以buf+i是没问题的，同理&buf[3]+i也是没问题的。
			
			
		3）访问数组时，是不是只能从第0个元素开始
				当然不是，可以从任何一个元素开始。
		
					int buf[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
					
					
			（a）访问3~9元素
					for(i=0; i<7; i++)
						printf("%d ", *(&buf[3]+i)); //*((buf+3)+i)
						
						
					等价于
					for(i=0; i<7; i++)
						printf("%d ", buf[3+i]); 		
			
			
					for(i=3; i<9; i++)
						printf("%d ", buf[i]); 
						
					
			（b）倒着访问所有元素
					for(i=0; i<10; i++)
						printf("%d", *(&buf[9]-i));  //*((buf+9)-i)
					
					等价于
					for(i=9; i>=0; i--)
						printf("%d", buf[i]);				 		
						
					你可以只访问数组中的某些元素，可以顺序访问，也可以倒序访问，根据你自己的需求而定。
					
					所有的元素空间都是挨着的，所以不管从哪一个元素开始，都可以得到每个元素的指针，然后依次访问
				每个元素，不过平时用的最多的都是从第0元素顺序访问的情况。
				
				
2.5.3、通过指针变量来间接来访问
	
	int buf[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
	
	int main(void)
	{	
		int *p = buf;  //&buf[0], int *
		
		for(i=0; i<10; i++)
			printf("%d", *(p + i));  //等价于p[i]
		
		Printf("\n");
	}
	
	第一个元素的指针类型为int *，所以p自然也就是int *的。
	int *p = buf等价于int *p = &buf[0]，将第一个元素的指针放到指针变量p后，再通过p去访问。
	
	疑问1：*(p++)可不可以？
	答：可以，因为等价于p = p + 1，p是一个变量，所以是可以的。
		*(p + i) 与 *(p++)的区别是，*(p + i)中p的值不会变，但是*(p++)中p的值会改变，随着++的进行，p中放的
	是数组中每个元素(变量)的指针。		
	
	
	疑问2：通过p[i]方式访问每个元素可以吗？
	答：当然可以，因为我们说过，p[i]等价于*(p+i)，不管p是指针变量，还是buf这种指针常量，[]与指针形式
	都是可以相互替换的。
		
		请记住这种替换，后面讲多维数组时，我们就会使用这种替换来分析多维数组。
		
	

2.6 一维数组的传参
2.6.1 只需使用单个元素时
	我们可以只传递数组的单个元素，传参时你可以传递单个元素的值或者指针，根据你的需求来定。

	
2.6.2 需要使用整个数组时
	我们就需要传递整个数组，在第4章就说过，为了效率，传递整个数组时只能传递指针。
	
	传递数组时，只需要告诉被调函数两个东西，被调函数即可访问整个数组。
	
	1）起始元素的指针
	
	2）访问到那个元素结束
		有两种方法来给定结束条件：
			
		· 传递元素个数
				这种是最常见的
		
		· 传递结束元素的指针
	
		知道了要访问的首和尾，自然就能访问数组中的每个元素。
	
	
（1）例子1
		#include <stdio.h>
		
		void fun(int n, int *buf)
		{
      int i = 0;
			
			for(i=0; i<n; i++)
				printf("%d", *(buf + i)); //buf[i]
		}
		
		int main(void)
		{
			int buf[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
			int n = sizeof(buf)/sizeof(int);

			fun(n, buf);

			printf("\n");
		}
		
		或者 
		#include <stdio.h>
		
		void fun(int *buf, int *bufn) 
		{
      int i = 0;

			for(i=0; (buf+i)<=bufn; i++)
				printf("%d", *(buf + i)); //buf[i]
		}

		int main(void)
		{
			int buf[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
			
			fun(buf, &buf[9]);

			printf("\n");
		}
		
			
（2）例子2
		void fun(int n, int *buf)
		{
      int i = 0;
			
			for(i=0; i<n; i++)
				printf("%d", *(buf + i)); //buf[i]
		}
		
		int main(void)
		{
			int buf[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
			int n = sizeof(buf)/sizeof(int);

			fun(3, &buf[3]);  //&buf[3] 等价于 buf+3

			printf("\n");
		}
		
		或者 
		
		void fun(int *buf, int *bufn)
		{
      int i = 0;

			for(i=0; (buf+i)<=bufn; i++)
				printf("%d", *(buf + i)); //buf[i]
		}

		int main(void)
		{
			int buf[] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
			int n = sizeof(buf)/sizeof(int);

			fun(&buf[3], &buf[5]); 

			printf("\n");
		}
		
		
		
（3）数组传参时，形参的等价写法
		1）例子1
			void fun(int n, int *buf)
			{
			}
			
			等价于
			
			void fun(int n, int buf[])
			{
			}
			
			1）int buf[]与int *buf是等价的，buf为一个指针变量
			
			2）int buf[]的[]中放不放数字都无所谓，也就是说int buf[]与int buf[n]是一样的，有没有n，n为多少
				都没有任何影响，因为buf始终都只是一个指针变量，而不是数组，千万不要以为形参buf是一个数组。
				
			
		2）例子2 
			void fun(int *buf, int *bufn) 
			{
			}
			同理，等价于
			void fun(int buf[] int bufn[]) 
			{
			}
			
			
		3）疑问：为什么数组的形参存在这种等价写法
			（1）原因1
						初学的c数组时，很多人不太理解数组与指针的关系，为了能够让数组传参时更加的人性化，所以给出了
					int buf[]的这种更加人性化的写法，让初学者能够更容易学习和使用，初学时不用被烦人指针所苦恼。
				
				
			（2）原因2
						采用int *buf的写法，如果仅看函数原型的话，很难看出实参到底是要传递一个普通变量指针，还是
					数组，但是通过int buf[]写法，明显可以看出是需要传递的是一个数组。
				
					比如，以一个Linux OS API为例，
					int pipe(int filedes[2]);
					
					
					一看形参就知道，需要定义一个2个元素的int数组，然后传递给pipe函数。
					2对filedes并无影响，filedes任然还是一个int *的指针变量，2只是想告诉看到这个函数原型的人，这个数组
					有多少个元素，让这个函数原型有更好的可读性。
					
						int fds[2];
					
						pipe(fds);
					
					
						如果原型为int pipe(int *filedes)的话，我就不知道到底是传递一个int一维数组，还是一个普通变量，
					此时就需要详细阅读函数手册，然后看函数手册是怎么说的。
						
						传递一维数组的话，建议形参采用int buf[]这种写法，这样可以更加具有可读性，但是我们自己应该
					清楚int buf[]其实等价于int *buf。
						
					
					疑问：为什么int pipe(int filedes[2])没有传递元素个数，或者结尾元素的指针？
					答：这个函数要处理的数组元素固定为2个，所以函数早就知道了元素的个数。
			
			
		4）疑问：一般的指针传参时，形参可以写成int p[]形式吗？
			当然可以，比如：
			
			#include <stdio.h>

			int fun(int p[]) //等价于int *p
			{
					*p = 100;
			}

			int main(void)
			{
					int a;

					fun(&a);
					
					printf("%d\n", a);

					return 0;
			}
			
			但是我们不建议这么写，因为这样不利于提高代码的可读性，传递一般的指针时，形参就写成int *p，写成
		int buf[]形式，会让别人误认为是要传递一个“一维数组”。
		
		


		
2.7 指针数组 与 数组指针	
	与“函数指针” 和 “指针函数”是类似的，前两个字是形容词，后面两个字是名词。
	
	· 指针数组
		存放指针的数组，本质为数组，只不过数组的每个元素是用来存放指针的。
		
	· 数组指针
		数组的指针，本质为指针，只不过是数组的指针。
		
		
2.7.1 指针数组
	举例说明：
	
	int *buf[5];

	
	本质是数组，只是每一个元素是用来存放int *指针的。
	
	每个元素（变量）的类型为int *类型，所以每个元素其实就是一个int *的指针变量。
	&buf[0]、&buf[1]...为每个指针变量的地址，显然类型为int **。
	
	
2.7.2 一维数组的“数组指针”
	以int buf[10]为例。 
	
	
（1）buf
		1）数组第0个元素的指针，即第0个元素的第一个字节的地址，等价&buf[0]。
		2）buf的指针类型为int *
		

（2）&buf
		1）一维数组的“数组指针”
				也就是整个一维数组的第一个字节的地址，其实就是第0个元素的第一个字节的地址，但是此时含义不一样，
			此时是整个数组的指针。
				
				图：
				
			
			
		2）&buf的指针类型：int (*)[10]
		
				由于是数组的指针，所以指针类型与数组的样子必然非常相似。
				这一点就好比“函数指针与函数的样子很相似”是一样的。
				
				int fun(void)
				{	
				
				}
				函数指针fun的类型为int (*)(void)。
				
				
		3）如何定义一个“一维数组指针变量”
				在*的后面加上变量名即可。
				
				int (*p)[10] = &buf;  //&buf的类型为int (*)[10]
				
				&buf的类型为int (*)[10]，所以p的类型也为int (*)[10]，如果类型不同的话，就需要进行强制转换。
	
	
				疑问1：int (*)[10]中的10的作用。
				答：10表示，通过“数组指针”访问所指向的空间时，所能访问的元素个数为10个。
				
				
		4）一维数组的“数组指针”有什么意义
				
				在一维数组中，数组指针的意义并不大，但是在多维数组中，一维数组的“数组指针”却非常重要，这是
			构建多维数组的基本组成。
				
				
				
（3）能不能省略数组指针类型中的()
			
			比如int (*p)[10]：
			
			()是不能省略的，不能省略的原因与函数指针类型中的()不能省略的原因是一样的，
			
			如果将()省略后就变为了int *p[10]，[]的结合性高于*，所以p先和[]结合，*则与int结合，
		p先和[]结合，那么p就是一个数组，而且是一个int *指针数组。
			
			
			如果()保留的话，*就会先和p结合，p就是一个数组指针变量。
			
			
			
（4）buf与&buf异同

		1）相同点
				二者值相等。
				
				
		2）不同点：buf与&buf的类型不同
				因为类型不同，所以buf+1和&buf+1的结果是不一样的。
			
			
		3）数组的“第一个元素指针”与“数组指针”之间的运算关系
		
				我们以int buf[10]为例：
		
		
				buf：数组第一个元素的指针
				&buf：数组指针
				
				在“第4章”我们讲过，*和&是逆向运算，所以*&buf等于buf，所以
				
				*数组指针 ———————————————————————————————> 数组第0个元素的指针
				
				 数组指针 <——————————————————————————————— &数组第0个元素的指针
					
				
					在“数组指针”和“第一个元素指针”之间的&和*的转换，其实起到的强制转换的作用，这一点与普通变量
				的&和*作用不同。
					
					int a = 10;
					
					&a是变量的指针。
					*&a解引用，所代表是空间a。
					图：

					&a与*&a是两个完全不同，&a是一个地址，*p是变量空间。
					
					
					数组元素也是一个普通变量，所以数组元素的&和*，也是一样的含义。
					int buf[10];
					
					&buf[0]：是一个地址
					*&buf[0]：变量空间
					
					*buf：代表buf[0]的变量空间，这是在解引用，但是
					&buf：“&第0个元素指针”确实是在强制转换，变为了数组指针
					
					
		
					“*数组指针”和“&第一个元素指针”所使用的*和&，确是做强制转换。

					buf：为int *
					&buf：为int (*)[10]
					
					&buf：等价于(int (*)[10])buf。
					*&buf：等价于(int *)&buf。
					
					buf和&buf都是地址，只是指针类型不同而已，所以对于&buf和*(&buf)显然只是在做强制转换。

		
		
		
		
（5）数组指针的强制转换
		1）例子1
				int buf[10];
				
				int (*p)[8] = (int (*)[8])&buf;
				
				&buf类型为int (*)[10]，而左边变量p的类型为int (*)[8]，所以需要进行强制转换。
				
				强转为int (*)[8]类型时表示，所指向的空间为8个元素，每个元素为int。
				
				p + n所得最终地址为p + n*8*sizeof(int)。 
				图：
				
				验证：
				printf("p = %d\n", p);
				printf("p+1 = %d\n", p+1);
				
				p+1，加的是1*8*sizeof(int)个字节。
				
				
		2）例子2
				int buf[10];
				
				char (*p)[8] = (char (*)[8])&buf;
				
				char (*)[8]类型表示，所指向的空间为8个元素，每个元素的char。
				
				p + n所得最终地址为p + n*8*sizeof(char)，所加的为8个char元素的数组空间。 
				图：
				
				验证：
				printf("p = %d\n", p);
				printf("p+1 = %d\n", p+1);
				
				指着相差1*8*sizeof(char)个字节。
			
				
				疑问：char (*p)[8] = (char (*)[8])&buf; 与 char (*p)[8] = (char (*)[8])buf;结果一样吗？
				答：这两个结果是一样的，因为buf和&buf值相等，都可以强制转换为char (*)[8]类型。
		
		
		3）例子3
				int buf[10];
				
				int *p = (int *)&buf;
				
				&buf为int (*)[10]，p为int *类型，所以要做强制转换，
				
				前面说过，将“数组指针”强制转换为“数组第0个元素指针”时，完全可以通过*来强制转换，所以：
				int *p = *&buf;
				
				
		4）例子4:
				int buf[10];
				
				int (*p)[10] = (int (*)[10])buf;
				
				buf为int *，p为int (*)[10]，需要做强制转换。
				
				前面说过，将“数组第0个元素指针”强制转为“数组指针”，可以通过&来强制转换，所以：
				int (*p)[10] = &buf;
				
				
			大家需要注意：
				如果没有强制转换需求的话，最好不要进行强制转换，因为这会导致访问数组空间时，解释方
			式发生了变化，这会导致解释空间时多访问空间，或者少访问空间。
			
			
（6）能不能将int (*)[8]中的8省略？
			
			不能，因为将8省略后，使用p去访问数组空间时，就不知道数组元素个数，显然就更不知道不知道应该如何解释
		所指向的数组空间。
		
		int (*p)[8]
		p+1：加的是一个数组空间的大小，这个数组9个元素，p+1*8*sizeof(int)
		
		但是
		
		int (*p)[]
		p+1：加一个数组空间的大小时，这个数组多大？p+?
		
		
		事实上由于int (*p)[]写法存在问题，编译器实际上不允许编译通过的。
		
		
			void fun(int (*p)[])
			{
					printf("%p\n", p+1); //这句话时编译不通过的，因为定义形参p时，[]中没有数字

					printf("a = %d\n", a);
			}

			int main(void)
			{
					int buf[10] =  {0,1,2,3,4,5};

					fun(&buf);


					return 0;
			}
			
		3）数组指针的作用
			在一维数组中，其实还不能感受出“数组指针”的作用的，但是“数组指针”对于多维数组来说很重要，后面
		讲多维数组时，我们就可以看出“数组指针”在多维数组中的作用。

		
		
（7）再说说一维数组的传参	
		正常情况下传递的是数组第一个元素的指针，那么可不可以传递“数组指针”呢？当然可以。
		
		1）传递数组指针后，访问数组的方式有两种：
		
			（a）以二维数组的方式来访问
					这个后面再介绍。
				
				
			（b）将“数组指针”强制转换为“元素指针”，然后再访问每一个元素
			
			
		2）例子
			#include <stdio.h>

			void fun(int n, int (*p)[n]) //n只有定义在前面，int (*p)[n]才能使用n
			{
					int *buf = (int *)p; //等价于int *buf = *p;

					int i = 0;

					for(i=0; i<n; i++)
					{
							printf("%d\n", *(buf+i));
					}
			}

			int main(void)
			{
					int buf[10] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};

					fun(10, &buf);

					return 0;
			}
			

				
3. 二维数组
3.1 为什么需要二维数组
		在实际开发中需要使用二维数组的情况不少，也不需要举什么例子。
		

3.2 二维数组的定义形式
	int buf[m][n];

	比如：int buf[3][4]
	
		buf[0][0] buf[0][1] buf[0][2] buf[0][3]   第0个小一维数组 
		
		buf[1][0] buf[1][1] buf[1][2] buf[1][3]   第1个小一维数组
		
		buf[2][0] buf[2][1] buf[2][2] buf[2][3]   第2个小一维数组
	
		二维数组由三个小一维数组来组成的，每个小一维数组4个元素。
	
	
3.2 二维数组的内存结构
		比如以int buf[3][4]为例，“二维数组”的存储空间是一片连续的空间，只是这片空间被划分为了三个小的一
	维数组，每个一维数组又有4个元素。	
		图：
		
	
	
3.3 向二维数组的给值

3.3.0 不初始化
	如int a[2][2]; //没有初始化
	
	在未初始化时，每个元素内容为多少，视数组所在内存位置而定。
	
	
3.3.1 初始化

（1）给定空间的初始化
					
		1）全部初始化为0
			int a[2][2] = {};
			等价于
			int a[2][2] = {0}，全部初始化为0
		
		2）完全初始化
			如int a[2][2] = {0, 1, 2, 3}，更规范的写法应该为int a[2][2] = {{0, 1}, {2, 3}}。
			
			0、1用于初始化0一个小一维数组的两个元素，2、3用于初始化第1个小一维数组的两个元素。
			
			
		3）部分初始化
			如int a[2][2] = {0, 1, 2}; 或则 = {{0, 1}, {2}}，没被初始化的其它元素的值为0。
			
			int a[2][2] = {,,,,,, 1,, 2,, 3,,}写法是不对的。
			
			
		4）个别初始化，如 int a[2][2] = {[1][0]=10, [0][1]=9, [1][1]=3}，未初始化的其它元素默认为0


		
（2）不给定空间的初始化

		int a[][2]= {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
			
			实际上我们任然是给定了空间的。行 = 元素个数/列，如果不能被整除的话，那就补增元素，直到能被整
		除为止，补增元素的值默认为0。
			
			比如例子中0~10只有11个数，11不能整数2，增补为12后就可以整除2了，此时总共12个元素，行位6，列2。
		
			int a[][2]= {{0, 1, 2, 3, 4, 5}, {6, 7, 8, 9, 10}};
		

		提问：int a[2][]= {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}写法是否可以
		编译器并不支持这种写法。
		
		提问：int a[][] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9}是否正确。
		显然不行，因为不知道如何划定二维数组的“行、列”，编译时是无法编译通过的。
		
		
3.3.2 赋值
	与一维数组一样，不能够整体赋值，只能单个元素赋值，或者使用memcpy来实现赋值。
		
（1）单个元素赋值
		#include <stdio.h>
		
		int a[3][3];
		
		int main(void)
		{       
			int i = 0, j = 0;
			
			for(i=0; i<3; i++)
			{
				for(j=0; j<3; j++)
				{
					a[i][j] = xxxx;
					printf("^ %d\n", a[i][j]);
				}	
			}
			
			return 0;   
		}

		
（2）memcpy函数
		int buf1[2][2] = {{0, 1}, {2, 3}};
		int buf2[2][2];	
		
		memcpy((void *)buf2, (void *)buf1, sizeof(buf1));
		
	
3.4 一维数组与二维数组的关系
	
	以int a[3][4]为例：
	
	二维维数其实还是一个一维数组，为什么这么说？我们可以从两个角度来看这个问题：

（1）第一个角度
		二维数组就一个只有三个元素的“一维数组”，只是每个元素又是一个小的“一维数组”。
		图：
		
		
（2）第二个角度
		忽略每个小的一维数组，我们完全可以将整个二维素组看成是一个大号的有12个元素一维数组。
		
		图：
		

		
3.5 二维数组的“数组名”的相关含义
	
	以int buf[3][4];为例：

buf的含义:
3.5.1 数组的名字，代表整个数组空间，sizeof(buf)，此时buf就是这个含义
	
	此时buf代表的这个二维数组就是一个大号的变量，sizeof(buf)所得到的就是这个大号变量的空间大小。

	
3.5.2 代表第0个元素的指针
	由于二维数组的第0个元素是一个“一维数组”，所以buf就是第0个一维数组的“数组指针”，
	也就“第0个一维数组”的“第一个字节的地址”，等价于&buf[0]。
		图：
	
	
	
	buf的指针类型
		每个“小一维数组”为4个元素的int数组，所以buf的数组指针类型为int (*)[4]。
	
	buf+1
		由于buf为第0个一维数组的数组指针，而buf+1加的是一个“小一维数组空间”的大小，小一维数组为4个元素，
	buf+1为buf+1*4*sizeof(int)，得到的就是第1个一维数组的“数组指针”。 
		图：
		
		
	buf+i：通过“第0个一维数组的数组指针”+i，可以跳转到任何一个小一维数组的第一个字节处。
		然后再将“数组指针”转为第0个元素的指针后，就可以访问“小一维数组”中的每一个元数了。
		图：
		
		
	
3.5.3 &buf
	根据：&第0个元素的指针  ————————> 元素所在数组的数组指针
		
		buf为二维数组第0个元素的指针，所以&buf为整个二维数组的数组指针。
		图：
			
			
		二维数组的数组指针的指针类型为int (*)[3][4]。
		
		
		
3.5.4 *buf
（1）*buf的含义
		buf为二维数组第0个元素的指针，也就是第0个“一维数组”的数组指针，根据
			
			*数组指针 ————————> 数组第一个元素的指针
			
		所以*buf为“第0个一维数组”的第0个元素的指针。
		
		图：
		
		
（2）*buf的指针类型
		小一维数组的每个元素为int的普通变量，那么*buf的指针类型就为int *。
		
		*buf 等价于*(buf+0)。
		
（3）*(buf+1)

		buf+1为第1个一维数组的指针数组，
		*(buf+1)为第1个一维数组的第0个元素的指针，指针类型为int *。
			图：
		
		
			
（4）**buf
		**buf ———> *(*(buf+0)+0) ———> 
		
		*(*(第0个一维数组的数组指针)+0)————>
		*(第0个一维数组的第0个元素的指针 + 0) ——> 
		第0个一维数组的第0个元素的空间
		
		**buf 其实就是buf[0][0]。
		
		按照[]与"指针访问方式"之间的等价关系，也可以得出这个结论。
		*(*(buf+0)+0) ————>*(buf[0]+0) ————————>buf[0][0]
		
		
		*(*(buf+i)+j)：第i个数组中第j个元素的空间。
		
		
		根据我们前面所讲的内容，*(*(buf+i)+j) ——> *(buf[i]+j) ——> buf[i][j]，这几个写法都是成立的。
	(*(buf+i))[j]的写法也是正确的。
		
		
		
（5）二维数组的buf[0]、buf[1]等的含义

			在面试的时候，可能会见到询问二维数组中buf[0]、buf[1]含义的题目，很多人都想记住它们的含义，但是
		实际上是记不住的，但是只要掌握了分析方法，我们可以很快搞清楚它的含义，以后分析3维等多维数组时，
		也是相同的规则。
		
			例子：
			int buf[3][2];
				
			buf[0][0]  buf[0][1]
			buf[1][0]  buf[1][1]
			buf[2][0]  buf[2][1]
			
		1）buf[0]、buf[1]、buf[2]的含义
			
			
			（a）分析思路1
					
					buf[0][0]  buf[0][1]
					
					为了好理解，我们将buf[0]替换为buf0。
					buf0[0]  buf0[1]  //为两个元素的小一维数组
					
					buf0为一维数组的第0个元素的指针，此时buf0对应的是第0个一维数组，所以buf0（buf[0]）为第0个一
					维数组的第0个元素的指针。
					
					同理，buf[1]为第1个一维数组的第0个元素的指针，buf[2]为第2个一维数组的第0个元素的指针。
					
					buf[0]、buf[1]、buf[2]的指针类型为int *。
					
					
					
					
			（b）分析思路2
					buf[0][0]  buf[0][1] ————> (*(buf+0))[0]  (*(buf+0))[1]
					
					通过前面的课程可知，buf为二维数组第0个一维数组的数组指针，根据
					
						*数组指针  ——————————>数组第一个元素指针
					
					*(buf+0)自然就是第0个一维数组的第0个元素的指针，所以buf[0]为第0个一维数组的第0个元素的指针。
					图：
					
					buf[1][0]  buf[1][1] ————> (*(buf+1))[0]  (*(buf+1))[1]
					
					依据同样的思路，也可以知道buf[1]为第1个一维数组的第0个元素的指针，buf[2]、buf[i]也是类似的。
					图：
					
					
					
			
			2）&buf[0]、&buf[1]、&buf[2]
			
					buf[0]是二维数组第0个一维数组的第0个元素的指针，根据
						&第0个元素的指针  ——————> 数组指针
										
					所以&buf[0]为第0个一维数组的数组指针，我们前面讲过，&buf[0]等价于buf。
					
					
					同理，&buf[1]为第1个一维数组的数组指针，等价于(buf + 1)
					同理，&buf[2]为第2个一维数组的数组指针，等价于(buf + 2)
					
					
			3）*buf[0]、*buf[1]、*buf[2]
			
			（a）*buf[0]
						buf[0]为第0个一维数组的第0个元素的指针，通过*解引用后，*buf[0]代表的就是第0个一维数组的
					第0个元素的空间，其实就是buf[0][0]元素的空间。
					
					换一种思路，也能得到同样结果：
					*buf[0] ————> *(buf[0] + 0) ————> buf[0][0]
					
					
			（b）*buf[1]
			
					*buf[1] ————> *(buf[1] + 0) ————> buf[1][0]
					
					
			（c）*buf[2]
					*buf[2] ————> *(buf[2] + 0) ————> buf[2][0]
					
		

										
3.6 二维数组的访问

3.6.1 [][]下标方式
	int buf[2][3] = {{0, 1, 2}, {3, 4, 5}};
	
	int i=0, j=0; 
	for(i=0; i<2; i++)
	{
		for(j=0; j<2; j++)
		{
			buf[i][j] = i*j;
		}
	}
	
3.6.2 指针方式
		[]访问方式的本质也是通过指针来访问，现在来看一下，如何通过指针方式来访问二维数组的每个元素的。
	
	int buf[2][3] = {{0, 1, 2}, {3, 4, 5}};
	
	int i=0, j=0; 
	
	for(i=0; i<2; i++)
	{
		for(j=0; j<2; j++)
		{
			*(*(buf+i)+j)= i*j;
		}
	}
	
	*(*(buf+i)+j)是如何访问到第i个一维数组的第j个元素的。
	
	第一步：buf+i，得到第i个一维数组的数组指针
	第二步：*(buf+i)，进行强制转换，得到第i个一维数组的第0个元素的指针
	第三步：*(buf+i)+j， 得到第i个一维数组的第j个元素的指针
	第四步：*(*(buf+i)+j)，解引用第j个元素的指针，得到第j个元素的空间

	
	
3.7 二维数组的传参

3.7.1 例子1：常见传参方式
	#include <stdio.h>
	
	void fun(int m, int n, int (*p)[3])  //或则int (*p)[n]
	{
		int i=0, j=0; 
		
		for(i=0; i<2; i++)
		{
			for(j=0; j<2; j++)
			{
				printf("%d \n", *(*(p+i)+j));
			}
		}
		
		printf("\n");
	}
	
	int main(void)
	{
		int buf[2][3] = {{0, 1, 2}, {3, 4, 5}};
		
		fun(2, 3, buf); //int (*)[3]
		
		return 0;
	}		
		
		fun(2, 3, buf)，buf为第0个一维数组的数组指针，每个一维数组有3个元素，因此类型为int (*)[3]，
	所以形参的类型也为int (*)[3]。
	
	传参时，如果不知道形参怎么写，那就搞清楚实参类型，然后你就知道形参应该怎么写。
		
		3不能省略，也不能写成2/4/5等其它值，否则在访问每个小一维数组时，就不能准确找到每个小一维数组。
	n会被传参为3，所以int (*)[3]的3也可以改为n。
		
	
	二维数组形参的等价写法：
	void fun(int m, int n, int (*p)[]) //*p ----> p[]
	{
	}
	
	
	等价于
	void fun(int m, int n, int p[][n])
	{
	}
	int p[][n]也可以写成int p[m][n]，第一个[]中有没有数字都无所谓，但是n必须要，刚才已经解释过原因。
	
	
	
	
3.7.3 二维数组传参时，可不可以传递*buf、&buf	
	比如：int buf[2][3];		
	
（1）*buf
			*buf为第0个一维数组第0个元素的指针，此时可以将“整个二维数组”看成一个有6个元素的大的一维数组，
		*buf为整个大的一维数组的第0个元素的指针，此时完全可以以一维数组的方式来访问二维数组。
		
		#include <stdio.h>
		
		void fun(int m, int n, int *p)
		{
			int i=0, j=0; 
			for(i=0; i<2*3; i++)
			{
				printf("%d \n", *(p+i));
			}
			printf("\n");
		}
		
		int main(void)
		{
			int buf[2][3] = {{0, 1, 2}, {3, 4, 5}};
			
			fun(2, 3, *buf); //等价于fun((int *)buf)
				
			return 0;
		}
		

（2）&buf
		&buf为整个二维数组的数组指针，&buf的指针类型为int (*)[2][3]，2和3不能省略，后面介绍三维数组时，
	就知道为什么不能省略了。
		#include <stdio.h>
		
		void fun(int m, int n, int (*buf)[m][n]) //m和n不能省略
		{
			/* 方式1：以二维数组方式访问 */
			int (*p)[n] = *buf; //等价于int (*p)[n] = (int (*)[n])buf 
			
			int i=0, j=0, k=0; 
			for(i=0; i<2; i++)
			{
				for(j=0; j<2; j++)
				{
					printf("%d \n", *(*(p+i)+j));
				}
				printf("\n");
			}
				
			/* 方式2：以三维数组访问
       * 三维数组是由二维数组构成的，将二维数看成是一个只有一个二维数组的三维数组。
			*/
			for(i=0; i<1; i++)
			{
				for(j=0; j<m; j++)
				{
					for(k=0; k<n; k++)
					{
						printf("%d \n", *(*(*(buf+i)+j)+k)); //buf[i][j][k]
					}
				}
			}
			printf("\n");
		}
		
		int main(void)
		{
			int buf[2][3] = {{0, 1, 2}, {3, 4, 5}};
			
			fun(2, 3, &buf); //等价于fun(2, 3, (int (*)[m][n)buf)
				
			return 0;
		}
		
		
3.8.2 以二维数组方式来访问一维数组
	进行一维数组传参时，也可以传递“数组指针”，然后以二维数组的方式来访问。
	此时我们可以将之前讲的“一维数组”看成是只包含一个小一维数组的二维数组。
	图：
	
	
	#include <stdio.h>

	void fun(int n, int (*buf)[10])
	{
		int i=0, j=0;
		
		/* 访问方式1 */
		int *p = (int *)buf; //等价于int *p = *buf
		
		for(i=0; i<n; i++)
			printf("%d", *(buf + i)); //buf[i]
		
		
		/* 方式2 */
		for(i=0; i<1; i++) //只有要一维数组，所以i只取0值
		{
			for(j=0; j<n; j++) 
			{
				printf("%d", *(*(buf+i)+j)); //buf[i][j]
			}
		}
	}
	
	int main(void)
	{
		int buf[10] = {0, 1, 2, 3, 4, 5, 6, 7, 8, 9};
		int n = sizeof(buf)/sizeof(int);

		fun(n, &buf);

		printf("\n");
		
		return 0;
	}
	

	
4. 三维数组		
	我们把三维数组搞清楚后，就算是完整的搞清楚了多维数组的构建规则。


4.1 定义形式
	int buf[m][n][z];
	
	int buf[3][2][2];
	

4.2 三维数组的内存结构
	以int buf[3][2][2]为例，也是一片的连续空间。


	第0元素：二维数组
	buf[0][0][0]  buf[0][0][1]     	第0元素：一维数组
	buf[0][1][0]  buf[0][1][1]			第1元素：一维数组
	
	第1元素：二维数组
	buf[1][0][0]  buf[1][0][1]			第0元素：一维数组
	buf[1][1][0]  buf[1][1][1]			第1元素：一维数组
	
	第2元素：二维数组
	buf[2][0][0]  buf[2][0][1]			第0元素：一维数组
	buf[2][1][0]  buf[2][1][1]			第1元素：一维数组

	
（1）将三维看成一维，整个三维数组由3个元素组成，每个元素为一个小二维数组
（2）将小二维看成一维，每个小二维数组由2个元素组成，每个元素为一个小一维数组
（3）每个一维数组由2个int元素组成
	
	图：


	
	

4.3 向三位数组给值				

4.3.1 初始化

（1）给定空间的初始化

		1）不初始化
				如int buf[3][2][2];，在未初始化时，每个元素的内容为多少，视数组在内存中的位置而定。
				
		2）全部初始化为0
			如int buf[3][2][2] = {}，等价于int buf[3][2][2] = {0}，全部初始化为0
		
		
		3）完全初始化
			int buf[3][2][2] = {{{0, 1}, {2, 3}}, {{4, 5}, {6, 7}}, {{8, 9}, {10, 11}}};
			这个写法有点不好理解，我们可以改为如下形式：
			
			int buf[3][2][2] = 
			{
				{{0, 1}, {2, 3}}, 	//第0个二维数组
				{{4, 5}, {6, 7}},		//第1个二维数组		
				{{8, 9}, {10, 11}}	//第2个二维数组
			};
			
			
		4）部分初始化
			部分初始化的时候，三维数组里面的每个二维数组，以及二维数组中每个一维数组，都可以做部分初始化。
			做部分初始化，一定是顺序的，其他没有初始化的就是0。
			
			int buf[3][2][2] = {{{0, 1}}, {{4, 5}, {6}}, {{8, 9}}}; 其余值默认为0。
			
			错误写法：int buf[3][2][2] = {{{0, 1}}, {, {4, 5}, {, 6}}, { ,{8, 9}}};

			
		5）个别初始化
			int a[2][2] = {[0][1][0]=10, [2][0][1]=9, [1][1][1]=20}，未初始化的其它元素默认为0
			
			
（2）不给定空间的初始化
		int buf[][2][2]= {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
		
		没有写的数字 = 元素个数/(2*2)，不能整除的话，那就补增元素，直到能整除为止，补增元素的值默认为0。
		
		例子中，元素增补到12就能整除分，这个三维分为3*2*2。
			
			
		除了buf[][2][2]这种方式外，buf[3][][2]、buf[3][2][]、buf[][][2]等写法都是错误的。
		
		
3.3.2 赋值					
	#include <stdio.h>
		
	int main(void)
	{       
		int buf[3][2][2];
	
		int i=0, j=0, k=0;
		
		for(i=0; i<3; i++)
		{
			for(j=0; j<2; j++)
			{
				for(k=0; k<2; k++)
				{
					buf[i][j][k] = i*j*k;		
				}		
			}	
		}
		
		return 0;   
	}					
				
	当然也能使用memcpy函数来实现两个三维数组之间的复制。
	
	int buf1[3][2][2] = {{{0, 1}, {2, 2}}, {{4, 5}, {6, 7}}, {{8, 9}, {10, 11}}};
	int buf2[3][2][2];
	
	memcpy((void *)buf2, (void *)buf1, sizeof(buf1));
	

	
3.4 三维数组的“数组名”的各个相关含义					
	以int buf[3][2][2]为例。
	
	
3.5.1 buf：数组的别名，指代整个数组空间，sizeof(buf)，buf此时指代就是整个数组空间 

	这是buf指代的数组就是一个大号的变量，得到就是这个变量的空间大小。

	
3.5.2 buf：第0个元素的指针
		三维数组的第0个元素为一个二维数组，所以buf为第0个二维数组的数组指针，等价于&buf[0](buf[0]就是三维
	数组的第0个元素)，也就是第0个小二维数组的第一个字节的地址。
	
	图：
	
	
（2）buf的指针类型
		三维数组的每个元素为一个二维数组，buf的指针类型为int (*)[2][2]。
		
（3）buf+1
		buf为第0个二维数组的数组指针，buf+1加的是一个二维数组空间的大小，buf+1实际为buf+1*2*2*sizeof(int)。
		
		图：
		
		buf+1，就从第0个二维数组第一个字节处，跳到了第1个二维数组的第一个字节处。
		
		
（4）buf+i
		buf+i实际为buf+i*2*2*sizeof(int)，就从第0个二维数组第一个字节处，跳转到第i个二维素组的第一个字节处。
		
		图：
	
	
3.5.3 &buf
	buf：第0个元素指针，也就是第0个二维数组的数组指针
	
	&第0个元素的指针  ————————> 元素所在数组的数组指针
		
	第0个元素所在的数组为整个三维维数组，所以&buf为整个三维数组的数组指针，指着类型为int (*)[3][2][2]。
	图：
			
	buf与&buf值相等，但是类型不同。


3.5.4 *buf
（1）*buf的含义
		buf为三维数组第0个元素的指针，即第0个二维数组的数组指针。
			
		*数组指针 ————————> 该数组第一个元素的指针
		
		所以*buf为二维数组第0元素的指针，由于二维数组的第0个元素为一个一维数组，所以*buf为第0个一维数组
	的数组指针。
		
		图：
		
		
（2）*buf的指针类型
		每个小的一维数组有2个int元素，所以*buf的指针类型为int (*)[2]。
		
		*buf 等价于 *(buf+0)
		
（3）*(buf+1)
			buf+1为第1个二维数组的数组指针，*(buf+1)则为第1个二维数组的第0个一维数组的数组指针，
		既然一维数组的数组指针，指针类型也为int (*)[2]。		
		图：

		*(buf+i)：为第i个二维数组的第0个一维数组的数组指针，指针类型也为int (*)[2]
		
		
（4）**buf、***buf
		1）**buf 
			**buf ———> *(*(buf+0)+0) ———> 
			
			*(第0个二维数组的第0个一位数组的数组指针 + 0) ——> 
			
			第0个二维数组的第0个一维数组的第0个元素的指针，指针为int *。
			
			图：
			
			
		2）***buf 
			***buf ————> *(**buf) ————>
			*(第0个二维数组的第0个一维数组的第0个元素的指针（int *）) ————> 
			第0个二维数组的第0个一维数组的第0个元素的空间
		
		
（5）*(*(*(buf+i)+j)+z)
			
			***buf 等价于 *(*(*(buf+0)+0))：第0个二维数组的第0个一维数组的第0个元素的空间
			
			*(*(*(buf+i)+j)+z)：为第i个二维数组的第j个一维数组的第z个元素的空间
			
			图：
			
			
			*(*(*(buf+i)+j)+z)的等价写法buf[i][j][k]，*(*(buf[i]+j)+k)、*(buf[i][j]+k)等混合写法也是正确的。
			


				
3.5.5 三维数组的buf[0]、buf[1]、buf[0][1]、buf[1][0]等的含义		
	例子：
	int buf[3][2][2];
			
	第0元素：二维数组
	buf[0][0][0]  buf[0][0][1]     	第0元素：一维数组
	buf[0][1][0]  buf[0][1][1]			第1元素：一维数组
	
	第1元素：二维数组
	buf[1][0][0]  buf[0][0][1]			第0元素：一维数组
	buf[1][1][0]  buf[0][1][1]			第1元素：一维数组
	
	第2元素：二维数组
	buf[2][0][0]  buf[0][0][1]			第0元素：一维数组
	buf[2][1][0]  buf[0][1][1]			第1元素：一维数组
		
		
（1）buf[0]、buf[1]、buf[2]的含义
			
	（a）分析思路1
			
			buf[0][1][1]  
			
			将buf[0]替换为buf0。
				buf0[0][1]  //这是二维数组的其中一个元素，buf0为维数组的名字
			
			
			buf0对应的为第0个二维数组，buf0为第0个二维数组的第0个元素的指针，二维数组的第0个元素为一个一维数
		组，所以buf0(buf[0])为第0个二维数组的第0个一维数组的数组指针，类型为int (*)[2]。
			图：
			
			同理：
			buf[1]为第1个二维数组的第0个一维数组的数组指针，类型为int (*)[2]。
			buf[2]为第2个二维数组的第0个一维数组的数组指针，类型为int (*)[2]。
					
			
	（b）分析思路2
			buf[0][1][1] ————> (*(buf+0))[1][1] 
			
			buf为三维数组第0个元素的指针，即第0个二维数组的数组指针。
			
			*数组指针 ————————> 该数组第一个元素的指针
			
			*(buf+0)（buf[0]）为第0个二维数组第0个一维数组的数组指针。
			
			buf[1]、buf[2]也是类似的分析方式。
			
			
（2）buf[0][1]的含义					
		buf[0][1][1]  
		
		1）分析思路1
		
			将buf[0][1]替换为buf01。
				buf01[1]  //为一维数组的元素
				
				buf01对应的是第0个二维数组的第1个一维数组，所以buf01(buf[0][1])为第0个二维数组中的第1个一维数组
			的第0个元素的指针，一维数组的元素为int，所以buf01的指针类型为int *。
			图：
			
			
			同理，同理buf[1][0]，第1个二维数组中的第0个一维数组的第0个元素的指针，类型也为int*。
			图：
		
		
		
		2）分析思路2
				buf[0][1][1]  ——————> (*(*(buf+0)+1))[1]
				
				*(*(buf+0)+1)（buf[0][1]）：根据“数组指针 与 第一个元素指针”的转换规则，显然buf[0][0]为第0个
			二维数组的第1个一维数组的第0个元素的指针
				
				
（3）&buf[0]、&buf[1]、&buf[0][1]、&buf[1][1]等
		按照“数组指针 与 第一个元素指针”的转换原则，自行分析。
		
		
（3）*buf[0]、*buf[1]、*buf[0][1]、*buf[1][1]
		按照“数组指针 与 第一个元素指针”的转换原则，自行分析。				
					
		
		
3.6	三维数组的访问
	int buf[3][2][2];
	
	                等价的本质写法
	buf[0][1][1] ————————————————————>   *(*(*(buf+0)+1)+1)
	
	通过二维数组指针 与 一维数组指针 与 每个小元素指针之间的转换，就可以找到每个小元素的空间。
	
	图：
			
			

3.7	三维数组的传参	
（1）例子 
		#include <stdio.h>
		
		{
				int i=0, j=0, k=0;
				
				for(i=0; i<m; i++)
				{
						for(j=0; j<n; j++)
						{
								for(k=0; k<z; k++)
								{
										printf("%d ", *(*(*(buf+i)+j)+z)); //buf[i][j][k]
								}
						}
				}
		}

		int main(void)
		{
				int buf[3][2][2] = 
				{   
						//第0个二维数组
						{{0, 1}, 
						{2, 3}},
						
						//第1个二维数组		
						{{4, 5}, 
						{6, 7}},
						
						//第2个二维数组			
						{{8, 9}, 
						{10, 11}}	
				};
				
				fun(3, 2, 2, buf); //int (*)[2][2]
				
				return 0;
		}
		
（2）形参的等价写法		
		void fun(int m, int n, int z, int (*buf)[n][z]) //*buf ——————> buf[]
		{
		}
		
		等价于
		
		void fun(int m, int n, int z, int buf[][n][z])
		{
		}
		
		int buf[][n][z]，第一个括号中有没有数字无所谓，但是n和z不能省，否则无法在二维数组之间进行跳转。
		
		
（3）传递其它的指针，行不行
		当然可以

		1）fun(**buf)
			
			**buf，为第0个二维数组的第0个一维数组第0个元素的指针，类型int *
			
			fun(**buf)等价于fun((int *)buf)，此时可以将整个三维数组看成时一个12个元素的一维数组，**buf为
		整个12个元素一维数组的第0个元素的指针，可以以一维数组的方式来访问三维数组。
			
		2）fun(&buf)
			传递三维数组的指针，三维数组指针在四维数组中才有意义，所以可以以四维数组的方式来访问三维数组
			
			
		3）fun(*buf)也是可以的
			实参是什么类型，形参应该怎么写，怎么使用在这个指针，这些具体情况就留个大家自己去分析。
			
			
4. 多维数组
		4/5/6维数组的构建方式也是完全一样的，多维数组的核心规则就是"数组指针与第一个元素指针"的转换规则。
		
		在一般的开发中，顶多就用到二维数组，但是在游戏开发中，3维4维以上的多维数组还是会用到的。
		
		我们在讲数组时，可能讲的比较繁琐，我们的目的是想让大家能够根本的理解数组的构建规则，理解了构建规则后，
	你会发现其实数组的很简单。
		
		你把数组相关的指针都理解后，应该说你的指针才算是真正的理解到位了。
		
		
	

5. 使用malloc开辟多维数组

5.1 举例理解
5.1.1 例子1
	#include <stdio.h>
	#include <stdlib.h>

	int main(void)
	{
		//开辟有3个元素的一维数组
		int *p = (int *)malloc(3*sizeof(int));
		memset((void *)p, 0, 3*sizeof(int)); //保险起见，我们将空间清零

		int i=0, j=0;
		for(i=0; i<3; i++)
		{
			*(p+i) = i;
		}
		
		i=0;
		for(i=0; i<3; i++)
		{
			printf("%d ", p[i]);
		}
		printf("\n");
		
		free(p);
		
		return 0;
	}	
	
	int *p = (int *)malloc(3*sizeof(int));
	开辟一片连续的空间，每个元素为int空间，每个元素的指针类型为int *，p中放的第一个元素的指针。
	图：
	
	
	通过每个元素的指针访问每个元素（变量）时，*解引用时就能找到每个元素空间。
	
	
5.1.2 例子2
	#include <stdio.h>
	#include <stdlib.h>

	int main(void)
	{
			//开辟3*2的二维数组
			int (*p)[2] = (int (*)[2])malloc(3*2*sizeof(int));
			memset((void *)p, 0, 3*2*sizeof(int)); //保险起见，我们将空间清零

			int i=0, j=0;
			for(i=0; i<3; i++)
			{
					for(j=0; j<2; j++)
					{
						 *(*(p+i)+j) = i + j;
					}
			}

			i=0; j=0;
			for(i=0; i<3; i++)
			{
					for(j=0; j<2; j++)
					{
							printf("%d ", p[i][j]);
					}
					printf("\n");
			}
			
			free(p);
			
			return 0;
	}

		int (*p)[2] = (int (*)[2])malloc(3*2*sizeof(int));
	
		开辟一片3*2*sizeof(int)的连续空间，总体上分成两个大的元素，每一个都是一个2个元素的一维数组。
		图：
		
		如果将p = (int (*)[2])malloc(3*2*sizeof(int)); 变为    
    int *p = (int *)malloc(3*2*sizeof(int));
		
		就表示，我们以一个一位数组的方式去访问这个空间，这个一位数组总共6个元素。
		所以空间还是那片空间，但是类型不同了，解释方式自然也会发生变化。
		
		二维数组的三个元素为一维数组，类型为int (*)[2]，p中放的是第0个元素（一维素组）的指针
（数组指针），所以p的类型也为int (*)[2]类型。
		
			
5.1.3 例子3
	#include <stdio.h>
	#include <stdlib.h>

	int main(void)
	{
			//开辟3*2*2的三维数组
			int (*p)[2][2] = (int (*)[2][2])malloc(3*2*2*sizeof(int));
			memset((void *)p, 0, 3*2*2*sizeof(int)); //保险起见，我们将空间清零
			
			int i=0, j=0, k=0;
			for(i=0; i<3; i++)
			{
					for(j=0; j<2; j++)
					{
							for(k=0; k<2; k++)
							{
								*(*(*(p+i)+j)+k) = i + j + k;
								//p[i][j][k] = i + j + k;
							}
					}
			}
			i=0; j=0; k=0;
			for(i=0; i<3; i++)
			{
					for(j=0; j<2; j++)
					{
							for(k=0; k<2; k++)
							{
									printf("%d ", p[i][j][k]);
							}
							printf("\n");
					}
					printf("\n");
			}
			
			free(p);
			
			return 0;
	}

	int (*p)[2][2] = (int (*)[2][2])malloc(3*2*2*sizeof(int));
	
		开辟一片3*2*2*sizeof(int)的连续空间，总体上分成3个大的元素，每一个都是一个2个元素的二维数组，
	每个二维数组包含两个元素，每个元素是包含两个int元素的一维数组。
		图：
	
		三维数组的三个元素为一维数组，类型为int (*)[2][2]，p中放的是第0个元素（二维素组）的指针
（二维数组的数组指针），所以p的类型也为int (*)[2][2]类型。
		
		*(*(p+i)+j)，通过“数组指针 与 第一个元素的指针的转换规则”，最后找到每一个int元素的空间
	并访问。
		
		
		
		
5.2 malloc时，通过“多级指针”创建另一种形式的多维数组
	创建一个4*3的新形式的二维数组，不是传统形式的二维数组。
	
	#include <stdio.h>
	
	int main(void)
	{
		int i = 0, j = 0;
		int **p = NULL;
		
		p = (int *)malloc(4*sizeof(int *));
		if(NULL != p)
		{
			for(i=0; i<4; i++)
			{
				*(p+i) = malloc(3*sizeof(int));
			}
		}
		
		for(i=0; i<4; i++)
		{
			for(j=0; j<3; j++)
			{
				*(*(p+i)+j) = i+j;
			}
		}
		
		for(i=0; i<4; i++)
		{
			for(j=0; j<3; j++)
			{
				printf("%d ", *(*(p+i)+j)); //p[i][j]
			}
			printf("\n");
		}
		
		return 0;
	}		

5.3 例子中二维数组的空间结构
	图：
	
	
	从空间结构可以看出，为不连续的空间，各个都是一维数组，通过指针拼接为多维数组。
	显然这种方式与int buf[4][3]不一样，我们将int buf[4][3]方式称为传统方式。
	
	
	释放空间时，只能单个单个的释放。
	for(j=0; j<3; j++)
	{
		free(*(p+i));
	}	
	free(p);
	

5.4 *
5.4.1 在传统的多维数组中，*的作用
		
		以这个传统的二维数组为例。
		int buf[3][2];
		
		“*数组指针”的作用为强制转换的作用，将指针类型从“数组指针”强制转换为“第0个元素的指针”。
		
		[][]方式与指针方式是等价的，buf[1][2] <——————> *(*(buf+1)+2)
	
	
	里面的*：将“数组指针”强制转为第一个元素的指针
	外面的*：这一个是解引用
	
	
5.4.2 多级指针所构建的多维数组中*的作用	

	在*(*(p+i)+j)中，两个*都是解引用的作用。
	
	(p+i)：p+i为p所指向一维数组中的第i个元素指针，元素空间指针的类型为int **
		图：
	
	*(p+i)：对int **类型的指针解引用后，代表的就是第i个元素空间，元素空间的类型为int *
					空间中放的是一个int *的指针。
		图：
					
	*(p+i)+j：第i个元素中指针所指向一维数组的第j个元素空间的指针，指针类型为int *
		图：
		
		解引用，找到p所指向一维数组中的第i个元素空间，里面放的
		图：
	
	*(*(p+i)+j)：解引用，为第j个空间，空间类型为int，找到空间后就可以访问了
		图：
		
		
		所以在“多级指针”构建的多为数组中，*的作用为解引用，不是进行强制转换，但是同样可以等价为[]方式。
		
	                    等价
		*(*(p+i)+j)  <——————————> p[i][j]
		
		
		
5. 字符串

5.1 字符数组
	char buf[] = {'h', 'e', 'l', 'l', 'o', 'w', 'o', 'r', 'l', 'd'};
	
	传递字符数组的时，为了知道操作的结束位置，必须传递元素个数或者最后一个元素的指针。
	
	void fun(char m, char buf[])
	{
		int i = 0;
		
		for(i=0; i<m; i++)
		{
			printf("%c", buf[i]);
		}
	}
	
	int main(void)
	{
		char buf[] = {'h', 'e', 'l', 'l', 'o', ' ', 'w', 'o', 'r', 'l', 'd'};
		
		fun(11, buf);
		
		return 0;
	}
	
		字符操作是非常频繁的事情，如果每次传参时都传递两个参数的话，是非常麻烦的，为了省去这个麻烦，
	就需要减少传参，只传递“起始元素指针”即可。
		
		为了知道访问到什么位置结束，所以在最后位置加上一个'\0'字符，访问到'\0'字符时，就表示访问
	到末尾了，所以最后一个字符为'\0'的“字符数组”就是字符串，或者说“字符串”就是‘\0’结尾的特殊的字符数组。

	

5.2 '\0'、0、NULL、'0'区别
5.2.1 '\0'、0、NULL

（1）相同点：这三个的值相同，都为0
		1）'\0'：空字符，也被称为NUL字符，它是一个转义字符，其ascii值为0	
				char buf[10] = {};
				等价于
				char buf[10] = {'\0','\0','\0', ...};
				
				因为0是'\0'的ascii值，所以全部初始化为0时，其实就是相当于全部初始化为了'\0'字符。
				
				
				疑问：什么是转义字符？
				答：'\0'如果不加\，就是'0'字符，加了\后，整个含义就发生了变化，所以'\0'与'0'是两个完全不同的
				字符，这就是“转义“的意思。
				  
				
		2）0
			就是一个int数。
		
		3）NULL
			空指针，在C中，NULL的宏体为(void *)0。

			
（2）不同点			
			虽然值都是0，但是各自的数据类型不同，我们说过，在强类型的c语言中，类型不同就意味者解释方式不同，
		各自的用途也不同。
		
		1）'\0'：用作字符串的结尾字符
		2）0：一般算数运算用
		3）NULL：空指针，用在指针操作中
			
		当然如果非要进行强制转化的话，也可以混用。
		char a = (char)0; 					//等价于char a = '0'
		char a = (char)NULL; 				//等价于char a = '0' 
		char *p = (void *)0;        //等价于char *p = NULL;
		char *p = (void *)'\0'; 		//等价于char *p = NULL;
		等
		
		
5.2.3 '0'		
	字符'0'，ascii码值为48，与'\0'是两个完全不同的字符，'\0'的ascii码值为0。
		
5.3 字符串数组

	我习惯与将字符串称为字符串数组，这个并不是标准称法，这个只是我的习惯。

5.3.1 字符串初始化
	char buf[] = {'h', 'e', 'l', 'l', 'o', ' ', 'w', 'o', 'r', 'l', 'd', '\0'};
	char buf[12] = {"hello world"}; //末尾包含'\0'字符
	char buf[] = "hello wolrd";

	
5.3.2 字符串的传参
	传递字符串时，只需要传递数组的第0个元素的指针即可。

	void fun(char *buf) //等价于char buf[]
	{
		int i = 0;
		
		for(i=0; buf[i]!='\0'; i++)
		{
			printf("%c", buf[i]);
		}
	}
	
	int main(void)
	{
		char buf[] = {'h', 'e', 'l', 'l', 'o', ' ', 'w', 'o', 'r', 'l', 'd', '\0'};
		
		fun(buf); //等价于&buf[0]，即'h'所在元素（变量）的指针
		
		return 0;
	}
		
5.4 字符串操作函数
		调用所有操作字符串的函数时，只需要传递第0个元素的指针即可，字符串操作函数会自动通过'\0'
	来判断操作什么位置结束。
		
		比如：
		char buf[] = "hello";
		
		printf("%s\n", buf);
		
		buf为h所在的第0个元素空间的指针，只要将开头的指针给printf函数，printf便可以访问每个字符，
		并将每个字符打印出来，直到遇到'\0'为止。
		
		
5.4.1 常见字符串操作函数
	常见的字符串操作函数的头文件为string.h，这里放有“字符串操作函数”所需的声明、宏定义等。
 
（1）strlen
		1）原型：int strlen(char *str)
		2）功能：统计字符串中字符的个数，统计时遇到'\0'为止，统计时不包括'\0'。
		3）返回：字符个数
		4）举例
			char buf[] = "hello world";
			
			strlen(buf);
					
（2）strcpy、strncpy
		1）原型：char *strcpy(char *dest, const char *src)
						 char *strncpy(char *dest, const char *src, int n)
						 
		2）功能：将src指向空间中的字符串，复制到dest指向的空间
						 将src指向空间中字符串的n个字符，复制到dest指向的空间
						 
		3）返回：返回dest指针
		4）举例
			char buf[] = "hello world";
			char buf1[12];
			
			strcpy(buf1, buf);
			strncpy(buf1, buf, 5); //buf1中只放了hello这5个字符
			
			使用strcpy/strncpy函数时，要确保目标空间的大小要大于你要复制的字符个数，否则会改写其它空间。
			
			
（3）strcat、strncat
		1）原型：char *strcat(char *dest, const char *src)
						 char *strncat(char *dest, const char *src, int n)
		
		2）功能：将src中的字符串附加到dest字符串的末尾
						 将src的n个字符附加到dest字符串的末尾
							
		3）返回：返回dest指针
		4）举例
			char buf[] = "world";
			char buf1[11] = "hello ";  
			
			strcat(buf1, buf); //buf1中放的内容为"hello wolrd"。
			strncat(buf1, buf, 3); //buf1中放的内容为"hello wol"。

			buf1的空间必须要足够大，都这会访问越界，将其它的空间给修改了。
			
			就算空间刚刚好，也要多出一个空间用来放'\0'。
			
			
			
（4）strcmp、strncmp
		1）原型：int strcmp(char *dest, const char *src)
						 int strncmp(char *dest, const char *src, int n)
		
		2）功能：对比src和dest字符串是否相同
						 对比src和dest字符串中前n个字符是否相同
						 
		3）返回：0表示相等，否则不相等
		4）举例
			char buf[] = "world";
			char buf1[12] = "hello ";  
			
			if(strcmp(buf1, buf) == 0) 
			{
				printf("登录成功\n");
			}

			if(strncmp(buf1, buf, 3) == 0)  //只对比字符串前3个字符
			{
				printf("登录成功\n");
			}
			
（5）strchr、strrchr
		1）原型：char *strchr(const char *s, char c)
						 char *strrchr(const char *s, char c)
		
		2）功能：从第0个元素向后找字符c，找到后就终止寻找
						 反过来，从最后一个元素向前找字符c，找到后就终止寻找
						 
						 
		3）返回：找到后返回被找到c所在字节的指针，否则返回NULL
		4）举例
			char buf[] = "hello world, how are you!";
		
			char *p = strchar(buf, 'r');
			printf("%c\n", *p);
			
			p = strrchar(buf, 'a');
			printf("%c\n", *p);
			
			
（6）strstr、strrstr
		1）原型：char *strstr(char *str1, const char *str2)
						 char *strrstr(char *str1, const char *str2)
		
		2）功能：从str1中顺序查找str2字符串，找到后就终止寻找
						 从str1中逆序查找str2字符串，找到后就终止寻找
						 
		3）返回：找到后，返回被找到字符串的指针，否则返回NULL
		4）举例
			char buf[] = "hello world, how are you!";
			
			char *str = strstr(buf, "orl");
			
			printf("%s\n", str);
			
			str = strrstr(buf, "re");
			printf("%s\n", str);
		

5.4.2 字符串与“数值”的转换函数
	需要包含stdlib.h

（1）strtod
		1）原型：double strtod(const char *str, char **endptr)
		
		2）功能：将str中字符串形式的数字转为double数字
						 endptr用于存放被转换的最后一个字符指针+1。
						 
		3）返回：返回转换后的double数字
		4）举例
			（a）例子1
					char str[30] = "20.30300";
					double ret = 0.0;

					ret = strtod(str, NULL); //第二个参数用不上，此时写NULL
					printf("%f\n", ret);
			
			
			（b）例子2
					char str[30] = "20.30300 This is test";
					char *ptr = NULL; 		//放" This is test"第一个字符所在空间的指针
					double ret;

					ret = strtod(str, &ptr);
					printf("%f\n", ret);  //20.30300
					printf("%s", ptr);		 // This is test
 
（2）atoi/atol
		1）原型：int atoi(const char *str) 
						 long atoi(const char *str) 
		
		2）功能：将str表示的数字转换int型的数字
						 将str表示的数字转换long型的数字
						 
		3）返回：返回转换所得的int/long型数字
		4）举例
				printf("%d\n", atoi("102"));
				printf("%ld\n", atol("102"));
			
			
		

		
5.5 字符串数组 和 字符串常量	
5.5.1 字符串数组
	char buf[] = "hello world";
	
	字符串中所有的字符都放在数组空间中。
	图：

	
5.5.2 字符串常量
（1）例子
		1）例子1
				char *p = "hello";
				
				p中是放不了"hello"的，所以"hello"被存放在了.rodata中，.rodata存储区域是只读的，所以"hello"为
			只读的字符串常量。
					
				初始化时，整个"hello"代表是第0个元素空间的指针（也叫字符串指针），放到了指针变量p中。
				
				图：
				
				
		2）printf("%s\n", "hello");
				
				"%s\n"和"hello"都是字符串常量，只不过"%s\n"被用于说明输出格式，由于字符串常量"%s\n"和"hello"
			整个就代指字符串指针，在将字符串常量直接传递给printf函数，其实是将“字符串指针”传递给printf函数。 
		
			
（2）字符串常量的特点
		1）特点1
				是一片连续空间的一维数组，只是空间开辟在了.rodata区域中。
				事实上只要是一片连续的空间，我们都可以认为是数组，都可以以数组方式来访问，不要认为只有
			int buf[10]这种带有[]的定义形式才是数组。
				
				字符串常量自然也是一个数组，所以完全可以以数组的形式来访问。
				
				#incldue <stdio.h>
				
				int main(void)
				{
					char *p = "hello"; 
			
					int i = 0;
					for(i=0; p[i]!='\0'; i++)
					{
						printf("%c\n", p[i]); //等价于*(p+i)
					}
					
					return 0;
				}
			
				事实上，由于"hello"整个就代表字符串指针（第0个元素的指针），所以printf("%c\n", p[i]); 	
				完全等价于printf("%c\n", "hello"[i]); 
					
					
		
		2）特点2
			字符串常量放在了.rodata中，而.rodata又是只读的，不能被改写，如果强行改写的话，会导致指针错误。
			
			
			"hello"[3] = 'u'; 	
												
												等价于  
			"hello"[3] = 'u' ————————>  *("hello" + 3)
			
			*("hello" + 3) = 'u';
			
			尝试将第3个字符'l'改为'u'会导致指针错误，显然这个是错误的。
			
		
			图：
			
	
			
	
（3）再举一个例子
		
		char *fun1(void)
		{
			char buf[] = "hello";
			
			return buf;
		}
		
		char *fun2(void)
		{
			char *p = "hello";
			
			return p;
		}
		
		int main(void)
		{
			char *ret1 = NULL;
			char *ret2 = NULL;
			
			ret1 = fun1();
			ret2 = fun2();
			
			return 0;
		}
		
			fun1中的buf的空间在栈中，前面就说过返回开辟于栈中的自动局部变量是危险的，因为函数结束后
		空间会被释放。
			
			修改代码：
			
			方式1：
			static char buf[] = "hello";
			
			方式2：
			char *buf = malloc(6*sizeof(char));
			strcpy(buf, "hello");
			
			
			fun2中所返回的指针所指向的空间在.rodata中，在整个程序运行的过程中，在.rodata中所开辟空间
		会一直存在，所以返回.rodata中的指针是没有问题的，但是空间只能读，不能被修改。
	
				
6. 指针变量、数组、字符串与sizeof		

6.1 sizeof 与 strlen
6.1.1 sizeof
	sizeof不是函数，sizeof是c语言的关键字，用于获取空间的字节数，参数可以是类型，也可以是变量。
	
	int a;
	sizeof(int), sizeof(a)
	
6.1.2 strlen
	strlen是一个字符串函数，用于统计字符串中字符的个数，参数为字符串指针。
	
	char *p = "hello world";
	
	sizeof(p); //结果为4，为变量p的空间字节数
	strlen(p); //11，为字符个数，不包括'\0'
	
	
6.2 指针变量与sizeof
	int *p;
	char *p1;
	int (*p2)[10];
	int (*p3)[3][4];
	
	sizeof(p)、sizeof(int *);
	sizeof(p1)、sizeof(char *);
	sizeof(p2)、sizeof(int (*)[10]);
	sizeof(p3)、sizeof(int (*)[3][4]);
	
	不管什么类型的指针变量，指针变量的大小都是相同的宽度，比如4个字节或者8个字节。
	
	
6.3 数组与sizeof
6.3.1 例子1
	int buf[10];
	
	sizeof(buf); 
		buf此时为数组名，代表的是整个数组，此时数组是一个大号的变量，所以sizeof的结果为数组这个大号变量
	的字节数（40字节）。
	
	sizeof(buf[2]); 
	每个元素就是一个int变量，所以sizeof的结果为4个字节。
	
	
6.3.2 例子2 
	void fun(int m, int p[]) //p[] 等价于 *p
	{
		printf("%d\n", sizeof(p));
	}
	
	int main(void)
	{	
		int buf[] = {0, 1, 2, 3, 4, 5, 6};
		
		fun(7, buf); //&buf[0]，int *
		
		return 0;
	}
	
		形参中int p[]的本质为int *p，所以sizeof的结果为4/8字节，很多同学总是被int p[]的样子所欺骗，
	总以为是一个数组，所以sizeof的结果为整个数组的大小，实际上是错的。
		
		当然int p[][n]、int p[][m][n]等也是同样的道理，都是一个指针变量，而不是数组。
		· int p[][n]：int (*p)[n]
		· int p[][m][n]：int (*p)[m][n]
			
			sizeof(p)所得的也是指针变量的字节数。
	
	
6.3 字符串常量与sizeof	

		char buf[] = "hello world";
		
		printf("%d\n", sizeof(buf)); //buf代表的是整个字符数组，所以为12，包括'\0'
		printf("%d\n", strlen(buf)); //strlen为字符函数，buf为&buf[0]，用于统计字符个数，为11，不包括'\0'


		
		char *p = "hello world";
		
		printf("%d\n", sizeof(p)); //p指针变量名，为整个指针变量的的字节数，为4/8	
		
		printf("%d\n", sizeof("hello wolrd"));  //12
		
			"hello wolrd"为字符串常量，放在.rodata中的常量空间中，在sizeof时，此时"hello wolrd"
		代表整个空间，所以sizeof结果为整个常量空间的字节数，为12。
	
	
		printf("%d\n", strlen("hello wolrd"));  //统计字符串中字符个数，为12，不包括'\0'
			strlen为字符串函数，需要传递的参数为字符串第0个字符所在元素的指针。
			进行函数传参时，如果实参直接写的是字符串常量的话，比如 strlen("hello wolrd")，整个字符串常量
		代表的是第0个字符所在元素空间的指针。
			

		
7. main函数的参数argc、argv 与 返回值	

		我们常见的main函数为int main(void)，但实际上main函数可以有形参，因为main函数也是被启动代码
	所调用的函数，main函数也会被别人调用，所面也是可以被传参，参数形式为
	int main(int argc, char **argv)。
		
		直接讲这两个参数，估计不太好理解，我们先从"字符串指针数组"说起。
	
	
7.1 字符串指针数组 
7.1.1 什么是"字符串指针数组"
		char *buf[] = {"how", "are", "you"};  //字符串指针数组
		
		作为字符串常量放在了.rodata中，buf[]中的每个元素只是用来存放每个字符串的字符串指针。
		
		图：

		
		"how", "are", "you"为字符串常量，各自代表的是第0个元素空间的指针（字符串指针），字符串的每个字节空间
	的类型为char，那么空间指针的指针类型则为char *，自然第0个字符所在空间的指针也为char *，所以存放字符串
	指针的数组也为char *。
		
		
		char *buf[] = {"how", "are", "you"};
		可以等价的理解为就是定义三个指针变量，用于存放字符串指针。
		
		char *buf[0] = "how"; 
		char *buf[1] = "are";
		char *buf[2] = "you";
		
		既然数组每个元素（变量）的类型为char *，那么数组每个元素指针的类型就为char **。
		
		
7.1.2 传递"字符串指针数组"
	
	void fun(int m, char **p) 
	{
		int i = 0;
		
		for(i=0; i<m; i++)
		{
			printf("%s\n", p[i]);
		}
	}
	
	int main(void)
	{
		char *buf[] = {"how", "are", "you"};
		
		fun(3, buf);//buf等价于&buf[0], buf[0]的类型为char *，&buf[0]的类型就为char **
		
		return 0;
	}
	
	形参的等价写法：
	void fun(int m, char **p)  //*p等价于p[]
	{
	}
	
	等价于
	void fun(int m, char *p[])  
	{
	}

	字符串指针数组，一般末尾都会使用NULL结尾，这样的话实际上可以通过NULL来判断结尾，比如下面这个例子。
	
	void fun(char *p[])
	{
		int i = 0;
		
		for(i=0; p[i]!=NULL; i++)
			printf("%s\n", p[i]);
	}
	
	int main(void)
	{
		char *buf[] = {"how", "are", "you", NULL};
		
		fun(buf);
		
		return 0;
	}
	

7.2 int main(int argc, char *argv[]) 
	
	根据argv[]与*argv的等价关系，char *argv[]等价于char **argv
	
	int main(int argc, char **argv)
	{
	
		return 0;
	}
	
	启动代码调在用main函数时，可以给main传递一个“字符串指针数组”。
			char *buf[] = {"xxx", "xxx", "xxx", ..., NULL};
			int n = sizeof(buf)/sizeof(char *)-1;
			
			main(n, buf);  //buf等价&buf[0]，buf[0]的类型为char *，&buf[0]的类型char **
			
			
	（1）argc：argc为argment count的缩写，放的是字符串的个数。
	（2）argv：argv为argment vector的缩写，放的是“字符串指针数组”第0个元素指针
			argment vector被称为“参数矢量”，矢量就是带有指向的东西，由于指针带有指向作用，因此在c中
		，指针也被称为矢量。
	
		疑问：main函数的形参是不是一定要命名为argc和argv呢？
		答：当然不是，取什么名字都可以。
			int main(int a, char **b)
			{
				return 0;
			}
			
			不过我们还是按照大家都熟悉的，约定俗成的名字来会更好些。
			
		
7.2 main函数参数的作用

7.2.1 裸机时（没有OS）
	裸机时main函数的传参没有什么意义，所以裸机运行c程序时，main函数的形式基本都为int main(void)或者
void main(void)。
	
	
7.2.2 有OS时
（1）作用
		当然，我这里说的OS指的是Linux、Windows等复杂的操作系统，而不是单片机上运行的RTOS这种小型的实时OS。
		
		main函数的参数用于实现父进程和子进程之间的参数传递：
		
									字符串指针数组
			父进程 ——————————————————————> 子进程（c程序：启动代码———————————————>main的argc和argv）

			
			有关父子进程的更多情况，请看《c深度解析》的第1章中的“程序加载、运行”课程。
			
			
（2）父子进程传参举例：在命令行运行程序时，输入命令行参数，传递命令行参数

		#include <stdio.h>
		
		int main(int argc, char **argv)
		{
			int i = 0;
			
			for(i=0; i<argc; i++)
			{
				printf("%s\n", argv[i]);
			}	
			
			return 0;
		}
		
		在命令行运行程序，然后在命令行输入命令行参数，然后main函数会打印出命令行参数。
		>a.exe afasff fds f dasf as 
		
		运行结果：
		a.exe 
		afasff 
		fds 
		f 
		dasf 
		as 
		
		
		字符串传递的过程为：
		
		1）父进程（命令行程序）
			（a）得到键盘输入的字符串，并构建出"字符串指针数组"
					char *buf[] = {".\qq.exe", "afasff", "fds", "f", "dasf", "as", NULL}; 
					int n = sizeof(argv)/sizeof(char *)-1; 
		
			（b）父进程创建“子进程”，在子进程中“加载运行”q.exe这个c程序
		
			（c）将buf和n传递给“子进程”中所运行q.exe程序的启动代码
		
		2）启动代码再将n和buf传递给main函数的形参argc和argv
			main函数就可以通过arg、argv访问"字符串指针数组"，通过指针数组中的每个"字符串指针"去访问每个字符串。
		
	                           n  buf                                n   buf
			父进程（命令行程序）————————————> 子进程（qq.exe：启动代码 ————————————> main的argc和argv）
			
			疑问：在命令行执行程序时，传递命令行参数有什么意义呢？
			答：当然有意义，但是我们这里不解释，大家可以看《linux系统编程、网络编程》这个课程，学了这个课
			程后，你自然知道命令行参数有什么意义。
		
		
		由于字符串指针数组以NULL结尾，所可以通过NULL判断结尾
			for(i=0; i<argc; i++)
			
			可以改为：
			
			for(i=0; argv[i]!=NULL; i++) 
			
			
			
7.2 main函数的返回值
	函数使用return的目的，是想将返回值返回给调用者，main函数的调用者是启动代码，所以main函数return的返回
值，肯定是返回给调用main函数的启动代码的，但是启动代码拿到返回值后，又会交给谁呢？ 

7.2.1 裸机时（没有OS）
		返回值返回给到“启动代码”就终止了，启动代码拿到返回值后也没有什么意义，也就说裸机时，main函数返回
	值并没有什么意义。
	
	所以说以前好多的裸机c程序，main函数都喜欢将返回值的类型写为void，比如：
	void main(void)
	{
		
	}
	
	
7.2.2 有OS时	
	启动代码会将返回值交给OS内核，这个肯定是由意义，操作系统内核拿到返回值能后，有什么作用呢？
	这个问题请大家看《linux系统编程、网络编程》。
