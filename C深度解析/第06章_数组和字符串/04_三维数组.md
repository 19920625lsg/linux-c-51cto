# 4. 三维数组		

我们把三维数组搞清楚后，就算是完整的搞清楚了多维数组的构建规则。

## 4.1 定义形式

```c
int buf[m][n][z];
int buf[3][2][2];
```

## 4.2 三维数组的内存结构

以int buf[3][2][2]为例，也是一片的连续空间。


```c
// 第0元素：二维数组
buf[0][0][0]  buf[0][0][1]     	// 第0元素：一维数组
buf[0][1][0]  buf[0][1][1]	// 第1元素：一维数组

// 第1元素：二维数组
buf[1][0][0]  buf[1][0][1]	// 第0元素：一维数组
buf[1][1][0]  buf[1][1][1]	// 第1元素：一维数组

// 第2元素：二维数组
buf[2][0][0]  buf[2][0][1]	// 第0元素：一维数组
buf[2][1][0]  buf[2][1][1]	// 第1元素：一维数组
```

	
+ （1）将三维看成一维，整个三维数组由3个元素组成，每个元素为一个小二维数组
+ （2）将小二维看成一维，每个小二维数组由2个元素组成，每个元素为一个小一维数组
+ （3）每个一维数组由2个int元素组成 图： 

## 4.3 向三位数组给值				

### 4.3.1 初始化

#### （1）给定空间的初始化

+ 1）不初始化
  如int buf[3][2][2];，在未初始化时，每个元素的内容为多少，视数组在内存中的位置而定。

+ 2）全部初始化为0
  如int buf[3][2][2] = {}，等价于int buf[3][2][2] = {0}，全部初始化为0

+ 3）完全初始化
  ```c
  int buf[3][2][2] = {{{0, 1}, {2, 3}}, {{4, 5}, {6, 7}}, {{8, 9}, {10, 11}}};
  ```
  这个写法有点不好理解，我们可以改为如下形式：

  ```c
  int buf[3][2][2] = 
  {
    {{0, 1}, {2, 3}}, 	//第0个二维数组
    {{4, 5}, {6, 7}},		//第1个二维数组		
    {{8, 9}, {10, 11}}	//第2个二维数组
  };
  ```


+ 4）部分初始化
  部分初始化的时候，三维数组里面的每个二维数组，以及二维数组中每个一维数组，都可以做部分初始化  
  做部分初始化，一定是顺序的，其他没有初始化的就是0  

  ```c
  int buf[3][2][2] = {{{0, 1}}, {{4, 5}, {6}}, {{8, 9}}}; // 其余值默认为0  
  ```

  错误写法：
  ```c
  int buf[3][2][2] = {{{0, 1}}, {, {4, 5}, {, 6}}, { ,{8, 9}}};
  ```

+ 5）个别初始化  
  ```c
  int a[2][2] = {[0][1][0]=10, [2][0][1]=9, [1][1][1]=20} // 未初始化的其它元素默认为0
  ```
    
#### （2）不给定空间的初始化
```c
int buf[][2][2]= {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
```
`没有写的数字 = 元素个数/(2*2)`，不能整除的话，那就补增元素，直到能整除为止，补增元素的值默认为0  
例子中，元素增补到12就能整除分，这个三维分为3*2*2    
除了buf[][2][2]这种方式外，buf[3][][2]、buf[3][2][]、buf[][][2]等写法都是错误的  
	
### 4.3.2 赋值

```c
#include <stdio.h>

int main(void)
{       
  int buf[3][2][2];

  int i=0, j=0, k=0;

  for(i=0; i<3; i++)
  {
    for(j=0; j<2; j++)
    {
      for(k=0; k<2; k++)
      {
        buf[i][j][k] = i*j*k;		
      }		
    }	
  }

  return 0;   
}					
```
				
当然也能使用memcpy函数来实现两个三维数组之间的复制。

```c
int buf1[3][2][2] = {{{0, 1}, {2, 2}}, {{4, 5}, {6, 7}}, {{8, 9}, {10, 11}}};
int buf2[3][2][2];

memcpy((void *)buf2, (void *)buf1, sizeof(buf1));
```
	

	
## 4.4 三维数组的“数组名”的各个相关含义					

以int buf[3][2][2]为例。
	
	
### 4.4.1 buf：数组的别名，指代整个数组空间，sizeof(buf)，buf此时指代就是整个数组空间 

这是buf指代的数组就是一个大号的变量，得到就是这个变量的空间大小。

### 4.4.2 buf：第0个元素的指针

#### （1）三维数组的第0个元素为一个二维数组
 
 所以buf为第0个二维数组的数组指针，等价于&buf[0](buf[0]就是三维数组的第0个元素)，也就是第0个小二维数组的第一个字节的地址。图：
	
#### （2）buf的指针类型

三维数组的每个元素为一个二维数组，buf的指针类型为int (*)[2][2]。
		
#### （3）buf+1

buf为第0个二维数组的数组指针，buf+1加的是一个二维数组空间的大小，buf+1实际为`buf+1*2*2*sizeof(int)` 图：
		
`buf+1`，就从第0个二维数组第一个字节处，跳到了第1个二维数组的第一个字节处 
		
#### （4）buf+i

`buf+i`实际为`buf+i*2*2*sizeof(int)`，就从第0个二维数组第一个字节处，跳转到第i个二维素组的第一个字节处.图：  

### 4.4.3 &buf

`buf`：第0个元素指针，也就是第0个二维数组的数组指针  
```
`&第0个元素的指针`  ————————> 元素所在数组的数组指针
```
第0个元素所在的数组为整个三维维数组，所以`&buf`为整个三维数组的数组指针，指着类型为`int (*)[3][2][2]`  图：  
`buf`与`&buf`值相等，但是类型不同  

### 4.4.4 `*buf`

#### （1）`*buf`的含义

buf为三维数组第0个元素的指针，即第0个二维数组的数组指针  

```
*数组指针 ————————> 该数组第一个元素的指针  
```

所以`*buf`为二维数组第0元素的指针，由于二维数组的第0个元素为一个一维数组，所以`*buf`为第0个一维数组的数组指针。图：  
		
		
#### （2）`*buf`的指针类型

每个小的一维数组有2个int元素，所以`*buf`的指针类型为`int (*)[2]`  
		
`*buf` 等价于 `*(buf+0)`
		
#### （3）`*(buf+1)`

+ `buf+1`为第1个二维数组的数组指针，`*(buf+1)`则为第1个二维数组的第0个一维数组的数组指针，既然一维数组的数组指针，指针类型也为`int (*)[2]`. 图：

+ `*(buf+i)`：为第i个二维数组的第0个一维数组的数组指针，指针类型也为`int (*)[2]`  

#### （4）`**buf`、`***buf`

+ 1）`**buf `

```c
**buf ———> *(*(buf+0)+0) ———> *(第0个二维数组的第0个一位数组的数组指针 + 0) ——> 第0个二维数组的第0个一维数组的第0个元素的指针，指针为int *
```

+ 2）`***buf` 

```c
***buf ————> *(**buf) ————>*(第0个二维数组的第0个一维数组的第0个元素的指针（int *）) ————> 第0个二维数组的第0个一维数组的第0个元素的空间
```
		
		
#### （5）*(*(*(buf+i)+j)+z)
			
+ `***`buf 等价于 `*(*(*(buf+0)+0))`：第0个二维数组的第0个一维数组的第0个元素的空间

+ `*(*(*(buf+i)+j)+z)`：为第i个二维数组的第j个一维数组的第z个元素的空间  图：

+ `*(*(*(buf+i)+j)+z)`的等价写法`buf[i][j][k]`，`*(*(buf[i]+j)+k)`、`*(buf[i][j]+k)`等混合写法也是正确的。
			


				
###  4.4.5 三维数组的`buf[0]`、`buf[1]`、`buf[0][1]`、`buf[1][0]`等的含义		

例子：  
```c
int buf[3][2][2];
```

```c
// 第0元素：二维数组
buf[0][0][0]  buf[0][0][1]     	// 第0元素：一维数组
buf[0][1][0]  buf[0][1][1]	// 第1元素：一维数组

// 第1元素：二维数组
buf[1][0][0]  buf[0][0][1]	// 第0元素：一维数组
buf[1][1][0]  buf[0][1][1]	// 第1元素：一维数组

// 第2元素：二维数组
buf[2][0][0]  buf[0][0][1]	// 第0元素：一维数组
buf[2][1][0]  buf[0][1][1]	// 第1元素：一维数组
```
		
		
#### （1）buf[0]、buf[1]、buf[2]的含义
			
+ （a）分析思路1

   buf[0][1][1]  

   将buf[0]替换为buf0。
   buf0[0][1]  //这是二维数组的其中一个元素，buf0为维数组的名字
   buf0对应的为第0个二维数组，buf0为第0个二维数组的第0个元素的指针，二维数组的第0个元素为一个一维数组，所以buf0(buf[0])为第0个二维数组的第0个一维数组的数组指针，类型为int (*)[2]。
   图： 

   同理：
    `buf[1]`为第1个二维数组的第0个一维数组的数组指针，类型为`int (*)[2]`
    `buf[2]`为第2个二维数组的第0个一维数组的数组指针，类型为`int (*)[2]`


+ （b）分析思路2  
    ```c
    buf[0][1][1] ————> (*(buf+0))[1][1] 
    ```
    buf为三维数组第0个元素的指针，即第0个二维数组的数组指针   

    ```
    *数组指针 ————————> 该数组第一个元素的指针
    ```
   ` *(buf+0)（buf[0]）`为第0个二维数组第0个一维数组的数组指针  

    `buf[1]`、`buf[2]`也是类似的分析方式  
			
			
#### （2）buf[0][1]的含义	

```c
buf[0][1][1]  
```

+ 1）分析思路1

  将buf[0][1]替换为buf01。
  ```c
  buf01[1]  //为一维数组的元素
  ```

buf01对应的是第0个二维数组的第1个一维数组，所以`buf01(buf[0][1])`为第0个二维数组中的第1个一维数组的第0个元素的指针，一维数组的元素为int，所以buf01的指针类型为`int *` 图：

同理，同理`buf[1][0]`，第1个二维数组中的第0个一维数组的第0个元素的指针，类型也为`int*` 图：

+ 2）分析思路2
    ```c
    buf[0][1][1]  ——————> (*(*(buf+0)+1))[1]
    ```

    `*(*(buf+0)+1)（buf[0][1]）`：根据“数组指针 与 第一个元素指针”的转换规则，显然buf[0][0]为第0个二维数组的第1个一维数组的第0个元素的指针  

#### （3）`&buf[0]`、`&buf[1]`、`&buf[0][1]`、`&buf[1][1]`等

按照“数组指针 与 第一个元素指针”的转换原则，自行分析  
		
		
#### （4）`*buf[0]`、`*buf[1]`、`*buf[0][1]`、`*buf[1][1]`

按照“数组指针 与 第一个元素指针”的转换原则，自行分析。				
					
		
		
## 4.5	三维数组的访问

```c
int buf[3][2][2];
```

```c
                等价的本质写法
buf[0][1][1] ————————————————————>   *(*(*(buf+0)+1)+1)
```

通过二维数组指针 与 一维数组指针 与 每个小元素指针之间的转换，就可以找到每个小元素的空间。图：
			
## 4.6	三维数组的传参	

### （1）例子 

```c
#include <stdio.h>

{
        int i=0, j=0, k=0;

        for(i=0; i<m; i++)
        {
                for(j=0; j<n; j++)
                {
                        for(k=0; k<z; k++)
                        {
                                printf("%d ", *(*(*(buf+i)+j)+z)); //buf[i][j][k]
                        }
                }
        }
}

int main(void)
{
        int buf[3][2][2] = 
        {   
                //第0个二维数组
                {{0, 1}, 
                {2, 3}},

                //第1个二维数组		
                {{4, 5}, 
                {6, 7}},

                //第2个二维数组			
                {{8, 9}, 
                {10, 11}}	
        };

        fun(3, 2, 2, buf); //int (*)[2][2]

        return 0;
}
```
		
### （2）形参的等价写法

```c
void fun(int m, int n, int z, int (*buf)[n][z]) //*buf ——————> buf[]
{
}
```

等价于

```c
void fun(int m, int n, int z, int buf[][n][z])
{
}
```

`int buf[][n][z]`: 第一个括号中有没有数字无所谓，但是n和z不能省，否则无法在二维数组之间进行跳转  
		
		
### （3）传递其它的指针，行不行

当然可以

#### 1）`fun(**buf)`

`**buf`，为第0个二维数组的第0个一维数组第0个元素的指针，类型`int *`  

`fun(**buf)`等价于`fun((int *)buf)`，此时可以将整个三维数组看成时一个12个元素的一维数组，`**buf`为整个12个元素一维数组的第0个元素的指针，可以以一维数组的方式来访问三维数组。  

#### 2）`fun(&buf)`  

传递三维数组的指针，三维数组指针在四维数组中才有意义，所以可以以四维数组的方式来访问三维数组  

#### 3）`fun(*buf)`也是可以的  

实参是什么类型，形参应该怎么写，怎么使用在这个指针，这些具体情况就留个大家自己去分析  
