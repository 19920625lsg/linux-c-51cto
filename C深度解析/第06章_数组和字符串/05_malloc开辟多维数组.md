# 5. 使用malloc开辟多维数组

## 5.1 举例理解

## 5.1.1 例子1

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main(void)
{
  //开辟有3个元素的一维数组, p是数组指针
  int *p = (int *)malloc(3*sizeof(int));
  memset((void *)p, 0, 3*sizeof(int)); //保险起见，我们将空间清零

  int i=0, j=0;
  for(i=0; i<3; i++)
  {
    *(p+i) = i;
  }

  i=0;
  for(i=0; i<3; i++)
  {
    printf("%d ", p[i]);
  }
  printf("\n");

  free(p);

  return 0;
}	
```

```c
int *p = (int *)malloc(3*sizeof(int));
```
开辟一片连续的空间，每个元素为int空间，每个元素的指针类型为`int *`，p中放的第一个元素的指针  图：

通过每个元素的指针访问每个元素(变量)时，`*`解引用时就能找到每个元素空间  

### 5.1.2 例子2

```c
#include <stdio.h>
#include <stdlib.h>

int main(void)
{
    //开辟3*2的二维数组
    int (*p)[2] = (int (*)[2])malloc(3*2*sizeof(int));
    memset((void *)p, 0, 3*2*sizeof(int)); //保险起见，我们将空间清零

    int i=0, j=0;
    for(i=0; i<3; i++)
    {
        for(j=0; j<2; j++)
        {
           *(*(p+i)+j) = i + j;
        }
    }

    i=0; j=0;
    for(i=0; i<3; i++)
    {
        for(j=0; j<2; j++)
        {
            printf("%d ", p[i][j]);
        }
        printf("\n");
    }

    free(p);

    return 0;
}
```

```c
int (*p)[2] = (int (*)[2])malloc(3*2*sizeof(int));
```

开辟一片`3*2*sizeof(int)`的连续空间，总体上分成两个大的元素，每一个都是一个2个元素的一维数组  图：  

如果将
```c
p = (int (*)[2])malloc(3*2*sizeof(int));
```
变为    
```c
int *p = (int *)malloc(3*2*sizeof(int));
```

就表示，我们以一个一位数组的方式去访问这个空间，这个一位数组总共6个元素。所以空间还是那片空间，但是类型不同了，解释方式自然也会发生变化  

二维数组的三个元素为一维数组，类型为`int (*)[2]`，p中放的是第0个元素(一维素组)的指针(数组指针)，所以p的类型也为`int (*)[2]`类型  
			
### 5.1.3 例子3

```c
#include <stdio.h>
#include <stdlib.h>

int main(void)
{
    //开辟3*2*2的三维数组
    int (*p)[2][2] = (int (*)[2][2])malloc(3*2*2*sizeof(int));
    memset((void *)p, 0, 3*2*2*sizeof(int)); //保险起见，我们将空间清零

    int i=0, j=0, k=0;
    for(i=0; i<3; i++)
    {
        for(j=0; j<2; j++)
        {
            for(k=0; k<2; k++)
            {
              *(*(*(p+i)+j)+k) = i + j + k;
              //p[i][j][k] = i + j + k;
            }
        }
    }
    i=0; j=0; k=0;
    for(i=0; i<3; i++)
    {
        for(j=0; j<2; j++)
        {
            for(k=0; k<2; k++)
            {
                printf("%d ", p[i][j][k]);
            }
            printf("\n");
        }
        printf("\n");
    }

    free(p);

    return 0;
}
```

```c
int (*p)[2][2] = (int (*)[2][2])malloc(3*2*2*sizeof(int));
```
	
开辟一片`3*2*2*sizeof(int)`的连续空间，总体上分成3个大的元素，每一个都是一个2个元素的二维数组，每个二维数组包含两个元素，每个元素是包含两个int元素的一维数组。  图：

三维数组的三个元素为一维数组，类型为`int (*)[2][2]`，p中放的是第0个元素（二维素组）的指针（二维数组的数组指针），所以p的类型也为`int (*)[2][2]`类型  

`*(*(p+i)+j)`，通过“数组指针 与 第一个元素的指针的转换规则”，最后找到每一个int元素的空间并访问  
		
## 5.2 malloc时，通过“多级指针”创建另一种形式的多维数组

创建一个`4*3`的新形式的二维数组，不是传统形式的二维数组
	
```c
#include <stdio.h>

int main(void)
{
  int i = 0, j = 0;
  int **p = NULL;

  p = (int *)malloc(4*sizeof(int *));
  if(NULL != p)
  {
    for(i=0; i<4; i++)
    {
      *(p+i) = malloc(3*sizeof(int));
    }
  }

  for(i=0; i<4; i++)
  {
    for(j=0; j<3; j++)
    {
      *(*(p+i)+j) = i+j;
    }
  }

  for(i=0; i<4; i++)
  {
    for(j=0; j<3; j++)
    {
      printf("%d ", *(*(p+i)+j)); //p[i][j]
    }
    printf("\n");
  }

  return 0;
}		
```

## 5.3 例子中二维数组的空间结构

图：
从空间结构可以看出，为不连续的空间，各个都是一维数组，通过指针拼接为多维数组。显然这种方式与int buf[4][3]不一样，我们将int buf[4][3]方式称为传统方式  

释放空间时，只能单个单个的释放  

```c
for(j=0; j<3; j++)
{
  free(*(p+i));
}	
free(p);
```
	

## 5.4 `*`

### 5.4.1 在传统的多维数组中，`*`的作用  
		
以这个传统的二维数组为例

```c
int buf[3][2];
```

`*数组指针`的作用为强制转换的作用，将指针类型从“数组指针”强制转换为“第0个元素的指针”  

`[][]`方式与指针方式是等价的，`buf[1][2]` <——————> `*(*(buf+1)+2)`  

+ 里面的`*`：将“数组指针”强制转为第一个元素的指针  
+ 外面的`*`：这一个是解引用  
	
	
### 5.4.2 多级指针所构建的多维数组中*的作用	

在`*(*(p+i)+j)`中，两个`*`都是解引用的作用  

+ `(p+i)`：`p+i`为p所指向一维数组中的第i个元素指针，元素空间指针的类型为`int **` 图：

+ `*(p+i)`：对`int **`类型的指针解引用后，代表的就是第i个元素空间，元素空间的类型为`int *`空间中放的是一个`int *`的指针 图： 

+ `*(p+i)+j`：第i个元素中指针所指向一维数组的第j个元素空间的指针，指针类型为`int *`  图：  
              解引用，找到p所指向一维数组中的第i个元素空间，里面放的  图：  

+ `*(*(p+i)+j)`：解引用，为第j个空间，空间类型为int，找到空间后就可以访问了  图：  
  所以在“多级指针”构建的多为数组中，`*`的作用为解引用，不是进行强制转换，但是同样可以等价为[]方式 
  
  ```c
                     等价
    *(*(p+i)+j)  <——————————> p[i][j]
  ```
