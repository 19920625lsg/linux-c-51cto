# 8. 双链表

## 8.1 双链表的节点结构体

双链表和单链表的实现并没有什么太大的差别，只不过比单链表的节点多了一个prev成员，用于指向上一个节点。

```c
//双链表的节点结构体
typedef struct DoubleNode  
{
    void *data; //指向数据空间，为了独立出“链表基本操作”，我们任然将data定义为void *
    struct DoubleNode *prev; //存放前继节点指针，指向上一个节点
    struct DoubleNode *next; //存放后继节点指针，指向下一个节点
}DNode;
```

由于双向链表比单链表多了一个向前的指向，所以使用起来更加方便

我们知道，在单链表中进行插入、删除操作时有点麻烦，必须找到前一个节点才能进行操作，但是在双链表中就不必如此麻烦，要操作那个节点，直接拿到这个节点的指针即可

双链表也分为了“双向非循环链表”和“双向循环链表”，我们举例时举的是“双向循环链表”
		
			
## 8.2 双向循环链表的结构

图5：
	
从图中可以看出，其实与单链表的差别并不大。
	
+ （1）头指针变量：存放的是头节点的指针，指向了头节点，为整个链表的入口。
+ （2）头节点：与单链表一样，为了方便操作，我们也加入“空头节点”。
+ （3）由于是循环链表，所以头节点的后面为链表头部，头节点的前面为链表尾
				
# 8.3 实现双向循环链表

### 8.3.1 实现链表基本操作

+ 创建节点
+ 插入节点
+ 删除节点

同样的，“链表基本操作”只与节点本身有关，与具体的数据无关。

由于双链表只是比单链表只多了一个指向，所以双链表与单链表的“基本操作”的几乎差不多，所以我们只需要在单链表代码的基础上进行修改，即可得到双链表的“基本操作函数”
		
#### （1）创建节点

+ 1）代码

```c
DNode *Dou_CreateNode(void *data, int dataSize)
{
    /* malloc开辟节点空间 */
    DNode *p = (DNode *)malloc(sizeof(DNode));
    if(NULL == p) print_error("malloc");

    //让prev、next默认指向空
    p->data = NULL;  
    p->prev = p->next = NULL;  			

    /* malloc开辟节点中的数据空间，然后存入数据
     * 有数据才开辟，没有数据就不用开辟了
    */
    if(NULL != data)
    {
        p->data = malloc(dataSize);
        if(NULL == p->data) print_error("malloc");

        //前面的课程就说过，结构体变量之间是可以整体复值的
        memcpy(p->data, data, dataSize);
    }

    return p;
}
```

+ 2）代码分析
  除了`*****`标记代码不同之外，其它与单链表的都是一样的  
			
#### （2）插入节点

由于双链表有next和prev这两个指向，所以插入操作会比单链表更加容易。

只要拿到了前一个节点和后一个节点的指针，就能在两个节点之间插入新节点。 图：

+ 1）通用插入代码

   ```c
    /* 功能：将新节点插入到前后两个节点之间
     *   prev：前一个节点的指针
     *   next：后一个节点的指针
     *   nodep：新节点的指针
    */
    void Dou_insertNode(DNode *prev, DNode *next, DNode *nodep)
    {
        //新节点与前一个节点相互指向
        prev->next = nodep;
        nodep->prev = prev;

        //新节点与后一个节点相互指向
        next->prev = nodep;
        nodep->next = next;
    }
   ``


+ 2）插入到p所指向节点的后面

    ```c
    void Dou_InsertNodeAfter(SNode *p, SNode *nodep)
    {
        Dou_insertNode(p, p->next, nodep);
    }
    ```


+ 3）插入到p所指向节点的前面

    ```c
    void Dou_InsertNodeBefore(SNode *p, SNode *nodep)
    {
        //p->prev为前一个节点的指针，p为后一个节点的指针
        Dou_insertNode(p->prev, p, nodep);
    }
    ```

+ 4）插入到链表的头部（也就是插入到头节点的后面）

    ```c
    //hp：头节点指针    nodep：新节点指针
    void Dou_HeadInertNode(SNode *hp, SNode *nodep)
    {
        Dou_InsertNodeAfter(hp, nodep); 
    }
    ```


+ 5）插入整个链表的尾部（也就是插入到头节点的前面）
   
   ```c
    //hp：头节点指针    nodep：新节点指针
    void Dou_TailInertNode(SNode *hp, SNode *nodep)
    {
        Dou_InsertNodeBefore(hp, nodep); 
    }
   ```
			
+ （3）删除节点  
    只要拿到了前一个节点和后一个节点的指针，就可以删除掉中间的节点  

   + 1）删除操作的通用代码

        ```c
        void Dou_Delete(SNode *prev, SNode *next)
        {
            prev->next = next;
            next->prev = prev;
        }
        ```


   + 2）删除某个节点（基于Dou_Delete实现）

        ```c
        //p指向了要被删除的节点
        void Dou_DeleteNode(SNode *p)
        {
            /* 删除节点，p->prev：前一个节点的指针， p->next：后一个节点的指针 */
            Dou_Delete(p->prev, p->next);

            /* 释放节点数据空间 */
            if(NULL != p->data)
                    free(p->data);//释放节点的数据空间

            p->data = NULL; 
            p->prev = p->next = NULL;

            //释放节点空间
            free(p); 
            p = NULL;
        }
        ```

		
### 8.3.2 基于链表的基本操作，正式实现一个存放学生数据的“双向循环链表”

#### （1）要实现的功能如下

+ 1）创建一个只有“头指针变量”和“头节点”的空双向循环链表
+ 2）从文件中读取出学生数据，然后保存到链表中	
+ 3）将所有学生数据打印显示出来
+ 4）按照学号查找学生数据
+ 5）从键盘输入学生数据，然后插入到链表中（头插或者尾插）
+ 6）修改学生数据
+ 7）保存链表数据到文件中
+ 8）按照学号排序
+ 9）删除某个学生节点
+ 10）清空链表（只剩一个空头节点）
+ 11）销毁链表（把空头节点也删除掉）
		
		
### （2）功能函数的实现

与单链表的功能函数基本差不多，所以直接在单链表代码的基础上修改即可。

+ 1）创建一个只有“头指针变量”和“头节点”的空双向循环链表
    
    ```c
    void createList(SNode **hpp)
    {
        //创建一个空间点作为头节点，由于空节点没有数据，所以参数传NULL和0
        *hpp = Dou_CreateNode(NULL, 0);

        //让头节点的next、prev放头节点自己的地址
        (*hpp)->next = (*hpp)->prev = *hpp; 
    }
    ```
    
    让头节点的next、prev放头节点自己的地址，就得到了基本的双向循环链表。


+ 2）从文件中读取出学生信息，然后保存到链表中

    这一个功能函数与单链表的基本没有区别。

    ```c
    void ReadDataFromFileToList(SNode *hp, const char *fileName)
    {
        FILE *fp = fopen(fileName, "r+"); 
        if(NULL == fp) print_error("fopen");

        Stu stu = {}; //暂存从文件中所读出的数据
        while(1)
        {
            fscanf(fp, "%s %d %c", stu.name, &stu.number, &stu.gender);
            if(feof(fp) != 0) break;
            SNode *nodep = Dou_CreateNode((void *)&stu, sizeof(stu));
            //Dou_HeadInertNode(hp, nodep); //*************
            Dou_TailInertNode(hp, nodep); //*************
        }
        fclose(fp);
    }
    ```

+ 3）将所有学生信息打印显示出来  
    与单链表的没有大区别，唯一不同的是，双链表的遍历结束判断条件变为if(hp == p)  
    ```c
    void ShowList(const DNode *hp)
    {
        DNode *p = hp->next;
        Stu *datap = NULL;

        if(hp == hp->next) printf("链表为空\n");
        else
        {
            while(1)
            {
                if(hp == p) break;  //*************
                datap = (Stu *)p->data;
                printf("%s %d %c\n", datap->name, datap->number, datap->gender); //打印显示
                p = p->next; //指向下一个节点
            }
        }
    }
    ```


+ 4）按照学号查找学生信息
    与单链表的也几乎一样，只不过在单链表中，返回的是找到节点上一个节点的指针，但是在双链表中，找到节点后，会直接返回该节点的指针，因为在双链表中，你要操作那个节点，直接使用该节点的指针即可  

    ```c
    DNode *FindStuByNumber(const DNode *hp)
    {
        DNode *p = hp->next;
        Stu *datap = NULL;
        int number = 0;

        if(hp == hp->next) printf("链表为空\n");
        else
        {
            printf("输入学号\n");
            scanf("%d", &number);
            while(1)
            {
                if(hp == p) break; //判断是否到了末尾 *****************

                datap = (Stu *)p->data; //暂存节点中数据指针
                if(datap->number == number)
                {
                    printf("%s %d %c\n", datap->name, datap->number, datap->gender);//打印节点中的学生信息
                    break;
                }
                p = p->next; //指向下一个节点
            }
        }

        return p;
    }
    ```

+ 5）从键盘输入某个学生数据，然后插入到链表中
    这个与单链表基本一样，只是稍微有点区别
    
    ```c
    void ReadDataFromKeybordToList(DNode *hp)
    {
        int select = 0;
        Stu stu = {};
        DNode *nodep = NULL;
        DNode *temp = NULL;

        printf("请输入学生信息，输入格式为：名字 学号 性别（M/F）\n");
        scanf("%s %d %c", stu.name, &stu.number, &stu.gender);

        /* 创建节点，将数据保存到节点中data所代表的数据空间 */
        nodep = Dou_CreateNode((void *)&stu, sizeof(stu));

        printf("1. 插入链表头部\n");
        printf("2. 插入链尾部\n");
        printf("3. 插入指定位置\n");
        scanf("%d", &select);
        switch(select)
        {
            case 1:
                Dou_HeadInertNode(hp, nodep);
                break;
            case 2:
                Dou_TailInertNode(hp, nodep);
                break;
            case 3:
                ShowList(hp);  //显示所有学生信息，方便查看
                temp = FindStuByNumber(hp);  //查找要插入的位置
                printf("1. 插入到前面\n"); //*************
                printf("2. 插入到后面\n"); //*************
                scanf("%d", &select);      //*************

                if(select == 1)      Dou_InsertNodeBefore(temp, nodep); //*********
                else if(select == 2) Dou_InsertNodeAfter(temp, nodep);  //*********
            default: 
                 printf("无此选项\n");
        }
    }
    ```
    
+ 6）修改学生数据
    与单链表基本一样，仅仅判断条件有所不同，如果FindStuByNumber最终返回的是头节点的指针，就说找了一圈没有找到，又回到了头节点上。

    ```c
    void AlterNode(const DNode *hp)
    {
        DNode *tmp = NULL;
        Stu *datap = NULL;

        tmp = FindStuByNumber(hp); //按照学号查找，找到后返回该节点的指针

        if(tmp == hp) printf("没有找到\n");
        else
        {
            datap = (Stu *)tmp->data;
            printf("输入新信息，格式：名字 学号 性别\n");
            scanf("%s %d %c", datap->name, &datap->number, &datap->gender); //向节点中，重新输入信息
        }
    }
    ```

+ 7）保存链表数据到文件中
    与单链表完全一样，唯一不同的只是判断结束的条件
    
    ```c
    void SaveListToFile(const DNode *hp, const char *fileName)
    {
        DNode *p = hp->next;
        Stu *datap = NULL;

        FILE *fp = fopen(fileName, "w"); 
        if(NULL == fp) print_error("fopen");

        while(1)
        {
            if(hp == p) break;    //判断是否到了末尾
            datap = (Stu *)p->data; //将void *强制转为Stu *
            fprintf(fp, "%s %d %c\n", datap->name, datap->number, datap->gender);//打印节点中的学生信息
            p = p->next; //指向下一个节点
        }
        fclose(fp);	//关闭文件，并将数据从库缓存刷新到文件中
    }
    ```

+ 8）按照学号排序

    排序算法有很多种，比如插入排序、选择排序、冒泡排序、快速排序、希尔排序等等。
    我们这里的重点不是介绍排序算法，在实际的应用开发中，排序算法对我们来说并不重要，所以我们这介绍简单的冒泡排序。
    我们这里讲排序目的就是想向大家演示，如何对链表进行排序。

    实现的从小到大排序：

    ```c
    void BubbleSort(const DNode *hp)
    {
        DNode *p     = NULL; 
        DNode *lastp = hp->prev; //指向最后一个节点
        Stu *datap = NULL;
        Stu *nextNodeDatap = NULL;
        Stu *temp = NULL;

        while(1)
        {
            p = hp->next; //指向第一个数据节点
            if(lastp->prev == hp) break;

            while(1)
            {
                if(p == lastp) break;
                datap = (Stu *)(p->data);
                nextNodeDatap = (Stu *)(p->next->data);
                if((datap->number) > (nextNodeDatap->number))
                {
                    temp = p->next->data;
                    p->next->data = p->data;
                    p->data = temp;
                }
                p = p->next;
            }
            lastp = lastp->prev;
        }
        printf("冒泡排序结束\n");
    }
    ```


+ 9）删除某个学生节点
    与单链表一样  
   
   ```c
    void DeleteStu(const DNode *hp)
    {
        DNode *p = FindStuByNumber(hp);
        Dou_DeleteNode(p);
    }
   ```

+ 10）清空链表（只剩一个空头节点）
    与单链表一样，只不过要删除第一个节点时，在单链表中p要指向头节点，但是在双链表中，p直接指向第一个节点

    ```c
    void EmptyList(const DNode *hp)
    {
        DNode *p = NULL; //*******
        while(1)
        {
             p = hp->next; //指向第一个数据 ********
             if(p == hp) break;  //***********
             Dou_DeleteNode(p);
        }
        printf("链表已被清空\n");
    }
    ```

+ 11）销毁链表（把空头节点也删除掉）
    与单链表完全一样
    
    ```c
    void DestroyList(const DNode *hp)
    {
        EmptyList(hp); //清空链表
        free(hp);
        printf("链表已被销毁\n");
    }
    ```
			
		
### 8.3.3 双链表例程的完整代码

+ 基本操作函数：dList_base_op.h、dList_base_op.c
+ 功能函数：dList.h、dList.c
+ main函数：main.c
	
#### （1）基本操作函数

+ 1）`dList_base_op.h`

    ```c
    #ifndef H_SLIST_BASE_OP_H
    #define H_SLIST_BASE_OP_H
    #include <stdlib.h> //exit函数需要这个头文件

    #define print_error(str) \
    do{\
        fprintf(stderr, "File %s, Line %d, Function %s error\n", __FILE__, __LINE__, str);\
        perror("error Reason");\
        exit(-1);\
    }while(0);

    typedef struct SignalNode  //单链表结构
    {
        void *data;
        struct SignalNode *prev; //指向上一个元素
        struct SignalNode *next; //指向下一个元素
    }DNode;


    extern DNode *Dou_CreateNode(void *data, int dataSize);
    extern void Dou_insertNode(DNode *prev, DNode *next, DNode *nodep);
    extern void Dou_InsertNodeAfter(DNode *p, DNode *nodep);
    extern void Dou_InsertNodeBefore(DNode *p, DNode *nodep);
    extern void Dou_Delete(DNode *prev, DNode *next);
    extern void Dou_DeleteNode(DNode *prevNodep);
    extern void Dou_HeadInertNode(DNode *hp, DNode *node);
    extern void Dou_TailInertNode(DNode *hp, DNode *node);

    #endif
    ```

+ 2）`dList_base_op.c`

    ```c
    #include <stdio.h>
    #include "dList_base_op.h"


    /* 功能：创建节点
     * 参数：
     *      data：指向空间中，存放了要被写入节点的数据
     *          如果data为NULL，就表示没有数据要存入节点，
     *          此时只是一没有数据的空节点
     *
     *      dataSize：数据空间的大小
     *
     * 返回值：返回新节点的指针（结构变量首字节地址）
     */
    DNode *Dou_CreateNode(void *data, int dataSize)
    {
        /* malloc开辟节点空间 */
        DNode *p = (DNode *)malloc(sizeof(DNode));
        if(NULL == p) print_error("malloc");

        //让prev、next默认指向空
        p->prev = p->next = NULL;

        /* malloc开辟节点中的数据空间，然后存入数据
         * 有数据才开辟，没有数据就不用开辟了
        */
        if(NULL != data)
        {
            p->data = malloc(dataSize);
            if(NULL == p) print_error("malloc");

            //前面的课程就说过，结构体变量之间是可以整体复值的
            memcpy(p->data, data, dataSize);
        }

        return p;
    }

    /* 功能：将新节点插入到前后两个节点之前
     * 参数：
     *   prev：前一个节点的指针
     *   next：后一个节点的指针
     *   nodep：新节点的指针
     *
     * 返回值：无
     */
    void Dou_insertNode(DNode *prev, DNode *next, DNode *nodep)
    {
        //新节点与后一个节点相互发生指向
        nodep->next = next;
        next->prev = nodep;

        //新节点与前一个节点相互发生指向
        nodep->prev = prev;
        prev->next = nodep;
    }

    /* 功能：将新节点nodep，插入到p所指向节点的后面
    */
    void Dou_InsertNodeAfter(DNode *p, DNode *nodep)
    {
        Dou_insertNode(p, p->next, nodep);
    }

    /* 功能：将新节点nodep，插入到p所指向节点的前面
    */
    void Dou_InsertNodeBefore(DNode *p, DNode *nodep)
    {
        Dou_insertNode(p->prev, p, nodep);
    }

    /* 功能：插入到链表头部，也就是插到头节点的后面
     * hp：头节点指针
     * nodep：新节点的指针
     * 返回值：无
     */
    void Dou_HeadInertNode(DNode *hp, DNode *nodep)
    {
        Dou_InsertNodeAfter(hp, nodep); //插入到头节点的后面
    }

    /* 功能：插入链表尾部，也就是插到头节点的前面
     * hp：头节点指针
     * nodep：新节点的指针
     * 返回值：无
     */
    void Dou_TailInertNode(DNode *hp, DNode *nodep)
    {
        Dou_InsertNodeBefore(hp, nodep); //插入到头节点的前面
    }

    /* 功能：删除两个节点之前的节点
     * 参数：
     *    prev：前一个节点的指针
     *    next：后一个节点的指针
     * 返回值：无
    */
    void Dou_Delete(DNode *prev, DNode *next)
    {
        prev->next = next;
        next->prev = prev;
    }

    /* 功能：删除某个节点
     * 参数：
     *    p：要删除节点的指针
     * 返回值：无
    */
    void Dou_DeleteNode(DNode *p)
    {
        /* 删除节点 */
        Dou_Delete(p->prev, p->next);

        /* 释放节点空间 */
        if(NULL != p->data)
                free(p->data);//释放节点的数据空间
        p->data = NULL; //不要让遗留的随机值（节点指针），干扰下一次的空间使用
        p->prev = p->next = NULL;

        free(p); //释放节点空间
        p = NULL;
    }
    ```
		
#### （2）功能函数

+ 1）dList.h

   ```c
    #ifndef H_SLIST_H
    #define H_SLIST_H
    #include "dList_base_op.h"

    /* 学生结构体(存放数据的结构体) */
    typedef struct Student
    {
        char name[40];
        int  number;
        char gender;
    }Stu;

    /* 功能函数的声明 */
    extern void createList(DNode **hpp);
    extern void ReadDataFromFileToList(DNode *hp, const char *fileName);
    extern void ShowList(const DNode *hp);
    extern DNode *FindStuByNumber(const DNode *hp);
    extern void ReadDataFromKeybordToList(DNode *hp);
    extern void AlterNode(const DNode *hp);
    extern void SaveListToFile(const DNode *hp, const char *fileName);
    extern void DeleteStu(const DNode *hp);
    extern void EmptyList(const DNode *hp);
    extern void DestroyList(const DNode *hp);

    #endif
   ```

+ 2）dList.c
    
    ```c
    #include <stdio.h>
    #include "dList.h"

    /* 功能：创建一个空链表
     * 参数：
     *      hpp：头指针变量的指针（地址）
     * 返回值：无
     */
    void createList(DNode **hpp)
    {
        //创建一个空间点作为头节点，由于空节点没有数据，所以参数传NULL和0
        *hpp = Dou_CreateNode(NULL, 0);

        //保险起见，给头节点next、prev放自己的地址
        //如此就做成了双向循环链表
        (*hpp)->next = (*hpp)->prev = *hpp;
    }

    /* 功能：读取文件中的学生信息，然后保存到单链表中
     *       如果文件中没有数据，链表就是一个空链表，我们可以选择从键盘输入学生数据
     * 参数：
     *      hp：头指针变量
     * 返回值：无
     */
    void ReadDataFromFileToList(DNode *hp, const char *fileName)
    {
        /* 打开存放学生信息的文件 */
        FILE *fp = fopen(fileName, "r+"); //FILE_PATH定义在了sList.h中
        if(NULL == fp) print_error("fopen");

        /* 循环读取文件内容，每读出一条，就存入创建的节点中
         * feof函数检测读到文件末尾时，就退出循环
        */
        Stu stu = {}; //暂存读出的数据
        while(1)
        {
            /* 格式化读文件，每次只读出一条，name是数组，就不要再&取地址了 */
            fscanf(fp, "%s %d %c", stu.name, &stu.number, &stu.gender);

            /* feof返回非零时，就表示读到末尾了，然后退出循环 */
            if(feof(fp) != 0) break;

            /* 创建节点，将数据保存到节点中data所代表的数据空间 */
            DNode *nodep = Dou_CreateNode((void *)&stu, sizeof(stu));

            /* 将节点插入链表，我们这里选择都在链表头部插入 */
            Dou_TailInertNode(hp, nodep);
        }

        fclose(fp);
    }


    /* 功能：遍历每一个节点，并打印出每个节点的学生数据
     * 参数：
     *   hp：头指针
     * 返回值：无
     */
    void ShowList(const DNode *hp)
    {
        DNode *p = hp->next;
        Stu *datap = NULL;

        if(hp == p) printf("链表为空\n");
        else
        {
            /* 遍历链表，找到每个节点，打印学生信息 */
            while(1)
            {
                if(hp == p) break; //如果p指向了头节点，表示遍历结束了
                datap = (Stu *)p->data; //将void *强制转为Stu *
                printf("%s %d %c\n", datap->name, datap->number, datap->gender);//打印节点中的学生信息
                p = p->next; //指向下一个节点
            }
        }
    }

    /* 功能：遍历链表，通过学号查找学生信息
     * 参数：
     *   hp：头指针
     *   number：要查找的学号
     * 返回值：无
     */
    DNode *FindStuByNumber(const DNode *hp)
    {
        DNode *p = hp->next;
        Stu *datap = NULL;
        int number = 0;

        if(hp == p) printf("链表为空\n");
        else
        {
            printf("输入学号\n");
            scanf("%d", &number);
            /* 遍历链表，找到每个节点，通过比对学号找到某学生信息 */
            while(1)
            {
                if(hp == p) break;    //判断是否到了末尾

                datap = (Stu *)p->data; //暂存节点中数据指针
                if(datap->number == number)
                {
                    printf("%s %d %c\n", datap->name, datap->number, datap->gender);//打印节点中的学生信息
                    break;
                }
                p = p->next; //指向下一个节点
            }
        }

        return p;
    }

    /* 功能：从键盘输入一条学生信息然后插入链表的头，
     *      当然你也可以插入链表中的任何位置，我们这里简单一点，直接插入到链表头
     * 参数：
     *   hp：头指针
     * 返回值：无
     */
    void ReadDataFromKeybordToList(DNode *hp)
    {
        int select = 0;
        Stu stu = {};
        DNode *nodep = NULL;
        DNode *temp = NULL;

        printf("%s %d %c\n", stu.name, stu.number, stu.gender);
        printf("请输入学生信息，输入格式为：名字 学号 性别（M/F）\n");
        scanf("%s %d %c", stu.name, &stu.number, &stu.gender);

        /* 创建节点，将数据保存到节点中data所代表的数据空间 */
        nodep = Dou_CreateNode((void *)&stu, sizeof(stu));

        printf("1. 插入链表头部\n");
        printf("2. 插入链尾部\n");
        printf("3. 插入指定位置\n");
        scanf("%d", &select);
        switch(select)
        {
            case 1:
                Dou_HeadInertNode(hp, nodep);
                break;
            case 2:
                Dou_TailInertNode(hp, nodep);
                break;
            case 3:
                ShowList(hp);  //显示所有学生信息，方便查看
                temp = FindStuByNumber(hp);  //查找要插入的位置
                printf("1. 插入到前面\n");
                printf("2. 插入到后面\n");
                scanf("%d", &select);
                if(select == 1)      Dou_InsertNodeBefore(temp, nodep);
                else if(select == 2) Dou_InsertNodeAfter(temp, nodep);
            default:
                printf("无此选项\n");
        }
    }

    /* 功能：通过学号找到学生信息，然后修改
     * 参数：
     *   hp：头指针
     *   number：要查找的学号
     * 返回值：无
     */
    void AlterNode(const DNode *hp)
    {
        DNode *tmp = NULL;
        Stu *datap = NULL;

        /* 调用FindStuByNumber函数，
         * 按照学号查找，找到后返回节点指针 */
        tmp = FindStuByNumber(hp);

        if(tmp == hp) printf("没有找到\n");
        else
        {
            //暂存节点中数据空间的指针，以方便操作，不过需要将void *强制转为Stu
            datap = (Stu *)tmp->data;
            printf("输入新信息，格式：名字 学号 性别\n");
            scanf("%s %d %c", datap->name, &datap->number, &datap->gender);
        }
    }

    /* 功能：将链表中的数据保存到文件中
     * 参数：
     *   hp：头指针
     * 返回值：无
     */
    void SaveListToFile(const DNode *hp, const char *fileName)
    {
        DNode *p = hp->next;
        Stu *datap = NULL;

        /* 以w方式打开（只写），并将文件内容清空，清空后
         * 再重新将被修改后的链表中的数据写入文件中 */
        FILE *fp = fopen(fileName, "w");
        if(NULL == fp) print_error("fopen");

        /* 遍历链表，找到每个节点，通过比对学号找到某学生信息 */
        while(1)
        {
            if(hp == p) break;    //判断是否到了末尾
            datap = (Stu *)p->data; //将void *强制转为Stu *
            fprintf(fp, "%s %d %c\n", datap->name, datap->number, datap->gender);//打印节点中的学生信息
            p = p->next; //指向下一个节点
        }
        //关闭文件，并将数据从库缓存刷新到文件中
        fclose(fp);
    }

    /* 功能：删除某个学生信息
     * 参数：
     *   hp：头指针
     * 返回值：无51
     */
    void DeleteStu(const DNode *hp)
    {
        //通过学号找到节点
        DNode *p = FindStuByNumber(hp);

        //删除节点
        Dou_DeleteNode(p);
    }

    /* 功能：删除所有的数据节点，只保留头节点
     * 参数：
     *   hp：头指针
     * 返回值：无
     */
    void EmptyList(const DNode *hp)
    {
        DNode *p = NULL;

        //先删除
        while(1)
        {
             p = hp->next;  //指向第一个数据
             if(p == hp) break;
             Dou_DeleteNode(p);
        }
        printf("链表已被清空\n");
    }

    /* 功能：将数据节点和头节点都删除，整个链表就被销毁了
     * 参数：
     *   hp：头指针
     * 返回值：无
     */
    void DestroyList(const DNode *hp)
    {
        //删除所有数据节点
        EmptyList(hp);

        //删除头节点
        free(hp);
        hp = NULL;
        printf("链表已被删除\n");
    }


    /* 功能：按学号的从小到大排序
     * 参数：hp：头指针
     * 返回值：无
     */
    void BubbleSort(const DNode *hp)
    {
        DNode *p     = NULL; //指向第一个节点
        DNode *lastp = hp->prev; //指向最后一个节点
        Stu *datap = NULL;
        Stu *nextNodeDatap = NULL;
        Stu *temp = NULL;

        while(1)
        {
            if(lastp->prev == hp) break;
            p = hp->next; //指向第一个节点

            while(1)
            {
                if(p == lastp) break;
                datap = (Stu *)(p->data);
                nextNodeDatap = (Stu *)(p->next->data);
                if((datap->number) >= (nextNodeDatap->number))
                {
                        temp = p->next->data;
                        p->next->data = p->data;
                        p->data = temp;
                }
                p = p->next;
            }
            lastp = lastp->prev;
        }
        printf("冒泡排序结束\n");
    }
    ```

+ （3）main.c
    
    ```c
    #include <stdio.h>
    #include "dList.h"

    //文件路径名
    #define FILE_PATH "C:\\Users\\Administrator\\Desktop\\StuFile.txt"

    #define SHOW                1
    #define FIND                2
    #define READ_KEYBORD        3
    #define ALTER               4
    #define SAVE                5
    #define DELETE              6
    #define EMPTY               7
    #define SORT                8
    #define EXIT                9

    /* 功能：交互函数
     * 参数：无
     * 返回值：选择
     */
    int interactive(void)
    {
        printf("1. 打印显示所有信息\n");
        printf("2. 按照学号查找，并打印学生信息\n");
        printf("3. 从键盘输入一条学生信息，然后插入链表\n");
        printf("4. 修改学生信息\n");
        printf("5. 保存链表到文件中\n");
        printf("6. 删除某个学生的信息\n");
        printf("7. 清空链表\n");
        printf("8. 按学号进行从小到大排序\n");
        printf("9. 退出程序，退出前先销毁链表\n");

        int select = 0;
        scanf("%d", &select);

        return select; //返回选择
    }

    int main(void)
    {
        DNode *hp = NULL;

        /* 创建空链表 */
        createList(&hp);

        /* 读取文件数据 */
        ReadDataFromFileToList(hp, FILE_PATH);

        /* 操作链表 */
        while(1)
        {
            //interactive为交互函数
            switch(interactive())
            {
                case SHOW:  //显示所有链表信息
                    ShowList(hp);
                    break;
                case FIND:  //按照学号查找
                    FindStuByNumber(hp);
                    break;
                case READ_KEYBORD:  //从键盘输入信息
                    ReadDataFromKeybordToList(hp);
                    break;
                case ALTER: //修改信息
                    AlterNode(hp);
                    break;
                case SAVE: //保存到文件中
                    SaveListToFile(hp, FILE_PATH);
                    break;
                case DELETE: //删除某个学生
                    DeleteStu(hp);
                    break;
                case EMPTY: //清空链表
                    EmptyList(hp);
                    break;
                case SORT: //清空链表
                    BubbleSort(hp);
                    break;
                case EXIT: //销毁链表
                    DestroyList(hp);
                    printf("退出程序\n");
                    return 0;
                    break;
                default: 
                    printf("无此选项\n");
            }
        }

        return 0;
    }
    ```

## 8.3 “链表例子程序”的健壮性问题

我们所写的链表程序，只是为了演示如何实现链表基本功能，并没有考虑程序的各种需要完善的细节，比如

+ （1）程序输入的健壮性问题  
    输入选择时要求输入整形数，但是如果输入的是a、b、c、d等字母的话，程序就出现问题。
		
+ （2）学号重复的问题
    我们知道学生的学号是不能重复的，所以当你输入学生信息时，应该自动检测是否重复。
	
像以上这些类似的问题我们都没有解决，毕竟这些不是我们的重点。
	
## 8.4 其它的链表操作

+ （1）链表的反序
+ （2）将链表拆分为两个、多个子链表
+ （3）将两个或多个链表合为一个链表
+ （4）等等
		
事实上这些操作只不过是在玩花样而已，事实上你只要将基础的内容掌握了，实现这些都不是问题。
