# 6. 链表

## 6.0 从顺序表的缺点说起

顺序表就是顺序存储的线性表。

顺序存储其实就是使用“数组”来存储的形式，数组的每个元素是顺序的一个挨着一个的空间，使用数组来存储线性表，在结构上是最为契合的，但是顺序表也存在不少的缺点：

仅仅站在存储的角度来说，使用顺序存储来存储线性表时非常合适的，不幸的是存在其它缺点。

### （1）顺序表的缺点1：删除、添加元素时，元素的移动很麻烦。

顺序表其实就是一个数组，我们以前使用数组时用的都很简单，不涉及到删除、添加元素的操作，实际上对数组进行删除、添加元素时，是一件比较麻烦的事情。

当删除和添加的位置越靠前时，所需要移动的元素就越多，如果总共有200个元素的话，将第一个元素删除后，后面199个元素都需要向前移动一个位置，很麻烦。图：

### （2）顺序表的缺点2：不利于 利用“内存碎片”。

在内存中开辟顺序表空间时，由于内存碎片空间太小了，很难被顺序表用起来，除非顺序表很小，但是顺序表的空间一般都是一整块的大容量空间。

其实有关顺序表我们是使用过的，我们在第7章讲“结构体内嵌函数指针”的例程时，当时我们存放学生和老师信息所用的数组其实就是顺序表，只不过当时不涉及到添加和删除元素，用的比较简单。

当时的老师信息和学生信息是线性表，把线性表存入数组后，数组就是为顺序表。

如果数组存放的逻辑结构为树形结构（二叉树）的数据话，数组就是顺序二叉树。

数组作为顺序存储来说，可以存放任何逻辑结构的数据。

正是由于顺序表存在以上所描述的缺点，后来才有了链表这个东西，链表可以很好的解决顺序表的以上两个缺点。

## 6.1 什么是链表

链式存储的线性表就是链表。

+ 链表的逻辑结构：线性结构
+ 链表的存储结构：链式存储结构

## 6.2 链式存储的特点

元素之间不需要紧挨着，只需要使用指针指向前后元素即可。图：

### （1）链式存储方式的优点：

+ 1）由于元素之间不需要紧挨着，所以不需要大片内存空间，能够很好的利用内存碎片

+ 2）删除、添加元素时，无需大批量的移动元素空间的内容，只需要修改指针指向即可。

### （2）链表的缺点

缺点就是每个元素必须要多开辟出存放指针的空间。不过这个缺点与链表本身的优点相比，可以忽略。

正是由于链表的明显优点，所以相比顺序表来说，链表使用的更加广泛。

## 6.3 链表的元素结构

> 链表的每个元素都是使用结构体来封装的，元素内部分为两部分，数据部分和指针部分。

### （1）单链表（单向链表）

```c
typedef struct SignalNode  //单链表的节点结构体，链表节点就是链表元素
{
    void *data; //指向存放数据的空间，具体指向什么样的数据空间，需要根据情况来定
    struct SignalNode *next; //存放后继节点指针，指向下一个元素
} SNode, *SNodep;
```

使用typedef的目的，主要是想让名字变的更简洁。

### （2）双链表（双向链表）

```c
typedef struct DoubleNode  //单链表结构
{
    void *data;  //指向存放数据的空间
    struct DoubleNode *prev; //存放前继节点指针，指向上一个元素
    struct DoubleNode *next; //存放后继节点指针，指向下一个元素（节点）
}DNode, *DNodep;
```

### （3）结构体内嵌自己类型时，需要注意的地方

我们举例说明：

+ 1）例子1

  ```c
  typedef struct DoubleNode  
  {
      void *data;
      struct DoubleNode dDode;  
  
  }DNode, *DNodep;
  ```
  
  报错如下：
  
  ```shell
   dnode.c:6:21: error: field 'dDode' has incomplete type
   struct DoubleNode dDode;  
                     ^
  ```

  直接内嵌定义一个自己类型的结构体变量肯定是不行的，因为struct DoubleNode类型还没有定义完成，不知道结构体类型的大小，编译时肯定会报错  
  
  用指针就不会存在这种问题，因为指针允许先于定义完成前存在  

+ 2）例子2

  ```c
  typedef struct DoubleNode  
  {
      void *data;
      struct DoubleNode *dDode;  
  }DNode, *DNodep;
  ```

  内嵌自己这个类型，定义一个指针变量确是可以的，因为我们在前面的章节就讲过，指针的宽度都是固定的，所以指针类型的大小都是固定的，编译时可以通过。

+ 3）例子3

  ```c
  typedef struct DoubleNode  
  {
      void *data;
      DNodep dDode;  
  }DNode, *DNodep;
  ```
  
  DNodep在后面，所以`在里面是不能使用typedef后的DNodep和DNode *`，只能使用struct DoubleNode。
  报错如下：
  ```shell
  dnode.c:6:3: error: unknown type name 'DNodep'
   DNodep dDode;  
   ^
  ```

### （4）从哪里开辟链表的元素空间(节点空间)

节点空间就是一个结构体变量空间，我们知道在.data、.bss、栈、堆都是可以开辟变量空间

**由于链表删除、添加频繁，为了方便操作，我们选择从`堆`中开辟链表的每个“节点空间”**，比如：

```c
SNode *p = (SNode *)malloc(sizeof(SNode));
if(NULL == p) print_error("malloc");
```

## 6.4 链表的具体课程内容

链表是本章的重点，我们打算分如下几部分来讲。

+ （1）单链表
+ （2）双链表
+ （3）Linux内核链表
+ （4）c++/java中的链表
