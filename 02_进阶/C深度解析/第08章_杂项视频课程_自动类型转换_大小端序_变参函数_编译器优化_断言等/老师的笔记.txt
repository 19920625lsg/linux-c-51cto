第8章：杂项 —— c语言中值得被关注的细节问题	

0. 数据溢出（数值范围和补码）
1. 自动类型转换
2. 大小端序
3. 逗号表达式
4. typedef	
   ***_t time_t
	 
5. 字节、字、半字，位宽

6. 编译器优化
		介绍编译器优化时，我们会花大量的篇幅对volatile关键字进行全面而且深入的介绍，特别是在嵌入式开发中，
	volatile属于经常使用关键字，因此必须掌握，而且在嵌入式面试中，volatile基本属于必考题目，而且volatile确
	实不是就很好理解，很多同学在网上搜索volatile资料时，很多也讲的是是而非，做volatile面试题时，大多同学
	都会做错，因此我们决心将volatile完全讲清楚
	
		而且在java等语言中，同样有volatile关键字，而且作用都是类似的，因此深入的理解c的volatile，理解java的
	volatile将会很简单，毕竟知识点都是相通的，而且java的语法本身就是从c --而得到。

7. extern "C"

8. 程序调试

9. 可变参函数、可变参宏、do{}while(0)的妙用

10. c内嵌汇编（内联汇编）

11. 调试版 与 发行版程序

12. 控制台程序 和 Application程序	

13. 断言
	
	
	
0. 数据溢出（数值范围和补码）
	本小节不仅仅只是介绍数据溢出，还会借此介绍整形的数值范围、补码、有符号与无符号等问题。

0.1. 面试题：指出如下代码的问题
	#define MAX 255
	
	int main(void)
	{
		unsigned char A[MAX],i;  //i被定义为unsigned char

		for (i=0; i<=MAX; i++)
			 A[i]=i;
	}
	
	
0.2 unsigned char的数值范围和数据溢出
0.2.1 数值范围
		i的类型为unsigned char，最高位不再用来表示符号，而是直接参与数值的表示，所unsigned char所允许
	的数值范围为：
		76543210  位编号
	 
		11111111  255     2的8次方-1，即100000000-1 
		11111110  254
		...
		00000001  1
		00000000  0      
																 
	所以，unsigned char类型的数值范围为：0 ~ 2的8次方-1（或者 0~255）
				
	不要去记数值范围，记是记不住的，关键是理解，只要理解了，随时可以推算出来。
	
	
0.2.2 unsigned char的数据溢出
（1）向上溢出
		 11111111 + 1  进位溢出
		100000000      由于char只有8位，最高位被舍弃，所以结果为00000000
		
		向上溢出变为了最小数0。
	
（2）向下溢出
		 00000000 - 1  借位溢出
		 11111111      借位向下溢出后，结果为11111111
		 
		向下溢出变为了最大数255。

（3）题目存在的问题	
		for (i=0; i<=MAX; i++)
			 A[i]=i;
		题目中for循环的i<=MAX是不成立的，因为i是unsigned char，它的数值范围为
			11111111  255     2的8次方-1，即100000000-1 
			...
			00000000  0 
		
		当i++到255后就会向上溢出为0，而MAX为255，所以i永远不存在大于255的情况，所以是一个死循环。


0.3 char的数值范围 和 数据溢出
 	 一般情况下，char默认就是signed char，但是也有极少数编译器比较特殊，char会被默认理解为unsigned char，
 有符号char必须明确的写为signed char，signed不能省略，不过这种情况很少，一般char都是默认为signed char。
	 
0.3.1 数值范围 
	char为有符号，最高位用于表示符号（1表示负数、0表示正数），不参与数值的表示，所以真正表示数据的只有7位。
	 符
	 号
	 位
		76543210

		01111111  127    2的7次方-1  即 10000000-1 
		01111110  126
		...
		00000011  3
		00000010  2
		00000001  1
		
		00000000  0     -------------------------
		
		11111111  -1     
		11111110  -2
		11111101  -3
		...				
		10000010  -126
		10000001  -127
		10000000  -128  -2的7次方
		
		char的数值范围：-2的7次方 ~ 2的7次方-1（-128 ~ 127）。
		
		有关char的数值范围，同样不要去记忆，关键是理解，只要理解了就能推导出来。
		
		疑问：为什么在计算机有符号数（char）中，11111111就代表-1、11111110就代表-2？
		答：这个涉及到了计算机存储数据时的补码问题，有关补码后面再介绍。
	
	
0.3.2 char型数据溢出 
		01111111  127    2的7次方-1  即 10000000-1 
		01111110  126
		...				
		00000000  0
		...				
		10000010  -126
		10000001  -127
		10000000  -128  -2的7次方

	1）向上溢出
		01111111+1   
		10000000     -128，在计算机有符号char中，10000000就代表-128
		
		所以同样的，最大数向上溢出，就变为了最小数。
		
		
	2）向下溢出	
		10000000-1
		01111111     为127，在计算机有符号char中，01111111就代表127
		
		与unsigned char一样，最大数向上溢出就变为了最小的数，最小的数向下溢出就变为了最大的数。
		
		
			
0.4 unsigned int、int的数值范围 与 数据溢出
0.4.1 回顾unsigned char和char
		char位数：8bit
		
	· unsigned char的数值范围
		0 ~ 2的8次方-1
	
	· char范围
		-2的7次方  ~  2的7次方-1 

	· 溢出
		 最小变最大，最大边最小。
		
		
0.4.2 unsigned int与int	
	 int位数：32bit
	
	· unsigned int的范围
		0 ~ 2的32次方-1
	   11111111 1111111 1111111 1111111   2的32次方-1
		 ..
		 00000000 0000000 0000000 0000000    0
	   
	· int的范围
		-2的31次方  ~  2的31次方-1 
		01111111 1111111 1111111 1111111    2的31次方-1
		...
		00000000 0000000 0000000 0000000    0   -----------
		11111111 1111111 1111111 1111111    -1
		...
		10000000 0000000 0000000 0000000   	-2的31次方
		
	· 溢出
		 最小变最大，最大边最小。

		 
0.4.3 short、long
		同样的道理，short、long也是一样的，只是位数不一样而已。
		
		通过以上介绍可知，只要大家理解了char、unsigned char的数值范围和数据溢出，int、unsigned int、
	short、unsigned short、...等的数值范围和数据溢出，也可以非常容易的被类推出来。	
		
	
0.5 计算机数据存储————补码

0.5.1 回顾char的数值范围
		01111111  127    2的7次方-1  即 10000000-1 
		...
		00000011  3
		00000010  2
		00000001  1
		
		00000000  0     -------------------------
		
		11111111  -1     
		11111110  -2
		11111101  -3
		...				
		10000000  -128  -2的7次方
		
		为什么在计算机的有符号数中11111111代表-1，11111110代表-2？
		答：因为计算机是使用补码来表示负数的，对于有符号char来说，在计算机看来11111111就是-1，11111110就是-2，
			10000000就是-128。
			
0.5.1 补码
	计算机存储数据时，是以补码形式存储的：
	
	正数的补码：就是自己，也就是说计算机存储正数补码时，存储的就是正数本身。
	
	负数的补码：绝对值取反+1，计算机存储负数时，存储的就是“绝对值取反+1”这个补码，在计算机中这个补码就
					代表这个负数。
		
		
（1）-1在计算机中存储时，存储的补码是多少

		 我们假设为char型。
		 
		 00000001  |-1| ~
		 11111110  +  
		        1   
		 11111111   
		
		存储的-1补码为11111111。
		
		
（2）-2在计算机中存储时，存储的补码是多少
		 我们假设为char型。
		 
		 00000010  |-2| ~
		 11111101  + 
            1   		 
		 11111110   
		 
		 存储的-2补码为11111110。

（3）得到了某个补码后，如何知道这个补码表示的是-?

		比如补码为11101100，假设还是为char类型，那么它所代表的是-？。?
		
		
					 取绝对值            取反  +1
		-？————————————————> ？ ——————————————>  11101100
		
		反推:
								-1  取反             加上-
		11101100 ————————————————> ？————————————>  -？ 
		
							 -1 取反                   加上-
		11101100 ——————————>00010100（20）———————————> -20

			
		所以在计算机有符号数（char）中，补码11101100代表的就是-20，11101100是计算机理解的-20，-20这个是人
	以理解的样子。
				
		计算机在显示器上显示-20这个图形给我们人识别时，就是这样先反推出“绝对值”，然后给绝对值加上-，然后再以
	人类所能识别的图形-20显示出来。
	 
	 
	 
（4） 计算机存储补码有什么好处

		提问：同一个有符号数的正数补码+负数补码 = ？
		为了描述的方便，我们还是以char型来讲解。
	
		1）5的补码：就是本身00000101，计算机存储5时，存储的就是这个数。
		2）-5的补码：11111011，计算机存储-5时，存储的就是这个数。

		3）5+(-5)
		
			计算机其实就是将5和-5的补码相加。
			
					5  00000101 
				 -5  11111011
						100000000 
						 00000000  char型只允许8bit有效，将溢出位去掉，结果为0。					
					
			这不就是实现了同一个数的正负数相加等于0吗，这就存储补码的好处，正数补码+负数补码 = 0。
					
			对于人来说，5+(-5)=0属于数学规则，人们只要一看到这个表达式就知道结果为0，但是对于计算机来说不可能
		通过感觉来计算，它必须要有具体的实现规则，这个规则就是正数、负数补码相加==0。
		
		
		
0.5.3 对于二进制数11011011来说，如果是char类型的话，它所代表的十进制数是多少？如果是unsigned char的话，
	它所代表的十进制数又是多少？

		对于同一个二进制数，因为有符号和无符号的区分，导致所代表的十进制数可能会截然不同。
		
		
（1）如果该二进制数的类型为char(signed char)
		最高位为符号位，1表示负数，0表示正数。
		
		11011011的最高位为1，表示它是负数的补码，所以表示的十进制数是一个负数，至于是-？，我们需要反推之
	后才知道。
		             -1  取反                          加上- 
		11011011——————————————————> 00100101（?37?）————————————>  -37

		所以，如果11011011的类型为char的话，代表的十进制数是-37。
		
		
（2）如果该二进制数的类型为unsigned char 
		最高位不再是符号位，最高位也用于表示数值，整个数就是一个正数的补码，我们前面说过，正数的补码就是正
	数本身，因此这个二进制数直接所对应的十进制，就是它所代表的十进制数。
		                          												
		11011011 ——————————————> ?219?
		
		因此，当二进制数11011011的类型为unsigned char，代表的是十进制数219。
	
	
（3）例子：int a= -20，unsgined int b = a;，请问a和b各自代表的十进制数是多少？
		
		请一定要理解这个例子，我们后面讲自动类型转换时，会牵涉到这个例子。
					
					
		1）a所代表的十进制数是多少？
			
			计算机存放-20时，存放的是-20的补码。
			
			         取反 + 1               补码：实际存储的内容
			|-20|  ——————————————>11111111 11111111 11111111 11101100
	
		
			由于a的类型为int（有符号），数据的最高位为符号位，最高位为1，表示它是负数的补码，
		因此11111111 11111111 11111111 11101100所表示的十进制数是一个负数，通过反推可知，为-20。
		 
		 
		2）unsgined int b = a
			通过初始化，a中的11111111 11111111 11111111 11101100被复制到了b中，还是那个二进制数，但是由于b
		的类型为unsgined int，因此会以unsgined int去解释这个数。
		
			此时最高位不再是符号位，整个二进制数就是正数的补码，因此这个二进制数代表的是一个非常大的正数
		?4294967276?。
				
				
	再次总结，对于同一个二进制数来说，由于有符号与无符号的区分，它所代表的十进制数可能会截然不同。
		
1. 自动类型转换
1.1 先看一个选择题
	int main(void)
	{
			unsigned int a = 100;
			
			while(a>-1)
			{
					--a;
			}

			printf("%d\n", a);

			return 0;
	}
	pritnf打印的结果是多少：
	
	A -1 　　B 100 	   C 0 		 D 死循环
	
	这道题的正确答案是B，那么为什么选B呢？
	这道题的实际情况是，条件a>-1根本不成立，while循环不会进去，所以a的值任然还是100。
	
	很多同学可能都做错了，做错的原因就是因为对“自动类型转换”不理解而导致的，接下来我们就来详细的讲一讲
“自动类型转换”是个啥，为什么条件a>-1根本就不会成立，“自动类型转换”对a>-1到底有什么影响。
	
1.2 回顾“强制类型转换”
	强制类型转换分为两种，一种是“隐式强制类型转换”，另一种是“显示强制类型转换”使用。
	
（1）什么时候会使用“隐式强制类型转换”
	
	· 使用=来初始化和赋值时，当左值类型与右值类型不一致时
	· 进行函数传参，当实参与形参的类型不一致时
	· 函数返回“返回值”，当返回值与返回类型不一致时
	
		一般来说我们不建议进行“隐式强制类型转换”，因为可能会导致很多的警告，我们都建议进行明确的
	“显示强制类型转换”。

（2）自动类型转换
		本小节要介绍的“自动类型转换”，虽然也是类型之间的转换，但是与“强制类型转换”并不一样。

		
1.3 进行算数、关系、位运算时的自动类型转换
	在进行算数、关系、位运算时，“运算数”的类型不可能完全相同，进行运算时必须转换为同一类型后才能运算。
	比如：
		char a = 'a';
		short b = 20;
		int c = 10;
	
		a * b + c; 		//a b c的类型不一致，进行算数运算时，必须进行类型统一后才能运算
	  
		if(a > c)		 	//a c的类不一致，进行关系运算时，同样也需要进行类型统一后才能运算
			
		像例子中这种进行类型统一的类型转换，就是自动类型转换。自动类型转换顾名思义，就是自动完成的。
		
		
1.3 自动类型转换的规则			
																																	
	· 总体原则：低类型向高类型转换、有符号向无符号转换
			char、short————>int————>unsigned int————>long————>unsigned long————>double
                                                                            ^
																																				    |
																																			    float
	· 当有char、short参与运算时，会先自动转为int，然后再参与运算		
	
	· 当有浮点参与运算时，所有类型都会自动转成double，然后参与运算
	
		仅仅看三条规则，估计大家看不懂是什么意思，不过没关系，我们介绍完后面的例子后，大家自然就能理解了。
		
		
（0）例子0
		char a 	= 20;
		short b = 30;
		char c;
		
		c = a + b;
		       
		a从char————>int，b从short————>int，然后再相加，a + b相加后结果的类型为int。
		赋值给c时，再将int隐式强制转换为char，然后再赋值给c。
			
			
（1）例子1
		char a ='a';
		short i = 1;
		long  k = 20;
		float f = 23.1;
		int result;
			
		result=(a/i+k)+(f*a-i);
		
		1）(a/i+k)：
		（a）a/i：a、i从char和short———>int，然后相除，a/i的结果为int
		（b）a/i+k：a/i的结果为int，k为long，因此a/i结果会从int———>long后，再与k相加，因此(a/i+k)结果就为long。
		
		2）(f*a-i)
		（a）f*a
				·  a————>int
				· f为float，有浮点参与运算，因此f、a————>double，然后再相乘，相乘的结果为double
		
		（c）f*a-i
				· i从short——>int
				· f*a的结果为double，所以i又从int————>double，然后再相减
				
				(f*a-i)结果的类型最后就为double。
		
		
		3）(a/i+k)与(f*a-i)相加
				(a/i+k)的结果为long，(f*a-i)的结果为double，所以前者从long————>double后，然就再相加。
				
				(a/i+k)+(f*a-i)的结果为double，再隐式强制转换为int，然后赋值给result。

			
（2）例子2
		char a ='a';
		short i = 1;
		unsigned int d = 20;
		long int k = 20;
		unsigned long int f = 304;
		char result;
				
		result = a*i*d + k + f + 12.3;
		
		1）a*i*d
			a、i—从char、short———>int，然后相乘。
			a*i的类型为int，d为unsigned int，a*i———>unsigned int，然后与d相乘
		
		2）a*i*d +k
			a*i*d为unsigned int，k为long，a*i*d————>long，然后与k相加
		
		3）a*i*d +k + f
			a*i*d +k为long类型，f为unsigned long，a*i*d+k————>unsigned long，然后相加
			
		4）a*i*d +k + f + 12.3
			a*i*d +k + f为unsigned long，常数12.3为double，a*i*d+k+f————>转为double，然后再与12.3相加
			
			最后整个的结果为double，赋值给result时，会隐式强制转换为char。
		
		
					char、short————>int————>unsigned int————>long————>unsigned long————>double
                                                                            ^
																																				    |
																																			    float		
（3）例子3	
		char a=10;
		short b=20;
		
		if(a > b)
		{
			
		}
		a、b————>int，然后进行比较
		
		
		
		
		
（4）例子4
			unsigned int a = 100;
			
			while(a>-1)
			{
					--a;
			}

			printf("%d\n", a);
		
		这个就是前面的那个例子。
		
		-1的类型默认为int，在计算机中存储时存储的是补码。
					    取反  +  1                  -1的补码
		|-1| ————————————————————> 11111111 11111111 11111111 11111111 
		

		由于a的类型为unsigned int，而-1的类型为int，根据自动类型转换规则，-1的类型会从int转换unsigned int，
	因此会以unsigned int来解释11111111 11111111 11111111 11111111，最高位不再是符号位，此时
	11111111 11111111 11111111 11111111为正数的补码，由于正数的补码就是本身，因此代表的是一个非常大的
	正数?4294967295?。
			while(a>-1) 其实为 	while(a>?4294967295)
		
		a的类型为unsigned int，值为100，100不可能>4294967295，因此不条件不成立，根本不会进入while循环，因此
	a的值还是100，所以打印结果100。
		
	注意：
		1）表达式中的整数比如-1，默认为int型
				例外：123L，这个表示long，L为long的意思
		
		2）表达中的浮点数比如12.45，默认为double
			int a = 10;
			a + 12.45; //a从int————>double，然后与12.45相加
		
			例外：12.45f，表示为float型，f就是float的意思
			
			
（3）例子5
		在& | ~的位运算中，同样会涉及到自动类型转换的问题，到下一章讲“位操作”时我们再介绍。
	
	
1.4 自动类型转换陷阱
		前面的while(a>-1)，按照正常的逻辑思维来说，肯定是希望进入while循环的，但是最终因为“自动类型转换”
	导致了条件的不成立，这种因为“自动类型转换”而导致的问题，我们就常称为“自动类型转换陷阱”。
		我们这里再看一个例子。
		
	unsigned int a = 6;

	int b = -10;

	if((a+b) > 6)
	{
		printf(" > \n");
	}	
	else 
	{
		printf(" < \n");
	}
	
	一般理解：(a+b) > 6 为 6 + -10 > 6，条件不成立，执行else中得printf语句，输出 < 。  
			
	但是实际情况是：
		在b中存储-6时，存储的是补码。
		        取反 +1
		|-6|————————————————> 111111111 11111111 11111111 11110101
			
		a的类型为unsigned int，而b为int，根据自动类型转换的规则，b会用从int变为unsigned int，此时b中
	111111111 11111111 11111111 11110101不在表示-6，而是一个非常大的数?4294967285?，因此
	(a+b) > 6成立，输出结果为 > 。
	
	
1.5 强制类型转换 与 自动类型转换 的区别		
1.5.1 强制类型转换
		不管是隐式强制类型转换，还是显式强制类型转换，在大部分类型之间都可以进行强制类型转换，不过将高类型转
	为低类型时，往往可能会丢失数据。

		int a =3435345345;
		char b = a; //会丢失“高三个字节”的数据
		
		
		
1.5.2 自动类型转换                     
		char、short————>int————>unsigned int————>long————>unsigned long————>double
                                                                          A
																																					|
																																				float
	
	我们从自动类型转换的规则可以的看出，自动类型的最大特点为，转换方向是从低类型向高类型转换，保证不会丢失
数据。
	
	就算是int ————> 转为unsigned int，顶多就是解释方式变化了，但是空间中所放的二进制数并没有变化。
	
	比如，-1在计算机中为11111...1111，-1————>unsigned后，二级制数据还是11111...1111，只不过解释方式不一样了
而已，作为有符号时代表的是-1，而作为无符号时代表的是一个很大的数据。
	
	在有些书上，往往会将“隐式强制转换” 也归类为“自动类型转换”的一种，但是我们这边不这么归类，因为通过前
面的描述可以看出，“强制类型转换“和“自动类型转换”还是着明显区别的。
		
		
2. 大小端序

2.1 MSB和LSB		
	在理解大小端序之前，我们先要理解什么是MSB，什么是LSB。
	数据在计算机中都是以二进制形式存在的，二进制数的最高为就是MSB，最低位就是LSB。
							
							int
		比如以0x23456334为例：
		
		它的二进制：00100011010001010110001100110100                       
 								|                              |
							 MSB                           LSB
							 
		MSB：Most Significant Bit（最高有效位），也就是最高位，最左侧的bit
		LSB：Least Significant Bit（最低有效位），也就是最低位，最右侧的bit
		
		
2.2 存储空间的高地址字节 与 低地址字节
	除了char外，其它类型的变量空间基本都有很多个字节，比如int的变量空间为4个字节，每个字节都有自己的地址。
	图1：
		
	
	地址最小的为低地址字节，地址最大的为高地址字节。	
	
	
	
2.3 大端序存储和小端序存储
	还是以0x23456334为例：	
	
	              0x23     0x45     0x63     0x34 
	它的二进制：00100011 01000101 01100011 00110100                          
 							|                                 |
						 MSB                               LSB
							 
	大端序存储：数据中MSB所在的字节存储在低地址字节空间，数据中LSB所在字节存储在高地址字节空间。
	图：
	
	
	小端序存储：与大端序刚好相反，数据中MSB所在的字节存储在高地址字节空间，数据中LSB所在字节存储在低地址
							字节空间。
	图3：
		

		计算机采用哪种端序来存储数据其实都无所谓，都能正确存取数据，我们程序员并不需要操心，不过我们需要了解
	这个大小端序这个概念。
	
	现在计算机的存储端序并没有统一的存储标准，有些是大端序的，有些则是小端序的。
	一般来说，如果Intel或AMD CPU，基本都是小端序的。
	ARM、PowerPC CPU则不一定，有些是大端的，有些是小端的。
	
			
2.4 测试计算机的大小端序
		我们可以测试自己电脑的大小端序，测试方式有好些种，我们这仅介绍一种即可，溺水三千只需一瓢而饮，那么多
	种方法，我们只需要知道一种即可。我们的个人电脑基本都是Intel的cpu，不出意外的话应该是小端序的。
	
（1）使用“联合体”来测试
			#include <stdio.h>

			union un
			{
					int a;
					char b;
			}test;

			int main(void)
			{
					test.a = 0x12345678;     //  0x12     0x34     0x56     0x78
					printf("%x\n", test.b);  //?00010010 00110100 01010110 01111000?
					
					if(test.b == 0x78)
					{
							printf("Little-endain：LSB in low Byte\n");
					}
					else if(test.b == 0x12)
					{
							printf("Big-endain：MSB in low Byte\n");
					}

					return 0;
			}

			打印结果：Little-endain：LSB in low Byte，为小端序存储。
			
			测试原理：
				a有四个字节，b只有一个字节，联合体的大小最大成员a的大小，a和b共用联合体空间时，都是从低地址字节
			空间开始共用空间的。
				图4：
				
				大端序存放时：0x12就应该在低地址字节中，通过b访问以char类型来解释空间时，读到的数据就是0x12。
				小端序存放时：0x78放在了低地址字节中，通过b访问以char类型来解释空间时，读到的数据就是0x78。
				图5：
				


2.5 通信中的大小端序
		通信时与存储无关，只与数据的传输有关，我们这里说的通信默认指都是串行通信，因为只有串行通信才存在
	“通信大小端”的问题。
	
	
	我们还是以0x23456334为例：	
	
	              0x23     0x45     0x63     0x34 
	它的二进制：00100011 01000101 01100011 00110100                   
 							|                                 |
						 MSB                               LSB
	
（1）通信大端序
		串行传输时，如果先从MSB开始发送，这就是通信的大端序。
		
		通信大端序由于是MSB先被发送，因此也被称为MSB先行。
		
		
（2）通信小端序
		串行传输时，如果先从LSB开始发送，这就是通信的小端序。
		
		通信小端序由于是LSB先被发送，因此也被称为LSB先行。
		
	我们在学习单片机/嵌入式的SPI、I2C、USB、网络通信时，底层硬件在收发数据时就会涉及到MSB先行和LSB先行
的问题，所以了解通信大小端序是有意义的。
	
	
3. 逗号表达式
3.1 逗号表达式的语法
	直接通过例子来介绍。
	
	int a = 10;
	int b = 20;
	int c;
	
	c = (a+10, b=a+100, sin(b)); 
	
	其中a+10, b=a+100, sin(b)为逗号表达式：
	· 逗号表达式的计算顺序为从左到右，依次进行。
	· 整个逗号表达式的值为最后一表达式的值，所c中放的为sin(b)的计算结果。
	
	当然并不是所有有,的地方都是逗号表达式，比如实参、形参的间隔就有逗号，但是并不是逗号表达式。
	
3.2 c = (a+10, b=a+100, sin(b)) 与 c=a+10, b=a+100, sin(b)

（1） c = (a+10, b=a+100, sin(b))
		整个表达式为赋值语句。
		左值：变量c
		右值：逗号表达式(a+10, b=a+100, sin(b))
			
		整个逗号表达式的值为sin(b)，c中放的是sin(b)的结果。

（2） c=a+10, b=a+100, sin(b)
		整个就是一个逗号表达式，整个逗号表达式的值为sin(b)，不过在这里整个逗号表达式的值并没有意义。

		
3.3 逗号表达式的意义 
	实际上从我们前面所举的例子来看，逗号表达式并没有什么实际的意义。
	
	事实上逗号表达式的使用场合也确实不多，可以说“逗号表达式”纯粹就是为了在只能写一条表达式的地方写多几
条表达式而设计的，用得最多的地方就是for。
	
	for( ; ; )
	在()只能有两个; ，如果需要在for的()中多添加表达式的话，只能使用逗号表达式来实现，比如
	
	for(i=0,j=SIZE-1; i<j; ++i,--j) 
	{
		
	}
	
		i=0,j=SIZE-1和++i,--j就是逗号表达式，在for中使用逗号表达式的目的，就是为了多写几个表达式，
	“逗号表达式”的整体值在for中并无意义。所以说在c中，逗号表达式唯一的用途基本就是用在for循环中，
	给for多添加几个“自变量”。
	
	疑问：在for循环中多指定几个自变量有意义吗？
	答：当然有，举个例子，判断某个单词是不是一个“回文单词”。
	什么是回文，比如 civic, dad, deed, deified都是回文。
	
		判断回文时，在for中使用i/j两个自变量来同时操作是最方便的，当然使用一个自变量也行，但是会不如两个方便，
	示例代码如下：
		
		#include <stdio.h>
		#include <string.h>

		int main(void)
		{
				int flag = 0, i=0, j=0;
				char word[] = "deified";

				for(i=0, j=strlen(word)-1; i<j; i++, j--)
				{
						if(word[i] != word[j])
						{
								flag++; //记录不相等字符的个数
						}
				}

				if(flag == 0) printf("是回文\n");
				else          printf("不是回文\n");

				return 0;
		}

		
4. typedef		
4.1 作用
	typedef用来给类型重命名，然后就可以使用重命名的类型来定义变量了，比如：
	
	typedef float fl; 
	typedef unsigned int uint;
	
	fl a; 		//等价于 float a
	uint b;		//等价于 unsigned int b
	
	疑问：重名后，原有类型还有效吗？
	答：当然有，float和unsigned int虽然被重命名了，但是float和unsigned int依然有效。
	
	提问：typedef uint u32可以吗？
	答：当然可以，我们在不少c源码中会经常见到这种多次重命名的情况，至于为什么要这么做，我们暂不解释。
	
4.2 typedef重命名的目的
	目的有两个：
（1）简化名字
		比如将unsigned int简化为uint。

（2）提高代码可移植性
		如何提高可移植性，后面再介绍。

	在一般情况下，使用typedef目的基本都是为了简化类型名字。
		
4.3 typedef使用举例
（1）普通类型
			int in;
			unsigned int uint;
			float fl;
			double dl;
			
			如果不加typedef的话，in、uint、fl、dl都是变量，但是加了typedef后，都是新类型名。
			
			typedef int in;
			typedef unsigned int uint;
			typedef float fl;
			typedef double dl;
				
（2）结构体、联合体、枚举
		同样的，如果不使用typedef的话就是变量，否则就是新类型名
		
		struct Student
		{
			...
		}Stu;	 //Stu：变量
		
		struct Student Stu; //Stu：变量
		
		typedef struct Student
		{
			...
		}Stu;	 //Stu：新类型名
		
		typedef struct Student Stu; //Stu：新类型名
		
		Stu stu1; //与struct Student stu效果是一样的
		
		
		typedef enum Week
		{
			SUM,
			MON,
			...
		}Wk;
		
		Wk weekday = SUM;
		
		
		联合体也是一样的，这里不再啰嗦。
		
		
（3）指针类型
		int *intp;
		struct Student *stup;
		typedef struct Student
		{
			...
		}*stup;	 //也是可以的，stup：新类型名
		
		void (*funp)(int, float);
		int (*bufp)[10];
		
		没有typedef时，全部是指针变量，但是加了typedef之后，就为指针类型。
		
		typedef int *intp;
		typedef struct Student *stup;
		
		
		
		typedef void (*funp)(int, float);
		typedef int (*bufp)[10];
		
		intp p1; //等价于int *p1
		stup p2; //等价于struct Student *p2
		funp p3; //等价于void (*p3)(int, float)
		bufp p4; //等价于int (*p4)[10];
		
		
（4）数组
		typedef的用法很灵活的，它也可以用在数组上，比如：
		
		int bufType[10];   //此时bufType一个数组，但是加上了typedef后，就是一个类型。
		
		typedef int bufType[10]; 
		
		bufType buf; //等价于int buf[10];
		
		
4.2 typedef与#define
	其实#define也可以用来对类型进行“重命名”，不过我们这里的重命名是打了“引号”的，与typedef之间有区别。

4.2.1 使用#define来重命名
		比如：

		#define uint unsigned int
		
		uint a; //与unsigned int a的效果是一致的。
	
		不过大家也发现了typedef的顺序和#define的顺序刚好相反，很多同学总是容易搞混淆它们顺序，我们建议大家
	只记住其中一个，然后另一个的顺序刚好相反，这样就不会混淆了。	
	
4.2.2 typedef与#define的区别
		二者的区别就来自于各自实现原理的不同，#define只是简单的宏替换，而typedef才是真正意义上的重命名。
		
		比如上面的uint就是一个宏，uint a进行宏替换后，最终面貌还是unsigned int a，但是typedef重命名的类型名
	不是宏，不存在宏替换的问题，正是由于二者的这点不同，导致它们之间有很大区别。
		接下来我们具体的对比一下它们的区别：
		
（1）各自的效果不一样
		typedef char * charp; 		//不要忘了加分号;
		charp p1, p2;  					//等价于char *p1, *p2;
		

		
		#define charp char *  
		charp p1, p2; 					//进行宏替换后，最终其实为char *p1, p2
		
		二者明显不一样。
		
（2）#define有局限
		typedef void (*funp)(int, double)
		
		像函数指针和数组指针类型，只能使用typedef来重命名，还真没办法使用#define来重命名。
		
		
（3）各自的处理阶段是不同的
		我们在第一章详细的介绍过编译链接的四个阶段：
		· 第一阶段：预编译
		· 第二阶段：编译
		· 第三阶段：汇编
		· 第四阶段：链接
			
			宏：在预编译阶段处理，将宏替换换真正的“宏体”
			类型：在编译阶段处理
			
			typedef重命名的类型名与原生的类型名只是名字不同而已，但是它们之前没有任何区别，因此

			typedef char *charp;
			charp p1, p2; 
			charp在编译阶段被处理。

				
			#define charp char *  
			charp p1, p2; 		
			charp为宏定义，在"预编译"阶段，charp宏会被展开为原生类型char *，然后char *会在编译阶段被处理
			
					
（4）我们的建议
			从前面的分析可以看出，使用#define来定义“新类型名”缺点不少，当我们自己写代码时，我们不建议使用
		#define来重命名“新类型名”，而是建议使用typedef来实现，typedef更规范。
			
			当然，虽然我们建议都使用typedef，但是实际上在有些c源码中，有时候还是会使用#define来重命名，当大
		家看到#define这种重命名方式时不要感到惊讶。
		
		
4.3 typedef与const
		我们直接举例介绍。
	
（1）例子1
		typdef const int cstInt;
		
		cstInt a = 10; //等价于const int a  或者 int const a
		
		
		通过简化的“新类型名”cstInt，就可以定义出一个const的int变量。
		
		
		
		typdef int *const cstIntp1;
		cstIntp1 p; //等价于int *const p
		
		
		typdef  int const  *cstIntp2; //等价于typdef const int *cstIntp2;
		cstIntp2 p; //等价于int const *p 或者const int *p
		
		
		typdef int const * const cstIntp3;
		cstIntp3 p;	//int const * const p
		
		
（2）例子2
		typedef int *intp;
		
		const intp p; 
		intp const p;
		以上这两种都等价于int *const p;

		如果想得到int const *p，只能
		typdef int const *cstIntp;
		cstIntp p; 
	

				
4.3 ***_t类型作用
	我们在C库、在OS API、Linux内核源码中，经常看到***_t的类型，比如：
	· Linux OS API： time_t time(time_t *tloc)
		time_t
	
	· posix c线程库函数：int pthread_create(pthread_t *thread, const pthread_attr_t *attr, 
										void *(*start_routine) (void *), void *arg);
										
			pthread_t、pthread_attr_t
			
	· Linux OS API：ssize_t write(int fd, const void *buf, size_t count);
	  ssize_t、size_t
	
	· c标准库函数：void *malloc(size_t size);
	
	· 等等
	
	很多同学一直搞不清楚这种***_t类型是怎么回事，它们到底有什么作用，我们这里就来介绍这个问题。


4.4 ***_t怎么来的
		这***_t类型都是通过typedef重命名后得到的，比如以time_t为例
		
		typedef time_t long int;
		
		我们将time_t的typedef的过程简化了，实际上中间还经过了多次typedef，我们直接将其省略了。
		以后凡是看到***_t类型，你就知道这个typedef后的类型，尾缀t就是typedef的意思。
		
		实际上_t只是命名习惯，不加_t也无所谓，但是在c库、c框架、c语言的OS内核代码中，都习惯于给新类型名加_t。
		事实上我们自己在重命名时不建议使用_t结尾，因为这样容易和c库等源码中的***_t类型搞混。
		
4.5 c库、Linux内核代码中的***_t有什么用		
	我们这里举例说明。

4.5.1 直接使用原生类型的弊端
（1）例子
			我们这个例子只是一个示例的例子，主要是为了说明其中的道理，大家不要纠结于其中细节的合理性。
			
			//windows环境的代码
			long int InitFun(long int arg)
			{
				...
			}
			
			这个代码要用到32位的整形，我们假设在Windows这边long int为32，而在Linux这边int才为32位，如果这个
		从windows这边迁移到Linux这边的话，我们需要将long int修改为int，如果你不改这个类型的，因为类型大小
		的不同，可能会给巨大隐患，所以必须修改类型：
			int InitFun(int arg)
			{
				...
			}
			
			如果代码是非常庞大，而且全部使用的都是原生类型的话，移植这些代码到不同平台上（比如不同的OS、不同CPU）时，
		就类型这个玩意，你就需要进行海量的改动，这个是非常痛苦的。
				
				当然如果是如下是那种情况的话，还好。
				（1）代码不涉及跨平台（只在一个平台上使用）
				（2）代码体量很小，改起来不费劲
				（3）代码对类型大小的变化不敏感
							一般来说类型大小变了，肯定会导致变量空间大小的变化，导致出现数据溢出等的问题，最后使得程序
						不能正常工作。
		
		
（2）解决原生类型的移植问题			
		定义一个.h，比如type.h
		
			#ifnedf H_TYPE_H
			#define H_TYPE_H
			
			#define __WINDOWS 
			//#define __LINUX

			#if defined(__WINDOWS)
				typedef  	int32_t long int
			
			#elif defined(__LINUX)
				typedef 	int32_t int;
					
			#endif
			
			...
			...
			...
			
			
			#endif	

			
			int32_t Init_Fun(int32_t arg)
			{
				...
			}
			
			
			在代码中只需要使用***_t即可，当代码需要移植到不同平台时，只要定义__WINDOWS或作者__LINUX宏，就可以
		通过条件编译来选择32int_t到底是long int还是int，给移植带了极大的便利。
			
			对条件编译不了解的同学，请看第2章《预编译》，我们有详细介绍。	
			
			
			c库函数、c实现的OS（大多数OS都是c写的）、c框架代码，都是大型c软件，而且大多都涉及到跨平台的问题，
			比如：
			· c标准库：在各大OS（windows/linux/安卓）上都能使用，涉及到跨OS
			· linux OS：能够在ARM cpu上运行，也能在POWRPC的cpu上运行，涉及跨芯片
				
			以上这些跨平台的代码都是海量级别的，所以如果没有***_t这种措施的话，跨平台移植时，就类型这一样就够
		折腾的。
			
			
4.6 我们自己的c应用代码，应该如何对待“原生类型”的使用呢

4.6.1 如果不涉及跨平台
		在这种情况下，我们可以直接使用原生类型，尽管如此，我们可能还是会使用typedef来重命名，不过此时只是
	想使用typedef来缩短类型名字的长度，让使用更加的方便，特别是函数的类型，有时候名字会非常长，如果不缩
	短名字，用起来非常不方便。
		比如：
			void (*funp)(int, float, struct student *);
			void (*funp1)(int, float, struct student *);
		每次定义都要写一长串，此时就可以使用typdef。
		
		typedef void (*funType)(int, float, struct student *);
		funType p1;
		
		
4.6.2 涉及到跨平台
	那么此时就需要typedef定义出新类型名，以面对代码在不同平台的移植。
	
		
5. 位宽、字节、字、半字
	很多同学对于位宽、字节、字、半字不是很理解，这里有必要介绍一下。
	
	其实有关这些概念就算你不知道，也并不会十分影响我们的编程开发，但是如果你知道的话肯定是最好的，这能
够帮助我们理解和解决其它与之相关的问题。

5.0 位宽
	“位宽”其实是一个非常底层的概念，只与硬件有关，与编程并没有太大关系。
	但是如果你能理解这个概念的话，有助于你阅读文档资料，因为有些文档资料里面会有位宽的概念，所以有必要
了解下。

5.1 什么是位宽 
	位宽就是cpu访问寄存器、缓存、内存、显存等时，一次能传输的数据位数（bit数）（最小传输单位）。
	
	我们这个说法不够严谨，实际上cpu是不能直接访问显存的，是由GPU来直接访问显存的，我们会和CPU对接。
	
5.2 “位宽”就是“数据线的根数”
	一般情况下，“位宽”就是“数据线的根数”，但是也有些少数情况是，“位宽”不等于“数据线根数”，不过这种情况不
考虑，因为常见的情况就是“位宽”等于“数据线的根数”。


5.3 位宽与内存对齐
	我们上一章介绍的“结构体成员对齐”，其实就是各种“内存对齐”情况当中的一种。
	
	“位宽”决定了访问寄存器、缓存、内存、显存等时，一次传输数据的bit数，进行内存对齐以后，可以按照“位宽”
的大小，一次就将数据传输完毕，但是如果不对齐的话，本来一次就能传输完毕数据，可能要传输好几次，如此显
然会降低了访问效率。
	
	这就是我们在上一章说的，“内存对齐”有利于提高访问效率。
	
	疑问：我是不是应该深入的研究下内存对齐呢？
	答：没必要。
		对于内存对齐这个东西，大家不要纠结，也没有必要纠结，因为编译器在编译时会帮我自动的进行“内存对齐”，
	包括结构体成员的“内存对齐”也是有编译器自动完成的，我们顶多会手动指定一下“对齐系数”。

		在上一章里面，我们为什么会重点的介绍一下“结构体成员”的内存对齐呢，主要是在Linux嵌入式开发中，有时
	候会涉及到，所以我们才介绍，否者我们是不会介绍的。
	
	
5.1 字节、字和半字
	字节、字和半字也是与硬件密切相关的概念。
	
（1）字节
		字节是固定的，8个bit为一个字节，不管是在什么硬件（cpu）平台上，都是一样的。
		
（2）字	
		一般来说，字就是“位宽”的大小，或者说就是“数据线的根数”。
		
		数据线为32根时，“位宽”为32bit(4字节)，字也就为32bit(4字节)。
		数据线为64根时，“位宽”为64bit(8字节)，字也就为64bit(8字节)。
		
（3）半字
		字的一半就是半字，这个非常好理解。
	
	
	字节与硬件平台无关，都是固定的8bit，但是“字”、“半字”与硬件平台有关，不同硬件平台下，“字”、“半字”不
一定相同。

5.2 编程时无需关心“字”、“半字”
		编程时，我们顶多只关心“字节”这个概念，因为字节是衡量变量空间大小的基本单位，但是对于半字和字来说，
	我们编程时关心的意义不大。
		
		对于编程的程序员来说，只需关心“字节”、char/short/int/float等这些类型。
		各种类型的大小，我们就是用“字节”来衡量，比如char1个字节，short2个字节等等。
	
	
5.2.1 char/short/int等类型的大小是否是固定？
	
	在“c标准”的规定里面，只有char的是固定的，为一个字节，但是除了char外的其它类型，“c标准”只是给了一
个范围，比如“c标准”规定，int的大小为2~8字节之间。

	c标准只给一个范围的这种规定，这个给c语言在不同硬件平台上的使用，提供了一种灵活性，具体int是4个字节还
是8字节，这个由硬件平台来决定，比如在有些硬件平台下，int为2字节，而有些则是8字节，不过常见的int都是4字节。
		
	我们想得到针对不同硬件平台的“二进制程序”，就必须使用专门针对该硬件平台的编译器，编译器在编译c代码时，
它会按照该平台的类型要求，去翻译char/short/int/double等类型，比如：
	
	该平台规定int为2字节：翻译int a;时，a的空间大小就是2字节。
	该平台规定int为8字节：翻译int a;时，a的空间大小就是8字节。
		
	疑问：不同平台下，char/short/int等类型的大小是不一样的，我怎样才能知道他们具体是多大呢？
	答：很简单，pritnf("%d\n", sizeof(类型名))就可以了。
		
	
6. 编译器优化
6.1 什么是编译器优化
		我们在编写程序时，代码写的可能并不精炼，代码不精练有两个表现：
	· 代码冗余
	· 代码不合理
	
（1）代码冗余
		代码冗余会带来如下两个问题：
		
		1）冗余代码会增加程序的代码量，所以冗余代码会浪费存储空间
		2）冗余代码也会被cpu执行，因此会降低代码的执行效率，浪费执行时间
		
		编译器就可以通过优化，帮我们优化掉这些冗余代码，提高代码质量。
		
（2）代码不合理
		我们举一个例子：
		
		int square(int *ptr)
		{
			return *ptr * *ptr;
		}
		
		以上是求平方的函数，在单线程中这个函数并没有问题，但是在多线程中这个代码中确存在问题。
		
		疑问：为什么在多线程中存在问题？
		答：因为存在如下可能性。
				当“当前线程”执行第一个*ptr时，假设ptr所指向空间的值为3，因此第一个*ptr为3，假如碰巧在执行第二个
			*ptr之前就切换到了其它线程上，刚好该线程将ptr所指向空间的内容改为了8，然后再切换会回来执行第
			二个*ptr时，此时第二个*ptr确为8，此时计算的结果为3*8。并不是我们需要的平方运算。
		
			编译器在编译时，会帮我们优化以上代码，将以上代码优化为如下形式的等价代码：
			int square(int *ptr)
			{
				int a = *ptr;
			
				return a * a; 
			}
			该代码求的一定是平方运算。
			
			
6.2 优化级别
		在第1章我们就提到过优化级别，不过当时介绍的很简略，那么现在我们来较为详细的介绍一下优化级别，介绍的
	目的就是让大家了解一下什么优化级别，以及应该如何对待这些不同的优化级别。
		
		首先我们要知道，不同编译器的优化级别是不一样的，比如以gcc为例，我们在Linux下，通过man命令查看gcc的
	命令手册，可以查看到gcc的优化级别：-O0  -O1（-O）  -O2  -O3  -Os -Ofast -Og。
		-O0  -O1（-O）  -O2  -O3这几个，数字越大优化级别就越高，-Os -Ofast -Og与O3算是同级别，但是会略有不同。
			
			
	我们在编译时，如何指定优化级别：
（1）在命令行下
		gcc a.c -O2
	
	
（2）在IDE下
		如果是通过IDE的话，就需要在IDE选项中指定优化级别，比如Codeblocks为例：
		演示：

		
		Codeblocks调用gcc时，就会给gcc指定这些选项。
		
		
		这里需要注意一点，优化级别越高，优化的就越深，编译器编译时越耗费时间，因为编译器对代码进行优化时，
	是需要执行相应的优化算法的，执行这些优化算法，必然会额外消耗时间，优化的越深，算法所学的时间就越多。
		
		
6.3 优化级别的介绍
	在gcc的man手册描述中，对每一个优化级别都有详细介绍，我们这里简单的介绍一下。
		
		-O0：表示不优化。
			gcc -g生成调试版（Debug）版程序时，默认就是-O0，在调试版中不会进行优化
			
			
		-O1：
				-O和-O1是一样的，这个优化级别会在不剧烈影响编译速度的前提下，尽量采用一些优化算法降低代码大小和
			提高代码的运行速度。
				O1为缺省值，gcc时如果不指定优化级别的话，默认就是O1优化级别。
				
				在不指定-g时，编译得到的是发行版（Release）版程序时，如果没有明确指定优化级别的话，会默认按照
			-O1来优化（默认值）。
				
				为什么发行版默认会进行最低级别的优化呢?
			答：因为发行版是给用户使用的，所以必须要提高代码质量，提高代码有两个方面，
				（1）降低代码量，减少对用户计算机存储空间占用
				（2）提高代码的执行效率，降低代码运行时间
				
		-O2：
			除了包括O1的优化选项外，还会进行进一步的优化，以提高目标代码的运行速度。
			
		-O3：
				该选项除了保留-O2所有的优化选项之外，还会采用很多“向量优化算法”，更好的利用现代CPU中的流水线，
			Cache等来更好的提高代码的运行速度。
				
			O3的优化级别很高，但是这个级别的优化也是很危险，因为
			1）优化的太深，编译速度会非常的慢，如果编译的海量代码的话，会非常痛苦，而且在优化效果上，O3其实并
				不比O2强太多。
				
			2）O3采用了深度优化算法，可能会导致“代码逻辑”出现大的变化，最终导致程序的运行结果并不是我们要的
				结果，而且编译失败的可能性也很大。
			
			鉴于以上问题，O3这个优化级别，大部分时候算是一种传说中的存在。
			
		-Os：
				Os与O3基本处于同一优化级别，只不过O3的侧重点是提高代码运行效率，而Os的侧重点是尽可能降低“代码量”。
			
		-Ofast：与O3属于同一级别，但是优化时可能会借鉴其它语言的一些相关特性来优化c代码。
		
		-Og：只进行与-g选项不冲突的优化，-g是调试选项，Og就是选择与调试不冲突的优化选项。
		
		
		如果你对优化级别感兴趣，请看gcc的手册，里面有详细描述，而且是非常权威的描述，比大家上网查到的很多
	信息要靠谱得多，但是不建议去详细阅读，意义不大，以后确实有需求再去看。
					
					
6.3 我们应该怎么对待优化

6.3.1 不要过分神话优化，优化也有缺点
		虽然优化能够提高代码质量，但是优化不一定都是好的，特别是当优化级别很深时，优化有可能会完全违背
	你原有的意思，最后导致程序不能运行得到期望的结果。
	
6.3.2 如何选择优化级别

（1）Debug版程序	
		gcc通过加上-g选项，在编译时就得到了调试版程序，此时如果没有明确指定优化级别的话，编译得到调试版程
	序时，默认是不会优化的。 
			
（2）Release版程序
		如果不加-g的话，就编译得到了Release版程序，如果没有明确指定优化级别的话，编译得到Release版
	程序时，一般默认为-O1优化级别，如果你想得到更高的优化级别，就需要明确的指定更高级的优化。
		
		在编译得到Release版程序时，建议使用默认优化级别即可，因为这是一个很合适的优化级别，
	既能帮我们进行一定程度的优化，同时又不会过分改动，让代码变的很厉害。
	
		如果非要提高优化级别的话，O2级别也是可以的，不过O3这个级别就要慎用了。
	
	
	疑问：O3级别似乎完全没有存在的意义呢?
	答：
		当然也不是的，如果说你的设备对于代码速度或者代码大小非常敏感，那么我们就需要通过O3这种高级别优化来
	极大的提升运行速度、减少占用的存储空间。
		
		比如早期单片机设备，存储空间很少很精贵，为了让代码尽可能的占用更少的代码空间，就需要选择高优化级别，
	以最大限度的减少代码量。使用高优化级别来优化时，如果不想让代码因优化而被严重扭曲，那么你的代码就要写
	的更加的严谨，越严谨的代码，被优化改动的可能性就越小。
		不过，现在就连单片机这类嵌入式计算机的cpu性能和存储空间都已经很高了，所以在单片机程序中也不会使用
	这种高级别的优化了。
		
		

6.4 volatile关键字
6.4.1 volatile的作用
		一般情况下，我们在编译得到“发行版（Realse版）”程序时，会了让代码质量更高，编译器一般会默认进行最
	低级别（-O1）的优化，而且我们也希望进行这种级别的优化，因为可以在一定程度上提高代码质量，同时程序
	代码又不会改动的很厉害。
		
		但是有些时候，我们虽然希望对整个程序进行优化，但是程序中的某些代码确不希望被优化，此时我们就可以使用
	volatile来阻止这些代码被优化，所以volatile的作用就是阻止编译器对某些代码进行优化。
		
		volatile最常见的作用就是修饰变量，修饰变量后，volatile就会阻止优化所有操作该变量的代码，如果没有
	volatile的修饰的话，编译器会对操作变量的代码，进行如下两种常见的优化：
	 1）删掉它认为无用的代码
	 2）抄近路，不使用变量在内存中的数据，而是直接赋值或者使用缓存中的数据
	
		如果这两种优化对程序来说无影响，那无所谓，但是如果这两种优化对程序有很大影响，我们就应该是使用
	volatile来修饰变量，阻止编译器对操作变量的代码进行优化。
	
（1）删掉它认为无用的代码
		比如：
			int i = 0;
			i = 1;
			i = 2;
			i = 3;
		
		编译器在编译这三句赋值语句，它会认为前两次的赋值毫无意义，因为它觉得其两次赋值会被第三次覆盖，
	优化时编译器会将前两句赋值删除，最终变为了如下样子：
			int i = 0;
			i = 3;
			
		假如连续三次赋值有意义的话，就不能优化删除代码，那么我么就必须使用volatile来阻止编译器的优化。
			volatile int i = 0;
			i = 1;
			i = 2;  
			i = 3;
			
			此时编译器不会对操作i的代码进行任何优化，完全保持源码，那么前两句赋值语句就不会被删除。
			
			当然，如果前两句确实毫无意义，那么我们也没有必要使用volatile来阻止优化，应该让编译器把这两句赋
		值语句优化掉，否则就会造成冗余代码，降低代码质量。
			
			
（2）抄近路，不使用变量在内存中的数据，而是直接赋值或者使用缓存中的数据
			int j = 10;
			int m, n, k;

			m = j;
			n = j;
			k = j;
			
			编译器在编译时，由于它发现在执行三句赋值语句期间，并没有任何修改j的代码，它认为j的值固
		定为10，此时编译器就会优化搞点小动作，得到它所认为的高质量代码，此时编译器可能会按照如下两种形
		式来优化。
		
		1）第一种优化方式
				编译认为，既然j的值固定为10，那干脆直接将10赋值给m、n、k就可以了，从而会把这三句话优化为如下
			形式的三句话。
				int j = 10;
				int m, n, k;

				m = 10;
				n = 10;
				k = 10;
			
			优化后代码就不会读内存中j变量的值，而是直接将m/n/k赋值为了10，它认为这种捷径更合理，这样就不
		需要费劲的去读取j变量的内存空间了。
		
		2）第二种优化方式
			m = j;
			将j内存空间中的10读到寄存器中，然后再从寄存器中将10赋给m。
			
			n = j;
			k = j;
			编译以上两句话时，编译器优化后的代码就会走捷径了，此时不会去读取变量j在内存中的10，而是直接读取
		寄存器中缓存的10，从寄存器中将10赋给n和k。
			
			
		3）以上两种优化方式存在的问题
		
			不管是以上哪一种优化方式，编译器都认为在执行三句赋值语句时，j的内容都固定为10，因此没有必要每次
		都去读j的内存空间，编译器就会优化代码，优化后的代码都会走捷径，不会每次都老老实实去内存中读取j中的10。
			
			如果在执行三句赋值语句期间，j的内容确实不会改变的话，那么编译器的以上优化确实提高了代码质量，因为
		优化后的代码，避免了费劲的去读取内存。
			
			但是如果在执行三赋值语句期间，j的值有可能会改变的话，那么编译器的优化就会带来问题。 
			
			那么j的值可能会因为哪些情况而改变呢？一般为如下三种：
			1）j被计算机硬件本身改变
			2）被中断函数改变
			3）在多线程中，被其它线程改变
			
			如果在我们的程序中，j的值确实存在被以上三种情况改变的可能的话，优化的代码确实存在严重的问题。
			
		疑问：什么问题呢？
			假设在执行m=j自后，j空间中的内容被改变为了20，那么n和k里面放的就应该是20，但是优化后的代码确使得
		m、k固定为10，优化后的代码根本无法响应j值的变化，此时我们就需要使用volatile来阻止优化。
				volatile int j = 10;
				int m, n, k;
					
				m = j;
				n = j;
				k = j;
			
			加了volatile之后，编译器就不会优化与j有关的操作代码，以上三句话都与j有关，自然也不会被优化。
			
			没有被优化的代码在执行每一次的赋值时，都会老老实实的将j内存空间中的值读出，并赋值给m、n、k，
		如果j的值在三次赋值中有改变的话，那么代码将能够很好的响应这个改变。
			
			同样的，最终加不加volatile需要由我们程序员自己来判断，如果你发现优化后的代码存在问题的话，就加上以
		阻止优化，否则就不要加，让编译器优化以提高代码质量。
		
		
（3）总结volatile的作用
		用来阻止编译器的优化，最常见的是修饰变量，阻止编译器优化操作变量的代码。
		1）阻止优化时删减代码
		2）阻止优化代码走捷径，保证每次都从变量的内存空间读取原始数值。
			
			
（4）对于变量的误区

		说到变量时，很多同学一直以为int a、float b、sturct Student c的a、b、c才算是变量，但事实上
	只要是可以被修改的空间都是变量。
		
		如果地址0x32343454所指向的空间可以被修改，对0x32343454进行解引用后，*((unsigned int *)0x32343454)
	同样也是一个变量。
					

6.4.2 volatile的真实案例

（1）例子1：volatile修饰寄存器变量的例子

			假设某个状态寄存器的地址为0x65464543，大小为4字节。
			
			状态寄存器的特点是，寄存器中的数值随时可能会被计算机硬件本身所修改。
			
			读“状态寄存器”的代码：
			#define  REG (*((unsigned int *)0x65464543))  //状态寄存器变量
			
			int i = REG; //读取状态寄存器变量的值，赋值给i
			int n = REG; //读取状态寄存器变量的值，赋值给n
			int k = i + n;
		
		1）编译器会如何优化
			编译器编译时，会认为第二次对n的赋值没有意义，编译器优化时会将第二个赋值语句删除，优化后的等价
		代码如下：
			int i = REG;
			int k = 2*i;
		
		
		2）实际情况
			实际情况是，状态寄存器变量中的值可能随时会被计算机硬件本身所修改，所以两次赋值时，所读到的寄存器中
		的值可能并不一样，因此第二次的赋值不能省略，那么此时就需要使用volatile来阻止优化了。
			#define  REG (*((volatile unsigned int *)0x65464543))  //状态寄存器变量
			
			int i = REG;
			int n = REG;
			int k = i + n;
			
			使用voatile修饰后，操作寄存器的代码将不会被优化。			
			大家在做单片机等与硬件密切相关的开发时，会经常见到使用volatile来修饰寄存器变量的情况，其实就是
		我们这里所讲的情况。
			
		疑问：为什么要强制转换为unsigned int *？
		答：如果不转为指针类型的话，0x65464543就是一个整形数，是不能够对整形数进行解引用的，而且寄存器的
			大小为四个字节，所以我们使用int来访问，因为int的大小恰好也是4个字节，如果使用char、short的话，
			就只能访问寄存器的1个~2个字节。
			
			而且对于寄存器操作来说，负数是没有意义的，为了防止负数最高位符号位的干扰，所以我们使用了unsigned，
		以无符号类型去解释寄存器空间时，将不会受到符号位的干扰。
			
			
（2）例子2：中断函数的例子
			int i = 0;
			
			int main(void)
			{
					...
					
					while(1)
					{
							if(i) dosomething();
					}
					
					return 0;
			}
			
			/* 中断处理函数 */
			void ISR_2(void)
			{
					i=1;
			}
		
		1）编译会如何优化？
				编译器在编译main函数中的if(i)时，它发现i的值一直为0，因此它认为if(0)永远是假的，所以它觉得
				if(i) dosomething();	
			完全是多余的，因为代码根本不会被执行，编译器在优化时就会将以上代码删除。
			
			
		2）实际情况
			实际情况是，i的值并不会一直为0，因为当某个中断产生后，比如按键按下产生了一个中断信号后，正在执行的
		main主线就会被打断，中断处理函数会被硬件自动调用，此时cpu进而会去执行“中断处理函数”的代码，在中断
		函数中将i的值修改为1，当“中断处理函数”执行完毕后，再回到被打断的主线继续执行，此时if(i)必然就
		是成立的，因此
				if(i) dosomething();		
			
			是有意义的，不能被优化删掉，此时我们就需要使用volatile来阻止编译器优化操作i的代码。
				volatile int i = 0;
				...
			
			
（3）例子3：多线程并发运行的例子
				
			主线程：                      次线程
			extern int i = 10;            extern int i;
			
			int main(void)                void *pth_fun(void *ptharg)
			{                             {
				int m, n, k;                	i = 20;  
				m = i;                        ...	
				n = i;                        ...
				k = i;                      }
				
				...
				...
				
				return 0;            
			}
			
			没有次线程时，整个程序就是单线程的，此时单线程就是主线程，main函数一定是由主线程来执行的。
			
			
		1）编译器会如何优化	
				这个例子我们在前面就大概的讲过，主线程中的m = i; n = i; k = i;，可能会被优化为如下等价形式：
				m = 10;
				n = 10;
				k = 10;
				
				编译器之所以会这么优化，是因为它认为i的值是固定死的，这样优化的能够提高代码质量。
				
		2）实际情况
				实际情况是，当主线程在执行中某个赋值语句时，比如刚要执行m = i;时，可能就会从主线程切换到次线
			程上，执行次线程的代码，此时次线程会通过i=20将i赋值为20，当再次切换到主线程执行m=i; n=i; n=k;时，
			m、n、k就应该被赋值为20，但是被优化后，m、n、k确固定为10，代码无法响应次线程的修改，此时需要阻止
			优化。
				
				为了阻止编译器优化，我们必须使用volatile修饰i，阻止编译器对操作i的代码进行优化，如此一来，
			当执行主线程的m = i; n = i; k = i;语句时，每次都会老老实实的从i的内存空间中读出实际数值，如果
			i的值发生变化了，那么赋值的就是发生变化后的值。
			
（3）其它例子
		比如操作共享内存时，我们也会使用volatile，使用volatile的例子不少，不过我们这里不再一一举例。
		
6.5 volatile不要乱用
	有需求时才使用volatile，否则不要胡乱使用，因为胡乱使用往往会带来不良效果。

	
6.5.1 回顾前面的例子
	int square(int *ptr)
	{
		return *ptr * *ptr;
	}
	
	在多线程中，这个函数存在缺陷，但是编译时编译器会帮我们优化为如下等价的代码：
	int square(int *ptr)
	{
		int a = *ptr;
		return a * a;
	}
	
	优化后的代码就不存在缺陷了。

	
6.5.2 给形参加了volatile的话，会怎样呢？
	比如：
		int square(volatile int *ptr)
		{
			int a = *ptr;
			return a * a;
		}
		
	volatile会阻止编译器的优化，代码的缺陷会被一直保留，显然volatile起到了反效果。

	当你需要优化的时候，不能加volatile，不需要优化时才需要加volatile，总之不能胡乱加。
	
6.5.3 这个例子告诉了我们什么道理
（1）volatile不能随便乱用，要看准了用
		当你确定时再使用，否者就会起到反效果，以上volatile起反效果的例子，是volatile的经典面试题，请大家
	一定要理解。
	
（2）写出高质量代码才是王道

		例子的根本原因是我们写的代码不够严谨，存在缺陷，需要通过编译器优化来提升代码质量，volatile阻止了
	优化后反倒起了反效果，如果我们一开始就将代码写为如下严谨形式的话，其实并不会受到volatile的影响。
			int square(int *ptr)
			{
				int a = &ptr;
				return a * a;
			}
			
		所以说，我们在写代码时要尽可能写出高质量的代码。
		同时尽可能的不要乱用volatile，因为有些时候防不胜防。
						
				
6.7 一个指针可以是volatile的吗？
	当然可以，比如：
		int a = 100;
		int *p = &a;
			
		int m, n, k;
		
		m = *p;
		n = *p;
		k = *p;	
	
	编译器可能认为p所指向的a的值一直为100，不会变化，所以同样会进行优化，比如优化为如下形式：
		m = 100;
		n = 100;
		k = 100;	
		
	但是如果a的内容有可能发生变化的话，比如：
		1）被硬件修改    2）被中断函数修改   3）被其它线程修改
	
	此时我们就应该使用volatile来阻止优化，
		volatile int *p = &a;
		
	然后每次赋值时，代码都会老老实实的将p所指向的a内存空间中内容读出，然后赋值给m、n、k，而不会走捷径、
抄近道。
		
		
6.8 volatile与const同时修饰变量有意义吗
	当然有意义，const与volatile并不冲突，比如修饰寄存器变量：	
	
	#define  REG (  *((volatile const unsigned int *)0x65464543)  ) 
	
	
6.8.1 有些同学会觉得没有意义的原因

	通过前面的讲解可知，volatile所修饰的变量，大多都有一个特点，那就是变量可能会随时会被修改，比如：
		1）被硬件修改     2）被中断函数修改   3）被其它线程修改

	变量的值不是固定不变的。

	const修饰变量的目的，是想让它变为“常量”，顾名思义常量是不变的，这不就矛盾了吗？
	const：希望变量不要变
	volatile：告诉编译器，这个值随时都可以能改变
		
	同时使用volatile与const真的有意义吗？
	
6.8.2 使用volatile和const同时修饰变量，并不矛盾 

（1）const的作用
			const修饰变量所得的是“伪常量”，“伪常量”并不是真正的不能修改的只读常量，“伪常量”只是不让代码去
		赋值修改而已，当程序中有代码尝试去赋值修改“伪常量”时，会导致无法编译通过，逼着程序员去掉赋值代码。
			
			const不让代码去修改变量，但是并不意味着不让计算机硬件本身去修改变量。
			
（2）volatile的作用
		告诉编译器不要优化，因为变量的值不是一成不变的，有可能会发生变化，虽然被const限制了代码这种
	修改途径，但是变量有可能随时会被计算机硬件本身修改，一旦优化后，程序将无法响应修改。
	
	
（3）总结const与volatile同时修饰“寄存器变量”的目的
		1）const的目的：阻止代码去赋值修改寄存器变量
	
		2）volatile的目的：告诉编译器，不要优化操作寄存器的代码，寄存器的值可能会随时改变。
			虽然因为cosnt的限制，变量不会被代码所改变，但是有可能会被计算机硬件本身所改变。

		const与volatile同时使用的情况，基本都是修饰寄存器的情况。

6.9 typedef与volatile 
		typedef volatile int vint32_t;
		
		
		vint32_t a = 100; //等价于volatile int a = 100;
		
		
		更规范的写法是：		
		#define __IO volatile    //当然__IO这个名字并不是固定的		
		
		typedef __IO int vint32_t;
		
		我们在好些c库源码中，往往会看到以上这种写法。

		
6.10 疑问：前面有关volatile的内容都听懂了，但是好像我还是不知道该在什么时候加volatile？

	如果你有这个问题的话，说明大家的功底还不够，功底这个东西是需要经验来支持的，目前最关键的是听懂我们
对于volatile的介绍，至少知道当出现以上我们介绍的情况时，你知道应该要加volatile，慢慢的当你有了相当的
开发经验后，自然就能了然于胸了。
		
	不过目前一定要先理解volatile的基本情况，因为c面试中，会经常出现volatile的经典面试题。
	特别是嵌入式相关的开发中，volatile使用的很频繁，因此面试单片机、linux嵌入式相关的工作时，volatile
是常考的题目，所以一定要掌握。

	不过大家可以放心的是，在本小节，我们基本上已经把c经典面试题会出现的volatile的内容都讲到了，我们后
面讲“c经典面试题”时，里面就有volatile的经典面试题，只要你把本部分内容听懂了，里面的volatile题目，
都没有问题，但是如果你没听懂的话，大部分学生可能都会做错，因为volatile确实有点不好理解。

	当然在java等语言中同样有volatile关键字，而且作用都是相似的，因此理解好了c的volatile，也有助于大家
理解java的volatile。


6.11 volatile 与 __volatile__

		怎么理解__volatile__呢？
		
		完全可以将__volatile__理解为一个预定义宏，它是GCC给volatile取的另一个名字，似乎GCC也支持
		__volatile写法，也就是也就说volatile、__volatile__、__volatile是等价的。
			volatile 			int i  =0;
			__volatile__ 	int i  =0;
			__volatile 		int i  =0;
			
			以上三个写法的作用是一样的。
				
		只不过volatile是c标准的关键字，而后面两个是GCC给volatile起的另外两个名字，当然其它c编译器也可能会给
	volatile搞出类似的名字，只不过名字不一定叫__volatile__、或者__volatile。
		
		不过__voltile__和__vilatile是GCC编译器提供的，如果使用__voltile__、__vilatile的话，其它C编译器可
	能无法识别，由于volatile是c标准关键字，所有的c编译器都会支持，因此建议在c代码中最好使用volatile。
	
		不过在Linux内核代码中，用的几乎都是__volatile__，因为Linux内核的“御用”编译器为GCC，因此全部使用
	__volatile__也并无不妥。
		
	
7. extern "C"

7.1 有什么作用
		c++是兼容c的，在c++中是可以调用c代码的，比如团队中有人擅长c++，有人擅长c，擅长c++的人可以使用c++来
	开发负责的模块，擅长C的就可以使用c来开发负责的模块，最后在c++和c代码整到一起，合为一个程序。
		
		由于c++的语法>c语法，所以最后只能使用C++编译器来编译整合后的代码，但是存在一个问题，那就是c++和c的
	语法毕竟有所差异，比如c++有函数重载，但是c没有，以c++编译器去编译c代码时，就会出问题。
		
		为了让c++代码能够很好的兼容c代码，避免出现不兼容的问题，就有了extern "C"，凡是被这个修饰的C代码，
	c++编译器在编译时就按照c的语法去编译，如果没有extern "C"的话，使用c++语法编译时就可能出问题。
	
		使用c++编译器编译c代码时，才需要extern "C"来兼容，如果你使用的c编译器来编译c代码的话，这个玩意就用
	不着了。
	
7.2 如何使用extern "C"
（1）它可以只修饰一句话
		extern "C" int max(int a, int b);  
			
		c++编译器编译这句话时，以c语法来编译。

（2）修饰一段代码
		XXX.h
		#ifndef H_XXX_H
		#define H_XXX_H
		
		...
		...
		...
		...
		
		//c++编译器编译这一段代码时，以c语法来编译
		extern "C" 
		{
			...
			...
		}
		
		...
		...
		...
		...
		
		#endif
		
		
		XXX.c 
		...
		
		//c++编译器编译这一段代码时，以c语法来编译
		//不能{}不能写在函数里面
		extern "C"
		{
			void fun()
			{
				...
				...
			}
		}
		
		...
		
（3）实际常见的情况
		在.h中和.c中都使用extern "C"，反倒会把事情搞麻烦了，常见情况是我们会在.h中使用，然后将.h中所有的
	内容都包含到extern "C" { }中。
		前面说过，只有在使用c++编译器编译c代码，才需要使用extern "c"来兼容，c++编译器一看到extern "c"就知道，
	它应该使用c语法来编译，使用c编译器来编译时是不需要extern "c"，所以我们使用条件编译来选择，当使用
	c++编译器编译时extern "c"自动有效，使用c编译器来编译时自动无效。
		
		我们在.h当中经常看到的extern "C"的用法是如下这样的：
		
		fine.h
		#ifndef H_FINE_H
		#define H_FINE_H
		
		
		/* 当使用c++编译器来编译C代码时，会自动生成__cplusplus宏，此时条件编译成立，extern "C"有效
     * 如果是c编译器的话，就不会产生__cplusplus宏，条件编译不成立，extern "C"无效
		*/
		#ifdef __cplusplus
		extern "C" 
		{
		#endif
		
		/* .h中所有的内容都在{}中 */
		...
		
		...
		
		...
		
		...
		
		
		/* 与extern "C" { 配对 */
		#ifdef __cplusplus
		}
		#endif
	
		
		#endif
	
		
		真实的例子：
		演示：
		
		
		对于我们自己写的c应用代码来说，如果需要和c++代码进行整合时，就是需要在自己的c代码里面使用extern "C"，
	让c++兼容c，如果没有这种需求的话，就不需要使用extern "C"。		
		
7. 程序调试
7.1 什么是程序调试
		任何一个软件在开发时都不可能一气呵成，编写完成后就是没有任何问题的可以直接发布的成品，都会遇到各
	种各样的bug，bug并不是编译错误，在开发过程中编译错误都容易解决，最不好解决的是程序能编译通过，但是
	无法得到正确运行结果的bug。
		小的bug可能导致程序运行不顺畅，大的bug可能就会直接导致程序跑飞、死机，显然我们把这些bug干掉，干掉
	Bug就是“程序调试”要干的事情，所以在程序开发的过程中，程序调试是非常重要的。
	
	
7.2 调试手段
	代码复杂后，仅仅看源码是很难找出bug的，所以我们需要借助一些调试手段，调试手段总体而言可以分为如下几种:

· 打印调试 	
· 单步调试 
· 硬件调试 
· log文件调试
		
7.2.1 打印调试
（1）什么是打印调试
		利用printf打印关键信息，然后通过这些关键信息来判断代码可能的问题。
		
（2）打印调试的优点
		打印调试简单易行，而且很直接、很直观，是程序员最为常用的调试方式。

（3）打印调试的缺点
		打印调试太少了可能找不出问题，但是太多了又有可能会淹没有用信息，不好把握。
		打印调试不如“单步调试”精确，显示的调试信息也不如“单步调试”丰富。
		
		
7.2.2 单步调试
		很多初学编程的同学一听到调试，总认为“单步调试”才是真正的调试，前面介绍的“打印调试”不算是一种正规的
	调试方法，甚至都鄙视“打印调试”，显然这是一种误区。
	
（1）如何实现单步调试
			编译器集合会提供“debug调试程序”（调试命令），比如gcc编译器集合就会提供debug调试程序（gdb.exe），
		我们在第1章介绍gcc编译器集合的时，其实就介绍过gdb，不知道大家还有没有映像。
			debug程序会专门负责单步调试，debug的使用方式有两种：
			
		1）直接命令行运行gdb，然后调试程序
			（a）编译时，在程序中包含基本的调试信息
					比如调试需要用到的文件名，行号，变量名等等
					
					实现方法：gcc a.c -g
						如果要进行gdb单步调试的话，必须加-g，如果不加-g的话，程序包含的调试信息太少，不能进行调试。
						
			（b）使用gdb命令，进行gdb调试，gdb就是gcc debug的缩写
					gdb ./a.out  
					
					· 设置断点的命令b 
						b lineNo：在主函数所在文件的lineNo行号出设置断点
						b fileName:lineNo：在fileName文件的lineNo行号处设置断点
						b funName：在funName函数名出设置断点
				
					· info b：查看所有断点b的信息。
					· 让断点失效：diable b，使能的话时enable 
					· 删除断点：clear b
					· 运行程序：r   开始运行后，就可以调试了
					· 单步运行：n（下一步，遇到函数时不进入函数），s（下一步，遇到函数则进入函数）
					· 查看变量值：p n(变量名)
					· 查看源码：l
					· 结束单步调试：kill
					· 推出gdb调试：q
					...
					
				有关gdb的其它命令，请大家自己另外了解，实际上相比打印调试来说，命令行的单步调试用的不多，所以
			这里对于gdb命令行调试来说，知道大概怎么使用，当要用到时能够自己摸索用起来就可以了。
				
				
		2）IDE调用gdb程序来进行单步调试			
				codeblocks使用的也是gcc编译器，Codeblocks会提供图形化界面的单步调试，但是背后同样是调用gdb来
			实现的，只不过提供了图形化的界面给我们，我们则不需要关心IDE在背后是如何去调用gdb的。	
			
			实现步骤：
			（a）创建debug工程
					创建了debug工程后，IDE调用gcc编译时就会自动加上-g选项，然后就能进行单步调试。
					
					演示： 
	
					
			（b）进行单步调试
					IDE提供了单步调试的界面按钮，操作非常的简单，大家自己下去熟悉下就好了。
						
						
（2）单步调试的优点和缺点
		2）单步调试的优点
			（a）单步调试可以帮助我们提供更精细的跟踪
			（b）相比打印调试，可以提供更加丰富的调试信息
					比如可以展示各个变量值，各个寄存器的值，甚至是某段c代码所对应的汇编代码
			
		2）单步调试的缺点
				单步跟踪调试的节奏往往有点慢，不如打印调试来的直接，所以大多数情况下程序员还是喜欢使用打印
			调试，当遇到特别难搞定的bug时，此时还是使用单步调试来精细的跟踪，然后找出bug。

			
			
7.2.3 硬件调试
	使用led、蜂鸣器等硬件来调试，这种调试方式常见于裸机（比如单片机）开发中，在纯应用开发中是见到不到的，
	
	天使方法：比如
	
		... //正常代码
		...
		驱动led、蜂鸣器的代码
		...
		...
	
		如果led被点亮了或者蜂鸣器鸣响了，说明前面的代码就没有问题，否则就说明前面的代码有问题，通过这种
	方式就可以找到问题的所在，当然这种调试方式并不是万能的，有些情况下，这种调试方式不合适。	
		在裸机开发中，也能使用打印调试和单步调试。
		

7.2.4 log文件（日志文件）调试
	很多同学不了解日志文件，这里有必要说一说。
	
（1） log文件会记录什么呢？
	日志文件原本是用来记录人每天工作相关内容，比如工作进度，工作计划等，这里的计算机log文件，指的是
软件程序在运行的过程中所记录的信息，log文件一般是txt文本形式，可以直接打开查看，但是有些log文件有固
定格式，不能直接使用txt文本打开阅读，事实上日志文件也能帮助我们进行调试。
	
（2）日志文件种类
	日志文件大体上个分为两种，分别是uninstall.log或是error.log，各自记录的信息不一样，作用也不一样。
	
		1）uninstall.log：通常用于记录软件在安装过程中所生成的记录，以便将来卸载的时候提供给卸载程序使用。
		2）error.log：通常用来记录软件运行过程中的所产生信息，程序运行时的bug信息也会被记录。
				程序在发布时不可能将所有的bug都找出来，剩余的bug只能在发布后的公测阶段来被发现，程序运行所产
			生的bug就会记录在日志文件中，然后就可以利用这些信息来帮助调试。	
			
		
7.2.5 补充：借助汇编来辅助调试
	这个我们了解一下即可。
	面对有些非常难搞定的问题，我们有时候还可以通过查看汇编代码来辅助解决。

		c代码 ————>编译 —————> 汇编  ————> 链接 ————> 二进制的可执行程序
			
		中间会产生汇编代码，我们可以查阅这个汇编代码。
		实际上还有“反汇编”这个东西，但是只有“逆向开发”才会涉及到反汇编，因此我们这里不深入介绍。

		事实上几乎所有的bug，都可以通过前面所介绍的方式来调试解决，“借助汇编来辅助调试”的这种方式，了解
	下就可以了，并不是必须的。
	
	
7.3 调试宏		
	有关调试宏，我们在第2章就介绍过，我们这里再介绍一下。
	调试宏其实就是“打印调试的宏”，也就是我们打印调试时所用到的宏。
	
7.3.1 调试宏举例
	#ifdef DEBUG
		#define debug(fmt, arg1, arg2) printf(fmt, arg1, arg2)
	#else
		#define debug(fmt, args...)  
	#endif
	
	如果定义了DEBUG宏，宏体为printf，此时debug宏有效，否则无效。
	
	但是以上调试宏有一个缺点，printf的参数时固定的，但是我们打印调试信息时，参数往往是不定的，所以我们
要改进一下。

	#ifdef DEBUG
		#define debug(fmt, args...) printf(fmt, args)	  
	#else
		#define debug(fmt, args...)
	#endif
	
	此时debug为变参宏，刚好对应着printf的变参需求，有关变参宏和变参函数，后面会详细介绍。
	
	
7.3.2 如何定义DEBUG宏
（1）在.h中定义：只有定义
（2）gcc编译时时，可以通过-D来指定为“自定义”的预定义宏
		gcc a.c b.c -DDEBUG
		
		这个预定宏是一个全局宏，对于所有的.h和.c来说，都是可见的，如果gcc时没有定义DEBUG的话，调试宏的宏体
	就是空，此时无效。
		
		在.h中定义需要源码，不太好，我们最好通过gcc的选项来指定，更方便。
		
		在IDE这边也会是一样的。
		演示：
					
			
7.3.3 函数错误打印
	函数错误打印，可以帮我们排查函数错误，以及进行异常处理，提高程序的健壮性。
	
（1）errno.h和错误号
			有关errno.h和错误号，我们在第5章就提到过，我们这里详细介绍一下。
			几乎所有的c标准库函数出错时，都会有相应的出错原因，c标准库会使用各种错误号（整数）来代表相应的错误，
		这些错误号定义在了errno.h中。
		
		errno.h：
			#ifndef _ERRNO_H_
			#define	_ERRNO_H_
			
			#define EPERM					1		/* Operation not permitted(权限问题，不允许操作) */
			...
			#define	EINVAL				22	/* Invalid argument（无效参数） */
			...
			#define	EROFS					30	/* Read-only file system（文件是只读的） */
			...
			#define	ENAMETOOLONG	38	/* Filename too long (91 in Cyg?)(文件名太长，最多只允许91字符) */
			...
			
			extern int errno; //存放错误号的全局变量，如果没有任何函数出错，里面默认就是0
			
			...
			
			#endif
			
		当被调用的库函数出错时，比如函数参数为无效参数时，就会自动将错误号22设置到全局变量errno中，以记录
	当前函数的出错信息。
		
		然后我们通过strerror这个函数，可以将errno中的22翻译为字符换"Invalid argument"，这样我们就知道发生
	了什么错误了。这就是我们为什么在阅读函数手册返回值时，经常会看到这么一句话，如果函数调用失败就会返
	回NULL或者-1等，然后设置errno，比如fopen函数的返回值描述为：
		原话为： Upon successful completion fopen(), fdopen()  and  freopen()  return  a
			FILE pointer.  Otherwise, NULL is returned and errno is set to indicate the error.
			
			
		#include <stdio.h>   //fprintf所需的.h
		#include <string.h>  //strerror所需的.h
		#include <errno.h>   //全局变量errno所在的头文件

		int main(void)
		{
				FILE * p= fopen(".\\file.txt", "t");
				if(NULL == p)
				{	
						//strerror会将errno中的错误号翻译为字符串
						fprintf(stderr, "fopen error：%s\n", strerror(errno)); 
						exit(-1); //直接终止进程
				}

				return 0;
		}
		
		结果为：fopen error：Invalid argument
		fopen为标准io函数，我们会在第9章详细介绍，事实上第二个参数"t"的写法是错误的，所以fopen会返回NULL并且
		将errno设置为错误号EINVAL（22）。
			strerror会自动取出errno的中的错误号并将22翻译为Invalid argument，并且将字符串指针返回，利用这个
		返回字符串指针，就能通过%s打印出"Invalid argument"，以提示除了什么错误。
			至于fprintf(stderr,...)的写法，我们在第9章讲标准IO时也会详细介绍。
			
		改进：大家也看出来了，使用strerror(errno)方式有些麻烦，还需要包含string.h和errno.h，所以c标准库给出了
		perror这个函数，这个函数只需要包含stdio.h即可，使用起来更方便。
		
		#include <stdio.h>   //printf所需的.h

		int main(int argc, char *argv[])
		{
				FILE * p= fopen(".\\file.txt", "t");
				if(NULL == p)
				{
						perror("fopen error"); 
						exit(-1); //直接终止进程
				}

				return 0;
		}
		显然perror更简洁。
		为了让报错处理更方便，我们最好将“报错操作”封装为函数或者带参宏。
	
	
（2）函数方式
		直接通过例子来理解。
			
			#include "stdio.h"
			
			//出错处理函数
			void print_error(char *file, int line, char *str)
			{
					//报告错误的位置
					fprintf(stderr, "File %s, Line %d, Function %s error\n", file, line, str);
					perror("error Reason"); //打印函数出错的原因
					exit(-1); //终止进程，说白了就是终止整个程序
			}

			int fun(int **p, int size)
			{
					*p = malloc(size);
					//如果malloc返回NULL，就说明错了，需要报函数错误
					if(NULL == *p) print_error(__FILE__, __LINE__, "malloc");
			}
			
			int main(void)
			{
					int ret = 0;
					int *p = 0;
					int size = sizeof(int)*4000000000000000000; 
					
					ret = fun(&p, size);
					
					return 0;
			}
			
			要开辟空间如此之大，肯定会报错，最后打印的错误信息为：
			File C:\Users\Administrator\Desktop\EGEProj\qq\a.c, Line 23, Function malloc error
			error Reason: Not enough space

			
		· exit函数：这个函数的作用是结束整个进程（程序），一般情况下，传递的参数其实没有什么意义，可以随
			意指定，不过按照约定俗成的规矩，如果是因为出错而要结束进程的话，一般都写-1。
			
				如果你真想知道exit(-1)的-1到底到哪里去了，大家请看《Linux系统、网络编程》课程的第5章：进程控制。
			
（3）宏方式
		在第2章介绍过，对于简短的函数来说，我们完全可以使用宏来代替。	
		#define print_error(str) \
		do{\
				fprintf(stderr, "File %s, Line %d, Function %s error\n", __FILE__, __LINE__, str);\
				perror("error Reason");\
				exit(-1);\
		}while(0);

		int fun(int **p, int size)
		{
				*p = malloc(size);
				if(NULL == *p) print_error( "malloc");
		}
		
		有同学不太理解do {}while(0)在这里到底有什么，有关这一点我们后面会详细介绍，目前简单的理解就是，
	等价于{ }。
		
		
（4）有关函数报错需要注意的地方
		1）并不是所有的函数都需要进行报错处理，只需对重要的、关键的函数进行报错处理
		2）我们自己写的函数，重要函数在出错时也要返回NULL或者-1等值来表示出错，并进行出错处理
		3）当函数出错后，一般的处理方式有两种
			（a）调用exit()结束整个进程
			（b）调用return返回上一级，此时返回一个值比如-1，用于表示函数执行出问题了。
			
			当然有需要的话，还应该对错误进行相应的处理。
			


7.4 如何编译得到得到Debug和Release程序			
		后面再介绍这个问题。
	
			
		
8. 可变参函数、可变参宏、do{}while(0)的妙用
8.1 可变参函数
8.1.1 什么是可变参函数
	参数个数和类型不定的函数就是可变参函数，比如scanf和printf函数就是典型的可变参函数。
	
	
8.1.2 介绍可变参函数的意义
	实际上我们自己所写的99%的c函数都是“定参函数”，参数个数和参数类型的都是确定，比如：
		
		void fun(int a, int *p, float c) //定参函数
		{
			...
		}
		
		我们自己使用“可变参函数”的情况并不多见，那么我们这里讲可变参函数的意义何在呢？
（1）虽然用的机会不多，但是有时还是有使用的可能的
（2）能够看懂c源码中可能存在的“可变参函数”
（3）借此理解printf、scanf可变参的实现原理，对printf、scanf函数不再感到神秘
（4）顺带介绍函数参数的“入栈顺序”
	
		对于可变参的学习重在理解，不要死记忆，死记忆没有意义，当你真的某天用到时，能够基于理解然后快速用起来，
	这就可以了。
			
			
8.1.3 形参的入栈
（1）形参空间的开辟
		在前面的章节讲过，在intel x86这种寄存器偏少的cpu和ARM这种寄存器偏多的cpu，形参空间的开辟会
	有所不同。
		ARM：前四个形参空间开辟寄存器上，超过四个的多余的形参，则开辟在栈（内存）中。
				这样做的目的是为了提高形参访问效率，因为寄存器的放速度要高于内存。
				
		x86：所有的形参空间都开辟于栈中
			
		为了便于讲解，我们这里只考虑所有形参都开辟于栈中的情况。
		
		
（2）形参的入栈顺序
		例子：
		void fun(char a, int b, int c, float d)
		{
			...
		}
		
		int main(void)
		{
				fun('a', 34, 42, 43.98);
				
				return 0;
		}		
		
		顺序有两种：
		1）左到右
				也就是a b c d的顺序入栈。
				图6：
				
				
				
				
				a: 高地址
				...
				...
				b：低地址
				
				我们将函数时，也提高过入栈，当时我们默认介绍的是“左到右”的入栈顺序。
				
		2）右到左
				也就是d c b a的顺序入栈。
				图：
		
		
				a: 低地址
				...
				...
				b：高地址
		
			不同平台（与OS、cpu）的入栈顺序是不一致的，入栈顺序与cpu、OS都有关系。
		
（2）怎么测试入栈顺序
		#include "stdio.h"
		
		void fun(int a, int b, int c, int d)
		{
				printf("%p\n", &a);
				printf("%p\n", &b);
				printf("%p\n", &c);
				printf("%p\n", &d);
		}

		int main(void)
		{
				fun(20, 34, 42, 43);

				return 0;
		}
		
		查看打印顺序：
		如果打印地址为从高到底：从右到左入栈
		
		windows这边是从“右到左”入栈的。
		
		如果打印地址为从低到高：从左到右入栈
		
		在Windows上的运行结果：
			0060ff00
			0060ff04
			0060ff08
			0060ff0c
			Windows为从右到左入栈
		
		在Linux上的运行结果：
			0x7ffdcac8fe3c
			0x7ffdcac8fe38
			0x7ffdcac8fe34
			0x7ffdcac8fe30
			Linux为从左到右入栈
			
		介绍入栈顺序的目的，主要是为了方便我们后面举例介绍“可变参函数”的实现。
				
8.1.4 可变参的实现

（1）可变参函数的定义格式		

		返回类型 fun(type fmt, ...)
		返回类型 fun(type fmt, type fm, ...)
		.......
		
		...代表可变参数，其它的为固定参数，而且至少包含一个固定参数，...只能在最后。
		
		scanf和printf的函数原型：
			int printf(const char *format, ...);
			int scanf(const char *format, ...);
			
		从格式可以明显看出，scanf和printf也是可变参函数。
								
		
（2）获取“可变参数”的原理
		
		可变参函数的定义格式非常简单，但问题是，我们应该如何获取每一个变参中值呢？
		不管形参时从左到右入栈，还是从右到左入栈，其实获取变参值的原理都是一样的，之后举例时
	我们就以“从右到左”的顺序来介绍。
	
		例子：	
		void fun(char *fmt, ...)
		{
			//获取...中每一个变参的值，然后进行处理
		}
		
		int main(void)
		{	
			fun("xxx", 10, 'a', 123.56);
			
			return 0;
		}	
		
		fun的第一个形参的类型为char *，这个是定参，类型是写死的，而...中每个变参的类型则是由实参的类型来
	决定的。
		
		不过需要注意的是，在变参中当实参为int，short，char时，变参统统以int来接收，实参为float、double时则
	统统以double来接收：
		· 10、'a'：以int接收，也就说会从栈中开辟int空间来存放
		· 123.56：以double来接收。
		· "xxx"：为字符串常量，实际是存放在了.rodata中，“固定形参fmt”中放的只是字符串指针。
			
		我们假设是“从右到左”入栈。
		图7：
		
		
		
		
		在fun函数中，如何访问...所代表的每个形参值呢？
		第1步：首先我们使用一个char *的指针变量（比如ap），指向...中第一个变参的空间，也就是...最左边的那个。
			图：
			
					
		第2步：ap + ...中每个变参空间的大小，然后得到每一个变参空间的地址，然后再以每个变参空间的类型去解释
			“地址”所指向的空间。
			图8：
		
			疑问：如何知道...中每个参数的类型呢？
			答：我们需要通过第一个fmt参数来得知...中每个变参的类型，讲到这里大家应该清楚了为什么scanf和printf
			函数的第一个参数会指定%d %s %f等格式，
						printf("%d %f\n", 12, 123.56); 
						
			这些格式就是用来指明每个变参的类型的，如果没有这些格式说明的话，就没有办法去解释每个变参空间。
			我们自己再实现“变参函数”时，可以沿用%d %f等这些格式，也可以自己规定新的格式，比如：
					c：char
					s：short
					i：int
					f：float
					d：double
										
					
（3）“解析变参”的具体实现	
		1）具体实现步骤
				具体实现时，会使用到va_start、va_arg、va_end带参宏，这个几个宏定义在了stdarg.h中，
			我们实现变参函数时，必须包含这个.h，讲第5章时我们介绍过stdarg.h，大家应该有映像。
			
			（a）定义一个char *指针变量	
					va_list ap
					
					va_list为typedef重命名后的类型名（typedef char* va_list），所以
					va_list ap等价于char *ap。
					
					
			（b）让ap指向...中第一个参数的空间
					va_start(ap, prev_param) 
					
				 · ap：指向...中的第一个变参
				 · prev_param：...前的最后一个固定参数
						...中的第一个参数与prev_param是紧挨着的，通过prev_param这个固定参数的指针，就可以计算机出
					...第一个参数的指针。
					
					
			（c）让指针ap的指向发生移动，指向...中下一个变参的空间
					va_arg(ap, type)  
					
					· ap：指向当前空间
					· type：当前空间的类型，具体代表什么类型，需要通过fmt来指定
						
					va_arg宏会计算出下一个变参空间的指针，计算方法为ap = ap + sizeof(type);
					我们只要拿到了...变参空间的指针，然后将ap强转为type *后，就可以解引用访问。		
					
			（d）va_end(ap)
					操作完毕后，我们需要使用va_end将ap赋值为NULL，防止ap变为野指针，给程序带来潜在风险。
					其实我们直接ap = NULL也是可以的。
					
					
					
					
		2）例子代码
			#include "stdio.h"
			#include <stdarg.h> //必须包含

			void fun(char *fmt, ...)
			{
					int i = 0;

					va_list ap = NULL; //等价于char *ap

					va_start(ap, fmt); //让ap指向f...中的第一个参数

					for(i=0; i<strlen(fmt); i++)
					{
							switch(fmt[i])
							{
									//c、s、i都以int解释
									case 'c':
									case 's':
									case 'i':
											printf("%d\n", *((int *)ap));
											va_arg(ap, int);  	//指向下一个变参空间
											break;

									//f、double都以double解释
									case 'f':
									case 'd':
											printf("%lf\n", *((double *)ap));
											va_arg(ap, float);	//指向下一个变参空间
											break;
							}
					}

					va_end(ap); //等价于ap = NULL
			}

			int main(void)
			{
					int a = 10;
					char b = 'a';
					float c = 123.56;
					
					//"icf"为 a b c各自对应的格式，对应关系必须一致，不能颠倒，否则解释就会出错
					fun("icf", a, b, c);

					return 0;
			}
			
			
8.2 可变参宏	
8.2.1 可变参宏的写法
	也是使用...来表示的，可变参宏其实就是为了和可变参函数配合使用而出现的。
	
	
8.2.2 常见的各种写法
（1）c标准语法所规定的写法
		#define debug(fmt, ...)  printf(fmt, __VA_ARGS__)  //写__VA_ARGS__代表“可变参数”
		
		debug("%d %s\n", 234, "sdfdsf"); //参数可以根据自己的情况来变化
		
		
（2）GCC扩展语法
		#define debug(format, args...) printf(format, args)  //args这个名字并不固定
		
		我们前面使用的就是这种情况。
	
	
8.2.2 如果不传递“可变参数”会怎样
	比如：
	#define debug(format, args...) fprintf(format, args)
	
	debug("11111111\n");  //只传递了第一个参数，可变参数一个也没有	
	
	编译时会报错，那如何解决这个问题呢？
	使用##来解决，将以上宏定义改为如下形式。
	#define debug(fmt, ...)  printf(fmt, ##__VA_ARGS__)
	或者：
	#define debug(format, args...) printf(format, ##args) 
		
	debug("11111111\n");  //这个写法就是允许的，适应起来可以更加的灵活 
		
	##的作用我们在第2章就详细介绍过，至于##在这里的作用，大家只需记住，有了##后就可以省略“可变参数”。
	为了让我们的调试宏更加的灵活，我们前面介绍的调试宏，都应该加上##。
		
		
		
8.3 do{}while(0)的妙用
8.3.1 定义复杂宏时避免;所带来的错误
		
		我们以前面的print_error宏为例，其实完全可以将do{}while(0);改为{}，改变后为
		#define print_error(str) \
		do{\
				fprintf(stderr, "File %s, Line %d, Function %s error\n", __FILE__, __LINE__, str);\
				perror("error Reason");\
				exit(-1);\
		}while(0);
		
		
		#define print_error(str) \
		{\
				fprintf(stderr, "File %s, Line %d, Function %s error\n", __FILE__, __LINE__, str);\
				perror("error Reason");\
				exit(-1);\
		}
		
		
		我们平时使用宏时往往喜欢加;，但是当前面为if判断时，加;会导致出现错误。
			if(NULL == *p) 
				print_error("malloc");	
			else 
			{
				...
			}
			
			进行宏展开：
			
			if(NULL == *p) 
			{
				fprintf(stderr, "File %s, Line %d, Function %s error\n", __FILE__, __LINE__, str);
				perror("error Reason");
				exit(-1);
			};
			else 
			{
				...
			}

			在if的最后}后面是不能加;的，否则编译会报错。
			那么有些同学可能会说，只要记住不能加;就可以了，但是但凡是靠人预防都是容易出问题的，所以我们需要
		更保险、更傻瓜的方法，有了这个保险的方法后，不需要我们去刻意记忆要加不加;这种麻烦事。
		
			但是我们使用do{}while(0);进行改进后：
			#define print_error(str) \
			do{\
					fprintf(stderr, "File %s, Line %d, Function %s error\n", __FILE__, __LINE__, str);\
					perror("error Reason");\
					exit(-1);\
			}while(0);
			
			if(NULL == *p) 
				print_error( "malloc");
			else 
			{
				...
			}
			
			进行展开后：
			
			if(NULL == *p) 
			do{
					fprintf(stderr, "File %s, Line %d, Function %s error\n", __FILE__, __LINE__, str);
					perror("error Reason");
					exit(-1);
			}while(0)
			else 
			{
				...
			}
			
			此时不加;和多加;都无所谓，不加原本就有一个;，多加也不会报错。

			do{}while(0);里面虽然包裹了好几句话，但是整体上do{}while(0);为一句话，与下面的写法是类似的
			if(a > 100)
				printf("hello wolrd\n");  //一句话时{}可以省略

				
			do{...}while(0);与其一样，也为一句话，当然你也可以将{}加上。
			if(NULL == *p) 
			{
				do{
					fprintf(stderr, "File %s, Line %d, Function %s error\n", __FILE__, __LINE__, str);
					perror("error Reason");
					exit(-1);
				}while(0);;  //两个;;无所谓
			}
			
			但是由于里面只有一句话，所以外面的{}完全可以省略。
			
			
			
			事实上在Linux下面，do{}while(0)还可以被({...;..;})替换，这个玩意我们在上一章就介绍过，它的作用与 
		do{}while(0)所希望起到的作用是一样的，所以
				define print_error(str)\
				do{\
						fprintf(stderr, "File %s, Line %d, Function %s error\n", __FILE__, __LINE__, str);\
						perror("error Reason");\
						exit(-1);\
				}while(0);
				
			完全可以替换为：
				define print_error(str)
				({\
						fprintf(stderr, "File %s, Line %d, Function %s error\n", __FILE__, __LINE__, str);\
						perror("error Reason");\
						exit(-1);\
				})
					
				({...;..;})能够将多句话合为一句话。
				
				不过由于({...;..;})是gcc才支持的写法，其它编译器不一定能识别，所以我们建议使用do{}while(0)。
			
			
				#define container_of(ptr, type, member)\
					({ \
						const typeof( ((type *)0)->member ) *__mptr = (ptr);\
						(type *)( (char *)__mptr - offsetof(type,member) );  \
					})
					
					
				使用do{}while(0)来代替({...;..;})
					#define container_of(ptr, type, member)\
						do{ \
							const typeof( ((type *)0)->member ) *__mptr = (ptr);\
							(type *)( (char *)__mptr - offsetof(type,member) );  \
						} while(0)
	
			
8.3.2 避免使用大量的goto的使用
	
	先举一个大量使用goto的例子。	
		int fun()
		{
			int ret = 0;
			
			somestruct *ptr = malloc(...);
			
			ret = fun1(ptr); //返回1代表Ok
			if(ret != 1)
					goto FREE;
			
			ret = fun2(ptr); //返回1代表Ok
			if(ret != 1)
					goto FREE;
			
			ret = fun3(ptr); //返回1代表Ok
			if(ret != 1)
					goto FREE;
			
			
		FREE:
			free(ptr);
			return 0;
		}
		
		因为goto的缺点，在c实际上不建议大量使用goto，但是这里确使用了很多的goto，显然不好，此时我们可以改为
	如下形式：			
		int fun()
		{
			int ret = 0;
			
			somestruct *ptr = malloc(...);
			
			ret = fun1(ptr); //返回1代表Ok
			if(ret != 1)
			{
				free(ptr);
				return 0;
			}
			
			ret = fun2(ptr); //返回1代表Ok
			if(ret != 1)
			{
				free(ptr);
				return 0;
			}
			
			ret = fun3(ptr); //返回1代表Ok
			if(ret != 1)
			{
				free(ptr);
				return 0;
			}
			
			return 0;
		}
			
		这个写法也是可以的，但是这会多出很多冗余代码，让代码变的很臃肿，此时我们就可以使用do{...}while(0);
		即能避免大量goto的使用，又可以让代码变的很简洁。
		int fun()
		{
			int ret = 0;
			
			somestruct *ptr = malloc(...);
			
			do
			{
				ret = fun1(ptr); 
				if(ret != 1) break;
				
				ret = fun2(ptr); 
				if(ret != 1) break;
				
				ret = fun3(ptr); 
				if(ret != 1) break;
			}while(0);
			
			free(ptr);
			return 0;
		}
		
		如果这里不使用do{...}while(0)的话，就只能使用前面的goto方式或者更繁琐的方式来实现。
			

9. c内嵌汇编（内联汇编）
9.1 什么是c内嵌汇编
		所谓c内嵌汇编，就是在c代码中嵌入汇编代码，不过此时需要使用asm关键字。
		asm为GCC编译器的扩展关键字，而__asm__、__asm则为asm的另两个名字。
	
	
9.2 内嵌格式
		__asm__ (汇编代码);
		
		为了防止优化，一般还会加上volatile或者__volatile__
		
		准确格式：
		__asm__ __volatile__(汇编语句模板 : 输出部分 : 输入部分 : 破坏描述部分);
		
		如果是运行在ARM cpu上，内嵌的就是ARM的汇编，如果是运行在Intel cpu上，内嵌的就是Intel的汇编。
	
		void test(void)
		{
			int input = 10,result;
			
			
			__asm__ __volatile__ 
			(
				"movl %1,%0" :

				"=r" (result) : "r" (input)
			);

			return;
		}
		
9.3 我们为什么要介绍内嵌汇编
		我们介绍内嵌汇编的目的，并不是想让大家去学习和掌握内嵌汇编，事实上对于我们c应用开发来说，内嵌汇编
	没有意义，我们不会用到，如果你花大把时间到这个里面去会得不偿失。
	
		疑问：什么时候使用内嵌汇编呢？
		答：使用内联汇编的场合非常少，只有在极少数的情况下才会用到，在我们c应用代码中几乎用不到，只有在
			Linux内核源码种可能才会见到，而且使用的也不多。
			
			我们这里之所以介绍内嵌函数，只是想告诉你有这么个东西存在，以后你要看见了，知道这是什么，对待
		方式就是忽略它。
		
		
10. 控制台程序 和 app应用程序	
	我们以codeblockes IDE为例，使用IDE创建工程时，其中有两个选择：
· Console application：控制台程序
· GUI application：GUI程序
	图:

	
10.1 Console application：控制台程序
	程序运行时如果交互界面为“控制台（命令行）”的话，这个程序就是控制程序（命令行程序）。
	图：
	
	
	如果创建工程时，你选择的是Console的，程序就只能通过“命令行”来交互（输入输出）。
	一般大家在初学c语言时，以及做底层开发时，使用的都是命令行交互界面。
	
	
10.2 GUI application：GUI程序
	GUI为Graphical User Interface，程序交互界面为更加人性化的“图形化界面”。
	
	如果你选择GUI的话，IDE就会提供“按钮、控制、输入框、文本框”的开发界面，方便开发GUI界面。

	
	

11. 断言（assert）
11.1 程序调试
	进行程序调试时，为了辅助我们调试，我们往往需要知道某些条件是否成立，某些值是否为我们需要的值，此时
我们可通过if判断、以printf打印来测试。
	比如：举一个简单的例子。
		
		void fun(int a, int b)
		{
			//调试检测传参是否符合要求
			if(a!=10)
			{
				printf("a:%d，非法参数\n"， a);
				exit(-1);
			}
			if(b!=20) 
			{
				printf("b:%d，非法参数\n"， b);
				exit(-1);
			}
			//...
		}
		
		int main(void)
		{	
			int a=10;
			int b=20;
			
			fun(a, b);
			
			retutn 0;
		}	
		
		但是if、printf这种做法存在如下问题：
		1）代码繁琐
		2）这个代码只是辅助调试的代码，最终发布程序时，这些代码都是要删除的，如果程序里面写了大量的这种
			代码的话，删除是一个很麻烦的事情，如果这些代码不删除，会增加程序的代码量，所以凡是与调试相关的信
			息，都是要删除的。

		此时我们可以使用assert（宏）来辅助调试。
		
11.2 assert宏		
		在前面的课程就介绍过，使用assert宏（断言）时，被定义在了assert.h，如果要使用assert宏的话，必须包含
	assert.h。
		#include <assert.h>
		
		void fun(int a, int b)
		{
			assert(a==10);
			assert(b==20);
			
			//...
		}
		
		int main(void)
		{	
			int a=10;
			int b=20;
			
			fun(a, b);
			
			return 0;
		}			
		
		assert中的判断需要反过来写，意思就是我（程序员）断言a==10，b==20，只要assert断言的条件为真，那么
	assert什么都不会做，因为我们要的就是a==10、b==20。
		但是如果判断为假的话，就证明参数出了问题，此时：
		· assert宏就会打印出断言出错位置：文件、函数、行号
		· 调用abort函数，然后让进程（程序）异常终止。

		我们这里的例子很简单，assert用来测试传参的合法性，但不要被例子所误导，以为只能用在传参的判断上，
	事实上调试，assert可以用在有判断需求的任何地方。
		
		
		
11.3 如何让assert宏失效
		gcc时通过-D指定NDEBUG宏即可让assert失效，比如：
		
		gcc a.c -DNDEBUG 
				
		之所以指定这个宏，这个与assert的实现原理有关，有关assert的具体实现，请大家自己查看c标准库assert.h中
	的内容，我们这里不再啰嗦，不过我认为没有必要去查看。
		
		
		
11.4 有些if判断是不能使用assert替换的
	前面说过，当正式release版（发行版）的程序时，assert将会无效，正常代码中的if判断是不能使用assert来代替。
	
	只有调试时钟涉及到的if判断，我们才会使用assert来代替。
	
	
	比如：
	（1）需要判断用户输入数据是否正确，如果不正确的话，就需要进行异常处理，此时就需要进行if判断，像这类
		的if判断是正代码，是不能使用assert来替换
			
	（2）函数报错处理的if不能使用assert代替
			比如：
				int *p = malloc(sizeof(int));
				if(NULL == p)
				{
					perror("malloc");
					exit(-1);
				}
				
				assert(p!=NULL); //这里是多余
				
				
				这类函数出错处理的代码必须要有的，所以不能使用assert代替。
			像这种已经有现成的if判断的地方，就没有必要再加上assert了，加上了也是多余，因此这个if判断也能帮
			我们报错。
		
	总结：什么时候使用断言？
	调试时，当我们不清楚程序中某些值是否为我们期望的值时，我们就可以使用assert判断，如果我们能够将debug
	打印调试宏与assert宏配合使用好的话，这将是我们很好的调试利器。

	
	
12. 编译得到“调试版” 与 “发行版”程序

12.1 调试版（DEBUG版）
	调试版的目的只有一个，在程序中需要包含各种调试信息，帮助我们进行程序调试。

12.1.1 命令行
（1）gcc时加上-g选项，在程序中包含“单步调试信息”
（2）gcc 通过-D指定DEBUG宏，使能debug打印调试宏
（3）gcc时不要指定NDEBUG宏，调试时assert断言宏有效
（4）其它：暂不关心

12.1.2 IDE 
（1）创建Debug版工程，编译时会动加上“单步调试信息”
（2）在IDE中设置DEBUG宏，使能debug打印调试宏
（3）不要指定NDEBUG宏，调试时让assert有效
（4）其它：暂不关心
		
		
12.2 发行版（RELEASE版）
	发行RELEASE版程序时，说明bug都已经被调试找出，此时可以发行了，发行时就需要将各种调试信息全部去掉，
如果你不去掉的话，这些调试信息就会非常的占用资源（内存）。
	
12.2.1 命令行
（1）gcc时指定-s，去掉“单步调试信息”
（2）gcc时不指定DEBUG宏，让所有的“debug打印调试宏”失效
（3）gcc时通过-D指定NDEBUG宏，让所assert宏也失效
（4）其它：比如进行一定程度的优化等，暂时不关心

	经过以上步骤后，就可以瘦身得到RELEASE版程序，编译时对DEBUG版程序瘦身之后，就能得到RELEASE版程序。
	
	
12.2.2 IDE
（1）将DEBUG工程改为RELEASE工程，编译时会自动删除“单步调试信息”
（2）在IDE中不要指定DEBUG宏，让所有的“debug打印调试宏”失效
（3）在IDE中指定NDEBUG宏，让所有assert宏失效
（4）其它：比如进行一定程度的优化等，暂时不关心
	
	
	
	
	