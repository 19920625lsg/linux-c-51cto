第10章 高级IO

1. 本章讲的是些什么？

		我们在第1章学习过“文件io”，第3章学过“标准IO”，标准IO是对文件IO封装得到的，不管文件io还是标准IO，
	讲的都是如何对文件进行读写数据。
		
		本章叫“高级IO”，从名字可以看出也与IO有关，但是本章所讲不仅仅是普通的数据读写，而是与数据读写
	（IO）有关的一些高级操作。
	
	
	· 本章所讲的高级IO有哪些？
	（1）非阻塞IO
	（2）记录锁（文件锁）
	（3）io多路复用（I/O multiplexing）
	（4）异步IO
	（5）存储映射
		
		本章所有的内容都与文件的IO有关（数据读写），只要涉及到文件的IO操作，就必然有文件描述符这个东西，
	所以本章所有的IO高级操作，都是使用fd来实现的。
		
		本章除了第5个“存储映射”外，其它高级IO操作都必须依赖fcntl函数的支持，所以对于本章来说，fcntl函数
	很重要。
	
		我们在讲第一章时就讲过这个函数，这个函数是一个杂物箱，有很多功能，但是第一章后这个函数一直
	没有怎么用，所以大家可能觉得有些生疏，但是不要紧，本章将会频繁的使用这个函数，经过了本章的学习后，
	大家对fcntl将不会再陌生。
	
	

2. 学习本章有用吗？
		本章所讲的内容，在后续的驱动课程中会经常用到，不用介绍太多的意义，就这一条就可以看出，本章很重要，
	所以请各位同学一定认真学习本章内容。
		
		对于本章来说没有太多的理论需要大家理解，本章的重点是掌握如何使用这些高级IO机制。
		重点学会使用高级IO相关的函数。
		
		当然，虽然本章很重要，但是对于本章的学习，同样是理解为重，不要死记硬背，理解后当你真的用到时，能够
	查阅笔记和资料快速用起来，就说明本章你学会了。

		
3. 非阻塞IO
	
	3.1 阻塞读文件
			从前面的课程中我们了解，读某些文件时，如果文件没有数据的话，往往会导致读操作会阻塞（休眠）。
		比如：
		（1）读鼠标、键盘等字符设备文件
		（2）读管道文件（有名无名）
			
				代码演示：
					阻塞读鼠标和键盘
			
		
		
		
		
		（1）疑问：读普通文件会阻塞吗？
				读普通文件时，如果读到了数据就成功返回，如果没有读到数据返回0，总之不会阻塞。
			
			
					演示：
				
					总之，不管有没有从普通文件读到数据，读普通文件时都不会阻塞。
		
		
		（2）疑问：写文件时会阻塞吗？
				在写某些文件时，当文件不能立即接收写入的数据时，也可能会导致写操作阻塞，一直阻塞到写成功为止。
			一把来说，写文件不会阻塞，因此我们不考虑写文件阻塞的情况，我们这里只讲读文件阻塞的情况。
		
		
		
	3.2 阻塞是好还是坏
			实际上读文件因为没有数据而阻塞，其实是好事，因为这样子就进入休眠状态，休眠时就不会占用CPU，节省了
		cpu的资源。
			
			我能不能将阻塞的读修改为非阻塞的读呢？
			答：可以，非阻塞读的意思就是说，如果有数据就成功读到，如果没有读到数据就出错返回，而不是阻塞。
				
				
			疑问：既然阻塞读很好，为什么提供非阻塞读呢？
			答：尽管我们很少非阻塞的读，但是有些时候还真需要非阻塞的读，因此OS还是为我们提供了非阻塞操作方式。
	
	3.3 如何实现非阻塞读
	
		（1）打开文件时指定O_NONBLOCK状态标志
				fd = open("/dev/input/mouse0", O_RDONLY|O_NONBLOCK);
        if(fd < 0)
        {    
						perror("open /dev/input/mouse1 is fail");
            exit(-1);
        }   
				代码演示：
						

				
				在讲IPC有名管道时，如果不希望阻塞的话，就可以在open打开“有名管道”时，指定O_NONBLOCK，然后读有名
			管道无数据时就不会阻塞。
				
				
				
		（2）通过fcntl函数指定O_NONBLOCK来实现
		
				什么情况下会使用fcntl来实现，
				
				1）情况1：当文件已经被open打开了，但是open是并没有指定你要的文件状态标志，而你又不下你给去修改
							open的参数，此时就是可以使用fcntl来重设或者补设。
				
				2）情况2：没办法在open指定，你手里只有一个文件描述符fd，此时就使用fcntl来重设或者补设
						比如无名管道，无名管道连名字都没有，没办法使用open函数，无名管道是使用pipe函数来返回文件
					描述符的，如果过你想非阻塞的读无名管道的话，是没有办法通过open来指定O_NONBLOCK的，此时就需
					要使用fcntl来重设或者补设。
				
				
						当然我们使用fcntl不仅仅只能重设或者补设O_NONBLOCK，也可以重设或者补设O_TRUNC/O_APPEND等任何
					你需要的“文件状态”标志。
				
				
					例子：将0设置为O_NONBLOCK。
					
					设置有两种方式：
					· 重设
						fcntl(0, F_SETFL, O_RDONLY|O_NONBLOCK);
					
					· 补设
						flag = fcntl(0, F_GETFL); 	//获取原有文件状态标志
						flag = flag | O_NONBLOCK; 	//通过|操作，在已有的标志上增设O_NONBLOCK
						fcntl(0, F_SETFL, flag); 		//将修改后的“文件状态标志”设置回去
						
						图：文件表
							

						
	

						
	3.4 实现同时“读鼠标”和“读键盘”
			
			由于一般情况下，“读鼠标”和“读键盘”都是阻塞的，为了不要让“读鼠标”和“读键盘”因为阻塞而相互干扰，
		可以采取如下办法来读。
		
		（1）fork子进程，然后父子进程两线任务
				父进程：读键盘
				子进程：读鼠标
					
				请自己实现：
				
					这种方式肯定是没问题的，但是我们这里仅仅只是告诉你这样可以，但是我们并不主张大家这么做，
				因为我们说过，多线任务时不要使用多进程来实现，开销太大。
				
			
		（2）创建次线程，主线程和次线程两线任务
				主线程：读键盘
				次线程：读鼠标
				
				这才是我们经常实现的方式。
				
				请自行实现：
				
			
		（3）将鼠标和键盘设置为“非阻塞”，while轮询的读。
				
				
		
		
		

		（4）补充
						把0设置为非阻塞，请问使用scanf从键盘读数据时阻塞的吗？
						
						代码演示：
						
						
					
					为什么scanf也不阻塞？
						scanf()是调用read(0, ...)来实现的，这个我们在第一章就讲的非常清楚，scanf的阻塞是因为调用
					read阻塞读0描述符导致的，既然已经将0改为了非阻塞，read读0就不再阻塞，自然scanf也就不再阻塞。
						
						
						所以如果你不想scanf阻塞的话，就可以将0描述符设置为非阻塞。
						
						当然我这个话只能针对Linux，因为fcntl函数是Linux的系统函数，不是标准C库函数，这个函数在
					windows那边不一定支持，在windows等系统下，如何设置非阻塞，他们的系统API可能不一样。
						
						不过对于c的标准IO函数scanf来说，都是希望阻塞读的，基本不会遇到需要将scanf改为非阻塞的情况。

4. 文件锁

		文件锁也被称为记录所，文件锁如果深讲的话，内容不少（比如文件锁最起码分为了建议锁和强制性锁）。
		
		但是我们这里不准备深讲，深讲没有任何意义，因为在后面的嵌入式课程和实际开发中，文件锁用到的机会
	并不多，那我们为什么还要讲呢？
	
		主要是为了对比学习各种的加锁机制，比如进程有进程信号量加锁机制，线程有线程互斥锁、线程信号量等
	加锁机制，学习文件锁有助于我们对比理解，对于我们后续理解驱动课程中的内核锁，c++、java等库所提供的
	资源保护的锁机制，都是很有意义的。

		当然还有另一个目的，那就是练习fcntl函数的使用，因为文件锁也需要用到fcntl函数。
	
		由于文件锁的知识点是刚才所讲的这样一种存在，所以对于文件锁内容的学习，理解>实际使用。
	
	
	4.1 文件锁的作用
			顾名思义，就是用来保护文件数据的。
			
			当多个进程共享读写同一个文件时，为了不让进程们各自读写数据时相互干扰，我们可以使用进程信号量来
		互斥实现，除了可以使用进程信号量以外，还可以使用我们本小节要讲的“文件锁”来实现，而且功能更丰富，
		使用起来相对还更容易些。

		
	4.2 多进程读写文件
	
			图：
	
	
	
	
			多进程共享读写同一个文件时，如果数据很重要的话，为了防止数据相互修改，应该满足如下读写条件：

		（1）写与写应该互斥
					当某个进程正在写文件，而且在数据没有写完时，其它进程不能写，否者会相互打乱对方写的数据。
					
					
		（2）读与写也应该是互斥的
				分两种情况：
		
				1）某个进程正在写数据，而且在数据没有写完时，其它进程不能读数据
						因为别人在没有写完之前，读到的数据是不完整的，所以读和写时互斥的。
					
				2）某个进程正在读数据，在数据没有读完之前，其它进程不能写数据
						因为可能会扰乱别人读到的数据。
		
		
		（3）读与读共享
					某个进程在读数时，就算数据没有读完，其它进程也可以共享读数据，并不需要互斥等别人读完后才能读。
				因为读文件是不会修改文件的内容，所以不用担心数据相互干扰的问题。
				
				
				总结起来就是，多进程读写文件时，如果你想进行资源保护的话，完美的资源保护应该满足如下这样的。				
				1）写与写之间互斥
				2）读与写之间互斥
				3）读与读之间共享
			
				
				如何实现以上读写要求？
						如果使用信号量来实现保护的话，只能是一律互斥，包括读与读都是互斥的，不能够向上面描述的，
				既能互斥又能共享，但是文件锁可以做到。
		
	4.3 文件锁
	
		4.3.1 文件锁的读锁与写锁
			对文件加锁时可以加两种锁，分别是“读文件锁”和“写文件锁”，我们这里简称为读锁和写锁。
			
			读锁、写锁之间关系
			
			（1）读锁和读锁共享：可以重复加读锁，别人加了读锁在没有解锁之前，我依然可以加读锁，这就是共享。	
				
			（2）读锁与写锁互斥：别人加了读锁没有解锁前，加写锁会失败，反过来也是如此。
					加锁失败后两种处理方式，
						- 阻塞，直到别人解锁然后加锁成功为止
						- 出错返回，不阻塞
					
					
			（3）写锁与写锁互斥：别人加了写锁在没有解锁前，不能加写锁，加写锁会失败。
					
					加锁失败后两种处理方式，
						- 阻塞，直到别人解锁然后加锁成功为止
						- 出错返回，不阻塞
					
					我们常用的是阻塞加锁，至于如何实现阻塞和非阻塞，后面详细讲。
						
	
		4.3.2 使用文件锁对文件进行保护
			读文件时加读锁，写文件时就加写锁，然后就可以很容易的实现符合如下要求的资源保护。
			
			1）写与写之间互斥
			2）读与写之间互斥
			3）读与读之间共享
			
			图：

			
	
			
	4.4 文件锁的加锁方式
	
		（1）对整个文件内容加锁
		
					对整个文件加锁是最常用的文件锁的加锁方式。
				
					当你对整个文件加锁时，如果文件的长度因为写入新数据或者截短而发生了变化，加锁内容的长度会
				自动变化，保证对内容变化着的整个文件加锁。
				
				
		（2）对文件某部分内容加锁			
					图：
						
				不过一般来说是，对多少内容加锁，就对多少内容解锁，如果你是对整个文件加锁，就将整个文件解锁。
				
				但是实际上加锁和实际解锁的长度可以不相同，比如我对1000个字节的内容加了锁，但是可以只对其中的
				100字节解锁，不过这种情况用的少，知道有这么回事即可。
				
			怎么实现文件的整个加锁和区域加锁呢？
			后面再详细介绍。
			
		
	4.5 文件锁的实现
			实现文件锁时，我们还是需要使用fcntl函数。
	
	
		4.4.1 再看看fcntl的函数原型
				#include <unistd.h>
				#include <fcntl.h>
			
				int fcntl(int fd, int cmd, .../*struct flock *flockptr */ );
				
				第三个参数是...，fcntl函数是一个变参函数，第三个参数用不到时就不写。
			
			（1）功能

						fcntl函数有多种功能，我们这里主要介绍实现文件锁的功能，当cmd被设置的是与文件锁相关的宏时，
					fcntl就是用于实现文件锁。
	
			（2）返回值：成功返回0，失败则返回-1，并且errno被设置。		
					
			（3）参数
					1）fd：文件描述符，指向需要被加锁的文件。
					2）cmd：实现文件锁时，cmd有三种设置，F_GETLK、F_SETLK和F_SETLKW含义如下：
					 
					 （a）F_GETLK
								从内核获取文件锁的信息，将其保存到第三个参数，此时第三个参数为struct flock *flockptr。
								我们这里是要设置文件锁，而不是获取已有文件锁的信息，我们这里用不到这个宏。
								
					 （b）F_SETLK
								设置第三个参数所代表的文件锁，而且设置的是非阻塞文件锁，也就是如果加锁失败不会阻塞。
								也就是说加锁失败后如果不想阻塞的话，就是由F_SETLK宏来决定的。
								
								此时需要用到第三个参数，struct flock *flockptr。
								
								使用举例：
								· 第一步：定义一个struct flock flockptr结构体变量（这个结构体变量就是文件锁）。
								· 第二步：设置flockptr的成员，表示你想设置什么样的文件锁。
								· 第三步：通过第三个参数，将设置好的flockptr的地址传递给fcntl，设置你要的文件锁
							
							
					 （c）F_SETLKW
								与F_SETLK一样，只不过设置的是阻塞文件锁，也就说加锁不成功的话就阻塞，是由F_SETLKW
							宏来决定的。
							
							
					int fcntl(int fd, int cmd, .../*struct flock *flockptr */ );
					3）第三个参数
								第三个参数设置为什么视情况而定，如果fcntl用于实现文件锁的话，第三个参数为
							struct flock *flockptr，flockptr代表的就是文件锁。
								
								对flockptr的成员设置为特定的值，就可以将文件锁设置为你想要的锁。
								
							struct flock结构体如下：
							（a）结构体原型
									struct flock
									{
											short l_type;   // Type of lock: F_RDLCK,F_WRLCK, F_UNLCK 
											short l_whence; //How to interpret l_start:SEEK_SET, SEEK_CUR, SEEK_END
											off_t l_start;   // Starting offset for lock 
											off_t l_len;    //Number of bytes to lock 
											pid_t l_pid;    //PID of process blocking our lock(F_GETLK only) 
									}

									成员说明：
									· l_type：锁类型
										- F_RDLCK：读锁（或称共享锁）
										- F_WRLCK：写锁
										- F_UNLCK：解锁 
											
									· l_whence：加锁位置粗定位，设置同lseek的whence
										- SEEK_SET：文件开始处 
										- SEEK_CUR：文件当前位置处
										- SEEK_END：文件末尾位置处
										
										l_whence这个与lseek函数的whence是一个含义，
											off_t lseek(int fd, off_t offset, int whence);
										
										在第1章文件IO我们就详细的讲过lseek函数。
										
									· l_start：精定位，相对l_whence的偏移，与lseek的offset的含义完全一致
										
										通过l_whence和l_start的值，就可以用来指定从文件的什么位置开始加锁，不过一般来说，
										我们会将l_whence指定为SEEK_SET，l_start指定为0，表示从整个文件头上开始加锁。
										
										
									· l_len：从l_whence和l_start所指定的起始地点算起，对文件多长的内容加锁。 
											如果l_len被设置0，表示一直加锁到文件的末尾，如果文件长度是变化的，将自动调整
										加锁的末尾位置。
											
											将l_whence和l_start设置为SEEK_SET和0，然后再将l_len设置为0，就表示从文件头加锁
										到文件末尾，其实就是对整个文件加锁。
											flockptr.l_whence=SEEK_SET;
											flockptr.l_start=0;
											flockptr.l_len=0;
											就就表示对整个文件加锁。
											
											如果只是对文件中间的某段加锁，这只是区域加锁，加区域锁时可以给文件n多个的独立区
										域加锁。
										
										
									· l_pid：当前正加着锁的那个进程的PID	
									
											只有当我们获取一个已存在锁的信息时，才会使用这个成员，这个成员的值不是我们
										设置的，是由文件锁自己设置的，我们只是获取以查看当前那个进程正加着锁。
											
											对于我们目前设置文件锁来说，这个成员用不到。
					
		4.4.2 代码演示
				使用文件锁的互斥操作，解决父子进程向同一文件写“hello ”，“world\n”时，hello hello world相连的问题。
				
				
				
		
			
		4.4.3 文件锁的原理
				我们理解了文件锁的原理后，我们就可以理解为什么文件锁可以实现互斥与共享了。
			
				图：
			
				
					链表上节点代表是一把锁（读锁和写锁），节点存在时表示没有解锁，如果解锁了锁节点就不存在了。
					锁节点记录了锁的基本信息。
					· 锁类型
					· 加锁的起始位置（l_whence、l_start）
					· 加锁的长度（l_len）
					· 当前正在加着锁的那个进程的PID
					
					
					加锁时，进程会检查共享的文件锁链表。
					
				（1）进程想加读锁
						1）如果链表上只有读锁节点
								所有目前其它进程对该文件只加了读锁，由于读锁时共享的，所以不管
							链表上有几个读锁节点，当前进程都能成功加读锁。
							图：
								
							提供：链表上可不可以存在n多个读锁节点？
							答：可以，因为读锁是共享的，不管别的进程有没有解读锁，所有的进程都可以加读锁，
								每加一个读锁，链表上就多一个读锁节点，只有当解锁时节点才被删除。
								
						2）如果链表上有一个写锁节点
								表明目前有进程对文件加了写锁，锁节点还存在，表示人家目前还没有解锁，读锁和写锁是互斥的，
							所以当前不能加读锁，别人解锁后才能加读锁，加锁后链表上就插入一个读锁节点。
								
						
							提问：链表上能不能同时存在多个写锁节点
							
							答：不可能，因为写锁是互斥的，目前只能有一个进程在给文件加写锁，在解锁之前，别的进程不能加
								写锁。
									所以链表上不可能有>一个的写锁节点，否者就不能实现互斥了。
							
							
							提问：链表上会不会同时存在读锁节点和写锁节点？
								读锁节点和写锁节点也是互斥的，链表上有读锁节点就不可能存在写锁节点，反过来有写锁节点就
								不可能有读锁节点。
					
					
				（2）你想加写锁
						1）如果链表上有读锁节点，别人还没有解锁，读锁与写锁互斥，不能加写锁。
								
						2）如果链表上有写锁节点，别人还没有解锁，写锁与写锁互斥，多以当前进程不能加写锁
				
				
				（3）对比进程信号量
						1）进程信号量：进程间共享信号量集合，通过检查集合中信号量的值，从而知道自己能不能操作
						2）文件锁：进程共享文件锁链表，通过检查链表上的锁节点，从而知道自己能不能操作

						
						
		4.4.4 文件锁其它值得注意的地方
		
			（a）在同一进程中，如果多个文件描述符指向同一文件，只要关闭其中任何一个文件描述符，
					那么该进程加在文件上的文件锁将会被删除，也就是该进程在“文件锁链表”上的“读锁写锁”节
					点会被删除。
					
						进程终止时会关闭所有打开的文件描述符，所以进程结束时会自动删除所有加的文件锁。

			（b）父进程所加的文件锁，子进程不会继承，我们在讲进程控制时就说过
						加锁是进程各自私人事情，不能继承，就好比你老爸有抽烟的嗜好，难道这也需要继承吗，肯定不是的。
		
		

		4.4.5 提一个问题：多线程间能不能使用fcntl实现的文件锁呢？
				可以，但是线程不能使用同一个open返回的文件描述符，线程必须使用自己open所得到的文件描述符才有效。
				
				代码演示：
		
	4.5 使用flock函数来实现文件锁
	
			flock与fcntl所实现的文件锁一样，既能够用在多进程上，也能用在多线程上，而且使用起来比fcntl的实现
		方式更方便，只是使用这个函数时，需要注意一些小细节。
			
			
		4.5.2 flock函数
				 
			（1）函数原型
					#include<sys/file.h>
					
			　　int flock(int fd, int operation);
					
					1）功能
							按照operation的要求，对fd所指向的文件加对应的文件锁。
							
							加锁不成功时会阻塞。
							
					2）返回值：成功返回0，失败返回-1，errno被设置
					
					3）参数
						（a）fd：指向需要被加锁的文件
						（b）operation
								· LOCK_SH：加共享锁
			　　			· LOCK_EX：加互斥锁
			　　			· LOCK_UN：解锁


			（2）代码演示
			
					1）用于多进程
							代码：
						
						
							flock用于多进程时，各进程必须独立open打开文件，对于非亲缘进程来说，不用说打开文件时肯定
						是各自独立调用open打开的。
							
							需要你注意的是亲缘进程（父子进程），子进程不能使用从父进程继承而来的文件描述符，父子进程
						flock时必须使用独自open所返回的文件描述符。
							
							这一点与fcntl实现的文件锁不一样，父子进程可以使用各自open返回的文件描述符加锁，但是同时子
						进程也可以使用从父进程继承而来的文件描述符加锁。
							
							
						· 共享锁与互斥锁之间互斥
						· 互斥锁与互斥锁之间互斥
						· 共享锁与共享锁之间共享
						
						
						
					2）用于多线程
						代码：
							

						用于多线程时与用于多进程一样，各线程必须使用各自open所返回的文件描述符才能加锁。
							
					
						fcntl函数实现的
						
						flock

5. io多路复用
	
	5.1 如何解决同时“读鼠标”和“读键盘”的问题
	
		1）多进程实现
		2）多线程
		3）将“读鼠标”和“读键盘”设置为非阻塞实现
			
		4）多路IO
			
			
	5.2 有关多路IO
	
		（1）多路IO的工作原理
		
					使用多路IO时，不需要多进程、多线程以“多线任务”方式实现，也不需要用到非阻塞，那么多路IO的实现
				原理又是什么呢？
			
					我们以阻塞读为例，来讲解多路IO的原理。
			
					图：
			
					
					
					如果是阻塞写的话，需要将文件描述符加入写集合，不过我们说过对于99%的情况来说，写操作不会阻塞，
				所以一般情况下对于写来说，使用多路Io没有意义。
				
				注意：对于多路io来说，只有操作阻塞的fd才有意义，如果文件描述符不是阻塞的，使用多路IO没有意义。
			
			
		（2）多路IO有什么优势
					比如以同时读写鼠标、读键盘为例，如果使用，
					
				1）多进程实现
						开销太大，绝对不建议这么做。
						
				2）非阻塞方式
						cpu空转，耗费cpu资源，不建议。
						
				3）多线程
						常用方法，不过本小节讲的“多路IO"也是一个不错的方法。
					
				4）多路IO
					使用多路IO时，多路IO机制由于在监听时如果没有动静的话，监听会休眠，因此开销也很低，
					相比多进程和非阻塞来说，多路IO机制也是很不错的方式。
					
					
		（3）select和poll
				多路IO有两种实现方式，分别是poll和select，其中select会比poll更常用些。
				


	
	5.2 多路io之select机制
	
		5.2.1 select函数
		
			（1）函数原型
					#include <sys/select.h>
					
					int select(int nfds, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, 
											struct timeval *timeout);

					1）功能
							监听集合中的描述符有没有动静，如果没有动静就阻塞。
							如果有动静就成功返回，返回值为集合中有动静的fd的数量。
							
							什么是有动静？
							比如以读为例，如果fd有数据来了需要被read时，这就是动静。
							

					2）参数
						（a）nfds：
								nfds = readfds, writefds, exceptfds这三个集合中值最大的那个描述符+1。
								nfds用于说明需要关心描述符的范围，这个范围必须覆盖所有集合中的文件描述符。
								
								比如“读集合”中包含0,3,6这三个文件描述符，写集合和异常集合为NULL（没有）。
										nfds==6+1
										
										表示监听范围包含7描述符，描述符因为是从0算起的，所以监听范围所包含的描述符为
										0、 1、 2、 3、 4、 5、 6 
										
										疑问：集合中只包含了0、3、6三个，但是为什么需要监听的有这么多，只能说人家select
										机制就是这么实现的，这个没办法。
										
						
						（b）readfds、writefds、exceptfds：读、写、异常集合。
								· readfds：读结合，放读会阻塞的文件描述符
								· writefds：写集合，放写会阻塞的描述符。
								· exceptfds：放会异常出错的文件描述符。
								
								常用的是读集合，写集合和异常集合基本用不到，所以这里不做介绍，写、异常集合不用时就写NULL。
								
								至于如何将文件描述符放入集合中，我们使用如下带参宏来实现。
								 void FD_CLR(int fd, fd_set *set)：将fd从集合set中清除，这个宏不常用
								 int  FD_ISSET(int fd, fd_set *set)：判断是不是set中的fd有动静了
								 void FD_SET(int fd, fd_set *set)：将fd放到集合set中
								 void FD_ZERO(fd_set *set)：将整个集合全部清空
									
									
								比如：
								fd_set readfds;//定义一个读集合
								FD_ZERO(&readfds); //把集合全部清空
								FD_SET(fd, &readfs);//将fd放到readfds集合中
								
								
						（d）timeout：用于设置阻塞超的时间
						
									select函数监听集合时，如果没有任何动静的话就阻塞（休眠）。
									如果timeout被设置为NULL的话，select会永远阻塞下去，直到被信号中断或者集合中的某些文件
								描述符有动静了。
									
									
									如果你不想休眠太久的话，就可以设置超时时间，如果时间到了但是集合中的fd还没有任何动静，
								select就返回，然后不再阻塞，超时时的返回的值为0。
								
								
								成员结构如下：
								struct timeval 
								{
									long    tv_sec;  /* seconds（秒） */
									long    tv_usec; /* microseconds （微秒）*/
								};
								· tv_sec：设置秒
								· tv_usec：设置微妙
									时间精度为微妙，也就是说可以设置一个精度为微妙级别的超时时间。
								
								由于select函数有超时功能，实际上可以使用select模拟出一个微妙级精度的定时器，大家下去
							后可以自己去网上查阅资料研究下怎么实现。
								给大家布置这个作业，并不是说使用select来实现定时器有多么的重要，而是希望借此让大家熟悉
							select函数。
							
								
					3）返回值
						（a）-1：说明函数调用失败，errno被设置。
									select调用出错的情况有很多种，比如select在阻塞时被信号唤醒从而导致出错返回，
								errno被设置为EINTR错误号，这个错误号表示函数是被信号中断而出错返回的。
									
									如果不想被信号中断，
									· 我们可以自己忽略、屏蔽这些信号
									· 手动重启select的调用
										
								lable:	ret = select(...);
												if(ret==-1 && errno==EINTR) goto lable;
												else if(ret == -1) print_err(...);
						
						（b）0：超时时间到并且集合中没有一个描述符有响应时，就返回0。
						（c）>0：集合中fd有动静时，函数返回有动静的文件描述符的数量。
							

						
			（2）代码演示		
					
					
					
						select每次重新监听时需要重新设置“集合”和“超时时间”，因为每次select监听结束时会清空“集合”和
					“超时时间”。
					
	5.3 多路io 之 poll机制

		5.3.1 poll函数
		
			（1）函数原型
					#include <poll.h>
					
					int poll(struct pollfd *fds, nfds_t nfds, int timeout);
					
					
			（2）功能
						监听集合有没有动静，如果没有动静就阻塞
						如果有动静就成功返回，返回值为集合中有动静的fd的数量。
			
			（3）参数
					1）fds：这个参数写为struct pollfd fds[]更好理解些，第一个参数要求传递一个struct pollfd结
							构体数组。
								
							这个数组就相当于select的文件描述符集合，只不过select是使用fd_set来定义的，而poll的集合
						是一个数组。
								
							struct pollfd的成员：
								 struct pollfd {
									 int   fd;      ：文件描述符
									 short events;  ：设置我们希望发生的事件，比如读事件，这个需要我们自己设置
									 short revents; ：实际发生的事件，比如读事件，由poll机制自己设置
							 };
							 
							 	struct pollfd fds[2];
								fds[0].fd = 0;
								fds[0].events = POLLIN;//读事件（输入事件）
								
								fds[1].fd = 3;
								fds[1].events = POLLIN;//读事件（输入事件）
							 
							 poll监听时如果没有动静就阻塞，有动静就不再阻塞，返回有动静的fd的数量。
								
							如何知道是那些fd有动静？
							 如果文件描述符“发生的事件”==“实际事件”，就说明希望的事件来了，就是对fd进行相应的“读或写”操作。
							 
							使用举例：
							if(fds[1].events == fds[1].revents)//如果相等，就说明fds[1].fd有动静。
							{
								//读写fds[1].fd
							}
								
							 
					2）nfds：数组的元素个数。
		
					3）timeout：超时时间，如果写的是
						（a）-1：不设置超时，如果集合没有动静就一直阻塞下去，直到poll函数被信号中断（唤醒）
											或者集合有动静为止
									
						（b）非-1值：比如3000（3000微妙），表示将超时时间设置为3秒
								也就是说poll超时时间的单位时微妙。
							
							
					4）返回值
						（a）返回-1：说明函数调失败，errno被设置。
								· 如果是被信号中断从而导致出错返回-1时，errno被设置为EINTR，
								· 如果不想被中断，要么重启poll的调用，要么忽略或者屏蔽这些信号。
								
						（b）0：超时时间到，而且没有文件描述符有动静。
						
						（c）>0：返回有响应的文件描述符的数量。
								
							
							
		5.3.2 代码演示

6. 异步io	

	6.1 回顾同时读键盘、鼠标的方法
		1）多进程
		2）多线程
		3）将“读鼠标”和“读键盘”设置为非阻塞
		4）多路IO（select、poll机制）
		
		5）异步IO
			
			
	6.2 异步IO的原理
	
			前面四种方式都是主动的去读，对于read函数来说它并不知道是不是一定有数据，如果有数据就读到数据，
		没有数据要么阻塞直到读到数据为止，要么就不阻塞。
			
			这就好比我想去澡堂洗澡，我不知道有没有位置，我去了后如果有位置我就立即洗澡（立即读数据），如果没有
		位置要么等（阻塞读），要么离开过段时间再来看（非阻塞读）。
			
			实际上除了以上描述的方式外，还有另外一种聪明的方式，那就是使用异步IO的方式来实现。
			异步IO的原理就是，底层把数据准备好后，内核就会给进程发送一个“异步通知的信号”通知进程，表示数据
		准备好了，然后调用信号处理函数去读数据，在没有准备好时，进程忙自己的事情。
			
			这就好比我跟澡堂老板说一声“有位置了打电话给我啊”，我就回去该忙啥就忙啥了，等老板通知我了我就知道
		有位置了，这样的方式不就更好吗。
		
			比如使用异步IO读鼠标，底层鼠标驱动把数据准备好后，会发一个“SIGIO”（异步通知信号）给进程，进程调
		用捕获函数读鼠标，读鼠标的SIGIO捕获函数需要我们自己定义。
	
	
	
	6.3 使用异步IO方式读鼠标和键盘
			
			进程正常阻塞读键盘，然后将读鼠标设置为异步IO方式。
	
	
			进程正常阻塞读键盘时，如果鼠标没有数据的话，进程不关心读鼠标的事情，如果鼠标数据来了，底层鼠标驱
		动就会向进程发送一个SIGIO信号，然后调用注册的SIGIO信号捕获函数读鼠标数据。
			
			图：
			
			
			当然也可以反过来，进程正常阻塞读鼠标，然后将读键盘设置为异步IO方式。
			
			
			异步IO这个名字怎么理解？
				比如以异步IO方式读鼠标数据为例，如果知道什么时间数据会来，等这个时间到时再去读数据，这就是步调统
			一的同步读。
				
				如果不知道什么时候会有数据来，这种就只能是什么时候数据来了就什么时候读，这种就是异步的读。
			之所叫异步，是因为我不知道你什么时候来，没办法统一步调（异步的），只能是随时来是随时读。
				
				
			
			不过使用异步IO有两个前提，
			（1）底层驱动必须要有相应的发送SIGIO信号的代码，只有这样当底层数据准备好后，底层才会发送
					SIGIO信号给进程。
					
					我们之所以可以对鼠标设置异步IO，是因为人家在实现鼠标驱动时，有写发送SIGIO信号的代码，
				如果驱动程序是我们自己写的，发送SIGIO的代码就需要我们自己来写。
				
				
			（2）应用层必须进行相应的异步IO的设置，否者无法使用异步IO
						应用层进行异步IO设置时，使用的也是fcntl函数。
						
						
						
						
	6.3 使用异步IO时，应用层的设置步骤
	
		（1）调用signal函数对SIGIO信号设置捕获函数
				在捕获函数里面实现读操作，比如读鼠标。
	
		（2）使用fcntl函数，将接收SIGIO信号的进程设置为当前进程
				如果不设置的，底层驱动并不知道将SIGIO信号发送给哪一个进程。
					fcntl(mousefd, F_SETOWN, getpid());	
		
		（3）使用fcntl函数，对文件描述符增设O_ASYNC的状态标志，让fd支持异步IO
					mousefd = open("/dev/input/mouse1", O_RDONLY); 
					
					flag = fcntl(mouse_fd, F_GETFL);
					flag |= O_ASYNC;	//补设O_ASYNC
					fcntl(mouse_fd, F_SETFL, flag);
						
						
						
	6.4 代码演示

7. 存储映射	
	
	
	7.1 普通读写文件方式的缺点
		
		7.1.1 普通读写文件的特点
					使用文件IO的read/write来进行文件的普通读写时，函数经过层层的调用后，才能够最终操作到文件，	
				
						比如我们以读（read函数）为例：
				
						应用层  read(fd, buf, sizeof(buf)); //buf应用缓存
											|
					------------|--------------------------------------
						OS层      |                                 
									 xxx1_read(**, xxx1_buf, **);   //xxx_buf1内核缓存
											|
											|
									 xxx2_read(**, xxx2_buf, **);   //xxx_buf2内核缓存
											|
											|
										......
											|
											|
									xxxn_read(**, xxxn_buf, **);   //xxxn_buf内核缓存
					------------|----------------------------------------
						  		    |
									  文件
					
					以上画的只是一个示意的过程，不是说这些函数就一定叫这样的名字，但是不管怎么说上图能够很好反
				映出，在读写时中间会有很多的调用过程，数据需要在不同的缓存间倒腾，最终才能从文件到应用缓存，或者
				从应用缓存到文件，效率很低。
				
					疑问：为什么中间经过一系列的捣腾后效率会很低呢？
					（1）cpu执行一堆的函数，很耗费cpu资源，而且浪费时间
					（2）中间一堆的缓存都是函数从内存开辟的，浪费内存资源，而且数据在各缓存间倒腾时也很耗费时间
					
					总之read、write这种普通读写文件的方式效率不高，那效率不高还要它干嘛？
					因为对于数据量较少的情况来说，这种普通读写方式还是非常方便的，而且数据量较少时，效率并不会太低，
					只有当数据量非常大时，效率的影响才会非常的明显。
					
					所以对于数据量很少的情况来说，我们最常用的还是普通的读写方式。
					
					
					疑问：使用标准IO函数的读和写，中间过程也很多吗？
					答：当然，因为“标准io”本来就是封装文件IO来实现的。
					
				
		7.1.2 普通读写方式的缺点：面对大量数据时显得很吃力
		
				（1）例子1
						比如应用层有超大量的数据，需要保存到“硬盘”的某个普通文件上。
							
									buf[] = 超大量数据;
								
									应用层 write(fd, buf, sizeof(buf)); //buf应用缓存
												|
						------------|--------------------------------------
							OS层      |                                 
											......
						------------|----------------------------------------
												|
									   普通文件
								 
							
								 
				（2）例子2
							应用程序向“显示器”这个字符设备文件的“显存”写视频和图片数据。
							
							大家都知道视频和图片的数据量非常大，特别是视频，
					
									buf[] = 视屏或者图片数据;
								
									应用层  write(fd, buf, sizeof(buf)); //buf应用缓存
												|
						------------|--------------------------------------
							OS层      |                                 
											......
						------------|----------------------------------------
												|
											显存（“LCD”字符设备文件）
					
				不管是以上的哪一个例子，当涉及大数据量时，如果使用普通read、write的话，中间过程太过繁杂，效率非
			常的低，所以使用普通的read、write就不行了，此时就需要使用到本小节讲的存储映射了。
				
				不过我们在讲存储映射时，我们目前只能先以普通文件来举例，至于如实使用存储映射，向底层
			“LCD”字符设备文件的“显存”写数据，我们只会大致的介绍下，细节只能留到讲“LCD驱动”时再详细介绍。
				
				
	7.2 存储映射所用的mmap函数
	
			mmap是memory map的缩写，map就是映射的意思，有些同学可能会说map不是地图的意思吗，map当动词时也有
		映射的意思。其实“地图”本身就真实地理环境的映射，所以地图本身就有映射的意思。
			
			
		7.2.1 mmap的原理
		
				比如以映射普通文件为例：
				
				
				mmap的原理就是，既然直接read、write很费劲，那我干脆抛弃read、write的操作，mmap采用直接映射的方
			式实现，mmap映射时，比如映射普通文件，其实就会将普通文件的硬盘空间的物理地址映射到进程空间的
			虚拟地址。
				图：
				
				
				
				
				
				通常情况下，进程空间的虚拟地址只映射自己底层物理空间的物理地址，但是使用mmap时，他会将文件的
			硬盘空间的地址也映射到虚拟地址空间，这么一来应用程序就可以直接通过映射的虚拟地址操作文件，根本就不
			需要read、write函数了，使用地址操作时省去了繁杂的中间调用过程，可以快速对文件进行大量数据的输
			入输出。
			
			疑问：使用存储映射时，read、write被省掉了，open是不是也被省掉了？
			答：open不能省，必须要将文件open后，才能使用mmap进行映射。

		7.2.2 映射时，具体映射到了进程空间的什么位置呢？
				
				映射到了“进程应用空间”堆和栈中间那片虚拟地址的位置。
				
				图：
				
				
			（1）进程内核空间：用于映射“OS”所在的物理内存空间
			（2）进程应用空间：用于映射“应用程序”所在的物理内存空间
					
				
		7.2.3 对比IPC之共享内存
				大家思考下，本小节讲的存储映射与共享内存是不是很像。
			
			（1）回顾共享内存
						共享内存是让不同的进程空间映射到同一片物理内存上，然后通过共享的物理内存来实现进程间通信。
						图：
					
					
					共享内存的使用过程：
					
					1）shmget：创建共享内存，其实就是从物理内存中划出一片准备用于共享的空间出来
					
					2）shmat：调用该函数的进程，将自己的进程空间的某片虚拟地址映射到共享内存上
									程序员不需要知道共享内存空间的起始物理地址是多少，shmat它会知道。
					
									至于说映射后的起始虚拟地址一般也是由shmat自己选择的，程序员不需要干预。
									
					3）shmdt：取消映射
					
					4）shmctl：将被取消映射的共享内存删除（释放）
						
						
						
			（2）对比存储映射和共享内存
			
					1）存储映射，其实也可以用来实现进程间通信
							
							比如A和B进程都映射到同一个普通文件上，这时A进程往里写数据，B进程从里面读数据，反过来
						也是一样的，如此就实现了进程间的通信。
							图：
							
							
							但是这顶多只算是广义上的通信，所谓广义上的通信就是，只要不是OS提供专门的IPC，就不是专门
						的进程间通信，只能算是广义的IPC。
							
							实际上，我们也不会使用mmap映射普通文件来实现进程间通信，因为操作硬盘的速度相比操作内存来
						说低了很多，如果你想实现进程间大量数据通信的话，完全可以使用与存储映射原理类似的
						“共享内存”来实现，而且速度很快。
						
						
					2）虽然存储映射和共享内存原理相似，但是各自用途不同
						
						（a）共享内存
								实现进程间大量数据通信（共享）。
									
							
						（b）存储映射
								对文件进行大量数的高效输入输出。
					
					
					
					
					
		7.2.4 mmap函数
		
			（1）函数原型
					#include <sys/mman.h>
				
					void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);

			
			（2）功能：将文件所在的磁盘空间映射到进程空间。
				
			（3）返回值：调用成功，返回映射的起始虚拟地址，失败则返回(void*)-1，errno被设置。
					
					
					
			（4）参数
					1）addr：人为指定映射的起始虚拟地址
							如果设置为NULL，表示由内核决定映射的起始虚拟地址，这也是最常见的设置方式，这与我们调用
						shmat映射共享内存时指定NULL是一样的。
							
							如果设置不为NULL，就表示由自己指定，指定的起始虚拟地址必须是虚拟页（4k）的整数倍，
						这与自己指定shmat的映射起始虚拟地址也是一样的。

						
					2）length：映射长度，也就是你想对文件映射多长。
					
					
					void *mmap(void *addr, size_t length, int prot, int flags, int fd, off_t offset);
					3）prot：指定对映射区的操作权限，可指定如下宏：
					 （a）PROT_EXEC：映射区的内容可执行。
														如果你映射的是普通文件是一个可执行文件的话，将映射权限指定为PROT_EXEC后，
													是能够通过映射后的虚拟地址去执行文件中的“指令”。
					 
												图：
												
												
					 
					 （b）PROT_READ：映射区的内容可读。
					 
					 （c）PROT_WRITE：映射区的内容可写。
							以上三种选项可相互 | 操作。
							比如：PROT_EXEC | PROT_READ
							
					 （d）PROT_NONE：映射区不允许访问（不允许执行、读、写），一般不会指定这个，如果指定为不可
								访问的话，映射就没有意义了。

						 
					4）flags：向映射区写入了数据，是否将数据立即更新到文件中。
						 （a）MAP_SHARED：立即更新。
						
						
					5）fd：需要被映射文件的描述符。
					
					6）offset：
							表示从文件头的offset处开始映射。
					
							一般都指定为0，表示从文件头开始映射。

			 		
					
		7.2.4 munmap
			（1）函数原型
					#include <sys/mman.h>
					
					int munmap(void *addr, size_t length);
					
			（2）功能：取消映射
			
			（3）返回值：调用成功返回0, 失败则-1, errno被设置。
			
			（4）参数
					1）addr：映射的起始虚拟地址
					2）length：需要取消的长度
		
		
		
		7.2.5 代码演示
		
				写一个例子程序，将A文件的大量数据复制到B文件中。
				
				如果采用传统方式，使用read函数从A文件读出数据，然后向B文件write，如果数据量很大的话，复制的
				效率会非常低，此时我们就可以使用存储映射来实现。
				
				实现原理：
				图
				

				
				mmap映射文件size为0的文件时，会映射失败，映射失败时内核会向进程发送一个SIGBUS信号，提示mmap
			失败了，这个信号的默认处理方式是终止，所以当进程收到这个信号时就被异常终止了。
			
				如果你不想被这个信号终止，你可以自己忽略或者屏蔽这个信号，一般来说我们不需要忽略和屏蔽该信号。
				
				
				代码演示：